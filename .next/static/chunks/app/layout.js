/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fubuntu%2FDocuments%2FProteinBind%2Fsrc%2Fapp%2Flayout.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fubuntu%2FDocuments%2FProteinBind%2Fsrc%2Fapp%2Flayout.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/layout.tsx */ \"(app-pages-browser)/./src/app/layout.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRnVidW50dSUyRkRvY3VtZW50cyUyRlByb3RlaW5CaW5kJTJGc3JjJTJGYXBwJTJGbGF5b3V0LnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLGtLQUEwRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2JlNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS91YnVudHUvRG9jdW1lbnRzL1Byb3RlaW5CaW5kL3NyYy9hcHAvbGF5b3V0LnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fubuntu%2FDocuments%2FProteinBind%2Fsrc%2Fapp%2Flayout.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/build/ably.js":
/*!*****************************************!*\
  !*** ./node_modules/ably/build/ably.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n\nAbly JavaScript Library v2.3.1\nhttps://github.com/ably/ably-js\n\nReleased under the Apache Licence v2.0*/(function (g, f) {\n    if (true) {\n      module.exports = f();\n    } else {}\n  }(this, () => {\nvar exports = {};\nvar module = { exports };\n\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/platform/web/index.ts\nvar web_exports = {};\n__export(web_exports, {\n  ErrorInfo: () => ErrorInfo,\n  Realtime: () => DefaultRealtime,\n  Rest: () => DefaultRest,\n  default: () => web_default,\n  msgpack: () => msgpack_default,\n  protocolMessageFromDeserialized: () => fromDeserializedIncludingDependencies\n});\nmodule.exports = __toCommonJS(web_exports);\n\n// src/common/platform.ts\nvar Platform = class {\n};\n\n// src/common/lib/util/logger.ts\nvar globalObject = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nfunction pad(timeSegment, three) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, \"0\");\n}\nfunction getHandler(logger) {\n  return Platform.Config.logTimestamps ? function(msg) {\n    const time = /* @__PURE__ */ new Date();\n    logger(\n      pad(time.getHours()) + \":\" + pad(time.getMinutes()) + \":\" + pad(time.getSeconds()) + \".\" + pad(time.getMilliseconds(), 1) + \" \" + msg\n    );\n  } : function(msg) {\n    logger(msg);\n  };\n}\nvar getDefaultLoggers = () => {\n  var _a2;\n  let consoleLogger;\n  let errorLogger;\n  if (typeof ((_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) === \"function\") {\n    consoleLogger = function(...args) {\n      console.log.apply(console, args);\n    };\n    errorLogger = console.warn ? function(...args) {\n      console.warn.apply(console, args);\n    } : consoleLogger;\n  } else {\n    consoleLogger = errorLogger = function() {\n    };\n  }\n  return [consoleLogger, errorLogger].map(getHandler);\n};\nvar _Logger = class _Logger {\n  constructor() {\n    this.deprecated = (description, msg) => {\n      this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n    };\n    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n      the object being serialised if the log level will not output the message */\n    this.shouldLog = (level) => {\n      return level <= this.logLevel;\n    };\n    this.setLog = (level, handler) => {\n      if (level !== void 0)\n        this.logLevel = level;\n      if (handler !== void 0)\n        this.logHandler = this.logErrorHandler = handler;\n    };\n    this.logLevel = _Logger.defaultLogLevel;\n    this.logHandler = _Logger.defaultLogHandler;\n    this.logErrorHandler = _Logger.defaultLogErrorHandler;\n  }\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.defaultLogHandler = logHandler;\n    this.defaultLogErrorHandler = logErrorHandler;\n    this.defaultLogger = new _Logger();\n  }\n  /**\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n   */\n  static logActionNoStrip(logger, level, action, message) {\n    logger.logAction(level, action, message);\n  }\n  logAction(level, action, message) {\n    if (this.shouldLog(level)) {\n      (level === 1 /* Error */ ? this.logErrorHandler : this.logHandler)(\"Ably: \" + action + \": \" + message, level);\n    }\n  }\n  renamedClientOption(oldName, newName) {\n    this.deprecationWarning(\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  renamedMethod(className, oldName, newName) {\n    this.deprecationWarning(\n      `\\`${className}\\`\\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  deprecationWarning(message) {\n    if (this.shouldLog(1 /* Error */)) {\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, 1 /* Error */);\n    }\n  }\n};\n_Logger.defaultLogLevel = 1 /* Error */;\n// public constants\n_Logger.LOG_NONE = 0 /* None */;\n_Logger.LOG_ERROR = 1 /* Error */;\n_Logger.LOG_MAJOR = 2 /* Major */;\n_Logger.LOG_MINOR = 3 /* Minor */;\n_Logger.LOG_MICRO = 4 /* Micro */;\n/* public static functions */\n/**\n * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n *\n * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you canâ€™t dynamically specify the log level.\n */\n_Logger.logAction = (logger, level, action, message) => {\n  _Logger.logActionNoStrip(logger, level, action, message);\n};\nvar Logger = _Logger;\nvar logger_default = Logger;\n\n// src/common/lib/util/utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Format: () => Format,\n  allSame: () => allSame,\n  allToLowerCase: () => allToLowerCase,\n  allToUpperCase: () => allToUpperCase,\n  arrChooseN: () => arrChooseN,\n  arrDeleteValue: () => arrDeleteValue,\n  arrEquals: () => arrEquals,\n  arrIntersect: () => arrIntersect,\n  arrIntersectOb: () => arrIntersectOb,\n  arrPopRandomElement: () => arrPopRandomElement,\n  arrSubtract: () => arrSubtract,\n  arrWithoutValue: () => arrWithoutValue,\n  cheapRandStr: () => cheapRandStr,\n  containsValue: () => containsValue,\n  copy: () => copy,\n  createMissingPluginError: () => createMissingPluginError,\n  dataSizeBytes: () => dataSizeBytes,\n  decodeBody: () => decodeBody,\n  encodeBody: () => encodeBody,\n  ensureArray: () => ensureArray,\n  forInOwnNonNullProperties: () => forInOwnNonNullProperties,\n  getBackoffCoefficient: () => getBackoffCoefficient,\n  getGlobalObject: () => getGlobalObject,\n  getJitterCoefficient: () => getJitterCoefficient,\n  getRetryTime: () => getRetryTime,\n  inherits: () => inherits,\n  inspectBody: () => inspectBody,\n  inspectError: () => inspectError,\n  intersect: () => intersect,\n  isEmpty: () => isEmpty,\n  isErrorInfoOrPartialErrorInfo: () => isErrorInfoOrPartialErrorInfo,\n  isNil: () => isNil,\n  isObject: () => isObject,\n  keysArray: () => keysArray,\n  matchDerivedChannel: () => matchDerivedChannel,\n  mixin: () => mixin,\n  parseQueryString: () => parseQueryString,\n  prototypicalClone: () => prototypicalClone,\n  randomString: () => randomString,\n  shallowClone: () => shallowClone,\n  shallowEquals: () => shallowEquals,\n  throwMissingPluginError: () => throwMissingPluginError,\n  toBase64: () => toBase64,\n  toQueryString: () => toQueryString,\n  valuesArray: () => valuesArray,\n  whenPromiseSettles: () => whenPromiseSettles,\n  withTimeoutAsync: () => withTimeoutAsync\n});\n\n// src/common/lib/types/errorinfo.ts\nfunction toString(err) {\n  let result = \"[\" + err.constructor.name;\n  if (err.message)\n    result += \": \" + err.message;\n  if (err.statusCode)\n    result += \"; statusCode=\" + err.statusCode;\n  if (err.code)\n    result += \"; code=\" + err.code;\n  if (err.cause)\n    result += \"; cause=\" + inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf(\"help.ably.io\") > -1))\n    result += \"; see \" + err.href + \" \";\n  result += \"]\";\n  return result;\n}\nvar ErrorInfo = class _ErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || typeof code !== \"number\" || typeof statusCode !== \"number\") {\n      throw new Error(\"ErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\nvar PartialErrorInfo = class _PartialErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || !isNil(code) && typeof code !== \"number\" || !isNil(statusCode) && typeof statusCode !== \"number\") {\n      throw new Error(\"PartialErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _PartialErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\n\n// src/common/lib/util/utils.ts\nfunction randomPosn(arrOrStr) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\nfunction mixin(target, ...args) {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\nfunction copy(src) {\n  return mixin({}, src);\n}\nfunction ensureArray(obj) {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\nfunction isObject(ob) {\n  return Object.prototype.toString.call(ob) == \"[object Object]\";\n}\nfunction isEmpty(ob) {\n  for (const prop in ob)\n    return false;\n  return true;\n}\nfunction isNil(arg) {\n  return arg == null;\n}\nfunction shallowClone(ob) {\n  const result = new Object();\n  for (const prop in ob)\n    result[prop] = ob[prop];\n  return result;\n}\nfunction prototypicalClone(ob, ownProperties) {\n  class F {\n  }\n  F.prototype = ob;\n  const result = new F();\n  if (ownProperties)\n    mixin(result, ownProperties);\n  return result;\n}\nvar inherits = function(ctor, superCtor) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\nfunction containsValue(ob, val) {\n  for (const i in ob) {\n    if (ob[i] == val)\n      return true;\n  }\n  return false;\n}\nfunction intersect(arr, ob) {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\nfunction arrIntersect(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrIntersectOb(arr, ob) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrSubtract(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const element = arr1[i];\n    if (arr2.indexOf(element) == -1)\n      result.push(element);\n  }\n  return result;\n}\nfunction arrDeleteValue(arr, val) {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res)\n    arr.splice(idx, 1);\n  return res;\n}\nfunction arrWithoutValue(arr, val) {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\nfunction keysArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(prop);\n  }\n  return result;\n}\nfunction valuesArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\nfunction forInOwnNonNullProperties(ob, fn) {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\nfunction allSame(arr, prop) {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function(item) {\n    return item[prop] === first;\n  });\n}\nvar Format = /* @__PURE__ */ ((Format2) => {\n  Format2[\"msgpack\"] = \"msgpack\";\n  Format2[\"json\"] = \"json\";\n  return Format2;\n})(Format || {});\nfunction arrPopRandomElement(arr) {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\nfunction toQueryString(params) {\n  const parts = [];\n  if (params) {\n    for (const key in params)\n      parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n  return parts.length ? \"?\" + parts.join(\"&\") : \"\";\n}\nfunction parseQueryString(query) {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result = {};\n  while (match = search.exec(query))\n    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n  return result;\n}\nfunction isErrorInfoOrPartialErrorInfo(err) {\n  return typeof err == \"object\" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\nfunction inspectError(err) {\n  var _a2, _b;\n  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === \"ErrorInfo\" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === \"PartialErrorInfo\")\n    return err.toString();\n  return Platform.Config.inspect(err);\n}\nfunction inspectBody(body) {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return body.toString();\n  } else if (typeof body === \"string\") {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\nfunction dataSizeBytes(data) {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === \"string\") {\n    return Platform.Config.stringByteSize(data);\n  }\n  throw new Error(\"Expected input of Utils.dataSizeBytes to be a buffer or string, but was: \" + typeof data);\n}\nfunction cheapRandStr() {\n  return String(Math.random()).substr(2);\n}\nvar randomString = async (numBytes) => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\nfunction arrChooseN(arr, n2) {\n  const numItems = Math.min(n2, arr.length), mutableArr = arr.slice(), result = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\nfunction whenPromiseSettles(promise, callback) {\n  promise.then((result) => {\n    callback == null ? void 0 : callback(null, result);\n  }).catch((err) => {\n    callback == null ? void 0 : callback(err);\n  });\n}\nfunction decodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.decode(body);\n  }\n  return JSON.parse(String(body));\n}\nfunction encodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.encode(body, true);\n  }\n  return JSON.stringify(body);\n}\nfunction allToLowerCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toLowerCase();\n  });\n}\nfunction allToUpperCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toUpperCase();\n  });\n}\nfunction getBackoffCoefficient(count) {\n  return Math.min((count + 2) / 3, 2);\n}\nfunction getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\nfunction getRetryTime(initialTimeout, retryAttempt) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\nfunction getGlobalObject() {\n  if (typeof __webpack_require__.g !== \"undefined\") {\n    return __webpack_require__.g;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return self;\n}\nfunction shallowEquals(source, target) {\n  return Object.keys(source).every((key) => source[key] === target[key]) && Object.keys(target).every((key) => target[key] === source[key]);\n}\nfunction matchDerivedChannel(name) {\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/;\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo(\"regex match failed\", 400, 40010);\n  }\n  if (match[2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  return {\n    qualifierParam: match[3] || \"\",\n    channelName: match[4]\n  };\n}\nfunction toBase64(str) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\nfunction arrEquals(a, b) {\n  return a.length === b.length && a.every(function(val, i) {\n    return val === b[i];\n  });\n}\nfunction createMissingPluginError(pluginName) {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\nfunction throwMissingPluginError(pluginName) {\n  throw createMissingPluginError(pluginName);\n}\nasync function withTimeoutAsync(promise, timeout = 5e3, err = \"Timeout expired\") {\n  const e = new ErrorInfo(err, 5e4, 500);\n  return Promise.race([promise, new Promise((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\n}\n\n// package.json\nvar version = \"2.3.1\";\n\n// src/common/lib/util/defaults.ts\nvar agent = \"ably-js/\" + version;\nvar Defaults = {\n  ENVIRONMENT: \"\",\n  REST_HOST: \"rest.ably.io\",\n  REALTIME_HOST: \"realtime.ably.io\",\n  FALLBACK_HOSTS: [\n    \"A.ably-realtime.com\",\n    \"B.ably-realtime.com\",\n    \"C.ably-realtime.com\",\n    \"D.ably-realtime.com\",\n    \"E.ably-realtime.com\"\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15e3,\n    suspendedRetryTimeout: 3e4,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 1e4,\n    httpMaxRetryDuration: 15e3,\n    channelRetryTimeout: 15e3,\n    fallbackRetryTimeout: 6e5,\n    /* For internal / test use only: */\n    connectionStateTtl: 12e4,\n    realtimeRequestTimeout: 1e4,\n    recvTimeout: 9e4,\n    webSocketConnectTimeout: 1e4,\n    webSocketSlowTimeout: 4e3\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n  version,\n  protocolVersion: 3,\n  agent,\n  getHost,\n  getPort,\n  getHttpScheme,\n  environmentFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders\n};\nfunction getHost(options, host, ws) {\n  if (ws)\n    host = host == options.restHost && options.realtimeHost || host || options.realtimeHost;\n  else\n    host = host || options.restHost;\n  return host;\n}\nfunction getPort(options, tls) {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\nfunction getHttpScheme(options) {\n  return options.tls ? \"https://\" : \"http://\";\n}\nfunction environmentFallbackHosts(environment) {\n  return [\n    environment + \"-a-fallback.ably-realtime.com\",\n    environment + \"-b-fallback.ably-realtime.com\",\n    environment + \"-c-fallback.ably-realtime.com\",\n    environment + \"-d-fallback.ably-realtime.com\",\n    environment + \"-e-fallback.ably-realtime.com\"\n  ];\n}\nfunction getFallbackHosts(options) {\n  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== \"undefined\" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\nfunction getHosts(options, ws) {\n  const hosts = [options.restHost].concat(getFallbackHosts(options));\n  return ws ? hosts.map((host) => getHost(options, host, true)) : hosts;\n}\nfunction checkHost(host) {\n  if (typeof host !== \"string\") {\n    throw new ErrorInfo(\"host must be a string; was a \" + typeof host, 4e4, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo(\"host must not be zero-length\", 4e4, 400);\n  }\n}\nfunction getRealtimeHost(options, production, environment, logger) {\n  if (options.realtimeHost)\n    return options.realtimeHost;\n  if (options.restHost) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MINOR,\n      \"Defaults.normaliseOptions\",\n      'restHost is set to \"' + options.restHost + '\" but realtimeHost is not set, so setting realtimeHost to \"' + options.restHost + '\" too. If this is not what you want, please set realtimeHost explicitly.'\n    );\n    return options.restHost;\n  }\n  return production ? Defaults.REALTIME_HOST : environment + \"-\" + Defaults.REALTIME_HOST;\n}\nfunction getTimeouts(options) {\n  const timeouts = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n  }\n  return timeouts;\n}\nfunction getAgentString(options) {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent2 in options.agents) {\n      agentStr += \" \" + agent2 + \"/\" + options.agents[agent2];\n    }\n  }\n  return agentStr;\n}\nfunction objectifyOptions(options, allowKeyOrToken, sourceForErrorMessage, logger, modularPluginsToInclude) {\n  if (options === void 0) {\n    const msg = allowKeyOrToken ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token` : `${sourceForErrorMessage} must be initialized with a client options object`;\n    logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n    throw new Error(msg);\n  }\n  let optionsObj;\n  if (typeof options === \"string\") {\n    if (options.indexOf(\":\") == -1) {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\\u2019s \\`token\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { token: options };\n    } else {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\\u2019s \\`key\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { key: options };\n    }\n  } else {\n    optionsObj = options;\n  }\n  if (modularPluginsToInclude) {\n    optionsObj = __spreadProps(__spreadValues({}, optionsObj), { plugins: __spreadValues(__spreadValues({}, modularPluginsToInclude), optionsObj.plugins) });\n  }\n  return optionsObj;\n}\nfunction normaliseOptions(options, MsgPack, logger) {\n  const loggerToUse = logger != null ? logger : logger_default.defaultLogger;\n  if (typeof options.recover === \"function\" && options.closeOnUnload === true) {\n    logger_default.logAction(\n      loggerToUse,\n      logger_default.LOG_ERROR,\n      \"Defaults.normaliseOptions\",\n      \"closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter\"\n    );\n    options.recover = void 0;\n  }\n  if (!(\"closeOnUnload\" in options)) {\n    options.closeOnUnload = !options.recover;\n  }\n  if (!(\"queueMessages\" in options))\n    options.queueMessages = true;\n  const environment = options.environment && String(options.environment).toLowerCase() || Defaults.ENVIRONMENT;\n  const production = !environment || environment === \"production\";\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\n  }\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + \"-\" + Defaults.REST_HOST);\n  const realtimeHost = getRealtimeHost(options, production, environment, loggerToUse);\n  (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!(\"tls\" in options))\n    options.tls = true;\n  const timeouts = getTimeouts(options);\n  if (MsgPack) {\n    if (\"useBinaryProtocol\" in options) {\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n    } else {\n      options.useBinaryProtocol = Platform.Config.preferBinary;\n    }\n  } else {\n    options.useBinaryProtocol = false;\n  }\n  const headers = {};\n  if (options.clientId) {\n    headers[\"X-Ably-ClientId\"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n  if (!(\"idempotentRestPublishing\" in options)) {\n    options.idempotentRestPublishing = true;\n  }\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split(\"?\");\n    connectivityCheckParams = qs ? parseQueryString(qs) : {};\n    if (uri.indexOf(\"://\") === -1) {\n      uri = \"https://\" + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n  return __spreadProps(__spreadValues({}, options), {\n    realtimeHost,\n    restHost,\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    headers\n  });\n}\nfunction normaliseChannelOptions(Crypto2, logger, options) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(channelOptions.cipher, logger);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if (\"cipher\" in channelOptions) {\n    channelOptions.cipher = void 0;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\nvar contentTypes = {\n  json: \"application/json\",\n  xml: \"application/xml\",\n  html: \"text/html\",\n  msgpack: \"application/x-msgpack\",\n  text: \"text/plain\"\n};\nvar defaultHeadersOptions = {\n  format: \"json\" /* json */,\n  protocolVersion: Defaults.protocolVersion\n};\nfunction defaultGetHeaders(options, {\n  format = defaultHeadersOptions.format,\n  protocolVersion = defaultHeadersOptions.protocolVersion\n} = {}) {\n  const accept = contentTypes[format];\n  return {\n    accept,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nfunction defaultPostHeaders(options, {\n  format = defaultHeadersOptions.format,\n  protocolVersion = defaultHeadersOptions.protocolVersion\n} = {}) {\n  let contentType;\n  const accept = contentType = contentTypes[format];\n  return {\n    accept,\n    \"content-type\": contentType,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nvar defaults_default = Defaults;\nfunction getDefaults(platformDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n\n// src/common/lib/util/multicaster.ts\nvar Multicaster = class _Multicaster {\n  // Private constructor; use static Multicaster.create instead\n  constructor(logger, members) {\n    this.logger = logger;\n    this.members = members || [];\n  }\n  call(err, result) {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(err, result);\n        } catch (e) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Multicaster multiple callback handler\",\n            \"Unexpected exception: \" + e + \"; stack = \" + e.stack\n          );\n        }\n      }\n    }\n  }\n  push(...args) {\n    this.members.push(...args);\n  }\n  createPromise() {\n    return new Promise((resolve, reject) => {\n      this.push((err, result) => {\n        err ? reject(err) : resolve(result);\n      });\n    });\n  }\n  resolveAll(result) {\n    this.call(null, result);\n  }\n  rejectAll(err) {\n    this.call(err);\n  }\n  static create(logger, members) {\n    const instance = new _Multicaster(logger, members);\n    return Object.assign((err, result) => instance.call(err, result), {\n      push: (fn) => instance.push(fn),\n      createPromise: () => instance.createPromise(),\n      resolveAll: (result) => instance.resolveAll(result),\n      rejectAll: (err) => instance.rejectAll(err)\n    });\n  }\n};\nvar multicaster_default = Multicaster;\n\n// src/common/constants/HttpMethods.ts\nvar HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {\n  HttpMethods2[\"Get\"] = \"get\";\n  HttpMethods2[\"Delete\"] = \"delete\";\n  HttpMethods2[\"Post\"] = \"post\";\n  HttpMethods2[\"Put\"] = \"put\";\n  HttpMethods2[\"Patch\"] = \"patch\";\n  return HttpMethods2;\n})(HttpMethods || {});\nvar HttpMethods_default = HttpMethods;\n\n// src/common/constants/HttpStatusCodes.ts\nvar HttpStatusCodes = /* @__PURE__ */ ((HttpStatusCodes2) => {\n  HttpStatusCodes2[HttpStatusCodes2[\"Success\"] = 200] = \"Success\";\n  HttpStatusCodes2[HttpStatusCodes2[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCodes2[HttpStatusCodes2[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCodes2[HttpStatusCodes2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCodes2[HttpStatusCodes2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  return HttpStatusCodes2;\n})(HttpStatusCodes || {});\nfunction isSuccessCode(statusCode) {\n  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;\n}\nvar HttpStatusCodes_default = HttpStatusCodes;\n\n// src/common/lib/client/auth.ts\nvar MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return (\"000000\" + Math.floor(Math.random() * 1e16)).slice(-16);\n}\nfunction isRealtime(client) {\n  return !!client.connection;\n}\nfunction normaliseAuthcallbackError(err) {\n  if (!isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\nvar hmac = (text, key) => {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n  return bufferUtils.base64Encode(digest);\n};\nfunction c14n(capability) {\n  if (!capability)\n    return \"\";\n  if (typeof capability == \"string\")\n    capability = JSON.parse(capability);\n  const c14nCapability = /* @__PURE__ */ Object.create(null);\n  const keys = keysArray(capability, true);\n  if (!keys)\n    return \"\";\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = capability[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\nfunction logAndValidateTokenAuthMethod(authOptions, logger) {\n  if (authOptions.authCallback) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authCallback\");\n  } else if (authOptions.authUrl) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authUrl\");\n  } else if (authOptions.key) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with client-side signing\");\n  } else if (authOptions.tokenDetails) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with supplied token only\");\n  } else {\n    const msg = \"authOptions must include valid authentication parameters\";\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n    throw new Error(msg);\n  }\n}\nfunction basicAuthForced(options) {\n  return \"useTokenAuth\" in options && !options.useTokenAuth;\n}\nfunction useTokenAuth(options) {\n  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);\n}\nfunction noWayToRenew(options) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\nvar trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\nvar Auth = class {\n  constructor(client, options) {\n    // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n    this.authOptions = {};\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n    if (useTokenAuth(options)) {\n      if (noWayToRenew(options)) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"Auth()\",\n          \"Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams, options);\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    } else {\n      if (!options.key) {\n        const msg = \"No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth()\", \"anonymous, using basic auth\");\n      this._saveBasicOptions(options);\n    }\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async authorize(tokenParams, authOptions) {\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo(\"Unable to update auth options with incompatible key\", 40102, 401);\n    }\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams != null ? tokenParams : null, authOptions != null ? authOptions : null);\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          this.client.connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err, tokenDetails2) => err ? reject(err) : resolve(tokenDetails2)\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {\n        this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n      }\n      throw err;\n    }\n  }\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(tokenParams, authOptions) {\n    this.tokenDetails = null;\n    this._saveTokenOptions(tokenParams, authOptions);\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n  async requestToken(tokenParams, authOptions) {\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || copy(this.tokenParams);\n    let tokenRequestCallback, client = this.client;\n    if (resolvedAuthOptions.authCallback) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authCallback\");\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authUrl\");\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = mixin(\n          { accept: \"application/json, text/plain\" },\n          resolvedAuthOptions.authHeaders\n        );\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === \"post\";\n        let providedQsParams;\n        const queryIdx = resolvedAuthOptions.authUrl.indexOf(\"?\");\n        if (queryIdx > -1) {\n          providedQsParams = parseQueryString(resolvedAuthOptions.authUrl.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl.slice(0, queryIdx);\n          if (!usePost) {\n            resolvedAuthOptions.authParams = mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams\n            );\n          }\n        }\n        const authParams = mixin({}, resolvedAuthOptions.authParams || {}, params);\n        const authUrlRequestCallback = (result) => {\n          var _a2, _b;\n          let body = (_a2 = result.body) != null ? _a2 : null;\n          let contentType = null;\n          if (result.error) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received Error: \" + inspectError(result.error)\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = (_b = result.headers[\"content-type\"]) != null ? _b : null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              contentType = contentTypeHeaderOrHeaders.join(\", \");\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received; content-type: \" + contentType + \"; body: \" + inspectBody(body)\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body))\n            body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo(\"authUrl response is missing a content-type header\", 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf(\"application/json\") > -1, text = contentType.indexOf(\"text/plain\") > -1 || contentType.indexOf(\"application/jwt\") > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                \"authUrl responded with unacceptable content-type \" + contentType + \", should be either text/plain, application/jwt or application/json\",\n                40170,\n                401\n              ),\n              null\n            );\n            return;\n          }\n          if (json) {\n            if (body.length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo(\"authUrl response exceeded max permitted length\", 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  \"Unexpected error processing authURL response; err = \" + e.message,\n                  40170,\n                  401\n                ),\n                null\n              );\n              return;\n            }\n          }\n          cb(null, body, contentType);\n        };\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Auth.requestToken().tokenRequestCallback\",\n          \"Requesting token from \" + resolvedAuthOptions.authUrl + \"; Params: \" + JSON.stringify(authParams) + \"; method: \" + (usePost ? \"POST\" : \"GET\")\n        );\n        if (usePost) {\n          const headers = authHeaders || {};\n          headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n          const body = toQueryString(authParams).slice(1);\n          whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods_default.Post,\n              resolvedAuthOptions.authUrl,\n              headers,\n              body,\n              providedQsParams\n            ),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        } else {\n          whenPromiseSettles(\n            this.client.http.doUri(HttpMethods_default.Get, resolvedAuthOptions.authUrl, authHeaders || {}, null, authParams),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth.requestToken()\",\n        \"using token auth with client-side signing\"\n      );\n      tokenRequestCallback = (params, cb) => {\n        whenPromiseSettles(\n          this.createTokenRequest(params, resolvedAuthOptions),\n          (err, result) => cb(err, result != null ? result : null)\n        );\n      };\n    } else {\n      const msg = \"Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)\";\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Auth()\",\n        \"library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n    if (\"capability\" in resolvedTokenParams)\n      resolvedTokenParams.capability = c14n(\n        resolvedTokenParams.capability\n      );\n    const tokenRequest = (signedTokenParams, tokenCb) => {\n      const keyName = signedTokenParams.keyName, path = \"/keys/\" + keyName + \"/requestToken\", tokenUri = function(host) {\n        return client.baseUri(host) + path;\n      };\n      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options);\n      if (resolvedAuthOptions.requestHeaders)\n        mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Auth.requestToken().requestToken\",\n        \"Sending POST to \" + path + \"; Token params: \" + JSON.stringify(signedTokenParams)\n      );\n      whenPromiseSettles(\n        this.client.http.do(HttpMethods_default.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err, result) => err ? tokenCb(err) : tokenCb(result.error, result.body, result.unpacked)\n      );\n    };\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(() => {\n        tokenRequestCallbackTimeoutExpired = true;\n        const msg = \"Token request callback timed out after \" + timeoutLength / 1e3 + \" seconds\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n        reject(new ErrorInfo(msg, 40170, 401));\n      }, timeoutLength);\n      tokenRequestCallback(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\n        if (tokenRequestCallbackTimeoutExpired)\n          return;\n        clearTimeout(tokenRequestCallbackTimeout);\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Auth.requestToken()\",\n            \"token request signing call returned error; err = \" + inspectError(err)\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        if (typeof tokenRequestOrDetails === \"string\") {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo(\"Token string is empty\", 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                \"Token string exceeded max permitted length (was \" + tokenRequestOrDetails.length + \" bytes)\",\n                40170,\n                401\n              )\n            );\n          } else if (tokenRequestOrDetails === \"undefined\" || tokenRequestOrDetails === \"null\") {\n            reject(new ErrorInfo(\"Token string was literal null/undefined\", 40170, 401));\n          } else if (tokenRequestOrDetails[0] === \"{\" && !(contentType && contentType.indexOf(\"application/jwt\") > -1)) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401\n              )\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails });\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== \"object\" || tokenRequestOrDetails === null) {\n          const msg = \"Expected token request callback to call back with a token string or token request/details object, but got a \" + typeof tokenRequestOrDetails;\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              \"Token request/details object exceeded max permitted stringified size (was \" + objectSize + \" bytes)\",\n              40170,\n              401\n            )\n          );\n          return;\n        }\n        if (\"issued\" in tokenRequestOrDetails) {\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!(\"keyName\" in tokenRequestOrDetails)) {\n          const msg = \"Expected token request callback to call back with a token string, token request object, or token details object\";\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        tokenRequest(tokenRequestOrDetails, (err2, tokenResponse, unpacked) => {\n          if (err2) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Auth.requestToken()\",\n              \"token request API call returned error; err = \" + inspectError(err2)\n            );\n            reject(normaliseAuthcallbackError(err2));\n            return;\n          }\n          if (!unpacked)\n            tokenResponse = JSON.parse(tokenResponse);\n          logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"token received\");\n          resolve(tokenResponse);\n        });\n      });\n    });\n  }\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams, authOptions) {\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || copy(this.tokenParams);\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo(\"No key specified\", 40101, 403);\n    }\n    const keyParts = key.split(\":\"), keyName = keyParts[0], keySecret = keyParts[1];\n    if (!keySecret) {\n      throw new ErrorInfo(\"Invalid key specified\", 40101, 403);\n    }\n    if (tokenParams.clientId === \"\") {\n      throw new ErrorInfo(\"clientId can\\u2019t be an empty string\", 40012, 400);\n    }\n    if (\"capability\" in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || \"\", ttl = tokenParams.ttl || \"\", capability = tokenParams.capability || \"\";\n    if (!request.timestamp) {\n      request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\n    }\n    const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;\n    const signText = request.keyName + \"\\n\" + ttl + \"\\n\" + capability + \"\\n\" + clientId + \"\\n\" + timestamp + \"\\n\" + nonce + \"\\n\";\n    request.mac = request.mac || hmac(signText, keySecret);\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getTokenRequest()\", \"generated signed request\");\n    return request;\n  }\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams() {\n    if (this.method == \"basic\")\n      return { key: this.key };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders() {\n    if (this.method == \"basic\") {\n      return { authorization: \"Basic \" + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { authorization: \"Bearer \" + toBase64(tokenDetails.token) };\n    }\n  }\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime) {\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\n      return this.client.time();\n    } else {\n      return this.getTimestampUsingOffset();\n    }\n  }\n  getTimestampUsingOffset() {\n    return Date.now() + (this.client.serverTimeOffset || 0);\n  }\n  isTimeOffsetSet() {\n    return this.client.serverTimeOffset !== null;\n  }\n  _saveBasicOptions(authOptions) {\n    this.method = \"basic\";\n    this.key = authOptions.key;\n    this.basicKey = toBase64(authOptions.key);\n    this.authOptions = authOptions || {};\n    if (\"clientId\" in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n  _saveTokenOptions(tokenParams, authOptions) {\n    this.method = \"token\";\n    if (tokenParams) {\n      this.tokenParams = tokenParams;\n    }\n    if (authOptions) {\n      if (authOptions.token) {\n        authOptions.tokenDetails = typeof authOptions.token === \"string\" ? { token: authOptions.token } : authOptions.token;\n      }\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n      if (\"clientId\" in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n      this.authOptions = authOptions;\n    }\n  }\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede) {\n    const token = this.tokenDetails;\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        throw new ErrorInfo(\n          \"Mismatch between clientId in token (\" + token.clientId + \") and current clientId (\" + this.clientId + \")\",\n          40102,\n          403\n        );\n      }\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Auth.getToken()\",\n          \"using cached token; expires = \" + token.expires\n        );\n        return token;\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"deleting expired token\");\n      this.tokenDetails = null;\n    }\n    const promise = (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create(this.logger))).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();\n    let tokenResponse, caughtError = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err;\n    }\n    if (this.currentTokenRequestId > tokenRequestId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth._ensureValidAuthCredentials()\",\n        \"Discarding token request response; overtaken by newer one\"\n      );\n      return promise;\n    }\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster == null ? void 0 : multicaster.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster == null ? void 0 : multicaster.resolveAll(this.tokenDetails = tokenResponse);\n    return promise;\n  }\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId) {\n    if (!(typeof clientId === \"string\" || clientId === null)) {\n      throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n    } else if (clientId === \"*\") {\n      throw new ErrorInfo(\n        'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err)\n        throw err;\n    }\n  }\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      const msg = \"Unexpected clientId mismatch: client has \" + this.clientId + \", requested \" + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth._uncheckedSetClientId()\", msg);\n      return err;\n    } else {\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n  _tokenClientIdMismatch(tokenClientId) {\n    return !!(this.clientId && this.clientId !== \"*\" && tokenClientId && tokenClientId !== \"*\" && this.clientId !== tokenClientId);\n  }\n  static isTokenErr(error) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n  revokeTokens(specifiers, options) {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n};\nvar auth_default = Auth;\n\n// src/common/types/http.ts\nfunction paramString(params) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + \"=\" + params[needle]);\n    }\n  }\n  return paramPairs.join(\"&\");\n}\nfunction appendingParams(uri, params) {\n  return uri + (params ? \"?\" : \"\") + paramString(params);\n}\nfunction logResult(result, method, uri, params, logger) {\n  if (result.error) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(uri, params) + \"; Error: \" + inspectError(result.error)\n    );\n  } else {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received; \" + appendingParams(uri, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body\" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + result.body)\n    );\n  }\n}\nfunction logRequest(method, uri, body, params, logger) {\n  if (logger.shouldLog(logger_default.LOG_MICRO)) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Sending; \" + appendingParams(uri, params) + \"; Body\" + (Platform.BufferUtils.isBuffer(body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(body) : \": \" + body)\n    );\n  }\n}\nvar Http = class {\n  constructor(client) {\n    this.client = client;\n    this.platformHttp = new Platform.Http(client);\n    this.checkConnectivity = this.platformHttp.checkConnectivity ? () => this.platformHttp.checkConnectivity() : void 0;\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  get supportsAuthHeaders() {\n    return this.platformHttp.supportsAuthHeaders;\n  }\n  get supportsLinkHeaders() {\n    return this.platformHttp.supportsLinkHeaders;\n  }\n  _getHosts(client) {\n    const connection = client.connection, connectionHost = connection && connection.connectionManager.host;\n    if (connectionHost) {\n      return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));\n    }\n    return defaults_default.getHosts(client.options);\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async do(method, path, headers, body, params) {\n    try {\n      const client = this.client;\n      if (!client) {\n        return { error: new ErrorInfo(\"http.do called without client\", 5e4, 500) };\n      }\n      const uriFromHost = typeof path === \"function\" ? path : function(host) {\n        return client.baseUri(host) + path;\n      };\n      const currentFallback = client._currentFallback;\n      if (currentFallback) {\n        if (currentFallback.validUntil > Date.now()) {\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error)) {\n            client._currentFallback = null;\n            return this.do(method, path, headers, body, params);\n          }\n          return result;\n        } else {\n          client._currentFallback = null;\n        }\n      }\n      const hosts = this._getHosts(client);\n      if (hosts.length === 1) {\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n      }\n      let tryAHostStartedAt = null;\n      const tryAHost = async (candidateHosts, persistOnSuccess) => {\n        const host = candidateHosts.shift();\n        tryAHostStartedAt = tryAHostStartedAt != null ? tryAHostStartedAt : /* @__PURE__ */ new Date();\n        const result = await this.doUri(method, uriFromHost(host), headers, body, params);\n        if (result.error && this.platformHttp.shouldFallback(result.error) && candidateHosts.length) {\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\n            return {\n              error: new ErrorInfo(\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\n                50003,\n                500\n              )\n            };\n          }\n          return tryAHost(candidateHosts, true);\n        }\n        if (persistOnSuccess) {\n          client._currentFallback = {\n            host,\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout\n          };\n        }\n        return result;\n      };\n      return tryAHost(hosts);\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async doUri(method, uri, headers, body, params) {\n    try {\n      logRequest(method, uri, body, params, this.logger);\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n      if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n        logResult(result, method, uri, params, this.logger);\n      }\n      return result;\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n};\n\n// src/common/lib/client/baseclient.ts\nvar BaseClient = class {\n  constructor(options) {\n    /**\n     * These exports are for use by UMD plugins; reason being so that constructors and static methods can be accessed by these plugins without needing to import the classes directly and result in the class existing in both the plugin and the core library.\n     */\n    this.Platform = Platform;\n    this.ErrorInfo = ErrorInfo;\n    this.Logger = logger_default;\n    this.Defaults = defaults_default;\n    this.Utils = utils_exports;\n    var _a2, _b, _c, _d, _e, _f, _g, _h;\n    this._additionalHTTPRequestImplementations = (_a2 = options.plugins) != null ? _a2 : null;\n    this.logger = new logger_default();\n    this.logger.setLog(options.logLevel, options.logHandler);\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"BaseClient()\",\n      \"initialized with clientOptions \" + Platform.Config.inspect(options)\n    );\n    this._MsgPack = (_c = (_b = options.plugins) == null ? void 0 : _b.MsgPack) != null ? _c : null;\n    const normalOptions = this.options = defaults_default.normaliseOptions(options, this._MsgPack, this.logger);\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = \"invalid key parameter\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"BaseClient()\", msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n    if (\"clientId\" in normalOptions) {\n      if (!(typeof normalOptions.clientId === \"string\" || normalOptions.clientId === null))\n        throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n      else if (normalOptions.clientId === \"*\")\n        throw new ErrorInfo(\n          'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400\n        );\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"BaseClient()\", \"started; version = \" + defaults_default.version);\n    this._currentFallback = null;\n    this.serverTimeOffset = null;\n    this.http = new Http(this);\n    this.auth = new auth_default(this, normalOptions);\n    this._rest = ((_d = options.plugins) == null ? void 0 : _d.Rest) ? new options.plugins.Rest(this) : null;\n    this._Crypto = (_f = (_e = options.plugins) == null ? void 0 : _e.Crypto) != null ? _f : null;\n    this.__FilteredSubscriptions = (_h = (_g = options.plugins) == null ? void 0 : _g.MessageInteractions) != null ? _h : null;\n  }\n  get rest() {\n    if (!this._rest) {\n      throwMissingPluginError(\"Rest\");\n    }\n    return this._rest;\n  }\n  get _FilteredSubscriptions() {\n    if (!this.__FilteredSubscriptions) {\n      throwMissingPluginError(\"MessageInteractions\");\n    }\n    return this.__FilteredSubscriptions;\n  }\n  get channels() {\n    return this.rest.channels;\n  }\n  get push() {\n    return this.rest.push;\n  }\n  get device() {\n    var _a2;\n    if (!((_a2 = this.options.plugins) == null ? void 0 : _a2.Push) || !this.push.LocalDevice) {\n      throwMissingPluginError(\"Push\");\n    }\n    if (!this._device) {\n      this._device = this.push.LocalDevice.load(this);\n    }\n    return this._device;\n  }\n  baseUri(host) {\n    return defaults_default.getHttpScheme(this.options) + host + \":\" + defaults_default.getPort(this.options, false);\n  }\n  async stats(params) {\n    return this.rest.stats(params);\n  }\n  async time(params) {\n    return this.rest.time(params);\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    return this.rest.request(method, path, version2, params, body, customHeaders);\n  }\n  batchPublish(specOrSpecs) {\n    return this.rest.batchPublish(specOrSpecs);\n  }\n  batchPresence(channels) {\n    return this.rest.batchPresence(channels);\n  }\n  setLog(logOptions) {\n    this.logger.setLog(logOptions.level, logOptions.handler);\n  }\n};\nBaseClient.Platform = Platform;\nvar baseclient_default = BaseClient;\n\n// src/common/lib/types/devicedetails.ts\nvar DeviceDetails = class _DeviceDetails {\n  toJSON() {\n    var _a2, _b, _c;\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,\n        state: (_b = this.push) == null ? void 0 : _b.state,\n        error: (_c = this.push) == null ? void 0 : _c.error\n      }\n    };\n  }\n  toString() {\n    var _a2, _b, _c, _d;\n    let result = \"[DeviceDetails\";\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.platform)\n      result += \"; platform=\" + this.platform;\n    if (this.formFactor)\n      result += \"; formFactor=\" + this.formFactor;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.metadata)\n      result += \"; metadata=\" + this.metadata;\n    if (this.deviceIdentityToken)\n      result += \"; deviceIdentityToken=\" + JSON.stringify(this.deviceIdentityToken);\n    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)\n      result += \"; push.recipient=\" + JSON.stringify(this.push.recipient);\n    if ((_b = this.push) == null ? void 0 : _b.state)\n      result += \"; push.state=\" + this.push.state;\n    if ((_c = this.push) == null ? void 0 : _c.error)\n      result += \"; push.error=\" + JSON.stringify(this.push.error);\n    if ((_d = this.push) == null ? void 0 : _d.metadata)\n      result += \"; push.metadata=\" + this.push.metadata;\n    result += \"]\";\n    return result;\n  }\n  static toRequestBody(body, MsgPack, format) {\n    return encodeBody(body, MsgPack, format);\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _DeviceDetails.fromValuesArray(body);\n    } else {\n      return _DeviceDetails.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    values.error = values.error && ErrorInfo.fromValues(values.error);\n    return Object.assign(new _DeviceDetails(), values);\n  }\n  static fromLocalDevice(device) {\n    return Object.assign(new _DeviceDetails(), device);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n};\nvar devicedetails_default = DeviceDetails;\n\n// src/common/lib/client/resource.ts\nasync function withAuthDetails(client, headers, params, opCallback) {\n  if (client.http.supportsAuthHeaders) {\n    const authHeaders = await client.auth.getAuthHeaders();\n    return opCallback(mixin(authHeaders, headers), params);\n  } else {\n    const authParams = await client.auth.getAuthParams();\n    return opCallback(headers, mixin(authParams, params));\n  }\n}\nfunction unenvelope(result, MsgPack, format) {\n  if (result.err && !result.body) {\n    return { err: result.err };\n  }\n  if (result.statusCode === HttpStatusCodes_default.NoContent) {\n    return __spreadProps(__spreadValues({}, result), { body: [], unpacked: true });\n  }\n  let body = result.body;\n  if (!result.unpacked) {\n    try {\n      body = decodeBody(body, MsgPack, format);\n    } catch (e) {\n      if (isErrorInfoOrPartialErrorInfo(e)) {\n        return { err: e };\n      } else {\n        return { err: new PartialErrorInfo(inspectError(e), null) };\n      }\n    }\n  }\n  if (!body) {\n    return { err: new PartialErrorInfo(\"unenvelope(): Response body is missing\", null) };\n  }\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;\n  if (wrappedStatusCode === void 0) {\n    return __spreadProps(__spreadValues({}, result), { body, unpacked: true });\n  }\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n    let wrappedErr = response && response.error || result.err;\n    if (!wrappedErr) {\n      wrappedErr = new Error(\"Error in unenveloping \" + body);\n      wrappedErr.statusCode = wrappedStatusCode;\n    }\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n  }\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n}\nfunction logResult2(result, method, path, params, logger) {\n  if (result.err) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(path, params) + \"; Error: \" + inspectError(result.err)\n    );\n  } else {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received; \" + appendingParams(path, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body: \" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + Platform.Config.inspect(result.body))\n    );\n  }\n}\nvar Resource = class _Resource {\n  static async get(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, throwError != null ? throwError : false);\n  }\n  static async delete(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, throwError);\n  }\n  static async post(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, throwError);\n  }\n  static async patch(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, throwError);\n  }\n  static async put(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, throwError);\n  }\n  static async do(method, client, path, body, headers, params, envelope, throwError) {\n    if (envelope) {\n      (params = params || {})[\"envelope\"] = envelope;\n    }\n    const logger = client.logger;\n    async function doRequest(headers2, params2) {\n      var _a2;\n      if (logger.shouldLog(logger_default.LOG_MICRO)) {\n        let decodedBody = body;\n        if (((_a2 = headers2[\"content-type\"]) == null ? void 0 : _a2.indexOf(\"msgpack\")) > 0) {\n          try {\n            if (!client._MsgPack) {\n              throwMissingPluginError(\"MsgPack\");\n            }\n            decodedBody = client._MsgPack.decode(body);\n          } catch (decodeErr) {\n            logger_default.logAction(\n              logger,\n              logger_default.LOG_MICRO,\n              \"Resource.\" + method + \"()\",\n              \"Sending MsgPack Decoding Error: \" + inspectError(decodeErr)\n            );\n          }\n        }\n        logger_default.logAction(\n          logger,\n          logger_default.LOG_MICRO,\n          \"Resource.\" + method + \"()\",\n          \"Sending; \" + appendingParams(path, params2) + \"; Body: \" + decodedBody\n        );\n      }\n      const httpResult = await client.http.do(method, path, headers2, body, params2);\n      if (httpResult.error && auth_default.isTokenErr(httpResult.error)) {\n        await client.auth.authorize(null, null);\n        return withAuthDetails(client, headers2, params2, doRequest);\n      }\n      return {\n        err: httpResult.error,\n        body: httpResult.body,\n        headers: httpResult.headers,\n        unpacked: httpResult.unpacked,\n        statusCode: httpResult.statusCode\n      };\n    }\n    let result = await withAuthDetails(client, headers, params, doRequest);\n    if (envelope) {\n      result = unenvelope(result, client._MsgPack, envelope);\n    }\n    if (logger.shouldLog(logger_default.LOG_MICRO)) {\n      logResult2(result, method, path, params, logger);\n    }\n    if (throwError) {\n      if (result.err) {\n        throw result.err;\n      } else {\n        const response = __spreadValues({}, result);\n        delete response.err;\n        return response;\n      }\n    }\n    return result;\n  }\n};\nvar resource_default = Resource;\n\n// src/common/lib/client/paginatedresource.ts\nfunction getRelParams(linkUrl) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);\n}\nfunction parseRelLinks(linkHeader) {\n  if (typeof linkHeader == \"string\")\n    linkHeader = linkHeader.split(\",\");\n  const relParams = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params)\n        relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\nfunction returnErrOnly(err, body, useHPR) {\n  return !(useHPR && (body || typeof err.code === \"number\"));\n}\nvar PaginatedResource = class {\n  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope != null ? envelope : null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async get(params) {\n    const result = await resource_default.get(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async delete(params) {\n    const result = await resource_default.delete(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async post(params, body) {\n    const result = await resource_default.post(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async put(params, body) {\n    const result = await resource_default.put(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async patch(params, body) {\n    const result = await resource_default.patch(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async handlePage(result) {\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"PaginatedResource.handlePage()\",\n        \"Unexpected error getting resource: err = \" + inspectError(result.err)\n      );\n      throw result.err;\n    }\n    let items, linkHeader, relParams;\n    try {\n      items = result.statusCode == HttpStatusCodes_default.NoContent ? [] : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n    } catch (e) {\n      throw result.err || e;\n    }\n    if (result.headers && (linkHeader = result.headers[\"Link\"] || result.headers[\"link\"])) {\n      relParams = parseRelLinks(linkHeader);\n    }\n    if (this.useHttpPaginatedResponse) {\n      return new HttpPaginatedResponse(\n        this,\n        items,\n        result.headers || {},\n        result.statusCode,\n        relParams,\n        result.err\n      );\n    } else {\n      return new PaginatedResult(this, items, relParams);\n    }\n  }\n};\nvar PaginatedResult = class {\n  constructor(resource, items, relParams) {\n    this.resource = resource;\n    this.items = items;\n    const self2 = this;\n    if (relParams) {\n      if (\"first\" in relParams) {\n        this.first = async function() {\n          return self2.get(relParams.first);\n        };\n      }\n      if (\"current\" in relParams) {\n        this.current = async function() {\n          return self2.get(relParams.current);\n        };\n      }\n      this.next = async function() {\n        if (\"next\" in relParams) {\n          return self2.get(relParams.next);\n        } else {\n          return null;\n        }\n      };\n      this.hasNext = function() {\n        return \"next\" in relParams;\n      };\n      this.isLast = () => {\n        var _a2;\n        return !((_a2 = this.hasNext) == null ? void 0 : _a2.call(this));\n      };\n    }\n  }\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  async get(params) {\n    const res = this.resource;\n    const result = await resource_default.get(res.client, res.path, res.headers, params, res.envelope, false);\n    return res.handlePage(result);\n  }\n};\nvar HttpPaginatedResponse = class extends PaginatedResult {\n  constructor(resource, items, headers, statusCode, relParams, err) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage\n    };\n  }\n};\nvar paginatedresource_default = PaginatedResource;\n\n// src/common/lib/types/pushchannelsubscription.ts\nvar _PushChannelSubscription = class _PushChannelSubscription {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId\n    };\n  }\n  toString() {\n    let result = \"[PushChannelSubscription\";\n    if (this.channel)\n      result += \"; channel=\" + this.channel;\n    if (this.deviceId)\n      result += \"; deviceId=\" + this.deviceId;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    result += \"]\";\n    return result;\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return _PushChannelSubscription.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    return Object.assign(new _PushChannelSubscription(), values);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n};\n_PushChannelSubscription.toRequestBody = encodeBody;\nvar PushChannelSubscription = _PushChannelSubscription;\nvar pushchannelsubscription_default = PushChannelSubscription;\n\n// src/common/lib/client/push.ts\nvar Push = class {\n  constructor(client) {\n    var _a2;\n    this.client = client;\n    this.admin = new Admin(client);\n    if (Platform.Config.push && ((_a2 = client.options.plugins) == null ? void 0 : _a2.Push)) {\n      this.stateMachine = new client.options.plugins.Push.ActivationStateMachine(client);\n      this.LocalDevice = client.options.plugins.Push.localDeviceFactory(devicedetails_default);\n    }\n  }\n  async activate(registerCallback, updateFailedCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.activatedCallback) {\n        reject(new ErrorInfo(\"Activation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.activatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.updateFailedCallback = updateFailedCallback;\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledActivate(this.stateMachine, registerCallback)\n      );\n    });\n  }\n  async deactivate(deregisterCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.deactivatedCallback) {\n        reject(new ErrorInfo(\"Deactivation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.deactivatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledDeactivate(this.stateMachine, deregisterCallback)\n      );\n    });\n  }\n};\nvar Admin = class {\n  constructor(client) {\n    this.client = client;\n    this.deviceRegistrations = new DeviceRegistrations(client);\n    this.channelSubscriptions = new ChannelSubscriptions(client);\n  }\n  async publish(recipient, payload) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    const body = mixin({ recipient }, payload);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    await resource_default.post(client, \"/push/publish\", requestBody, headers, params, null, true);\n  }\n};\nvar DeviceRegistrations = class {\n  constructor(client) {\n    this.client = client;\n  }\n  async save(device) {\n    const client = this.client;\n    const body = devicedetails_default.fromValues(device);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.put(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async get(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    const response = await resource_default.get(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/deviceRegistrations\", headers, envelope, async function(body, headers2, unpacked) {\n      return devicedetails_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async remove(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/deviceRegistrations\", headers, params, null, true);\n  }\n};\nvar ChannelSubscriptions = class _ChannelSubscriptions {\n  constructor(client) {\n    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n    this.remove = _ChannelSubscriptions.prototype.removeWhere;\n    this.client = client;\n  }\n  async save(subscription) {\n    const client = this.client;\n    const body = pushchannelsubscription_default.fromValues(subscription);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.post(\n      client,\n      \"/push/channelSubscriptions\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return pushchannelsubscription_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/channelSubscriptions\", headers, envelope, async function(body, headers2, unpacked) {\n      return pushchannelsubscription_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/channelSubscriptions\", headers, params, null, true);\n  }\n  async listChannels(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    return new paginatedresource_default(client, \"/push/channels\", headers, envelope, async function(body, headers2, unpacked) {\n      const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params);\n  }\n};\nvar push_default = Push;\n\n// src/common/lib/types/message.ts\nfunction normaliseContext(context) {\n  if (!context || !context.channelOptions) {\n    return {\n      channelOptions: context,\n      plugins: {},\n      baseEncodedPreviousPayload: void 0\n    };\n  }\n  return context;\n}\nfunction normalizeCipherOptions(Crypto2, logger, options) {\n  if (options && options.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(options.cipher, logger);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher\n    };\n  }\n  return options != null ? options : {};\n}\nfunction getMessageSize(msg) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += dataSizeBytes(msg.data);\n  }\n  return size;\n}\nasync function fromEncoded(logger, Crypto2, encoded, inputOptions) {\n  const msg = fromValues(encoded);\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  try {\n    await decode(msg, options);\n  } catch (e) {\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Message.fromEncoded()\", e.toString());\n  }\n  return msg;\n}\nasync function fromEncodedArray(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function encrypt(msg, options) {\n  let data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;\n  encoding = encoding ? encoding + \"/\" : \"\";\n  if (!Platform.BufferUtils.isBuffer(data)) {\n    data = Platform.BufferUtils.utf8Encode(String(data));\n    encoding = encoding + \"utf-8/\";\n  }\n  const ciphertext = await cipher.encrypt(data);\n  msg.data = ciphertext;\n  msg.encoding = encoding + \"cipher+\" + cipher.algorithm;\n  return msg;\n}\nasync function encode(msg, options) {\n  const data = msg.data;\n  const nativeDataType = typeof data == \"string\" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;\n  if (!nativeDataType) {\n    if (isObject(data) || Array.isArray(data)) {\n      msg.data = JSON.stringify(data);\n      msg.encoding = msg.encoding ? msg.encoding + \"/json\" : \"json\";\n    } else {\n      throw new ErrorInfo(\"Data type is unsupported\", 40013, 400);\n    }\n  }\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\nasync function encodeArray(messages, options) {\n  return Promise.all(messages.map((message) => encode(message, options)));\n}\nvar serialize = encodeBody;\nasync function decode(message, inputContext) {\n  const context = normaliseContext(inputContext);\n  let lastPayload = message.data;\n  const encoding = message.encoding;\n  if (encoding) {\n    const xforms = encoding.split(\"/\");\n    let lastProcessedEncodingIndex, encodingsToProcess = xforms.length, data = message.data;\n    let xform = \"\";\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match)\n          break;\n        xform = match[1];\n        switch (xform) {\n          case \"base64\":\n            data = Platform.BufferUtils.base64Decode(String(data));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = data;\n            }\n            continue;\n          case \"utf-8\":\n            data = Platform.BufferUtils.utf8Decode(data);\n            continue;\n          case \"json\":\n            data = JSON.parse(data);\n            continue;\n          case \"cipher\":\n            if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {\n              const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error(\"Unable to decrypt message with given cipher; incompatible cipher params\");\n              }\n              data = await cipher.decrypt(data);\n              continue;\n            } else {\n              throw new Error(\"Unable to decrypt message; not an encrypted channel\");\n            }\n          case \"vcdiff\":\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo(\"Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)\", 40019, 400);\n            }\n            if (typeof Uint8Array === \"undefined\") {\n              throw new ErrorInfo(\n                \"Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)\",\n                40020,\n                400\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === \"string\") {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);\n              data = Platform.BufferUtils.toBuffer(data);\n              data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\n              lastPayload = data;\n            } catch (e) {\n              throw new ErrorInfo(\"Vcdiff delta decode failed with \" + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error(\"Unknown encoding\");\n        }\n      }\n    } catch (e) {\n      const err = e;\n      throw new ErrorInfo(\n        \"Error processing the \" + xform + \" encoding, decoder returned \\u2018\" + err.message + \"\\u2019\",\n        err.code || 40013,\n        400\n      );\n    } finally {\n      message.encoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join(\"/\");\n      message.data = data;\n    }\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n}\nasync function fromResponseBody(body, options, logger, MsgPack, format) {\n  if (format) {\n    body = decodeBody(body, MsgPack, format);\n  }\n  for (let i = 0; i < body.length; i++) {\n    const msg = body[i] = fromValues(body[i]);\n    try {\n      await decode(msg, options);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"Message.fromResponseBody()\", e.toString());\n    }\n  }\n  return body;\n}\nfunction fromValues(values) {\n  return Object.assign(new Message(), values);\n}\nfunction fromValuesArray(values) {\n  const count = values.length, result = new Array(count);\n  for (let i = 0; i < count; i++)\n    result[i] = fromValues(values[i]);\n  return result;\n}\nfunction getMessagesSize(messages) {\n  let msg, total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\nvar Message = class {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    let encoding = this.encoding;\n    let data = this.data;\n    if (data && Platform.BufferUtils.isBuffer(data)) {\n      if (arguments.length > 0) {\n        encoding = encoding ? encoding + \"/base64\" : \"base64\";\n        data = Platform.BufferUtils.base64Encode(data);\n      } else {\n        data = Platform.BufferUtils.toBuffer(data);\n      }\n    }\n    return {\n      name: this.name,\n      id: this.id,\n      clientId: this.clientId,\n      connectionId: this.connectionId,\n      connectionKey: this.connectionKey,\n      extras: this.extras,\n      encoding,\n      data\n    };\n  }\n  toString() {\n    let result = \"[Message\";\n    if (this.name)\n      result += \"; name=\" + this.name;\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.timestamp)\n      result += \"; timestamp=\" + this.timestamp;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.connectionId)\n      result += \"; connectionId=\" + this.connectionId;\n    if (this.encoding)\n      result += \"; encoding=\" + this.encoding;\n    if (this.extras)\n      result += \"; extras =\" + JSON.stringify(this.extras);\n    if (this.data) {\n      if (typeof this.data == \"string\")\n        result += \"; data=\" + this.data;\n      else if (Platform.BufferUtils.isBuffer(this.data))\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(this.data);\n      else\n        result += \"; data (json)=\" + JSON.stringify(this.data);\n    }\n    if (this.extras)\n      result += \"; extras=\" + JSON.stringify(this.extras);\n    result += \"]\";\n    return result;\n  }\n};\nvar message_default = Message;\n\n// src/common/lib/types/presencemessage.ts\nvar actions = [\"absent\", \"present\", \"enter\", \"leave\", \"update\"];\nfunction toActionValue(actionString) {\n  return actions.indexOf(actionString);\n}\nasync function fromEncoded2(logger, encoded, options) {\n  const msg = fromValues2(encoded, true);\n  try {\n    await decode2(msg, options != null ? options : {});\n  } catch (e) {\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"PresenceMessage.fromEncoded()\", e.toString());\n  }\n  return msg;\n}\nasync function fromEncodedArray2(logger, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded2(logger, encoded, options);\n    })\n  );\n}\nfunction fromValues2(values, stringifyAction) {\n  if (stringifyAction) {\n    values.action = actions[values.action];\n  }\n  return Object.assign(new PresenceMessage(), values);\n}\nvar decode2 = decode;\nasync function fromResponseBody2(body, options, logger, MsgPack, format) {\n  const messages = [];\n  if (format) {\n    body = decodeBody(body, MsgPack, format);\n  }\n  for (let i = 0; i < body.length; i++) {\n    const msg = messages[i] = fromValues2(body[i], true);\n    try {\n      await decode2(msg, options);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"PresenceMessage.fromResponseBody()\", e.toString());\n    }\n  }\n  return messages;\n}\nfunction fromValuesArray2(values) {\n  const count = values.length, result = new Array(count);\n  for (let i = 0; i < count; i++)\n    result[i] = fromValues2(values[i]);\n  return result;\n}\nfunction fromData(data) {\n  if (data instanceof PresenceMessage) {\n    return data;\n  }\n  return fromValues2({\n    data\n  });\n}\nvar PresenceMessage = class {\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized() {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n  /* RTP2b2 */\n  parseId() {\n    if (!this.id)\n      throw new Error(\"parseId(): Presence message does not contain an id\");\n    const parts = this.id.split(\":\");\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10)\n    };\n  }\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    let data = this.data;\n    let encoding = this.encoding;\n    if (data && Platform.BufferUtils.isBuffer(data)) {\n      if (arguments.length > 0) {\n        encoding = encoding ? encoding + \"/base64\" : \"base64\";\n        data = Platform.BufferUtils.base64Encode(data);\n      } else {\n        data = Platform.BufferUtils.toBuffer(data);\n      }\n    }\n    return {\n      id: this.id,\n      clientId: this.clientId,\n      /* Convert presence action back to an int for sending to Ably */\n      action: toActionValue(this.action),\n      data,\n      encoding,\n      extras: this.extras\n    };\n  }\n  toString() {\n    let result = \"[PresenceMessage\";\n    result += \"; action=\" + this.action;\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.timestamp)\n      result += \"; timestamp=\" + this.timestamp;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.connectionId)\n      result += \"; connectionId=\" + this.connectionId;\n    if (this.encoding)\n      result += \"; encoding=\" + this.encoding;\n    if (this.data) {\n      if (typeof this.data == \"string\")\n        result += \"; data=\" + this.data;\n      else if (Platform.BufferUtils.isBuffer(this.data))\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(this.data);\n      else\n        result += \"; data (json)=\" + JSON.stringify(this.data);\n    }\n    if (this.extras) {\n      result += \"; extras=\" + JSON.stringify(this.extras);\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar presencemessage_default = PresenceMessage;\n\n// src/common/lib/client/restpresence.ts\nvar RestPresence = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  get logger() {\n    return this.channel.logger;\n  }\n  async get(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.get()\", \"channel = \" + this.channel.name);\n    const client = this.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    const options = this.channel.channelOptions;\n    return new paginatedresource_default(\n      client,\n      this.channel.client.rest.presenceMixin.basePath(this),\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        return await fromResponseBody2(\n          body,\n          options,\n          this.logger,\n          client._MsgPack,\n          unpacked ? void 0 : format\n        );\n      }\n    ).get(params);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.history()\", \"channel = \" + this.channel.name);\n    return this.channel.client.rest.presenceMixin.history(this, params);\n  }\n};\nvar restpresence_default = RestPresence;\n\n// src/common/lib/client/restchannel.ts\nvar MSG_ID_ENTROPY_BYTES = 9;\nfunction allEmptyIds(messages) {\n  return messages.every(function(message) {\n    return !message.id;\n  });\n}\nvar RestChannel = class {\n  constructor(client, name, channelOptions) {\n    var _a2, _b;\n    logger_default.logAction(client.logger, logger_default.LOG_MINOR, \"RestChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.client = client;\n    this.presence = new restpresence_default(this);\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, channelOptions);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  setOptions(options) {\n    var _a2;\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.history()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.history(this, params);\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null) {\n      messages = [fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    if (!params) {\n      params = {};\n    }\n    const client = this.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options, { format });\n    mixin(headers, options.headers);\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = await randomString(MSG_ID_ENTROPY_BYTES);\n      messages.forEach(function(message, index) {\n        message.id = msgIdBase + \":\" + index.toString();\n      });\n    }\n    await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(messages), maxMessageSize = options.maxMessageSize;\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        \"Maximum size of messages that can be published at once exceeded ( was \" + size + \" bytes; limit is \" + maxMessageSize + \" bytes)\",\n        40009,\n        400\n      );\n    }\n    await this._publish(serialize(messages, client._MsgPack, format), headers, params);\n  }\n  async _publish(requestBody, headers, params) {\n    await resource_default.post(\n      this.client,\n      this.client.rest.channelMixin.basePath(this) + \"/messages\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n};\nvar restchannel_default = RestChannel;\n\n// src/common/lib/types/stats.ts\nvar Stats = class _Stats {\n  constructor(values) {\n    this.entries = values && values.entries || void 0;\n    this.schema = values && values.schema || void 0;\n    this.appId = values && values.appId || void 0;\n    this.inProgress = values && values.inProgress || void 0;\n    this.unit = values && values.unit || void 0;\n    this.intervalId = values && values.intervalId || void 0;\n  }\n  static fromValues(values) {\n    return new _Stats(values);\n  }\n};\nvar stats_default = Stats;\n\n// src/common/lib/client/restchannelmixin.ts\nvar RestChannelMixin = class {\n  static basePath(channel) {\n    return \"/channels/\" + encodeURIComponent(channel.name);\n  }\n  static history(channel, params) {\n    const client = channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    const options = channel.channelOptions;\n    return new paginatedresource_default(client, this.basePath(channel) + \"/messages\", headers, envelope, async function(body, headers2, unpacked) {\n      return await fromResponseBody(\n        body,\n        options,\n        channel.logger,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  static async status(channel) {\n    const format = channel.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(channel.client.options, { format });\n    const response = await resource_default.get(\n      channel.client,\n      this.basePath(channel),\n      headers,\n      {},\n      format,\n      true\n    );\n    return response.body;\n  }\n};\n\n// src/common/lib/client/restpresencemixin.ts\nvar RestPresenceMixin = class {\n  static basePath(presence) {\n    return RestChannelMixin.basePath(presence.channel) + \"/presence\";\n  }\n  static async history(presence, params) {\n    const client = presence.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    const options = presence.channel.channelOptions;\n    return new paginatedresource_default(client, this.basePath(presence) + \"/history\", headers, envelope, async function(body, headers2, unpacked) {\n      return await fromResponseBody2(\n        body,\n        options,\n        presence.logger,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n};\n\n// src/common/lib/client/rest.ts\nvar Rest = class {\n  constructor(client) {\n    this.channelMixin = RestChannelMixin;\n    this.presenceMixin = RestPresenceMixin;\n    // exposed for plugins but shouldn't be bundled with minimal realtime\n    this.Resource = resource_default;\n    this.DeviceDetails = devicedetails_default;\n    this.client = client;\n    this.channels = new Channels(this.client);\n    this.push = new push_default(this.client);\n  }\n  async stats(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options), format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    mixin(headers, this.client.options.headers);\n    return new paginatedresource_default(this.client, \"/stats\", headers, envelope, function(body, headers2, unpacked) {\n      const statsValues = unpacked ? body : JSON.parse(body);\n      for (let i = 0; i < statsValues.length; i++)\n        statsValues[i] = stats_default.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params);\n  }\n  async time(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const timeUri = (host) => {\n      return this.client.baseUri(host) + \"/time\";\n    };\n    let { error, body, unpacked } = await this.client.http.do(\n      HttpMethods_default.Get,\n      timeUri,\n      headers,\n      null,\n      params\n    );\n    if (error) {\n      throw error;\n    }\n    if (!unpacked)\n      body = JSON.parse(body);\n    const time = body[0];\n    if (!time) {\n      throw new ErrorInfo(\"Internal error (unexpected result type from GET /time)\", 5e4, 500);\n    }\n    this.client.serverTimeOffset = time - Date.now();\n    return time;\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    var _a2;\n    const [encoder, decoder, format] = (() => {\n      if (this.client.options.useBinaryProtocol) {\n        if (!this.client._MsgPack) {\n          throwMissingPluginError(\"MsgPack\");\n        }\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, \"msgpack\" /* msgpack */];\n      } else {\n        return [JSON.stringify, JSON.parse, \"json\" /* json */];\n      }\n    })();\n    const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    params = params || {};\n    const _method = method.toLowerCase();\n    const headers = _method == \"get\" ? defaults_default.defaultGetHeaders(this.client.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.client.options, { format, protocolVersion: version2 });\n    if (typeof body !== \"string\") {\n      body = (_a2 = encoder(body)) != null ? _a2 : null;\n    }\n    mixin(headers, this.client.options.headers);\n    if (customHeaders) {\n      mixin(headers, customHeaders);\n    }\n    const paginatedResource = new paginatedresource_default(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function(resbody, headers2, unpacked) {\n        return ensureArray(unpacked ? resbody : decoder(resbody));\n      },\n      /* useHttpPaginatedResponse: */\n      true\n    );\n    if (!Platform.Http.methods.includes(_method)) {\n      throw new ErrorInfo(\"Unsupported method \" + _method, 40500, 405);\n    }\n    if (Platform.Http.methodsWithBody.includes(_method)) {\n      return paginatedResource[_method](params, body);\n    } else {\n      return paginatedResource[_method](params);\n    }\n  }\n  async batchPublish(specOrSpecs) {\n    let requestBodyDTO;\n    let singleSpecMode;\n    if (Array.isArray(specOrSpecs)) {\n      requestBodyDTO = specOrSpecs;\n      singleSpecMode = false;\n    } else {\n      requestBodyDTO = [specOrSpecs];\n      singleSpecMode = true;\n    }\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(this.client, \"/messages\", requestBody, headers, {}, null, true);\n    const batchResults = response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    if (singleSpecMode) {\n      return batchResults[0];\n    } else {\n      return batchResults;\n    }\n  }\n  async batchPresence(channels) {\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const channelsParam = channels.join(\",\");\n    const response = await resource_default.get(this.client, \"/presence\", headers, { channels: channelsParam }, null, true);\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n  async revokeTokens(specifiers, options) {\n    if (useTokenAuth(this.client.options)) {\n      throw new ErrorInfo(\"Cannot revoke tokens when using token auth\", 40162, 401);\n    }\n    const keyName = this.client.options.keyName;\n    let resolvedOptions = options != null ? options : {};\n    const requestBodyDTO = __spreadValues({\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`)\n    }, resolvedOptions);\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(\n      this.client,\n      `/keys/${keyName}/revokeTokens`,\n      requestBody,\n      headers,\n      {},\n      null,\n      true\n    );\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n};\nvar Channels = class {\n  constructor(client) {\n    this.client = client;\n    this.all = /* @__PURE__ */ Object.create(null);\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    delete this.all[String(name)];\n  }\n};\n\n// src/common/lib/client/baserest.ts\nvar BaseRest = class extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    super(defaults_default.objectifyOptions(options, false, \"BaseRest\", logger_default.defaultLogger, { Rest }));\n  }\n};\n\n// src/common/lib/client/modularplugins.ts\nvar allCommonModularPlugins = { Rest };\n\n// src/common/lib/types/defaultmessage.ts\nvar DefaultMessage = class extends message_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  // Used by tests\n  static fromValues(values) {\n    return Object.assign(new message_default(), values);\n  }\n  // Used by tests\n  static async encode(msg, options) {\n    return encode(msg, options);\n  }\n  // Used by tests\n  static async decode(message, inputContext) {\n    return decode(message, inputContext);\n  }\n};\n\n// src/common/lib/types/defaultpresencemessage.ts\nvar DefaultPresenceMessage = class extends presencemessage_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded2(logger_default.defaultLogger, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray2(logger_default.defaultLogger, encodedArray, options);\n  }\n  static fromValues(values, stringifyAction) {\n    return fromValues2(values, stringifyAction);\n  }\n};\n\n// src/common/lib/client/defaultrest.ts\nvar _DefaultRest = class _DefaultRest extends BaseRest {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2, _b;\n    const MsgPack = _DefaultRest._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRest._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Rest\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRest.Crypto) != null ? _a2 : void 0,\n        MsgPack: (_b = _DefaultRest._MsgPack) != null ? _b : void 0\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRest._Crypto = null;\n_DefaultRest.Message = DefaultMessage;\n_DefaultRest.PresenceMessage = DefaultPresenceMessage;\n_DefaultRest._MsgPack = null;\n// Used by tests\n_DefaultRest._Http = Http;\nvar DefaultRest = _DefaultRest;\n\n// src/common/lib/util/eventemitter.ts\nfunction callListener(logger, eventThis, listener, args) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_ERROR,\n      \"EventEmitter.emit()\",\n      \"Unexpected listener exception: \" + e + \"; stack = \" + (e && e.stack)\n    );\n  }\n}\nfunction removeListener(targetListeners, listener, eventFilter) {\n  let listeners;\n  let index;\n  let eventName;\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter];\n    }\n    if (Array.isArray(listeners)) {\n      while ((index = listeners.indexOf(listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (isObject(listeners)) {\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\nvar EventEmitter = class {\n  constructor(logger) {\n    this.logger = logger;\n    this.any = [];\n    this.events = /* @__PURE__ */ Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = /* @__PURE__ */ Object.create(null);\n  }\n  on(...args) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === \"function\") {\n        this.any.push(listener);\n      } else {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== \"function\") {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n      if (isNil(event)) {\n        this.any.push(listener);\n      } else if (Array.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== \"string\") {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n  off(...args) {\n    if (args.length == 0 || isNil(args[0]) && isNil(args[1])) {\n      this.any = [];\n      this.events = /* @__PURE__ */ Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = /* @__PURE__ */ Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener = null;\n    let event = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === \"function\") {\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n    } else {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n    if (listener && isNil(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n    if (Array.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n    if (typeof event !== \"string\") {\n      throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event])\n        Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event, ...args) {\n    const eventThis = { event };\n    const listeners = [];\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n    listeners.forEach((listener) => {\n      callListener(this.logger, eventThis, listener, args);\n    });\n  }\n  once(...args) {\n    const argCount = args.length;\n    if (argCount === 0 || argCount === 1 && typeof args[0] !== \"function\") {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event, resolve);\n      });\n    }\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === \"function\") {\n      this.anyOnce.push(firstArg);\n    } else if (isNil(firstArg)) {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Array.isArray(firstArg)) {\n      const self2 = this;\n      const listenerWrapper = function() {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        firstArg.forEach(function(eventName) {\n          self2.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      firstArg.forEach(function(eventName) {\n        self2.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== \"string\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n  /**\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   */\n  async whenState(targetState, currentState) {\n    if (typeof targetState !== \"string\" || typeof currentState !== \"string\") {\n      throw new Error(\"whenState requires a valid state String argument\");\n    }\n    if (targetState === currentState) {\n      return null;\n    } else {\n      return this.once(targetState);\n    }\n  }\n};\nvar eventemitter_default = EventEmitter;\n\n// src/common/lib/types/protocolmessage.ts\nvar actions2 = {\n  HEARTBEAT: 0,\n  ACK: 1,\n  NACK: 2,\n  CONNECT: 3,\n  CONNECTED: 4,\n  DISCONNECT: 5,\n  DISCONNECTED: 6,\n  CLOSE: 7,\n  CLOSED: 8,\n  ERROR: 9,\n  ATTACH: 10,\n  ATTACHED: 11,\n  DETACH: 12,\n  DETACHED: 13,\n  PRESENCE: 14,\n  MESSAGE: 15,\n  SYNC: 16,\n  AUTH: 17,\n  ACTIVATE: 18\n};\nvar ActionName = [];\nObject.keys(actions2).forEach(function(name) {\n  ActionName[actions2[name]] = name;\n});\nvar flags = {\n  /* Channel attach state flags */\n  HAS_PRESENCE: 1 << 0,\n  HAS_BACKLOG: 1 << 1,\n  RESUMED: 1 << 2,\n  TRANSIENT: 1 << 4,\n  ATTACH_RESUME: 1 << 5,\n  /* Channel mode flags */\n  PRESENCE: 1 << 16,\n  PUBLISH: 1 << 17,\n  SUBSCRIBE: 1 << 18,\n  PRESENCE_SUBSCRIBE: 1 << 19\n};\nvar flagNames = Object.keys(flags);\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\nfunction toStringArray(array) {\n  const result = [];\n  if (array) {\n    for (let i = 0; i < array.length; i++) {\n      result.push(array[i].toString());\n    }\n  }\n  return \"[ \" + result.join(\", \") + \" ]\";\n}\nvar channelModes = [\"PRESENCE\", \"PUBLISH\", \"SUBSCRIBE\", \"PRESENCE_SUBSCRIBE\"];\nvar serialize2 = encodeBody;\nfunction deserialize(serialized, MsgPack, presenceMessagePlugin, format) {\n  const deserialized = decodeBody(serialized, MsgPack, format);\n  return fromDeserialized(deserialized, presenceMessagePlugin);\n}\nfunction fromDeserialized(deserialized, presenceMessagePlugin) {\n  const error = deserialized.error;\n  if (error)\n    deserialized.error = ErrorInfo.fromValues(error);\n  const messages = deserialized.messages;\n  if (messages)\n    for (let i = 0; i < messages.length; i++)\n      messages[i] = fromValues(messages[i]);\n  const presence = presenceMessagePlugin ? deserialized.presence : void 0;\n  if (presenceMessagePlugin) {\n    if (presence && presenceMessagePlugin)\n      for (let i = 0; i < presence.length; i++)\n        presence[i] = presenceMessagePlugin.presenceMessageFromValues(presence[i], true);\n  }\n  return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), { presence }));\n}\nfunction fromDeserializedIncludingDependencies(deserialized) {\n  return fromDeserialized(deserialized, { presenceMessageFromValues: fromValues2, presenceMessagesFromValuesArray: fromValuesArray2 });\n}\nfunction fromValues3(values) {\n  return Object.assign(new ProtocolMessage(), values);\n}\nfunction stringify(msg, presenceMessagePlugin) {\n  let result = \"[ProtocolMessage\";\n  if (msg.action !== void 0)\n    result += \"; action=\" + ActionName[msg.action] || 0;\n  const simpleAttributes = [\"id\", \"channel\", \"channelSerial\", \"connectionId\", \"count\", \"msgSerial\", \"timestamp\"];\n  let attribute;\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n    attribute = simpleAttributes[attribIndex];\n    if (msg[attribute] !== void 0)\n      result += \"; \" + attribute + \"=\" + msg[attribute];\n  }\n  if (msg.messages)\n    result += \"; messages=\" + toStringArray(fromValuesArray(msg.messages));\n  if (msg.presence && presenceMessagePlugin)\n    result += \"; presence=\" + toStringArray(presenceMessagePlugin.presenceMessagesFromValuesArray(msg.presence));\n  if (msg.error)\n    result += \"; error=\" + ErrorInfo.fromValues(msg.error).toString();\n  if (msg.auth && msg.auth.accessToken)\n    result += \"; token=\" + msg.auth.accessToken;\n  if (msg.flags)\n    result += \"; flags=\" + flagNames.filter(msg.hasFlag).join(\",\");\n  if (msg.params) {\n    let stringifiedParams = \"\";\n    forInOwnNonNullProperties(msg.params, function(prop) {\n      if (stringifiedParams.length > 0) {\n        stringifiedParams += \"; \";\n      }\n      stringifiedParams += prop + \"=\" + msg.params[prop];\n    });\n    if (stringifiedParams.length > 0) {\n      result += \"; params=[\" + stringifiedParams + \"]\";\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar ProtocolMessage = class {\n  constructor() {\n    this.hasFlag = (flag) => {\n      return (this.flags & flags[flag]) > 0;\n    };\n  }\n  setFlag(flag) {\n    return this.flags = this.flags | flags[flag];\n  }\n  getMode() {\n    return this.flags && this.flags & flags.MODE_ALL;\n  }\n  encodeModesToFlags(modes) {\n    modes.forEach((mode) => this.setFlag(mode));\n  }\n  decodeModesFromFlags() {\n    const modes = [];\n    channelModes.forEach((mode) => {\n      if (this.hasFlag(mode)) {\n        modes.push(mode);\n      }\n    });\n    return modes.length > 0 ? modes : void 0;\n  }\n};\nvar protocolmessage_default = ProtocolMessage;\n\n// src/common/lib/transport/messagequeue.ts\nvar MessageQueue = class extends eventemitter_default {\n  constructor(logger) {\n    super(logger);\n    this.messages = [];\n  }\n  count() {\n    return this.messages.length;\n  }\n  push(message) {\n    this.messages.push(message);\n  }\n  shift() {\n    return this.messages.shift();\n  }\n  last() {\n    return this.messages[this.messages.length - 1];\n  }\n  copyAll() {\n    return this.messages.slice();\n  }\n  append(messages) {\n    this.messages.push.apply(this.messages, messages);\n  }\n  prepend(messages) {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n  completeMessages(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.completeMessages()\",\n      \"serial = \" + serial + \"; count = \" + count\n    );\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error(\"MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue\");\n    }\n    const first = messages[0];\n    if (first) {\n      const startSerial = first.message.msgSerial;\n      const endSerial = serial + count;\n      if (endSerial > startSerial) {\n        const completeMessages = messages.splice(0, endSerial - startSerial);\n        for (const message of completeMessages) {\n          message.callback(err);\n        }\n      }\n      if (messages.length == 0)\n        this.emit(\"idle\");\n    }\n  }\n  completeAllMessages(err) {\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n  }\n  resetSendAttempted() {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n  clear() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.clear()\",\n      \"clearing \" + this.messages.length + \" messages\"\n    );\n    this.messages = [];\n    this.emit(\"idle\");\n  }\n};\nvar messagequeue_default = MessageQueue;\n\n// src/common/lib/transport/protocol.ts\nvar PendingMessage = class {\n  constructor(message, callback) {\n    this.message = message;\n    this.callback = callback;\n    this.merged = false;\n    const action = message.action;\n    this.sendAttempted = false;\n    this.ackRequired = action == actions2.MESSAGE || action == actions2.PRESENCE;\n  }\n};\nvar Protocol = class extends eventemitter_default {\n  constructor(transport) {\n    super(transport.logger);\n    this.transport = transport;\n    this.messageQueue = new messagequeue_default(this.logger);\n    transport.on(\"ack\", (serial, count) => {\n      this.onAck(serial, count);\n    });\n    transport.on(\"nack\", (serial, count, err) => {\n      this.onNack(serial, count, err);\n    });\n  }\n  onAck(serial, count) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"Protocol.onAck()\", \"serial = \" + serial + \"; count = \" + count);\n    this.messageQueue.completeMessages(serial, count);\n  }\n  onNack(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_ERROR,\n      \"Protocol.onNack()\",\n      \"serial = \" + serial + \"; count = \" + count + \"; err = \" + inspectError(err)\n    );\n    if (!err) {\n      err = new ErrorInfo(\"Unable to send message; channel not responding\", 50001, 500);\n    }\n    this.messageQueue.completeMessages(serial, count, err);\n  }\n  onceIdle(listener) {\n    const messageQueue = this.messageQueue;\n    if (messageQueue.count() === 0) {\n      listener();\n      return;\n    }\n    messageQueue.once(\"idle\", listener);\n  }\n  send(pendingMessage) {\n    if (pendingMessage.ackRequired) {\n      this.messageQueue.push(pendingMessage);\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Protocol.send()\",\n        \"sending msg; \" + stringify(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence)\n      );\n    }\n    pendingMessage.sendAttempted = true;\n    this.transport.send(pendingMessage.message);\n  }\n  getTransport() {\n    return this.transport;\n  }\n  getPendingMessages() {\n    return this.messageQueue.copyAll();\n  }\n  clearPendingMessages() {\n    return this.messageQueue.clear();\n  }\n  finish() {\n    const transport = this.transport;\n    this.onceIdle(function() {\n      transport.disconnect();\n    });\n  }\n};\nvar protocol_default = Protocol;\n\n// src/common/lib/client/connectionstatechange.ts\nvar ConnectionStateChange = class {\n  constructor(previous, current, retryIn, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn)\n      this.retryIn = retryIn;\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar connectionstatechange_default = ConnectionStateChange;\n\n// src/common/lib/transport/connectionerrors.ts\nvar ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 8e4,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001\n};\nvar ConnectionErrors = {\n  disconnected: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.DISCONNECTED,\n    message: \"Connection to server temporarily unavailable\"\n  }),\n  suspended: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.SUSPENDED,\n    message: \"Connection to server unavailable\"\n  }),\n  failed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.FAILED,\n    message: \"Connection failed or disconnected by server\"\n  }),\n  closing: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSING,\n    message: \"Connection closing\"\n  }),\n  closed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSED,\n    message: \"Connection closed\"\n  }),\n  unknownConnectionErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal connection error\"\n  }),\n  unknownChannelErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal channel error\"\n  })\n};\nfunction isRetriable(err) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\nvar connectionerrors_default = ConnectionErrors;\n\n// src/common/lib/transport/transport.ts\nvar closeMessage = fromValues3({ action: actions2.CLOSE });\nvar disconnectMessage = fromValues3({ action: actions2.DISCONNECT });\nvar Transport = class extends eventemitter_default {\n  constructor(connectionManager, auth, params, forceJsonProtocol) {\n    super(connectionManager.logger);\n    if (forceJsonProtocol) {\n      params.format = void 0;\n      params.heartbeats = true;\n    }\n    this.connectionManager = connectionManager;\n    this.auth = auth;\n    this.params = params;\n    this.timeouts = params.options.timeouts;\n    this.format = params.format;\n    this.isConnected = false;\n    this.isFinished = false;\n    this.isDisposed = false;\n    this.maxIdleInterval = null;\n    this.idleTimer = null;\n    this.lastActivity = null;\n  }\n  connect() {\n  }\n  close() {\n    if (this.isConnected) {\n      this.requestClose();\n    }\n    this.finish(\"closed\", connectionerrors_default.closed());\n  }\n  disconnect(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"disconnected\", err || connectionerrors_default.disconnected());\n  }\n  fail(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"failed\", err || connectionerrors_default.failed());\n  }\n  finish(event, err) {\n    var _a2;\n    if (this.isFinished) {\n      return;\n    }\n    this.isFinished = true;\n    this.isConnected = false;\n    this.maxIdleInterval = null;\n    clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);\n    this.idleTimer = null;\n    this.emit(event, err);\n    this.dispose();\n  }\n  onProtocolMessage(message) {\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Transport.onProtocolMessage()\",\n        \"received on \" + this.shortName + \": \" + stringify(message, this.connectionManager.realtime._RealtimePresence) + \"; connectionId = \" + this.connectionManager.connectionId\n      );\n    }\n    this.onActivity();\n    switch (message.action) {\n      case actions2.HEARTBEAT:\n        logger_default.logActionNoStrip(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Transport.onProtocolMessage()\",\n          this.shortName + \" heartbeat; connectionId = \" + this.connectionManager.connectionId\n        );\n        this.emit(\"heartbeat\", message.id);\n        break;\n      case actions2.CONNECTED:\n        this.onConnect(message);\n        this.emit(\"connected\", message.error, message.connectionId, message.connectionDetails, message);\n        break;\n      case actions2.CLOSED:\n        this.onClose(message);\n        break;\n      case actions2.DISCONNECTED:\n        this.onDisconnect(message);\n        break;\n      case actions2.ACK:\n        this.emit(\"ack\", message.msgSerial, message.count);\n        break;\n      case actions2.NACK:\n        this.emit(\"nack\", message.msgSerial, message.count, message.error);\n        break;\n      case actions2.SYNC:\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      case actions2.ACTIVATE:\n        break;\n      case actions2.AUTH:\n        whenPromiseSettles(this.auth.authorize(), (err) => {\n          if (err) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Transport.onProtocolMessage()\",\n              \"Ably requested re-authentication, but unable to obtain a new token: \" + inspectError(err)\n            );\n          }\n        });\n        break;\n      case actions2.ERROR:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Transport.onProtocolMessage()\",\n          \"received error action; connectionId = \" + this.connectionManager.connectionId + \"; err = \" + Platform.Config.inspect(message.error) + (message.channel ? \", channel: \" + message.channel : \"\")\n        );\n        if (message.channel === void 0) {\n          this.onFatalError(message);\n          break;\n        }\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      default:\n        this.connectionManager.onChannelMessage(message, this);\n    }\n  }\n  onConnect(message) {\n    this.isConnected = true;\n    if (!message.connectionDetails) {\n      throw new Error(\"Transport.onConnect(): Connect message recieved without connectionDetails\");\n    }\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n    if (maxPromisedIdle) {\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n      this.onActivity();\n    }\n  }\n  onDisconnect(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onDisconnect()\", \"err = \" + inspectError(err));\n    this.finish(\"disconnected\", err);\n  }\n  onFatalError(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onFatalError()\", \"err = \" + inspectError(err));\n    this.finish(\"failed\", err);\n  }\n  onClose(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onClose()\", \"err = \" + inspectError(err));\n    this.finish(\"closed\", err);\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestClose()\", \"\");\n    this.send(closeMessage);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestDisconnect()\", \"\");\n    this.send(disconnectMessage);\n  }\n  ping(id) {\n    const msg = { action: actions2.HEARTBEAT };\n    if (id)\n      msg.id = id;\n    this.send(fromValues3(msg));\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.dispose()\", \"\");\n    this.isDisposed = true;\n    this.off();\n  }\n  onActivity() {\n    if (!this.maxIdleInterval) {\n      return;\n    }\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\n    this.setIdleTimer(this.maxIdleInterval + 100);\n  }\n  setIdleTimer(timeout) {\n    if (!this.idleTimer) {\n      this.idleTimer = setTimeout(() => {\n        this.onIdleTimerExpire();\n      }, timeout);\n    }\n  }\n  onIdleTimerExpire() {\n    if (!this.lastActivity || !this.maxIdleInterval) {\n      throw new Error(\"Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set\");\n    }\n    this.idleTimer = null;\n    const sinceLast = Date.now() - this.lastActivity;\n    const timeRemaining = this.maxIdleInterval - sinceLast;\n    if (timeRemaining <= 0) {\n      const msg = \"No activity seen from realtime in \" + sinceLast + \"ms; assuming connection has dropped\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Transport.onIdleTimerExpire()\", msg);\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\n    } else {\n      this.setIdleTimer(timeRemaining + 100);\n    }\n  }\n  static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {\n    const transport = new transportCtor(connectionManager, auth, transportParams);\n    let transportAttemptTimer;\n    const errorCb = function(err) {\n      clearTimeout(transportAttemptTimer);\n      callback({ event: this.event, error: err });\n    };\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n    transportAttemptTimer = setTimeout(() => {\n      transport.off([\"preconnect\", \"disconnected\", \"failed\"]);\n      transport.dispose();\n      errorCb.call(\n        { event: \"disconnected\" },\n        new ErrorInfo(\"Timeout waiting for transport to indicate itself viable\", 5e4, 500)\n      );\n    }, realtimeRequestTimeout);\n    transport.on([\"failed\", \"disconnected\"], errorCb);\n    transport.on(\"preconnect\", function() {\n      logger_default.logAction(\n        connectionManager.logger,\n        logger_default.LOG_MINOR,\n        \"Transport.tryConnect()\",\n        \"viable transport \" + transport\n      );\n      clearTimeout(transportAttemptTimer);\n      transport.off([\"failed\", \"disconnected\"], errorCb);\n      callback(null, transport);\n    });\n    transport.connect();\n    return transport;\n  }\n  static isAvailable() {\n    throw new ErrorInfo(\"isAvailable not implemented for transport\", 5e4, 500);\n  }\n};\nvar transport_default = Transport;\n\n// src/common/constants/TransportName.ts\nvar TransportNames;\n((TransportNames2) => {\n  TransportNames2.WebSocket = \"web_socket\";\n  TransportNames2.Comet = \"comet\";\n  TransportNames2.XhrPolling = \"xhr_polling\";\n})(TransportNames || (TransportNames = {}));\n\n// src/common/lib/transport/connectionmanager.ts\nvar globalObject2 = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nvar haveWebStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);\n};\nvar haveSessionStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);\n};\nvar noop = function() {\n};\nvar transportPreferenceName = \"ably-transport-preference\";\nfunction bundleWith(dest, src, maxSize) {\n  let action;\n  if (dest.channel !== src.channel) {\n    return false;\n  }\n  if ((action = dest.action) !== actions2.PRESENCE && action !== actions2.MESSAGE) {\n    return false;\n  }\n  if (action !== src.action) {\n    return false;\n  }\n  const kind = action === actions2.PRESENCE ? \"presence\" : \"messages\", proposed = dest[kind].concat(src[kind]), size = getMessagesSize(proposed);\n  if (size > maxSize) {\n    return false;\n  }\n  if (!allSame(proposed, \"clientId\")) {\n    return false;\n  }\n  if (!proposed.every(function(msg) {\n    return !msg.id;\n  })) {\n    return false;\n  }\n  dest[kind] = proposed;\n  return true;\n}\nfunction decodeRecoveryKey(recoveryKey) {\n  try {\n    return JSON.parse(recoveryKey);\n  } catch (e) {\n    return null;\n  }\n}\nvar TransportParams = class {\n  constructor(options, host, mode, connectionKey) {\n    this.options = options;\n    this.host = host;\n    this.mode = mode;\n    this.connectionKey = connectionKey;\n    this.format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n  }\n  getConnectParams(authParams) {\n    const params = authParams ? copy(authParams) : {};\n    const options = this.options;\n    switch (this.mode) {\n      case \"resume\":\n        params.resume = this.connectionKey;\n        break;\n      case \"recover\": {\n        const recoveryContext = decodeRecoveryKey(options.recover);\n        if (recoveryContext) {\n          params.recover = recoveryContext.connectionKey;\n        }\n        break;\n      }\n      default:\n    }\n    if (options.clientId !== void 0) {\n      params.clientId = options.clientId;\n    }\n    if (options.echoMessages === false) {\n      params.echo = \"false\";\n    }\n    if (this.format !== void 0) {\n      params.format = this.format;\n    }\n    if (this.stream !== void 0) {\n      params.stream = this.stream;\n    }\n    if (this.heartbeats !== void 0) {\n      params.heartbeats = this.heartbeats;\n    }\n    params.v = defaults_default.protocolVersion;\n    params.agent = getAgentString(this.options);\n    if (options.transportParams !== void 0) {\n      mixin(params, options.transportParams);\n    }\n    return params;\n  }\n  toString() {\n    let result = \"[mode=\" + this.mode;\n    if (this.host) {\n      result += \",host=\" + this.host;\n    }\n    if (this.connectionKey) {\n      result += \",connectionKey=\" + this.connectionKey;\n    }\n    if (this.format) {\n      result += \",format=\" + this.format;\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar ConnectionManager = class _ConnectionManager extends eventemitter_default {\n  constructor(realtime, options) {\n    super(realtime.logger);\n    this.supportedTransports = {};\n    this.disconnectedRetryCount = 0;\n    this.pendingChannelMessagesState = { isProcessing: false, queue: [] };\n    this.realtime = realtime;\n    this.initTransports();\n    this.options = options;\n    const timeouts = options.timeouts;\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n    this.states = {\n      initialized: {\n        state: \"initialized\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        failState: \"disconnected\"\n      },\n      connecting: {\n        state: \"connecting\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: connectingTimeout,\n        failState: \"disconnected\"\n      },\n      connected: {\n        state: \"connected\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: true,\n        failState: \"disconnected\"\n      },\n      disconnected: {\n        state: \"disconnected\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: timeouts.disconnectedRetryTimeout,\n        failState: \"disconnected\"\n      },\n      suspended: {\n        state: \"suspended\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.suspendedRetryTimeout,\n        failState: \"suspended\"\n      },\n      closing: {\n        state: \"closing\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.realtimeRequestTimeout,\n        failState: \"closed\"\n      },\n      closed: { state: \"closed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"closed\" },\n      failed: { state: \"failed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"failed\" }\n    };\n    this.state = this.states.initialized;\n    this.errorReason = null;\n    this.queuedMessages = new messagequeue_default(this.logger);\n    this.msgSerial = 0;\n    this.connectionDetails = void 0;\n    this.connectionId = void 0;\n    this.connectionKey = void 0;\n    this.connectionStateTtl = timeouts.connectionStateTtl;\n    this.maxIdleInterval = null;\n    this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);\n    this.transportPreference = null;\n    if (this.transports.includes(TransportNames.WebSocket)) {\n      this.webSocketTransportAvailable = true;\n    }\n    if (this.transports.includes(TransportNames.XhrPolling)) {\n      this.baseTransport = TransportNames.XhrPolling;\n    } else if (this.transports.includes(TransportNames.Comet)) {\n      this.baseTransport = TransportNames.Comet;\n    }\n    this.httpHosts = defaults_default.getHosts(options);\n    this.wsHosts = defaults_default.getHosts(options, true);\n    this.activeProtocol = null;\n    this.host = null;\n    this.lastAutoReconnectAttempt = null;\n    this.lastActivity = null;\n    this.forceFallbackHost = false;\n    this.connectCounter = 0;\n    this.wsCheckResult = null;\n    this.webSocketSlowTimer = null;\n    this.webSocketGiveUpTimer = null;\n    this.abandonedWebSocket = false;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.ConnectionManager()\", \"started\");\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"requested transports = [\" + (options.transports || defaults_default.defaultTransports) + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"available transports = [\" + this.transports + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"http hosts = [\" + this.httpHosts + \"]\"\n    );\n    if (!this.transports.length) {\n      const msg = \"no requested transports available\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"realtime.ConnectionManager()\", msg);\n      throw new Error(msg);\n    }\n    const addEventListener = Platform.Config.addEventListener;\n    if (addEventListener) {\n      if (haveSessionStorage() && typeof options.recover === \"function\") {\n        addEventListener(\"beforeunload\", this.persistConnection.bind(this));\n      }\n      if (options.closeOnUnload === true) {\n        addEventListener(\"beforeunload\", () => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"Realtime.ConnectionManager()\",\n            \"beforeunload event has triggered the connection to close as closeOnUnload is true\"\n          );\n          this.requestState({ state: \"closing\" });\n        });\n      }\n      addEventListener(\"online\", () => {\n        var _a2;\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018online\\u2019 event\",\n            \"reattempting connection\"\n          );\n          this.requestState({ state: \"connecting\" });\n        } else if (this.state == this.states.connecting) {\n          (_a2 = this.pendingTransport) == null ? void 0 : _a2.off();\n          this.disconnectAllTransports();\n          this.startConnect();\n        }\n      });\n      addEventListener(\"offline\", () => {\n        if (this.state == this.states.connected) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018offline\\u2019 event\",\n            \"disconnecting active transport\"\n          );\n          this.disconnectAllTransports();\n        }\n      });\n    }\n  }\n  /*********************\n   * transport management\n   *********************/\n  // Used by tests\n  static supportedTransports(additionalImplementations) {\n    const storage = { supportedTransports: {} };\n    this.initTransports(additionalImplementations, storage);\n    return storage.supportedTransports;\n  }\n  static initTransports(additionalImplementations, storage) {\n    const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\n      const transport = implementations[transportName];\n      if (transport && transport.isAvailable()) {\n        storage.supportedTransports[transportName] = transport;\n      }\n    });\n  }\n  initTransports() {\n    _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n  }\n  createTransportParams(host, mode) {\n    return new TransportParams(this.options, host, mode, this.connectionKey);\n  }\n  getTransportParams(callback) {\n    const decideMode = (modeCb) => {\n      if (this.connectionKey) {\n        modeCb(\"resume\");\n        return;\n      }\n      if (typeof this.options.recover === \"string\") {\n        modeCb(\"recover\");\n        return;\n      }\n      const recoverFn = this.options.recover, lastSessionData = this.getSessionRecoverData(), sessionRecoveryName = this.sessionRecoveryName();\n      if (lastSessionData && typeof recoverFn === \"function\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Calling clientOptions-provided recover function with last session data (recovery scope: \" + sessionRecoveryName + \")\"\n        );\n        recoverFn(lastSessionData, (shouldRecover) => {\n          if (shouldRecover) {\n            this.options.recover = lastSessionData.recoveryKey;\n            modeCb(\"recover\");\n          } else {\n            modeCb(\"clean\");\n          }\n        });\n        return;\n      }\n      modeCb(\"clean\");\n    };\n    decideMode((mode) => {\n      const transportParams = this.createTransportParams(null, mode);\n      if (mode === \"recover\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport recovery mode = recover; recoveryKey = \" + this.options.recover\n        );\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\n        if (recoveryContext) {\n          this.msgSerial = recoveryContext.msgSerial;\n        }\n      } else {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport params = \" + transportParams.toString()\n        );\n      }\n      callback(transportParams);\n    });\n  }\n  /**\n   * Attempt to connect using a given transport\n   * @param transportParams\n   * @param candidate, the transport to try\n   * @param callback\n   */\n  tryATransport(transportParams, candidate, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"trying \" + candidate);\n    this.proposedTransport = transport_default.tryConnect(\n      this.supportedTransports[candidate],\n      this,\n      this.realtime.auth,\n      transportParams,\n      (wrappedErr, transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager.tryATransport()\",\n              \"connection \" + state.state + \" while we were attempting the transport; closing \" + transport\n            );\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n        if (wrappedErr) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.tryATransport()\",\n            \"transport \" + candidate + \" \" + wrappedErr.event + \", err: \" + wrappedErr.error.toString()\n          );\n          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {\n            this.errorReason = wrappedErr.error;\n            whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err) => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === \"failed\") {\n            this.notifyState({ state: \"failed\", error: wrappedErr.error });\n            callback(true);\n          } else if (wrappedErr.event === \"disconnected\") {\n            if (!isRetriable(wrappedErr.error)) {\n              this.notifyState({ state: this.states.connecting.failState, error: wrappedErr.error });\n              callback(true);\n            } else {\n              callback(false);\n            }\n          }\n          return;\n        }\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.tryATransport()\",\n          \"viable transport \" + candidate + \"; setting pending\"\n        );\n        this.setTransportPending(transport, transportParams);\n        callback(null, transport);\n      }\n    );\n  }\n  /**\n   * Called when a transport is indicated to be viable, and the ConnectionManager\n   * expects to activate this transport as soon as it is connected.\n   * @param transport\n   * @param transportParams\n   */\n  setTransportPending(transport, transportParams) {\n    const mode = transportParams.mode;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.setTransportPending()\",\n      \"transport = \" + transport + \"; mode = \" + mode\n    );\n    this.pendingTransport = transport;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    transport.once(\"connected\", (error, connectionId, connectionDetails) => {\n      this.activateTransport(error, transport, connectionId, connectionDetails);\n      if (mode === \"recover\" && this.options.recover) {\n        delete this.options.recover;\n        this.unpersistConnection();\n      }\n    });\n    const self2 = this;\n    transport.on([\"disconnected\", \"closed\", \"failed\"], function(error) {\n      self2.deactivateTransport(transport, this.event, error);\n    });\n    this.emit(\"transport.pending\", transport);\n  }\n  /**\n   * Called when a transport is connected, and the connectionmanager decides that\n   * it will now be the active transport. Returns whether or not it activated\n   * the transport (if the connection is closing/closed it will choose not to).\n   * @param transport the transport instance\n   * @param connectionId the id of the new active connection\n   * @param connectionDetails the details of the new active connection\n   */\n  activateTransport(error, transport, connectionId, connectionDetails) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"transport = \" + transport\n    );\n    if (error) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"error = \" + error);\n    }\n    if (connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionId =  \" + connectionId\n      );\n    }\n    if (connectionDetails) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionDetails =  \" + JSON.stringify(connectionDetails)\n      );\n    }\n    this.persistTransportPreference(transport);\n    const existingState = this.state, connectedState = this.states.connected.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"current state = \" + existingState.state\n    );\n    if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Disconnecting transport and abandoning\"\n      );\n      transport.disconnect();\n      return false;\n    }\n    delete this.pendingTransport;\n    if (!transport.isConnected) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Declining to activate transport \" + transport + \" since it appears to no longer be connected\"\n      );\n      return false;\n    }\n    const existingActiveProtocol = this.activeProtocol;\n    this.activeProtocol = new protocol_default(transport);\n    this.host = transport.params.host;\n    const connectionKey = connectionDetails.connectionKey;\n    if (connectionKey && this.connectionKey != connectionKey) {\n      this.setConnection(connectionId, connectionDetails, !!error);\n    }\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\n    Platform.Config.nextTick(() => {\n      transport.on(\n        \"connected\",\n        (connectedErr, _connectionId, connectionDetails2) => {\n          this.onConnectionDetailsUpdate(connectionDetails2, transport);\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));\n        }\n      );\n    });\n    if (existingState.state === this.states.connected.state) {\n      if (error) {\n        this.errorReason = this.realtime.connection.errorReason = error;\n        this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, error));\n      }\n    } else {\n      this.notifyState({ state: \"connected\", error });\n      this.errorReason = this.realtime.connection.errorReason = error || null;\n    }\n    this.emit(\"transport.active\", transport);\n    if (existingActiveProtocol) {\n      if (existingActiveProtocol.messageQueue.count() > 0) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.activateTransport()\",\n          \"Previous active protocol (for transport \" + existingActiveProtocol.transport.shortName + \", new one is \" + transport.shortName + \") finishing with \" + existingActiveProtocol.messageQueue.count() + \" messages still pending\"\n        );\n      }\n      if (existingActiveProtocol.transport === transport) {\n        const msg = \"Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = \" + transport.shortName + \"; stack = \" + new Error().stack;\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", msg);\n      } else {\n        existingActiveProtocol.finish();\n      }\n    }\n    return true;\n  }\n  /**\n   * Called when a transport is no longer the active transport. This can occur\n   * in any transport connection state.\n   * @param transport\n   */\n  deactivateTransport(transport, state, error) {\n    const currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = transport === this.pendingTransport, noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"transport = \" + transport\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"state = \" + state + (wasActive ? \"; was active\" : wasPending ? \"; was pending\" : \"\") + (noTransportsScheduledForActivation ? \"\" : \"; another transport is scheduled for activation\")\n    );\n    if (error && error.message)\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"reason =  \" + error.message\n      );\n    if (wasActive) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"Getting, clearing, and requeuing \" + this.activeProtocol.messageQueue.count() + \" pending messages\"\n      );\n      this.queuePendingMessages(currentProtocol.getPendingMessages());\n      currentProtocol.clearPendingMessages();\n      this.activeProtocol = this.host = null;\n    }\n    this.emit(\"transport.inactive\", transport);\n    if (wasActive && noTransportsScheduledForActivation || wasActive && state === \"failed\" || state === \"closed\" || currentProtocol === null && wasPending) {\n      if (state === \"disconnected\" && error && error.statusCode > 500 && this.httpHosts.length > 1) {\n        this.unpersistTransportPreference();\n        this.forceFallbackHost = true;\n        this.notifyState({ state, error, retryImmediately: true });\n        return;\n      }\n      const newConnectionState = state === \"failed\" && auth_default.isTokenErr(error) ? \"disconnected\" : state;\n      this.notifyState({ state: newConnectionState, error });\n      return;\n    }\n  }\n  /* Helper that returns true if there are no transports which are pending,\n   * have been connected, and are just waiting for onceNoPending to fire before\n   * being activated */\n  noTransportsScheduledForActivation() {\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\n  }\n  setConnection(connectionId, connectionDetails, hasConnectionError) {\n    const prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;\n    if (connIdChanged || recoverFailure) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"Resetting msgSerial\");\n      this.msgSerial = 0;\n      this.queuedMessages.resetSendAttempted();\n    }\n    if (this.connectionId !== connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.setConnection()\",\n        \"New connectionId; reattaching any attached channels\"\n      );\n    }\n    this.realtime.connection.id = this.connectionId = connectionId;\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n  }\n  clearConnection() {\n    this.realtime.connection.id = this.connectionId = void 0;\n    this.realtime.connection.key = this.connectionKey = void 0;\n    this.msgSerial = 0;\n    this.unpersistConnection();\n  }\n  createRecoveryKey() {\n    if (!this.connectionKey) {\n      return null;\n    }\n    return JSON.stringify({\n      connectionKey: this.connectionKey,\n      msgSerial: this.msgSerial,\n      channelSerials: this.realtime.channels.channelSerials()\n    });\n  }\n  checkConnectionStateFreshness() {\n    if (!this.lastActivity || !this.connectionId) {\n      return;\n    }\n    const sinceLast = Date.now() - this.lastActivity;\n    if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.checkConnectionStateFreshness()\",\n        \"Last known activity from realtime was \" + sinceLast + \"ms ago; discarding connection state\"\n      );\n      this.clearConnection();\n      this.states.connecting.failState = \"suspended\";\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  persistConnection() {\n    if (haveSessionStorage()) {\n      const recoveryKey = this.createRecoveryKey();\n      if (recoveryKey) {\n        this.setSessionRecoverData({\n          recoveryKey,\n          disconnectedAt: Date.now(),\n          location: globalObject2.location,\n          clientId: this.realtime.auth.clientId\n        });\n      }\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  unpersistConnection() {\n    this.clearSessionRecoverData();\n  }\n  /*********************\n   * state management\n   *********************/\n  getError() {\n    if (this.errorReason) {\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\n      newError.cause = this.errorReason;\n      return newError;\n    }\n    return this.getStateError();\n  }\n  getStateError() {\n    var _a2, _b;\n    return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);\n  }\n  activeState() {\n    return this.state.queueEvents || this.state.sendEvents;\n  }\n  enactStateChange(stateChange) {\n    const action = \"Connection state\";\n    const message = stateChange.current + (stateChange.reason ? \"; reason: \" + stateChange.reason : \"\");\n    if (stateChange.current === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.enactStateChange\",\n      \"setting new state: \" + stateChange.current + \"; reason = \" + (stateChange.reason && stateChange.reason.message)\n    );\n    const newState = this.state = this.states[stateChange.current];\n    if (stateChange.reason) {\n      this.errorReason = stateChange.reason;\n      this.realtime.connection.errorReason = stateChange.reason;\n    }\n    if (newState.terminal || newState.state === \"suspended\") {\n      this.clearConnection();\n    }\n    this.emit(\"connectionstate\", stateChange);\n  }\n  /****************************************\n   * ConnectionManager connection lifecycle\n   ****************************************/\n  startTransitionTimer(transitionState) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.startTransitionTimer()\",\n      \"transitionState: \" + transitionState.state\n    );\n    if (this.transitionTimer) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startTransitionTimer()\",\n        \"clearing already-running timer\"\n      );\n      clearTimeout(this.transitionTimer);\n    }\n    this.transitionTimer = setTimeout(() => {\n      if (this.transitionTimer) {\n        this.transitionTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager \" + transitionState.state + \" timer expired\",\n          \"requesting new state: \" + transitionState.failState\n        );\n        this.notifyState({ state: transitionState.failState });\n      }\n    }, transitionState.retryDelay);\n  }\n  cancelTransitionTimer() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.cancelTransitionTimer()\", \"\");\n    if (this.transitionTimer) {\n      clearTimeout(this.transitionTimer);\n      this.transitionTimer = null;\n    }\n  }\n  startSuspendTimer() {\n    if (this.suspendTimer)\n      return;\n    this.suspendTimer = setTimeout(() => {\n      if (this.suspendTimer) {\n        this.suspendTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager suspend timer expired\",\n          \"requesting new state: suspended\"\n        );\n        this.states.connecting.failState = \"suspended\";\n        this.notifyState({ state: \"suspended\" });\n      }\n    }, this.connectionStateTtl);\n  }\n  checkSuspendTimer(state) {\n    if (state !== \"disconnected\" && state !== \"suspended\" && state !== \"connecting\")\n      this.cancelSuspendTimer();\n  }\n  cancelSuspendTimer() {\n    this.states.connecting.failState = \"disconnected\";\n    if (this.suspendTimer) {\n      clearTimeout(this.suspendTimer);\n      this.suspendTimer = null;\n    }\n  }\n  startRetryTimer(interval) {\n    this.retryTimer = setTimeout(() => {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager retry timer expired\", \"retrying\");\n      this.retryTimer = null;\n      this.requestState({ state: \"connecting\" });\n    }, interval);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  startWebSocketSlowTimer() {\n    this.webSocketSlowTimer = setTimeout(() => {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager WebSocket slow timer\",\n        \"checking connectivity\"\n      );\n      if (this.wsCheckResult === null) {\n        this.checkWsConnectivity().then(() => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager WebSocket slow timer\",\n            \"ws connectivity check succeeded\"\n          );\n          this.wsCheckResult = true;\n        }).catch(() => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket slow timer\",\n            \"ws connectivity check failed\"\n          );\n          this.wsCheckResult = false;\n        });\n      }\n      if (this.realtime.http.checkConnectivity) {\n        whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (err || !connectivity) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MAJOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check failed\"\n            );\n            this.cancelWebSocketGiveUpTimer();\n            this.notifyState({\n              state: \"disconnected\",\n              error: new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404)\n            });\n          } else {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check succeeded\"\n            );\n          }\n        });\n      }\n    }, this.options.timeouts.webSocketSlowTimeout);\n  }\n  cancelWebSocketSlowTimer() {\n    if (this.webSocketSlowTimer) {\n      clearTimeout(this.webSocketSlowTimer);\n      this.webSocketSlowTimer = null;\n    }\n  }\n  startWebSocketGiveUpTimer(transportParams) {\n    this.webSocketGiveUpTimer = setTimeout(() => {\n      var _a2, _b;\n      if (!this.wsCheckResult) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket give up timer\",\n          \"websocket connection took more than 10s; \" + (this.baseTransport ? \"trying base transport\" : \"\")\n        );\n        if (this.baseTransport) {\n          this.abandonedWebSocket = true;\n          (_a2 = this.proposedTransport) == null ? void 0 : _a2.dispose();\n          (_b = this.pendingTransport) == null ? void 0 : _b.dispose();\n          this.connectBase(transportParams, ++this.connectCounter);\n        } else {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket give up timer\",\n            \"websocket connectivity appears to be unavailable but no other transports to try\"\n          );\n        }\n      }\n    }, this.options.timeouts.webSocketConnectTimeout);\n  }\n  cancelWebSocketGiveUpTimer() {\n    if (this.webSocketGiveUpTimer) {\n      clearTimeout(this.webSocketGiveUpTimer);\n      this.webSocketGiveUpTimer = null;\n    }\n  }\n  notifyState(indicated) {\n    var _a2, _b;\n    const state = indicated.state;\n    const retryImmediately = state === \"disconnected\" && (this.state === this.states.connected || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.notifyState()\",\n      \"new state: \" + state + (retryImmediately ? \"; will retry connection immediately\" : \"\")\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.checkSuspendTimer(indicated.state);\n    if (state === \"suspended\" || state === \"connected\") {\n      this.disconnectedRetryCount = 0;\n    }\n    if (this.state.terminal)\n      return;\n    const newState = this.states[indicated.state];\n    let retryDelay = newState.retryDelay;\n    if (newState.state === \"disconnected\") {\n      this.disconnectedRetryCount++;\n      retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n    }\n    const change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      retryDelay,\n      indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    if (retryImmediately) {\n      const autoReconnect = () => {\n        if (this.state === this.states.disconnected) {\n          this.lastAutoReconnectAttempt = Date.now();\n          this.requestState({ state: \"connecting\" });\n        }\n      };\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n      if (sinceLast && sinceLast < 1e3) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.notifyState()\",\n          \"Last reconnect attempt was only \" + sinceLast + \"ms ago, waiting another \" + (1e3 - sinceLast) + \"ms before trying again\"\n        );\n        setTimeout(autoReconnect, 1e3 - sinceLast);\n      } else {\n        Platform.Config.nextTick(autoReconnect);\n      }\n    } else if (state === \"disconnected\" || state === \"suspended\") {\n      this.startRetryTimer(retryDelay);\n    }\n    if (state === \"disconnected\" && !retryImmediately || state === \"suspended\" || newState.terminal) {\n      Platform.Config.nextTick(() => {\n        this.disconnectAllTransports();\n      });\n    }\n    if (state == \"connected\" && !this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.notifyState()\",\n        \"Broken invariant: attempted to go into connected state, but there is no active protocol\"\n      );\n    }\n    this.enactStateChange(change);\n    if (this.state.sendEvents) {\n      this.sendQueuedMessages();\n    } else if (!this.state.queueEvents) {\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n      this.failQueuedMessages(change.reason);\n    }\n  }\n  requestState(request) {\n    var _a2, _b;\n    const state = request.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.requestState()\",\n      \"requested state: \" + state + \"; current state: \" + this.state.state\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.checkSuspendTimer(state);\n    if (state == \"connecting\" && this.state.state == \"connected\")\n      return;\n    if (state == \"closing\" && this.state.state == \"closed\")\n      return;\n    const newState = this.states[state], change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      null,\n      request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    this.enactStateChange(change);\n    if (state == \"connecting\") {\n      Platform.Config.nextTick(() => {\n        this.startConnect();\n      });\n    }\n    if (state == \"closing\") {\n      this.closeImpl();\n    }\n  }\n  startConnect() {\n    if (this.state !== this.states.connecting) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startConnect()\",\n        \"Must be in connecting state to connect, but was \" + this.state.state\n      );\n      return;\n    }\n    const auth = this.realtime.auth;\n    const connectCount = ++this.connectCounter;\n    const connect = () => {\n      this.checkConnectionStateFreshness();\n      this.getTransportParams((transportParams) => {\n        if (transportParams.mode === \"recover\" && transportParams.options.recover) {\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n          if (recoveryContext) {\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n          }\n        }\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        this.connectImpl(transportParams, connectCount);\n      });\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"starting connection\");\n    this.startSuspendTimer();\n    this.startTransitionTimer(this.states.connecting);\n    if (auth.method === \"basic\") {\n      connect();\n    } else {\n      const authCb = (err) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (err) {\n          this.actOnErrorFromAuthorize(err);\n        } else {\n          connect();\n        }\n      };\n      if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {\n        whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n      } else {\n        whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n      }\n    }\n  }\n  /*\n   * there are, at most, two transports available with which a connection may\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n   * comet in nodejs). web_socket is always preferred, and the base transport is\n   * only used in case web_socket connectivity appears to be unavailable.\n   *\n   * connectImpl begins the transport selection process by checking which transports\n   * are available, and if there is a cached preference. It then defers to the\n   * transport-specific connect methods: connectWs and connectBase.\n   *\n   * It is also responsible for invalidating the cache in the case that a base\n   * transport preference is stored but web socket connectivity is now available.\n   *\n   * handling of the case where we need to failover from web_socket to the base\n   * transport is implemented in the connectWs method.\n   */\n  connectImpl(transportParams, connectCount) {\n    const state = this.state.state;\n    if (state !== this.states.connecting.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.connectImpl()\",\n        \"Must be in connecting state to connect, but was \" + state\n      );\n      return;\n    }\n    const transportPreference = this.getTransportPreference();\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n      this.checkWsConnectivity().then(() => {\n        this.wsCheckResult = true;\n        this.abandonedWebSocket = false;\n        this.unpersistTransportPreference();\n        if (this.state === this.states.connecting) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.connectImpl():\",\n            \"web socket connectivity available, cancelling connection attempt with \" + this.baseTransport\n          );\n          this.disconnectAllTransports();\n          this.connectWs(transportParams, ++this.connectCounter);\n        }\n      }).catch(noop);\n    }\n    if (transportPreference && transportPreference === this.baseTransport || this.baseTransport && !this.webSocketTransportAvailable) {\n      this.connectBase(transportParams, connectCount);\n    } else {\n      this.connectWs(transportParams, connectCount);\n    }\n  }\n  /*\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n   *   connectivity check fails, we give up the connection sequence entirely and\n   *   transition to disconnected. if the websocket connectivity check fails then\n   *   we assume no ws connectivity and failover to base transport. in the case that\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n   *   and, if unsuccessful, ultimately transition to disconnected.\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n   *   connectivity check is still pending then we assume that there is an issue\n   *   with the transport and fallback to base transport.\n   */\n  connectWs(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectWs()\");\n    this.startWebSocketSlowTimer();\n    this.startWebSocketGiveUpTimer(transportParams);\n    this.tryTransportWithFallbacks(\"web_socket\", transportParams, true, connectCount, () => {\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\n    });\n  }\n  connectBase(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectBase()\");\n    if (this.baseTransport) {\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n    } else {\n      this.notifyState({\n        state: \"disconnected\",\n        error: new ErrorInfo(\"No transports left to try\", 8e4, 404)\n      });\n    }\n  }\n  tryTransportWithFallbacks(transportName, transportParams, ws, connectCount, shouldContinue) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.tryTransportWithFallbacks()\",\n      transportName\n    );\n    const giveUp = (err) => {\n      this.notifyState({ state: this.states.connecting.failState, error: err });\n    };\n    const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\n    const hostAttemptCb = (fatal, transport) => {\n      if (connectCount !== this.connectCounter) {\n        return;\n      }\n      if (!shouldContinue()) {\n        if (transport) {\n          transport.dispose();\n        }\n        return;\n      }\n      if (!transport && !fatal) {\n        tryFallbackHosts();\n      }\n    };\n    const host = candidateHosts.shift();\n    if (!host) {\n      giveUp(new ErrorInfo(\"Unable to connect (no available host)\", 80003, 404));\n      return;\n    }\n    transportParams.host = host;\n    const tryFallbackHosts = () => {\n      if (!candidateHosts.length) {\n        giveUp(new ErrorInfo(\"Unable to connect (and no more fallback hosts to try)\", 80003, 404));\n        return;\n      }\n      if (!this.realtime.http.checkConnectivity) {\n        giveUp(new PartialErrorInfo(\"Internal error: Http.checkConnectivity not set\", null, 500));\n        return;\n      }\n      whenPromiseSettles(\n        this.realtime.http.checkConnectivity(),\n        (err, connectivity) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            giveUp(new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404));\n            return;\n          }\n          transportParams.host = arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        }\n      );\n    };\n    if (this.forceFallbackHost && candidateHosts.length) {\n      this.forceFallbackHost = false;\n      tryFallbackHosts();\n      return;\n    }\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\n  }\n  closeImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.closeImpl()\", \"closing connection\");\n    this.cancelSuspendTimer();\n    this.startTransitionTimer(this.states.closing);\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.close();\n    }\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().close();\n    }\n    this.notifyState({ state: \"closed\" });\n  }\n  onAuthUpdated(tokenDetails, callback) {\n    var _a2;\n    switch (this.state.state) {\n      case \"connected\": {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Sending AUTH message on active transport\"\n        );\n        const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n        if (activeTransport && activeTransport.onAuthUpdated) {\n          activeTransport.onAuthUpdated(tokenDetails);\n        }\n        const authMsg = fromValues3({\n          action: actions2.AUTH,\n          auth: {\n            accessToken: tokenDetails.token\n          }\n        });\n        this.send(authMsg);\n        const successListener = () => {\n          this.off(failureListener);\n          callback(null, tokenDetails);\n        };\n        const failureListener = (stateChange) => {\n          if (stateChange.current === \"failed\") {\n            this.off(successListener);\n            this.off(failureListener);\n            callback(stateChange.reason || this.getStateError());\n          }\n        };\n        this.once(\"connectiondetails\", successListener);\n        this.on(\"connectionstate\", failureListener);\n        break;\n      }\n      case \"connecting\":\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Aborting current connection attempts in order to start again with the new auth details\"\n        );\n        this.disconnectAllTransports();\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Connection state is \" + this.state.state + \"; waiting until either connected or failed\"\n        );\n        const listener = (stateChange) => {\n          switch (stateChange.current) {\n            case \"connected\":\n              this.off(listener);\n              callback(null, tokenDetails);\n              break;\n            case \"failed\":\n            case \"closed\":\n            case \"suspended\":\n              this.off(listener);\n              callback(stateChange.reason || this.getStateError());\n              break;\n            default:\n              break;\n          }\n        };\n        this.on(\"connectionstate\", listener);\n        if (this.state.state === \"connecting\") {\n          this.startConnect();\n        } else {\n          this.requestState({ state: \"connecting\" });\n        }\n      }\n    }\n  }\n  disconnectAllTransports() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.disconnectAllTransports()\",\n      \"Disconnecting all transports\"\n    );\n    this.connectCounter++;\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.proposedTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting proposed transport: \" + this.pendingTransport\n      );\n      this.proposedTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().disconnect();\n    }\n  }\n  /******************\n   * event queueing\n   ******************/\n  send(msg, queueEvent, callback) {\n    callback = callback || noop;\n    const state = this.state;\n    if (state.sendEvents) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"sending event\");\n      this.sendImpl(new PendingMessage(msg, callback));\n      return;\n    }\n    const shouldQueue = queueEvent && state.queueEvents;\n    if (!shouldQueue) {\n      const err = \"rejecting event, queueEvent was \" + queueEvent + \", state was \" + state.state;\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", err);\n      callback(this.errorReason || new ErrorInfo(err, 9e4, 400));\n      return;\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.send()\",\n        \"queueing msg; \" + stringify(msg, this.realtime._RealtimePresence)\n      );\n    }\n    this.queue(msg, callback);\n  }\n  sendImpl(pendingMessage) {\n    const msg = pendingMessage.message;\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n      msg.msgSerial = this.msgSerial++;\n    }\n    try {\n      this.activeProtocol.send(pendingMessage);\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.sendImpl()\",\n        \"Unexpected exception in transport.send(): \" + e.stack\n      );\n    }\n  }\n  queue(msg, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.queue()\", \"queueing event\");\n    const lastQueued = this.queuedMessages.last();\n    const maxSize = this.options.maxMessageSize;\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\n      if (!lastQueued.merged) {\n        lastQueued.callback = multicaster_default.create(this.logger, [lastQueued.callback]);\n        lastQueued.merged = true;\n      }\n      lastQueued.callback.push(callback);\n    } else {\n      this.queuedMessages.push(new PendingMessage(msg, callback));\n    }\n  }\n  sendQueuedMessages() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.sendQueuedMessages()\",\n      \"sending \" + this.queuedMessages.count() + \" queued messages\"\n    );\n    let pendingMessage;\n    while (pendingMessage = this.queuedMessages.shift())\n      this.sendImpl(pendingMessage);\n  }\n  queuePendingMessages(pendingMessages) {\n    if (pendingMessages && pendingMessages.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.queuePendingMessages()\",\n        \"queueing \" + pendingMessages.length + \" pending messages\"\n      );\n      this.queuedMessages.prepend(pendingMessages);\n    }\n  }\n  failQueuedMessages(err) {\n    const numQueued = this.queuedMessages.count();\n    if (numQueued > 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.failQueuedMessages()\",\n        \"failing \" + numQueued + \" queued messages, err = \" + inspectError(err)\n      );\n      this.queuedMessages.completeAllMessages(err);\n    }\n  }\n  onChannelMessage(message, transport) {\n    this.pendingChannelMessagesState.queue.push({ message, transport });\n    if (!this.pendingChannelMessagesState.isProcessing) {\n      this.processNextPendingChannelMessage();\n    }\n  }\n  processNextPendingChannelMessage() {\n    if (this.pendingChannelMessagesState.queue.length > 0) {\n      this.pendingChannelMessagesState.isProcessing = true;\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();\n      this.processChannelMessage(pendingChannelMessage.message).catch((err) => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.processNextPendingChannelMessage() received error \",\n          err\n        );\n      }).finally(() => {\n        this.pendingChannelMessagesState.isProcessing = false;\n        this.processNextPendingChannelMessage();\n      });\n    }\n  }\n  async processChannelMessage(message) {\n    await this.realtime.channels.processChannelMessage(message);\n  }\n  async ping() {\n    var _a2;\n    if (this.state.state !== \"connected\") {\n      throw new ErrorInfo(\"Unable to ping service; not connected\", 4e4, 400);\n    }\n    const transport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n    if (!transport) {\n      throw this.getStateError();\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.ping()\", \"transport = \" + transport);\n    const pingStart = Date.now();\n    const id = cheapRandStr();\n    return withTimeoutAsync(\n      new Promise((resolve) => {\n        const onHeartbeat = (responseId) => {\n          if (responseId === id) {\n            transport.off(\"heartbeat\", onHeartbeat);\n            resolve(Date.now() - pingStart);\n          }\n        };\n        transport.on(\"heartbeat\", onHeartbeat);\n        transport.ping(id);\n      }),\n      this.options.timeouts.realtimeRequestTimeout,\n      \"Timeout waiting for heartbeat response\"\n    );\n  }\n  abort(error) {\n    this.activeProtocol.getTransport().fail(error);\n  }\n  getTransportPreference() {\n    var _a2, _b;\n    return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));\n  }\n  persistTransportPreference(transport) {\n    var _a2, _b;\n    this.transportPreference = transport.shortName;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);\n    }\n  }\n  unpersistTransportPreference() {\n    var _a2, _b;\n    this.transportPreference = null;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);\n    }\n  }\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n   * server returns 403. */\n  actOnErrorFromAuthorize(err) {\n    if (err.code === 40171) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.code === 40102) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {\n      const msg = \"Client configured authentication provider returned 403; failing the connection\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.actOnErrorFromAuthorize()\", msg);\n      this.notifyState({ state: \"failed\", error: new ErrorInfo(msg, 80019, 403, err) });\n    } else {\n      const msg = \"Client configured authentication provider request failed\";\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.actOnErrorFromAuthorize\", msg);\n      this.notifyState({ state: this.state.failState, error: new ErrorInfo(msg, 80019, 401, err) });\n    }\n  }\n  onConnectionDetailsUpdate(connectionDetails, transport) {\n    if (!connectionDetails) {\n      return;\n    }\n    this.connectionDetails = connectionDetails;\n    if (connectionDetails.maxMessageSize) {\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\n    }\n    const clientId = connectionDetails.clientId;\n    if (clientId) {\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\n      if (err) {\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.onConnectionDetailsUpdate()\", err.message);\n        transport.fail(err);\n        return;\n      }\n    }\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\n    if (connectionStateTtl) {\n      this.connectionStateTtl = connectionStateTtl;\n    }\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\n    this.emit(\"connectiondetails\", connectionDetails);\n  }\n  checkWsConnectivity() {\n    const ws = new Platform.Config.WebSocket(defaults_default.wsConnectivityUrl);\n    return new Promise((resolve, reject) => {\n      let finished = false;\n      ws.onopen = () => {\n        if (!finished) {\n          finished = true;\n          resolve();\n          ws.close();\n        }\n      };\n      ws.onclose = ws.onerror = () => {\n        if (!finished) {\n          finished = true;\n          reject();\n        }\n      };\n    });\n  }\n  sessionRecoveryName() {\n    return this.options.recoveryKeyStorageName || \"ably-connection-recovery\";\n  }\n  getSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n  setSessionRecoverData(value) {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName(), value));\n  }\n  clearSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n};\nvar connectionmanager_default = ConnectionManager;\n\n// src/common/lib/client/connection.ts\nvar Connection = class extends eventemitter_default {\n  constructor(ably, options) {\n    super(ably.logger);\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    this.ably = ably;\n    this.connectionManager = new connectionmanager_default(ably, options);\n    this.state = this.connectionManager.state.state;\n    this.key = void 0;\n    this.id = void 0;\n    this.errorReason = null;\n    this.connectionManager.on(\"connectionstate\", (stateChange) => {\n      const state = this.state = stateChange.current;\n      Platform.Config.nextTick(() => {\n        this.emit(state, stateChange);\n      });\n    });\n    this.connectionManager.on(\"update\", (stateChange) => {\n      Platform.Config.nextTick(() => {\n        this.emit(\"update\", stateChange);\n      });\n    });\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.connect()\", \"\");\n    this.connectionManager.requestState({ state: \"connecting\" });\n  }\n  async ping() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.ping()\", \"\");\n    return this.connectionManager.ping();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.close()\", \"connectionKey = \" + this.key);\n    this.connectionManager.requestState({ state: \"closing\" });\n  }\n  get recoveryKey() {\n    this.logger.deprecationWarning(\n      \"The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.\"\n    );\n    return this.createRecoveryKey();\n  }\n  createRecoveryKey() {\n    return this.connectionManager.createRecoveryKey();\n  }\n};\nvar connection_default = Connection;\n\n// src/common/lib/client/channelstatechange.ts\nvar ChannelStateChange = class {\n  constructor(previous, current, resumed, hasBacklog, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (current === \"attached\") {\n      this.resumed = resumed;\n      this.hasBacklog = hasBacklog;\n    }\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar channelstatechange_default = ChannelStateChange;\n\n// src/common/lib/client/realtimechannel.ts\nvar noop2 = function() {\n};\nfunction validateChannelOptions(options) {\n  if (options && \"params\" in options && !isObject(options.params)) {\n    return new ErrorInfo(\"options.params must be an object\", 4e4, 400);\n  }\n  if (options && \"modes\" in options) {\n    if (!Array.isArray(options.modes)) {\n      return new ErrorInfo(\"options.modes must be an array\", 4e4, 400);\n    }\n    for (let i = 0; i < options.modes.length; i++) {\n      const currentMode = options.modes[i];\n      if (!currentMode || typeof currentMode !== \"string\" || !channelModes.includes(String.prototype.toUpperCase.call(currentMode))) {\n        return new ErrorInfo(\"Invalid channel mode: \" + currentMode, 4e4, 400);\n      }\n    }\n  }\n}\nvar RealtimeChannel = class _RealtimeChannel extends eventemitter_default {\n  constructor(client, name, options) {\n    var _a2, _b;\n    super(client.logger);\n    this.retryCount = 0;\n    this.history = async function(params) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.history()\", \"channel = \" + this.name);\n      const restMixin = this.client.rest.channelMixin;\n      if (params && params.untilAttach) {\n        if (this.state !== \"attached\") {\n          throw new ErrorInfo(\"option untilAttach requires the channel to be attached\", 4e4, 400);\n        }\n        if (!this.properties.attachSerial) {\n          throw new ErrorInfo(\n            \"untilAttach was specified and channel is attached, but attachSerial is not defined\",\n            4e4,\n            400\n          );\n        }\n        delete params.untilAttach;\n        params.from_serial = this.properties.attachSerial;\n      }\n      return restMixin.history(this, params);\n    };\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, options);\n    this.client = client;\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n    this.connectionManager = client.connection.connectionManager;\n    this.state = \"initialized\";\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.syncChannelSerial = void 0;\n    this.properties = {\n      attachSerial: void 0,\n      channelSerial: void 0\n    };\n    this.setOptions(options);\n    this.errorReason = null;\n    this._requestedFlags = null;\n    this._mode = null;\n    this._attachResume = false;\n    this._decodingContext = {\n      channelOptions: this.channelOptions,\n      plugins: client.options.plugins || {},\n      baseEncodedPreviousPayload: void 0\n    };\n    this._lastPayload = {\n      messageId: null,\n      protocolMessageChannelSerial: null,\n      decodeFailureRecoveryInProgress: null\n    };\n    this._allChannelChanges = new eventemitter_default(this.logger);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n  }\n  get presence() {\n    if (!this._presence) {\n      throwMissingPluginError(\"RealtimePresence\");\n    }\n    return this._presence;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  invalidStateError() {\n    return new ErrorInfo(\n      \"Channel operation failed as channel state is \" + this.state,\n      90001,\n      400,\n      this.errorReason || void 0\n    );\n  }\n  static processListenerArgs(args) {\n    args = Array.prototype.slice.call(args);\n    if (typeof args[0] === \"function\") {\n      args.unshift(null);\n    }\n    return args;\n  }\n  async setOptions(options) {\n    var _a2;\n    const previousChannelOptions = this.channelOptions;\n    const err = validateChannelOptions(options);\n    if (err) {\n      throw err;\n    }\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n    if (this._decodingContext)\n      this._decodingContext.channelOptions = this.channelOptions;\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n      this.attachImpl();\n      return new Promise((resolve, reject) => {\n        this._allChannelChanges.once(\n          [\"attached\", \"update\", \"detached\", \"failed\"],\n          function(stateChange) {\n            switch (this.event) {\n              case \"update\":\n              case \"attached\":\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          }\n        );\n      });\n    }\n  }\n  _shouldReattachToSetOptions(options, prevOptions) {\n    if (!(this.state === \"attached\" || this.state === \"attaching\")) {\n      return false;\n    }\n    if (options == null ? void 0 : options.params) {\n      const requestedParams = omitAgent(options.params);\n      const existingParams = omitAgent(prevOptions.params);\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n        return true;\n      }\n      if (!shallowEquals(existingParams, requestedParams)) {\n        return true;\n      }\n    }\n    if (options == null ? void 0 : options.modes) {\n      if (!prevOptions.modes || !arrEquals(options.modes, prevOptions.modes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async publish(...args) {\n    let messages = args[0];\n    let argCount = args.length;\n    if (!this.connectionManager.activeState()) {\n      throw this.connectionManager.getError();\n    }\n    if (argCount == 1) {\n      if (isObject(messages))\n        messages = [fromValues(messages)];\n      else if (Array.isArray(messages))\n        messages = fromValuesArray(messages);\n      else\n        throw new ErrorInfo(\n          \"The single-argument form of publish() expects a message object or an array of message objects\",\n          40013,\n          400\n        );\n    } else {\n      messages = [fromValues({ name: args[0], data: args[1] })];\n    }\n    const maxMessageSize = this.client.options.maxMessageSize;\n    await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(messages);\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        \"Maximum size of messages that can be published at once exceeded ( was \" + size + \" bytes; limit is \" + maxMessageSize + \" bytes)\",\n        40009,\n        400\n      );\n    }\n    return new Promise((resolve, reject) => {\n      this._publish(messages, (err) => err ? reject(err) : resolve());\n    });\n  }\n  _publish(messages, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.publish()\", \"message count = \" + messages.length);\n    const state = this.state;\n    switch (state) {\n      case \"failed\":\n      case \"suspended\":\n        callback(ErrorInfo.fromValues(this.invalidStateError()));\n        break;\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"RealtimeChannel.publish()\",\n          \"sending message; channel state is \" + state\n        );\n        const msg = new protocolmessage_default();\n        msg.action = actions2.MESSAGE;\n        msg.channel = this.name;\n        msg.messages = messages;\n        this.sendMessage(msg, callback);\n        break;\n      }\n    }\n  }\n  onEvent(messages) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.onEvent()\", \"received message\");\n    const subscriptions = this.subscriptions;\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      subscriptions.emit(message.name, message);\n    }\n  }\n  async attach() {\n    if (this.state === \"attached\") {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      this._attach(false, null, (err, result) => err ? reject(err) : resolve(result));\n    });\n  }\n  _attach(forceReattach, attachReason, callback) {\n    if (!callback) {\n      callback = (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"RealtimeChannel._attach()\",\n            \"Channel attach failed: \" + err.toString()\n          );\n        }\n      };\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      callback(connectionManager.getError());\n      return;\n    }\n    if (this.state !== \"attaching\" || forceReattach) {\n      this.requestState(\"attaching\", attachReason);\n    }\n    this.once(function(stateChange) {\n      switch (this.event) {\n        case \"attached\":\n          callback == null ? void 0 : callback(null, stateChange);\n          break;\n        case \"detached\":\n        case \"suspended\":\n        case \"failed\":\n          callback == null ? void 0 : callback(\n            stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to attach; reason unknown; state = \" + this.event, 9e4, 500)\n          );\n          break;\n        case \"detaching\":\n          callback == null ? void 0 : callback(new ErrorInfo(\"Attach request superseded by a subsequent detach request\", 9e4, 409));\n          break;\n      }\n    });\n  }\n  attachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.attachImpl()\", \"sending ATTACH message\");\n    const attachMsg = fromValues3({\n      action: actions2.ATTACH,\n      channel: this.name,\n      params: this.channelOptions.params,\n      // RTL4c1: Includes the channel serial to resume from a previous message\n      // or attachment.\n      channelSerial: this.properties.channelSerial\n    });\n    if (this._requestedFlags) {\n      attachMsg.encodeModesToFlags(this._requestedFlags);\n    } else if (this.channelOptions.modes) {\n      attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));\n    }\n    if (this._attachResume) {\n      attachMsg.setFlag(\"ATTACH_RESUME\");\n    }\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n    }\n    this.sendMessage(attachMsg, noop2);\n  }\n  async detach() {\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    switch (this.state) {\n      case \"suspended\":\n        this.notifyState(\"detached\");\n        return;\n      case \"detached\":\n        return;\n      case \"failed\":\n        throw new ErrorInfo(\"Unable to detach; channel state = failed\", 90001, 400);\n      default:\n        this.requestState(\"detaching\");\n      case \"detaching\":\n        return new Promise((resolve, reject) => {\n          this.once(function(stateChange) {\n            switch (this.event) {\n              case \"detached\":\n                resolve();\n                break;\n              case \"attached\":\n              case \"suspended\":\n              case \"failed\":\n                reject(\n                  stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to detach; reason unknown; state = \" + this.event, 9e4, 500)\n                );\n                break;\n              case \"attaching\":\n                reject(new ErrorInfo(\"Detach request superseded by a subsequent attach request\", 9e4, 409));\n                break;\n            }\n          });\n        });\n    }\n  }\n  detachImpl(callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.detach()\", \"sending DETACH message\");\n    const msg = fromValues3({ action: actions2.DETACH, channel: this.name });\n    this.sendMessage(msg, callback || noop2);\n  }\n  async subscribe(...args) {\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (this.state === \"failed\") {\n      throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n    if (event && typeof event === \"object\" && !Array.isArray(event)) {\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n    } else {\n      this.subscriptions.on(event, listener);\n    }\n    return this.attach();\n  }\n  unsubscribe(...args) {\n    var _a2;\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (typeof event === \"object\" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {\n      this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach((l) => this.subscriptions.off(l));\n      return;\n    }\n    this.subscriptions.off(event, listener);\n  }\n  sync() {\n    switch (this.state) {\n      case \"initialized\":\n      case \"detaching\":\n      case \"detached\":\n        throw new PartialErrorInfo(\"Unable to sync to channel; not attached\", 4e4);\n      default:\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    const syncMessage = fromValues3({ action: actions2.SYNC, channel: this.name });\n    if (this.syncChannelSerial) {\n      syncMessage.channelSerial = this.syncChannelSerial;\n    }\n    connectionManager.send(syncMessage);\n  }\n  sendMessage(msg, callback) {\n    this.connectionManager.send(msg, this.client.options.queueMessages, callback);\n  }\n  sendPresence(presence, callback) {\n    const msg = fromValues3({\n      action: actions2.PRESENCE,\n      channel: this.name,\n      presence: Array.isArray(presence) ? this.client._RealtimePresence.presenceMessagesFromValuesArray(presence) : [this.client._RealtimePresence.presenceMessageFromValues(presence)]\n    });\n    this.sendMessage(msg, callback);\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n  async processMessage(message) {\n    if (message.action === actions2.ATTACHED || message.action === actions2.MESSAGE || message.action === actions2.PRESENCE) {\n      this.setChannelSerial(message.channelSerial);\n    }\n    let syncChannelSerial, isSync = false;\n    switch (message.action) {\n      case actions2.ATTACHED: {\n        this.properties.attachSerial = message.channelSerial;\n        this._mode = message.getMode();\n        this.params = message.params || {};\n        const modesFromFlags = message.decodeModesFromFlags();\n        this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;\n        const resumed = message.hasFlag(\"RESUMED\");\n        const hasPresence = message.hasFlag(\"HAS_PRESENCE\");\n        const hasBacklog = message.hasFlag(\"HAS_BACKLOG\");\n        if (this.state === \"attached\") {\n          if (!resumed) {\n            if (this._presence) {\n              this._presence.onAttached(hasPresence);\n            }\n          }\n          const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);\n          this._allChannelChanges.emit(\"update\", change);\n          if (!resumed || this.channelOptions.updateOnAttached) {\n            this.emit(\"update\", change);\n          }\n        } else if (this.state === \"detaching\") {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"attached\", message.error, resumed, hasPresence, hasBacklog);\n        }\n        break;\n      }\n      case actions2.DETACHED: {\n        const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo(\"Channel detached\", 90001, 404);\n        if (this.state === \"detaching\") {\n          this.notifyState(\"detached\", detachErr);\n        } else if (this.state === \"attaching\") {\n          this.notifyState(\"suspended\", detachErr);\n        } else if (this.state === \"attached\" || this.state === \"suspended\") {\n          this.requestState(\"attaching\", detachErr);\n        }\n        break;\n      }\n      case actions2.SYNC:\n        isSync = true;\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n        if (!message.presence)\n          break;\n      case actions2.PRESENCE: {\n        const presence = message.presence;\n        if (!presence) {\n          break;\n        }\n        const { id, connectionId, timestamp } = message;\n        const options = this.channelOptions;\n        let presenceMsg;\n        for (let i = 0; i < presence.length; i++) {\n          try {\n            presenceMsg = presence[i];\n            await decode2(presenceMsg, options);\n            if (!presenceMsg.connectionId)\n              presenceMsg.connectionId = connectionId;\n            if (!presenceMsg.timestamp)\n              presenceMsg.timestamp = timestamp;\n            if (!presenceMsg.id)\n              presenceMsg.id = id + \":\" + i;\n          } catch (e) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"RealtimeChannel.processMessage()\",\n              e.toString()\n            );\n          }\n        }\n        if (this._presence) {\n          this._presence.setPresence(presence, isSync, syncChannelSerial);\n        }\n        break;\n      }\n      case actions2.MESSAGE: {\n        if (this.state !== \"attached\") {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"RealtimeChannel.processMessage()\",\n            'Message \"' + message.id + '\" skipped as this channel \"' + this.name + '\" state is not \"attached\" (state is \"' + this.state + '\").'\n          );\n          return;\n        }\n        const messages = message.messages, firstMessage = messages[0], lastMessage = messages[messages.length - 1], id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;\n        if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n          const msg = 'Delta message decode failure - previous message not available for message \"' + message.id + '\" on this channel \"' + this.name + '\".';\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", msg);\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n          break;\n        }\n        for (let i = 0; i < messages.length; i++) {\n          const msg = messages[i];\n          try {\n            await decode(msg, this._decodingContext);\n          } catch (e) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"RealtimeChannel.processMessage()\",\n              e.toString()\n            );\n            switch (e.code) {\n              case 40018:\n                this._startDecodeFailureRecovery(e);\n                return;\n              case 40019:\n              case 40021:\n                this.notifyState(\"failed\", e);\n                return;\n            }\n          }\n          if (!msg.connectionId)\n            msg.connectionId = connectionId;\n          if (!msg.timestamp)\n            msg.timestamp = timestamp;\n          if (!msg.id)\n            msg.id = id + \":\" + i;\n        }\n        this._lastPayload.messageId = lastMessage.id;\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n        this.onEvent(messages);\n        break;\n      }\n      case actions2.ERROR: {\n        const err = message.error;\n        if (err && err.code == 80016) {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"failed\", ErrorInfo.fromValues(err));\n        }\n        break;\n      }\n      default:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"RealtimeChannel.processMessage()\",\n          \"Fatal protocol error: unrecognised action (\" + message.action + \")\"\n        );\n        this.connectionManager.abort(connectionerrors_default.unknownChannelErr());\n    }\n  }\n  _startDecodeFailureRecovery(reason) {\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MAJOR,\n        \"RealtimeChannel.processMessage()\",\n        \"Starting decode failure recovery process.\"\n      );\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\n      this._attach(true, reason, () => {\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\n      });\n    }\n  }\n  onAttached() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.onAttached\",\n      \"activating channel; name = \" + this.name\n    );\n  }\n  notifyState(state, reason, resumed, hasPresence, hasBacklog) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.notifyState\",\n      \"name = \" + this.name + \", current state = \" + this.state + \", notifying state \" + state\n    );\n    this.clearStateTimer();\n    if ([\"detached\", \"suspended\", \"failed\"].includes(state)) {\n      this.properties.channelSerial = null;\n    }\n    if (state === this.state) {\n      return;\n    }\n    if (this._presence) {\n      this._presence.actOnChannelState(state, hasPresence, reason);\n    }\n    if (state === \"suspended\" && this.connectionManager.state.sendEvents) {\n      this.startRetryTimer();\n    } else {\n      this.cancelRetryTimer();\n    }\n    if (reason) {\n      this.errorReason = reason;\n    }\n    const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);\n    const action = 'Channel state for channel \"' + this.name + '\"';\n    const message = state + (reason ? \"; reason: \" + reason : \"\");\n    if (state === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    if (state !== \"attaching\" && state !== \"suspended\") {\n      this.retryCount = 0;\n    }\n    if (state === \"attached\") {\n      this.onAttached();\n    }\n    if (state === \"attached\") {\n      this._attachResume = true;\n    } else if (state === \"detaching\" || state === \"failed\") {\n      this._attachResume = false;\n    }\n    this.state = state;\n    this._allChannelChanges.emit(state, change);\n    this.emit(state, change);\n  }\n  requestState(state, reason) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.requestState\",\n      \"name = \" + this.name + \", state = \" + state\n    );\n    this.notifyState(state, reason);\n    this.checkPendingState();\n  }\n  checkPendingState() {\n    const cmState = this.connectionManager.state;\n    if (!cmState.sendEvents) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.checkPendingState\",\n        \"sendEvents is false; state is \" + this.connectionManager.state.state\n      );\n      return;\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.checkPendingState\",\n      \"name = \" + this.name + \", state = \" + this.state\n    );\n    switch (this.state) {\n      case \"attaching\":\n        this.startStateTimerIfNotRunning();\n        this.attachImpl();\n        break;\n      case \"detaching\":\n        this.startStateTimerIfNotRunning();\n        this.detachImpl();\n        break;\n      case \"attached\":\n        this.sync();\n        break;\n      default:\n        break;\n    }\n  }\n  timeoutPendingState() {\n    switch (this.state) {\n      case \"attaching\": {\n        const err = new ErrorInfo(\"Channel attach timed out\", 90007, 408);\n        this.notifyState(\"suspended\", err);\n        break;\n      }\n      case \"detaching\": {\n        const err = new ErrorInfo(\"Channel detach timed out\", 90007, 408);\n        this.notifyState(\"attached\", err);\n        break;\n      }\n      default:\n        this.checkPendingState();\n        break;\n    }\n  }\n  startStateTimerIfNotRunning() {\n    if (!this.stateTimer) {\n      this.stateTimer = setTimeout(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel.startStateTimerIfNotRunning\", \"timer expired\");\n        this.stateTimer = null;\n        this.timeoutPendingState();\n      }, this.client.options.timeouts.realtimeRequestTimeout);\n    }\n  }\n  clearStateTimer() {\n    const stateTimer = this.stateTimer;\n    if (stateTimer) {\n      clearTimeout(stateTimer);\n      this.stateTimer = null;\n    }\n  }\n  startRetryTimer() {\n    if (this.retryTimer)\n      return;\n    this.retryCount++;\n    const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n    this.retryTimer = setTimeout(() => {\n      if (this.state === \"suspended\" && this.connectionManager.state.sendEvents) {\n        this.retryTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"RealtimeChannel retry timer expired\",\n          \"attempting a new attach\"\n        );\n        this.requestState(\"attaching\");\n      }\n    }, retryDelay);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n  getReleaseErr() {\n    const s = this.state;\n    if (s === \"initialized\" || s === \"detached\" || s === \"failed\") {\n      return null;\n    }\n    return new ErrorInfo(\n      \"Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was \" + s,\n      90001,\n      400\n    );\n  }\n  setChannelSerial(channelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.setChannelSerial()\",\n      \"Updating channel serial; serial = \" + channelSerial + \"; previous = \" + this.properties.channelSerial\n    );\n    if (channelSerial) {\n      this.properties.channelSerial = channelSerial;\n    }\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n};\nfunction omitAgent(channelParams) {\n  const _a2 = channelParams || {}, { agent: _ } = _a2, paramsWithoutAgent = __objRest(_a2, [\"agent\"]);\n  return paramsWithoutAgent;\n}\nvar realtimechannel_default = RealtimeChannel;\n\n// src/common/lib/client/baserealtime.ts\nvar _BaseRealtime = class _BaseRealtime extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    var _a2, _b;\n    super(defaults_default.objectifyOptions(options, false, \"BaseRealtime\", logger_default.defaultLogger));\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime()\", \"\");\n    if (typeof EdgeRuntime === \"string\") {\n      throw new ErrorInfo(\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime. If you are running Vercel Edge functions, please replace your \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API instead of the Realtime API. If you are server-rendering your application in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\" to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\n        4e4,\n        400\n      );\n    }\n    this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n    this._RealtimePresence = (_b = (_a2 = this.options.plugins) == null ? void 0 : _a2.RealtimePresence) != null ? _b : null;\n    this.connection = new connection_default(this, this.options);\n    this._channels = new Channels2(this);\n    if (this.options.autoConnect !== false)\n      this.connect();\n  }\n  static transportImplementationsFromPlugins(plugins) {\n    const transports = {};\n    if (plugins == null ? void 0 : plugins.WebSocketTransport) {\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n    }\n    if (plugins == null ? void 0 : plugins.XHRPolling) {\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n    }\n    return transports;\n  }\n  get channels() {\n    return this._channels;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.connect()\", \"\");\n    this.connection.connect();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.close()\", \"\");\n    this.connection.close();\n  }\n};\n// internal API to make EventEmitter usable in other SDKs\n_BaseRealtime.EventEmitter = eventemitter_default;\nvar BaseRealtime = _BaseRealtime;\nvar Channels2 = class extends eventemitter_default {\n  constructor(realtime) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.all = /* @__PURE__ */ Object.create(null);\n    realtime.connection.connectionManager.on(\"transport.active\", () => {\n      this.onTransportActive();\n    });\n  }\n  channelSerials() {\n    let serials = {};\n    for (const name of keysArray(this.all, true)) {\n      const channel = this.all[name];\n      if (channel.properties.channelSerial) {\n        serials[name] = channel.properties.channelSerial;\n      }\n    }\n    return serials;\n  }\n  // recoverChannels gets the given channels and sets their channel serials.\n  recoverChannels(channelSerials) {\n    for (const name of keysArray(channelSerials, true)) {\n      const channel = this.get(name);\n      channel.properties.channelSerial = channelSerials[name];\n    }\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n  async processChannelMessage(msg) {\n    const channelName = msg.channel;\n    if (channelName === void 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event unspecified channel, action = \" + msg.action\n      );\n      return;\n    }\n    const channel = this.all[channelName];\n    if (!channel) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event for non-existent channel: \" + channelName\n      );\n      return;\n    }\n    await channel.processMessage(msg);\n  }\n  /* called when a transport becomes connected; reattempt attach/detach\n   * for channels that are attaching or detaching. */\n  onTransportActive() {\n    for (const channelName in this.all) {\n      const channel = this.all[channelName];\n      if (channel.state === \"attaching\" || channel.state === \"detaching\") {\n        channel.checkPendingState();\n      } else if (channel.state === \"suspended\") {\n        channel._attach(false, null);\n      } else if (channel.state === \"attached\") {\n        channel.requestState(\"attaching\");\n      }\n    }\n  }\n  /* Connection interruptions (ie when the connection will no longer queue\n   * events) imply connection state changes for any channel which is either\n   * attached, pending, or will attempt to become attached in the future */\n  propogateConnectionInterruption(connectionState, reason) {\n    const connectionStateToChannelState = {\n      closing: \"detached\",\n      closed: \"detached\",\n      failed: \"failed\",\n      suspended: \"suspended\"\n    };\n    const fromChannelStates = [\"attaching\", \"attached\", \"detaching\", \"suspended\"];\n    const toChannelState = connectionStateToChannelState[connectionState];\n    for (const channelId in this.all) {\n      const channel = this.all[channelId];\n      if (fromChannelStates.includes(channel.state)) {\n        channel.notifyState(toChannelState, reason);\n      }\n    }\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);\n    } else if (channelOptions) {\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n        throw new ErrorInfo(\n          \"Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.\",\n          4e4,\n          400\n        );\n      }\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  getDerived(name, deriveOptions, channelOptions) {\n    if (deriveOptions.filter) {\n      const filter = toBase64(deriveOptions.filter);\n      const match = matchDerivedChannel(name);\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n    }\n    return this.get(name, channelOptions);\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    name = String(name);\n    const channel = this.all[name];\n    if (!channel) {\n      return;\n    }\n    const releaseErr = channel.getReleaseErr();\n    if (releaseErr) {\n      throw releaseErr;\n    }\n    delete this.all[name];\n  }\n};\nvar baserealtime_default = BaseRealtime;\n\n// src/common/lib/client/realtimepresence.ts\nfunction getClientId(realtimePresence) {\n  return realtimePresence.channel.client.auth.clientId;\n}\nfunction isAnonymousOrWildcard(realtimePresence) {\n  const realtime = realtimePresence.channel.client;\n  const clientId = realtime.auth.clientId;\n  return (!clientId || clientId === \"*\") && realtime.connection.state === \"connected\";\n}\nfunction waitAttached(channel, callback, action) {\n  switch (channel.state) {\n    case \"attached\":\n    case \"suspended\":\n      action();\n      break;\n    case \"initialized\":\n    case \"detached\":\n    case \"detaching\":\n    case \"attaching\":\n      whenPromiseSettles(channel.attach(), function(err) {\n        if (err)\n          callback(err);\n        else\n          action();\n      });\n      break;\n    default:\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\n  }\n}\nfunction newerThan(item, existing) {\n  if (item.isSynthesized() || existing.isSynthesized()) {\n    return item.timestamp >= existing.timestamp;\n  }\n  const itemOrderings = item.parseId(), existingOrderings = existing.parseId();\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n    return itemOrderings.index > existingOrderings.index;\n  } else {\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\n  }\n}\nvar RealtimePresence = class extends eventemitter_default {\n  constructor(channel) {\n    super(channel.logger);\n    this.channel = channel;\n    this.syncComplete = false;\n    this.members = new PresenceMap(this, (item) => item.clientId + \":\" + item.connectionId);\n    this._myMembers = new PresenceMap(this, (item) => item.clientId);\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.pendingPresence = [];\n  }\n  async enter(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to enter a presence channel\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"enter\");\n  }\n  async update(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to update presence data\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"update\");\n  }\n  async enterClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"enter\");\n  }\n  async updateClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"update\");\n  }\n  async _enterOrUpdateClient(id, clientId, data, action) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.\" + action + \"Client()\",\n      \"channel = \" + channel.name + \", id = \" + id + \", client = \" + (clientId || \"(implicit) \" + getClientId(this))\n    );\n    const presence = fromData(data);\n    presence.action = action;\n    if (id) {\n      presence.id = id;\n    }\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    await encode(presence, channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return new Promise((resolve, reject) => {\n          channel.sendPresence(presence, (err) => err ? reject(err) : resolve());\n        });\n      case \"initialized\":\n      case \"detached\":\n        channel.attach();\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      default: {\n        const err = new PartialErrorInfo(\n          \"Unable to \" + action + \" presence channel while in \" + channel.state + \" state\",\n          90001\n        );\n        err.code = 90001;\n        throw err;\n      }\n    }\n  }\n  async leave(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must have been specified to enter or leave a presence channel\", 40012, 400);\n    }\n    return this.leaveClient(void 0, data);\n  }\n  async leaveClient(clientId, data) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.leaveClient()\",\n      \"leaving; channel = \" + this.channel.name + \", client = \" + clientId\n    );\n    const presence = fromData(data);\n    presence.action = \"leave\";\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    return new Promise((resolve, reject) => {\n      switch (channel.state) {\n        case \"attached\":\n          channel.sendPresence(presence, (err) => err ? reject(err) : resolve());\n          break;\n        case \"attaching\":\n          this.pendingPresence.push({\n            presence,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n          break;\n        case \"initialized\":\n        case \"failed\": {\n          const err = new PartialErrorInfo(\"Unable to leave presence channel (incompatible state)\", 90001);\n          reject(err);\n          break;\n        }\n        default:\n          reject(channel.invalidStateError());\n      }\n    });\n  }\n  async get(params) {\n    const waitForSync = !params || (\"waitForSync\" in params ? params.waitForSync : true);\n    return new Promise((resolve, reject) => {\n      function returnMembers(members) {\n        resolve(params ? members.list(params) : members.values());\n      }\n      if (this.channel.state === \"suspended\") {\n        if (waitForSync) {\n          reject(\n            ErrorInfo.fromValues({\n              statusCode: 400,\n              code: 91005,\n              message: \"Presence state is out of sync due to channel being in the SUSPENDED state\"\n            })\n          );\n        } else {\n          returnMembers(this.members);\n        }\n        return;\n      }\n      waitAttached(\n        this.channel,\n        (err) => reject(err),\n        () => {\n          const members = this.members;\n          if (waitForSync) {\n            members.waitSync(function() {\n              returnMembers(members);\n            });\n          } else {\n            returnMembers(members);\n          }\n        }\n      );\n    });\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimePresence.history()\", \"channel = \" + this.name);\n    const restMixin = this.channel.client.rest.presenceMixin;\n    if (params && params.untilAttach) {\n      if (this.channel.state === \"attached\") {\n        delete params.untilAttach;\n        params.from_serial = this.channel.properties.attachSerial;\n      } else {\n        throw new ErrorInfo(\n          \"option untilAttach requires the channel to be attached, was: \" + this.channel.state,\n          4e4,\n          400\n        );\n      }\n    }\n    return restMixin.history(this, params);\n  }\n  setPresence(presenceSet, isSync, syncChannelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.setPresence()\",\n      \"received presence for \" + presenceSet.length + \" participants; syncChannelSerial = \" + syncChannelSerial\n    );\n    let syncCursor, match;\n    const members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;\n    if (isSync) {\n      this.members.startSync();\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n        syncCursor = match[1];\n      }\n    }\n    for (let i = 0; i < presenceSet.length; i++) {\n      const presence = fromValues2(presenceSet[i]);\n      switch (presence.action) {\n        case \"leave\":\n          if (members.remove(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\n            myMembers.remove(presence);\n          }\n          break;\n        case \"enter\":\n        case \"present\":\n        case \"update\":\n          if (members.put(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId) {\n            myMembers.put(presence);\n          }\n          break;\n      }\n    }\n    if (isSync && !syncCursor) {\n      members.endSync();\n      this.channel.syncChannelSerial = null;\n    }\n    for (let i = 0; i < broadcastMessages.length; i++) {\n      const presence = broadcastMessages[i];\n      this.subscriptions.emit(presence.action, presence);\n    }\n  }\n  onAttached(hasPresence) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimePresence.onAttached()\",\n      \"channel = \" + this.channel.name + \", hasPresence = \" + hasPresence\n    );\n    if (hasPresence) {\n      this.members.startSync();\n    } else {\n      this._synthesizeLeaves(this.members.values());\n      this.members.clear();\n    }\n    this._ensureMyMembersPresent();\n    const pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;\n    if (pendingPresCount) {\n      this.pendingPresence = [];\n      const presenceArray = [];\n      const multicaster = multicaster_default.create(this.logger);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence.onAttached\",\n        \"sending \" + pendingPresCount + \" queued presence messages\"\n      );\n      for (let i = 0; i < pendingPresCount; i++) {\n        const event = pendingPresence[i];\n        presenceArray.push(event.presence);\n        multicaster.push(event.callback);\n      }\n      this.channel.sendPresence(presenceArray, multicaster);\n    }\n  }\n  actOnChannelState(state, hasPresence, err) {\n    switch (state) {\n      case \"attached\":\n        this.onAttached(hasPresence);\n        break;\n      case \"detached\":\n      case \"failed\":\n        this._clearMyMembers();\n        this.members.clear();\n      case \"suspended\":\n        this.failPendingPresence(err);\n        break;\n    }\n  }\n  failPendingPresence(err) {\n    if (this.pendingPresence.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.failPendingPresence\",\n        \"channel; name = \" + this.channel.name + \", err = \" + inspectError(err)\n      );\n      for (let i = 0; i < this.pendingPresence.length; i++)\n        try {\n          this.pendingPresence[i].callback(err);\n        } catch (e) {\n        }\n      this.pendingPresence = [];\n    }\n  }\n  _clearMyMembers() {\n    this._myMembers.clear();\n  }\n  _ensureMyMembersPresent() {\n    const myMembers = this._myMembers, reenterCb = (err) => {\n      if (err) {\n        const msg = \"Presence auto-re-enter failed: \" + err.toString();\n        const wrappedErr = new ErrorInfo(msg, 91004, 400);\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimePresence._ensureMyMembersPresent()\", msg);\n        const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);\n        this.channel.emit(\"update\", change);\n      }\n    };\n    for (const memberKey in myMembers.map) {\n      const entry = myMembers.map[memberKey];\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence._ensureMyMembersPresent()\",\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set'\n      );\n      whenPromiseSettles(this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, \"enter\"), reenterCb);\n    }\n  }\n  _synthesizeLeaves(items) {\n    const subscriptions = this.subscriptions;\n    items.forEach(function(item) {\n      const presence = fromValues2({\n        action: \"leave\",\n        connectionId: item.connectionId,\n        clientId: item.clientId,\n        data: item.data,\n        encoding: item.encoding,\n        timestamp: Date.now()\n      });\n      subscriptions.emit(\"leave\", presence);\n    });\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    await channel.attach();\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n};\nvar PresenceMap = class extends eventemitter_default {\n  constructor(presence, memberKey) {\n    super(presence.logger);\n    this.presence = presence;\n    this.map = /* @__PURE__ */ Object.create(null);\n    this.syncInProgress = false;\n    this.residualMembers = null;\n    this.memberKey = memberKey;\n  }\n  get(key) {\n    return this.map[key];\n  }\n  getClient(clientId) {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.clientId == clientId && item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  list(params) {\n    const map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action === \"absent\")\n        continue;\n      if (clientId && clientId != item.clientId)\n        continue;\n      if (connectionId && connectionId != item.connectionId)\n        continue;\n      result.push(item);\n    }\n    return result;\n  }\n  put(item) {\n    if (item.action === \"enter\" || item.action === \"update\") {\n      item = fromValues2(item);\n      item.action = \"present\";\n    }\n    const map = this.map, key = this.memberKey(item);\n    if (this.residualMembers)\n      delete this.residualMembers[key];\n    const existingItem = map[key];\n    if (existingItem && !newerThan(item, existingItem)) {\n      return false;\n    }\n    map[key] = item;\n    return true;\n  }\n  values() {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  remove(item) {\n    const map = this.map, key = this.memberKey(item);\n    const existingItem = map[key];\n    if (existingItem && !newerThan(item, existingItem)) {\n      return false;\n    }\n    if (this.syncInProgress) {\n      item = fromValues2(item);\n      item.action = \"absent\";\n      map[key] = item;\n    } else {\n      delete map[key];\n    }\n    return true;\n  }\n  startSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.startSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!this.syncInProgress) {\n      this.residualMembers = copy(map);\n      this.setInProgress(true);\n    }\n  }\n  endSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.endSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (syncInProgress) {\n      for (const memberKey in map) {\n        const entry = map[memberKey];\n        if (entry.action === \"absent\") {\n          delete map[memberKey];\n        }\n      }\n      this.presence._synthesizeLeaves(valuesArray(this.residualMembers));\n      for (const memberKey in this.residualMembers) {\n        delete map[memberKey];\n      }\n      this.residualMembers = null;\n      this.setInProgress(false);\n    }\n    this.emit(\"sync\");\n  }\n  waitSync(callback) {\n    const syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.waitSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!syncInProgress) {\n      callback();\n      return;\n    }\n    this.once(\"sync\", callback);\n  }\n  clear() {\n    this.map = {};\n    this.setInProgress(false);\n    this.residualMembers = null;\n  }\n  setInProgress(inProgress) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"PresenceMap.setInProgress()\", \"inProgress = \" + inProgress);\n    this.syncInProgress = inProgress;\n    this.presence.syncComplete = !inProgress;\n  }\n};\nvar realtimepresence_default = RealtimePresence;\n\n// src/common/lib/transport/websockettransport.ts\nvar shortName = TransportNames.WebSocket;\nfunction isNodeWebSocket(ws) {\n  return !!ws.on;\n}\nvar WebSocketTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName;\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\n    this.wsHost = params.host;\n  }\n  static isAvailable() {\n    return !!Platform.Config.WebSocket;\n  }\n  createWebSocket(uri, connectParams) {\n    this.uri = uri + toQueryString(connectParams);\n    return new Platform.Config.WebSocket(this.uri);\n  }\n  toString() {\n    return \"WebSocketTransport; uri=\" + this.uri;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const self2 = this, params = this.params, options = params.options;\n    const wsScheme = options.tls ? \"wss://\" : \"ws://\";\n    const wsUri = wsScheme + this.wsHost + \":\" + defaults_default.getPort(options) + \"/\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"uri: \" + wsUri);\n    whenPromiseSettles(\n      this.auth.getAuthParams(),\n      function(err, authParams) {\n        if (self2.isDisposed) {\n          return;\n        }\n        let paramStr = \"\";\n        for (const param in authParams)\n          paramStr += \" \" + param + \": \" + authParams[param] + \";\";\n        logger_default.logAction(\n          self2.logger,\n          logger_default.LOG_MINOR,\n          \"WebSocketTransport.connect()\",\n          \"authParams:\" + paramStr + \" err: \" + err\n        );\n        if (err) {\n          self2.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams);\n        try {\n          const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function() {\n            self2.onWsOpen();\n          };\n          wsConnection.onclose = function(ev) {\n            self2.onWsClose(ev);\n          };\n          wsConnection.onmessage = function(ev) {\n            self2.onWsData(ev.data);\n          };\n          wsConnection.onerror = function(ev) {\n            self2.onWsError(ev);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            wsConnection.on(\"ping\", function() {\n              self2.onActivity();\n            });\n          }\n        } catch (e) {\n          logger_default.logAction(\n            self2.logger,\n            logger_default.LOG_ERROR,\n            \"WebSocketTransport.connect()\",\n            \"Unexpected exception creating websocket: err = \" + (e.stack || e.message)\n          );\n          self2.disconnect(e);\n        }\n      }\n    );\n  }\n  send(message) {\n    const wsConnection = this.wsConnection;\n    if (!wsConnection) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", \"No socket connection\");\n      return;\n    }\n    try {\n      wsConnection.send(\n        serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format)\n      );\n    } catch (e) {\n      const msg = \"Exception from ws connection when trying to send: \" + inspectError(e);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", msg);\n      this.finish(\"disconnected\", new ErrorInfo(msg, 5e4, 500));\n    }\n  }\n  onWsData(data) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"WebSocketTransport.onWsData()\",\n      \"data received; length = \" + data.length + \"; type = \" + typeof data\n    );\n    try {\n      this.onProtocolMessage(\n        deserialize(\n          data,\n          this.connectionManager.realtime._MsgPack,\n          this.connectionManager.realtime._RealtimePresence,\n          this.format\n        )\n      );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"WebSocketTransport.onWsData()\",\n        \"Unexpected exception handing channel message: \" + e.stack\n      );\n    }\n  }\n  onWsOpen() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsOpen()\", \"opened WebSocket\");\n    this.emit(\"preconnect\");\n  }\n  onWsClose(ev) {\n    let wasClean, code;\n    if (typeof ev == \"object\") {\n      code = ev.code;\n      wasClean = ev.wasClean || code === 1e3;\n    } else {\n      code = ev;\n      wasClean = code == 1e3;\n    }\n    delete this.wsConnection;\n    if (wasClean) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", \"Cleanly closed WebSocket\");\n      const err = new ErrorInfo(\"Websocket closed\", 80003, 400);\n      this.finish(\"disconnected\", err);\n    } else {\n      const msg = \"Unclean disconnection of WebSocket ; code = \" + code, err = new ErrorInfo(msg, 80003, 400);\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", msg);\n      this.finish(\"disconnected\", err);\n    }\n    this.emit(\"disposed\");\n  }\n  onWsError(err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"WebSocketTransport.onError()\",\n      \"Error from WebSocket: \" + err.message\n    );\n    Platform.Config.nextTick(() => {\n      this.disconnect(Error(err.message));\n    });\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.dispose()\", \"\");\n    this.isDisposed = true;\n    const wsConnection = this.wsConnection;\n    if (wsConnection) {\n      wsConnection.onmessage = function() {\n      };\n      delete this.wsConnection;\n      Platform.Config.nextTick(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"WebSocketTransport.dispose()\", \"closing websocket\");\n        if (!wsConnection) {\n          throw new Error(\"WebSocketTransport.dispose(): wsConnection is not defined\");\n        }\n        wsConnection.close();\n      });\n    }\n  }\n};\nvar websockettransport_default = WebSocketTransport;\n\n// src/common/lib/client/filteredsubscriptions.ts\nvar FilteredSubscriptions = class {\n  static subscribeFilter(channel, filter, listener) {\n    const filteredListener = (m) => {\n      var _a2, _b, _c, _d, _e, _f;\n      const mapping = {\n        name: m.name,\n        refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,\n        refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,\n        isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),\n        clientId: m.clientId\n      };\n      if (Object.entries(filter).find(\n        ([key, value]) => value !== void 0 ? mapping[key] !== value : false\n      )) {\n        return;\n      }\n      listener(m);\n    };\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\n    channel.subscriptions.on(filteredListener);\n  }\n  // Adds a new filtered subscription\n  static addFilteredSubscription(channel, filter, realListener, filteredListener) {\n    var _a2;\n    if (!channel.filteredSubscriptions) {\n      channel.filteredSubscriptions = /* @__PURE__ */ new Map();\n    }\n    if (channel.filteredSubscriptions.has(realListener)) {\n      const realListenerMap = channel.filteredSubscriptions.get(realListener);\n      realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);\n    } else {\n      channel.filteredSubscriptions.set(\n        realListener,\n        /* @__PURE__ */ new Map([[filter, [filteredListener]]])\n      );\n    }\n  }\n  static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {\n    if (!channel.filteredSubscriptions) {\n      return [];\n    }\n    if (!realListener && filter) {\n      return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {\n        var _a2;\n        let listenerMaps = filterMaps.get(filter);\n        filterMaps.delete(filter);\n        if (filterMaps.size === 0) {\n          (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);\n        }\n        return listenerMaps;\n      }).reduce(\n        (prev, cur) => cur ? prev.concat(...cur) : prev,\n        []\n      );\n    }\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n      return [];\n    }\n    const realListenerMap = channel.filteredSubscriptions.get(realListener);\n    if (!filter) {\n      const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n      channel.filteredSubscriptions.delete(realListener);\n      return listeners2;\n    }\n    let listeners = realListenerMap.get(filter);\n    realListenerMap.delete(filter);\n    return listeners || [];\n  }\n};\n\n// src/common/lib/client/defaultrealtime.ts\nvar _DefaultRealtime = class _DefaultRealtime extends baserealtime_default {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2;\n    const MsgPack = _DefaultRealtime._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRealtime._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Realtime\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRealtime.Crypto) != null ? _a2 : void 0,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence: realtimepresence_default,\n          presenceMessageFromValues: fromValues2,\n          presenceMessagesFromValuesArray: fromValuesArray2\n        },\n        WebSocketTransport: websockettransport_default,\n        MessageInteractions: FilteredSubscriptions\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRealtime.Utils = utils_exports;\n_DefaultRealtime.ConnectionManager = connectionmanager_default;\n_DefaultRealtime.ProtocolMessage = protocolmessage_default;\n_DefaultRealtime._Crypto = null;\n_DefaultRealtime.Message = DefaultMessage;\n_DefaultRealtime.PresenceMessage = DefaultPresenceMessage;\n_DefaultRealtime._MsgPack = null;\n// Used by tests\n_DefaultRealtime._Http = Http;\nvar DefaultRealtime = _DefaultRealtime;\n\n// src/platform/web/lib/util/hmac-sha256.ts\nvar uint8Array = Uint8Array;\nvar uint32Array = Uint32Array;\nvar pow = Math.pow;\nvar DEFAULT_STATE = new uint32Array(8);\nvar ROUND_CONSTANTS = [];\nvar M = new uint32Array(64);\nfunction getFractionalBits(n2) {\n  return (n2 - (n2 | 0)) * pow(2, 32) | 0;\n}\nvar n = 2;\nvar nPrime = 0;\nwhile (nPrime < 64) {\n  isPrime = true;\n  for (factor = 2; factor <= n / 2; factor++) {\n    if (n % factor === 0) {\n      isPrime = false;\n    }\n  }\n  if (isPrime) {\n    if (nPrime < 8) {\n      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\n    }\n    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\n    nPrime++;\n  }\n  n++;\n}\nvar isPrime;\nvar factor;\nvar LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\nfunction convertEndian(word) {\n  if (LittleEndian) {\n    return (\n      // byte 1 -> byte 4\n      word >>> 24 | // byte 2 -> byte 3\n      (word >>> 16 & 255) << 8 | // byte 3 -> byte 2\n      (word & 65280) << 8 | // byte 4 -> byte 1\n      word << 24\n    );\n  } else {\n    return word;\n  }\n}\nfunction rightRotate(word, bits) {\n  return word >>> bits | word << 32 - bits;\n}\nfunction sha256(data) {\n  var STATE = DEFAULT_STATE.slice();\n  var legth = data.length;\n  var bitLength = legth * 8;\n  var newBitLength = 512 - (bitLength + 64) % 512 - 1 + bitLength + 65;\n  var bytes = new uint8Array(newBitLength / 8);\n  var words = new uint32Array(bytes.buffer);\n  bytes.set(data, 0);\n  bytes[legth] = 128;\n  words[words.length - 1] = convertEndian(bitLength);\n  var round;\n  for (var block = 0; block < newBitLength / 32; block += 16) {\n    var workingState = STATE.slice();\n    for (round = 0; round < 64; round++) {\n      var MRound;\n      if (round < 16) {\n        MRound = convertEndian(words[block + round]);\n      } else {\n        var gamma0x = M[round - 15];\n        var gamma1x = M[round - 2];\n        MRound = M[round - 7] + M[round - 16] + (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ gamma0x >>> 3) + (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ gamma1x >>> 10);\n      }\n      M[round] = MRound |= 0;\n      var t1 = (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) + (workingState[4] & workingState[5] ^ ~workingState[4] & workingState[6]) + workingState[7] + MRound + ROUND_CONSTANTS[round];\n      var t2 = (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) + (workingState[0] & workingState[1] ^ workingState[2] & (workingState[0] ^ workingState[1]));\n      for (var i = 7; i > 0; i--) {\n        workingState[i] = workingState[i - 1];\n      }\n      workingState[0] = t1 + t2 | 0;\n      workingState[4] = workingState[4] + t1 | 0;\n    }\n    for (round = 0; round < 8; round++) {\n      STATE[round] = STATE[round] + workingState[round] | 0;\n    }\n  }\n  return new uint8Array(\n    new uint32Array(\n      STATE.map(function(val) {\n        return convertEndian(val);\n      })\n    ).buffer\n  );\n}\nfunction hmac2(key, data) {\n  if (key.length > 64)\n    key = sha256(key);\n  if (key.length < 64) {\n    const tmp = new Uint8Array(64);\n    tmp.set(key, 0);\n    key = tmp;\n  }\n  var innerKey = new Uint8Array(64);\n  var outerKey = new Uint8Array(64);\n  for (var i = 0; i < 64; i++) {\n    innerKey[i] = 54 ^ key[i];\n    outerKey[i] = 92 ^ key[i];\n  }\n  var msg = new Uint8Array(data.length + 64);\n  msg.set(innerKey, 0);\n  msg.set(data, 64);\n  var result = new Uint8Array(64 + 32);\n  result.set(outerKey, 0);\n  result.set(sha256(msg), 64);\n  return sha256(result);\n}\n\n// src/platform/web/lib/util/bufferutils.ts\nvar BufferUtils = class {\n  constructor() {\n    this.base64CharSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    this.hexCharSet = \"0123456789abcdef\";\n  }\n  // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\n  uint8ViewToBase64(bytes) {\n    let base64 = \"\";\n    const encodings = this.base64CharSet;\n    const byteLength = bytes.byteLength;\n    const byteRemainder = byteLength % 3;\n    const mainLength = byteLength - byteRemainder;\n    let a, b, c, d;\n    let chunk;\n    for (let i = 0; i < mainLength; i = i + 3) {\n      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];\n      a = (chunk & 16515072) >> 18;\n      b = (chunk & 258048) >> 12;\n      c = (chunk & 4032) >> 6;\n      d = chunk & 63;\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n    }\n    if (byteRemainder == 1) {\n      chunk = bytes[mainLength];\n      a = (chunk & 252) >> 2;\n      b = (chunk & 3) << 4;\n      base64 += encodings[a] + encodings[b] + \"==\";\n    } else if (byteRemainder == 2) {\n      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];\n      a = (chunk & 64512) >> 10;\n      b = (chunk & 1008) >> 4;\n      c = (chunk & 15) << 2;\n      base64 += encodings[a] + encodings[b] + encodings[c] + \"=\";\n    }\n    return base64;\n  }\n  base64ToArrayBuffer(base64) {\n    const binary_string = atob == null ? void 0 : atob(base64);\n    const len = binary_string.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      const ascii = binary_string.charCodeAt(i);\n      bytes[i] = ascii;\n    }\n    return this.toArrayBuffer(bytes);\n  }\n  isBuffer(buffer) {\n    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n  toBuffer(buffer) {\n    if (!ArrayBuffer) {\n      throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return new Uint8Array(buffer);\n    }\n    if (ArrayBuffer.isView(buffer)) {\n      return new Uint8Array(this.toArrayBuffer(buffer));\n    }\n    throw new Error(\"BufferUtils.toBuffer expected an ArrayBuffer or a view onto one\");\n  }\n  toArrayBuffer(buffer) {\n    if (!ArrayBuffer) {\n      throw new Error(\"Can't convert to ArrayBuffer: browser does not support the necessary types\");\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return buffer;\n    }\n    if (ArrayBuffer.isView(buffer)) {\n      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n    }\n    throw new Error(\"BufferUtils.toArrayBuffer expected an ArrayBuffer or a view onto one\");\n  }\n  base64Encode(buffer) {\n    return this.uint8ViewToBase64(this.toBuffer(buffer));\n  }\n  base64Decode(str) {\n    if (ArrayBuffer && Platform.Config.atob) {\n      return this.base64ToArrayBuffer(str);\n    } else {\n      throw new Error(\"Expected ArrayBuffer to exist and Platform.Config.atob to be configured\");\n    }\n  }\n  hexEncode(buffer) {\n    const uint8Array2 = this.toBuffer(buffer);\n    return uint8Array2.reduce((accum, byte) => accum + byte.toString(16).padStart(2, \"0\"), \"\");\n  }\n  hexDecode(hexEncodedBytes) {\n    if (hexEncodedBytes.length % 2 !== 0) {\n      throw new Error(\"Can't create a byte array from a hex string of odd length\");\n    }\n    const uint8Array2 = new Uint8Array(hexEncodedBytes.length / 2);\n    for (let i = 0; i < uint8Array2.length; i++) {\n      uint8Array2[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\n    }\n    return this.toArrayBuffer(uint8Array2);\n  }\n  utf8Encode(string) {\n    if (Platform.Config.TextEncoder) {\n      const encodedByteArray = new Platform.Config.TextEncoder().encode(string);\n      return this.toArrayBuffer(encodedByteArray);\n    } else {\n      throw new Error(\"Expected TextEncoder to be configured\");\n    }\n  }\n  /* For utf8 decoding we apply slightly stricter input validation than to\n   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\n   * can take (in particular allowing strings, which are just interpreted as\n   * binary); here we ensure that the input is actually a buffer since trying\n   * to utf8-decode a string to another string is almost certainly a mistake */\n  utf8Decode(buffer) {\n    if (!this.isBuffer(buffer)) {\n      throw new Error(\"Expected input of utf8decode to be an arraybuffer or typed array\");\n    }\n    if (TextDecoder) {\n      return new TextDecoder().decode(buffer);\n    } else {\n      throw new Error(\"Expected TextDecoder to be configured\");\n    }\n  }\n  areBuffersEqual(buffer1, buffer2) {\n    if (!buffer1 || !buffer2)\n      return false;\n    const arrayBuffer1 = this.toArrayBuffer(buffer1);\n    const arrayBuffer2 = this.toArrayBuffer(buffer2);\n    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength)\n      return false;\n    const bytes1 = new Uint8Array(arrayBuffer1);\n    const bytes2 = new Uint8Array(arrayBuffer2);\n    for (var i = 0; i < bytes1.length; i++) {\n      if (bytes1[i] != bytes2[i])\n        return false;\n    }\n    return true;\n  }\n  byteLength(buffer) {\n    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\n      return buffer.byteLength;\n    }\n    return -1;\n  }\n  arrayBufferViewToBuffer(arrayBufferView) {\n    return this.toArrayBuffer(arrayBufferView);\n  }\n  hmacSha256(message, key) {\n    const hash = hmac2(this.toBuffer(key), this.toBuffer(message));\n    return this.toArrayBuffer(hash);\n  }\n};\nvar bufferutils_default = new BufferUtils();\n\n// src/platform/web/lib/util/crypto.ts\nvar createCryptoClass = function(config, bufferUtils) {\n  var DEFAULT_ALGORITHM = \"aes\";\n  var DEFAULT_KEYLENGTH = 256;\n  var DEFAULT_MODE = \"cbc\";\n  var DEFAULT_BLOCKLENGTH = 16;\n  function validateCipherParams(params) {\n    if (params.algorithm === \"aes\" && params.mode === \"cbc\") {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        \"Unsupported key length \" + params.keyLength + \" for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)\"\n      );\n    }\n  }\n  function normaliseBase64(string) {\n    return string.replace(\"_\", \"/\").replace(\"-\", \"+\");\n  }\n  function isCipherParams(params) {\n    return params instanceof CipherParams;\n  }\n  class CipherParams {\n    constructor(algorithm, keyLength, mode, key) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n    }\n  }\n  class Crypto2 {\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params) {\n      var key;\n      if (!params.key) {\n        throw new Error(\"Crypto.getDefaultParams: a key is required\");\n      }\n      if (typeof params.key === \"string\") {\n        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = params.key;\n      } else {\n        key = bufferUtils.toArrayBuffer(params.key);\n      }\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.byteLength * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          \"Crypto.getDefaultParams: a keyLength of \" + params.keyLength + \" was specified, but the key actually has length \" + cipherParams.keyLength\n        );\n      }\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as an ArrayBuffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength) {\n      try {\n        return config.getRandomArrayBuffer((keyLength || DEFAULT_KEYLENGTH) / 8);\n      } catch (err) {\n        throw new ErrorInfo(\"Failed to generate random key: \" + err.message, 400, 5e4, err);\n      }\n    }\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params, logger) {\n      var _a2;\n      var cipherParams = isCipherParams(params) ? params : this.getDefaultParams(params);\n      return {\n        cipherParams,\n        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null, logger)\n      };\n    }\n  }\n  Crypto2.CipherParams = CipherParams;\n  Crypto2;\n  class CBCCipher {\n    constructor(params, iv, logger) {\n      this.logger = logger;\n      if (!crypto.subtle) {\n        if (isSecureContext) {\n          throw new Error(\n            \"Crypto operations are not possible since the browser\\u2019s SubtleCrypto class is unavailable (reason unknown).\"\n          );\n        } else {\n          throw new Error(\n            \"Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\\u2019s SubtleCrypto class is not available.\"\n          );\n        }\n      }\n      this.algorithm = params.algorithm + \"-\" + String(params.keyLength) + \"-\" + params.mode;\n      this.webCryptoAlgorithm = params.algorithm + \"-\" + params.mode;\n      this.key = bufferUtils.toArrayBuffer(params.key);\n      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\n    }\n    concat(buffer1, buffer2) {\n      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\n      const outputView = new DataView(output);\n      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\n      for (let i = 0; i < buffer1View.byteLength; i++) {\n        outputView.setInt8(i, buffer1View.getInt8(i));\n      }\n      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\n      for (let i = 0; i < buffer2View.byteLength; i++) {\n        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\n      }\n      return output;\n    }\n    async encrypt(plaintext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.encrypt()\", \"\");\n      const iv = await this.getIv();\n      const cryptoKey = await crypto.subtle.importKey(\"raw\", this.key, this.webCryptoAlgorithm, false, [\"encrypt\"]);\n      const ciphertext = await crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);\n      return this.concat(iv, ciphertext);\n    }\n    async decrypt(ciphertext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.decrypt()\", \"\");\n      const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\n      const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\n      const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\n      const cryptoKey = await crypto.subtle.importKey(\"raw\", this.key, this.webCryptoAlgorithm, false, [\"decrypt\"]);\n      return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);\n    }\n    async getIv() {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        return iv;\n      }\n      const randomBlock = await config.getRandomArrayBuffer(DEFAULT_BLOCKLENGTH);\n      return bufferUtils.toArrayBuffer(randomBlock);\n    }\n  }\n  return Crypto2;\n};\n\n// src/common/constants/XHRStates.ts\nvar XHRStates = /* @__PURE__ */ ((XHRStates2) => {\n  XHRStates2[XHRStates2[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n  XHRStates2[XHRStates2[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n  XHRStates2[XHRStates2[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n  XHRStates2[XHRStates2[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n  return XHRStates2;\n})(XHRStates || {});\nvar XHRStates_default = XHRStates;\n\n// src/platform/web/lib/http/http.ts\nfunction createMissingImplementationError() {\n  return new ErrorInfo(\n    \"No HTTP request plugin provided. Provide at least one of the FetchRequest or XHRRequest plugins.\",\n    400,\n    4e4\n  );\n}\nvar _a;\nvar Http2 = (_a = class {\n  constructor(client) {\n    this.checksInProgress = null;\n    this.checkConnectivity = void 0;\n    this.supportsAuthHeaders = false;\n    this.supportsLinkHeaders = false;\n    var _a2;\n    this.client = client != null ? client : null;\n    const connectivityCheckUrl = (client == null ? void 0 : client.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;\n    const connectivityCheckParams = (_a2 = client == null ? void 0 : client.options.connectivityCheckParams) != null ? _a2 : null;\n    const connectivityUrlIsDefault = !(client == null ? void 0 : client.options.connectivityCheckUrl);\n    const requestImplementations = __spreadValues(__spreadValues({}, Http2.bundledRequestImplementations), client == null ? void 0 : client._additionalHTTPRequestImplementations);\n    const xhrRequestImplementation = requestImplementations.XHRRequest;\n    const fetchRequestImplementation = requestImplementations.FetchRequest;\n    const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);\n    if (!hasImplementation) {\n      throw createMissingImplementationError();\n    }\n    if (Platform.Config.xhrSupported && xhrRequestImplementation) {\n      this.supportsAuthHeaders = true;\n      this.Request = async function(method, uri, headers, params, body) {\n        return new Promise((resolve) => {\n          var _a3;\n          const req = xhrRequestImplementation.createRequest(\n            uri,\n            headers,\n            params,\n            body,\n            XHRStates_default.REQ_SEND,\n            (_a3 = client && client.options.timeouts) != null ? _a3 : null,\n            this.logger,\n            method\n          );\n          req.once(\n            \"complete\",\n            (error, body2, headers2, unpacked, statusCode) => resolve({ error, body: body2, headers: headers2, unpacked, statusCode })\n          );\n          req.exec();\n        });\n      };\n      if (client == null ? void 0 : client.options.disableConnectivityCheck) {\n        this.checkConnectivity = async function() {\n          return true;\n        };\n      } else {\n        this.checkConnectivity = async function() {\n          var _a3;\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MICRO,\n            \"(XHRRequest)Http.checkConnectivity()\",\n            \"Sending; \" + connectivityCheckUrl\n          );\n          const requestResult = await this.doUri(\n            HttpMethods_default.Get,\n            connectivityCheckUrl,\n            null,\n            null,\n            connectivityCheckParams\n          );\n          let result = false;\n          if (!connectivityUrlIsDefault) {\n            result = !requestResult.error && isSuccessCode(requestResult.statusCode);\n          } else {\n            result = !requestResult.error && ((_a3 = requestResult.body) == null ? void 0 : _a3.replace(/\\n/, \"\")) == \"yes\";\n          }\n          logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"(XHRRequest)Http.checkConnectivity()\", \"Result: \" + result);\n          return result;\n        };\n      }\n    } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {\n      this.supportsAuthHeaders = true;\n      this.Request = async (method, uri, headers, params, body) => {\n        return fetchRequestImplementation(method, client != null ? client : null, uri, headers, params, body);\n      };\n      this.checkConnectivity = async function() {\n        var _a3;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"(Fetch)Http.checkConnectivity()\",\n          \"Sending; \" + connectivityCheckUrl\n        );\n        const requestResult = await this.doUri(HttpMethods_default.Get, connectivityCheckUrl, null, null, null);\n        const result = !requestResult.error && ((_a3 = requestResult.body) == null ? void 0 : _a3.replace(/\\n/, \"\")) == \"yes\";\n        logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"(Fetch)Http.checkConnectivity()\", \"Result: \" + result);\n        return result;\n      };\n    } else {\n      this.Request = async () => {\n        const error = hasImplementation ? new PartialErrorInfo(\"no supported HTTP transports available\", null, 400) : createMissingImplementationError();\n        return { error };\n      };\n    }\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  async doUri(method, uri, headers, body, params) {\n    if (!this.Request) {\n      return { error: new PartialErrorInfo(\"Request invoked before assigned to\", null, 500) };\n    }\n    return this.Request(method, uri, headers, params, body);\n  }\n  shouldFallback(errorInfo) {\n    const statusCode = errorInfo.statusCode;\n    return statusCode === 408 && !errorInfo.code || statusCode === 400 && !errorInfo.code || statusCode >= 500 && statusCode <= 504;\n  }\n}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);\nvar http_default = Http2;\n\n// src/platform/web/lib/util/webstorage.ts\nvar test = \"ablyjs-storage-test\";\nvar globalObject3 = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof window !== \"undefined\" ? window : self;\nvar Webstorage = class {\n  constructor() {\n    try {\n      globalObject3.sessionStorage.setItem(test, test);\n      globalObject3.sessionStorage.removeItem(test);\n      this.sessionSupported = true;\n    } catch (e) {\n      this.sessionSupported = false;\n    }\n    try {\n      globalObject3.localStorage.setItem(test, test);\n      globalObject3.localStorage.removeItem(test);\n      this.localSupported = true;\n    } catch (e) {\n      this.localSupported = false;\n    }\n  }\n  get(name) {\n    return this._get(name, false);\n  }\n  getSession(name) {\n    return this._get(name, true);\n  }\n  remove(name) {\n    return this._remove(name, false);\n  }\n  removeSession(name) {\n    return this._remove(name, true);\n  }\n  set(name, value, ttl) {\n    return this._set(name, value, ttl, false);\n  }\n  setSession(name, value, ttl) {\n    return this._set(name, value, ttl, true);\n  }\n  _set(name, value, ttl, session) {\n    const wrappedValue = { value };\n    if (ttl) {\n      wrappedValue.expires = Date.now() + ttl;\n    }\n    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\n  }\n  _get(name, session) {\n    if (session && !this.sessionSupported)\n      throw new Error(\"Session Storage not supported\");\n    if (!session && !this.localSupported)\n      throw new Error(\"Local Storage not supported\");\n    const rawItem = this.storageInterface(session).getItem(name);\n    if (!rawItem)\n      return null;\n    const wrappedValue = JSON.parse(rawItem);\n    if (wrappedValue.expires && wrappedValue.expires < Date.now()) {\n      this.storageInterface(session).removeItem(name);\n      return null;\n    }\n    return wrappedValue.value;\n  }\n  _remove(name, session) {\n    return this.storageInterface(session).removeItem(name);\n  }\n  storageInterface(session) {\n    return session ? globalObject3.sessionStorage : globalObject3.localStorage;\n  }\n};\nvar webstorage_default = new Webstorage();\n\n// src/platform/web/config.ts\nvar globalObject4 = getGlobalObject();\nvar isVercelEdgeRuntime = typeof EdgeRuntime === \"string\";\nif (typeof Window === \"undefined\" && typeof WorkerGlobalScope === \"undefined\" && !isVercelEdgeRuntime) {\n  console.log(\n    \"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\"\n  );\n}\nfunction allowComet() {\n  const loc = globalObject4.location;\n  return !globalObject4.WebSocket || !loc || !loc.origin || loc.origin.indexOf(\"http\") > -1;\n}\nfunction isWebWorkerContext() {\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n    return true;\n  } else {\n    return false;\n  }\n}\nvar userAgent = globalObject4.navigator && globalObject4.navigator.userAgent.toString();\nvar currentUrl = globalObject4.location && globalObject4.location.href;\nvar Config = {\n  agent: \"browser\",\n  logTimestamps: true,\n  userAgent,\n  currentUrl,\n  binaryType: \"arraybuffer\",\n  WebSocket: globalObject4.WebSocket,\n  fetchSupported: !!globalObject4.fetch,\n  xhrSupported: globalObject4.XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest(),\n  allowComet: allowComet(),\n  useProtocolHeartbeats: true,\n  supportsBinary: !!globalObject4.TextDecoder,\n  /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\n   *\n   * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\n   */\n  preferBinary: false,\n  ArrayBuffer: globalObject4.ArrayBuffer,\n  atob: globalObject4.atob,\n  nextTick: typeof globalObject4.setImmediate !== \"undefined\" ? globalObject4.setImmediate.bind(globalObject4) : function(f) {\n    setTimeout(f, 0);\n  },\n  addEventListener: globalObject4.addEventListener,\n  inspect: JSON.stringify,\n  stringByteSize: function(str) {\n    return globalObject4.TextDecoder && new globalObject4.TextEncoder().encode(str).length || str.length;\n  },\n  TextEncoder: globalObject4.TextEncoder,\n  TextDecoder: globalObject4.TextDecoder,\n  getRandomArrayBuffer: async function(byteLength) {\n    const byteArray = new Uint8Array(byteLength);\n    globalObject4.crypto.getRandomValues(byteArray);\n    return byteArray.buffer;\n  },\n  isWebworker: isWebWorkerContext(),\n  push: {\n    platform: \"browser\" /* Browser */,\n    formFactor: \"desktop\" /* Desktop */,\n    storage: webstorage_default\n  }\n};\nvar config_default = Config;\n\n// src/common/lib/transport/comettransport.ts\nfunction shouldBeErrorAction(err) {\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n  if (err.code) {\n    if (auth_default.isTokenErr(err))\n      return false;\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code))\n      return true;\n    return err.code >= 4e4 && err.code < 5e4;\n  } else {\n    return false;\n  }\n}\nfunction protocolMessageFromRawError(err) {\n  if (shouldBeErrorAction(err)) {\n    return [fromValues3({ action: actions2.ERROR, error: err })];\n  } else {\n    return [fromValues3({ action: actions2.DISCONNECTED, error: err })];\n  }\n}\nvar CometTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(\n      connectionManager,\n      auth,\n      params,\n      /* binary not supported for comet so force JSON protocol */\n      true\n    );\n    /* Historical comment, back from when we supported JSONP:\n     *\n     * > For comet, we could do the auth update by aborting the current recv and\n     * > starting a new one with the new token, that'd be sufficient for realtime.\n     * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n     * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n     * > comet transports the same and do it for all of them. So we send the AUTH\n     * > instead, and don't need to abort the recv\n     *\n     * Now that weâ€™ve dropped JSONP support, we may be able to revisit the above;\n     * see https://github.com/ably/ably-js/issues/1214.\n     */\n    this.onAuthUpdated = (tokenDetails) => {\n      this.authParams = { access_token: tokenDetails.token };\n    };\n    this.stream = \"stream\" in params ? params.stream : true;\n    this.sendRequest = null;\n    this.recvRequest = null;\n    this.pendingCallback = null;\n    this.pendingItems = null;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const params = this.params;\n    const options = params.options;\n    const host = defaults_default.getHost(options, params.host);\n    const port = defaults_default.getPort(options);\n    const cometScheme = options.tls ? \"https://\" : \"http://\";\n    this.baseUri = cometScheme + host + \":\" + port + \"/comet/\";\n    const connectUri = this.baseUri + \"connect\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"uri: \" + connectUri);\n    whenPromiseSettles(this.auth.getAuthParams(), (err, authParams) => {\n      if (err) {\n        this.disconnect(err);\n        return;\n      }\n      if (this.isDisposed) {\n        return;\n      }\n      this.authParams = authParams;\n      const connectParams = this.params.getConnectParams(authParams);\n      if (\"stream\" in connectParams)\n        this.stream = connectParams.stream;\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"CometTransport.connect()\",\n        \"connectParams:\" + toQueryString(connectParams)\n      );\n      let preconnected = false;\n      const connectRequest = this.recvRequest = this.createRequest(\n        connectUri,\n        null,\n        connectParams,\n        null,\n        this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV\n      );\n      connectRequest.on(\"data\", (data) => {\n        if (!this.recvRequest) {\n          return;\n        }\n        if (!preconnected) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onData(data);\n      });\n      connectRequest.on(\"complete\", (err2) => {\n        if (!this.recvRequest) {\n          err2 = err2 || new ErrorInfo(\"Request cancelled\", 80003, 400);\n        }\n        this.recvRequest = null;\n        if (!preconnected && !err2) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onActivity();\n        if (err2) {\n          if (err2.code) {\n            this.onData(protocolMessageFromRawError(err2));\n          } else {\n            this.disconnect(err2);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      connectRequest.exec();\n    });\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestClose()\");\n    this._requestCloseOrDisconnect(true);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestDisconnect()\");\n    this._requestCloseOrDisconnect(false);\n  }\n  _requestCloseOrDisconnect(closing) {\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n    if (closeOrDisconnectUri) {\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);\n      request.on(\"complete\", (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"CometTransport.request\" + (closing ? \"Close()\" : \"Disconnect()\"),\n            \"request returned err = \" + inspectError(err)\n          );\n          this.finish(\"disconnected\", err);\n        }\n      });\n      request.exec();\n    }\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"\");\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      if (this.recvRequest) {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"aborting recv request\");\n        this.recvRequest.abort();\n        this.recvRequest = null;\n      }\n      this.finish(\"disconnected\", connectionerrors_default.disconnected());\n      Platform.Config.nextTick(() => {\n        this.emit(\"disposed\");\n      });\n    }\n  }\n  onConnect(message) {\n    var _a2;\n    if (this.isDisposed) {\n      return;\n    }\n    const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;\n    transport_default.prototype.onConnect.call(this, message);\n    const baseConnectionUri = this.baseUri + connectionStr;\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CometTransport.onConnect()\", \"baseUri = \" + baseConnectionUri);\n    this.sendUri = baseConnectionUri + \"/send\";\n    this.recvUri = baseConnectionUri + \"/recv\";\n    this.closeUri = baseConnectionUri + \"/close\";\n    this.disconnectUri = baseConnectionUri + \"/disconnect\";\n  }\n  send(message) {\n    if (this.sendRequest) {\n      this.pendingItems = this.pendingItems || [];\n      this.pendingItems.push(message);\n      return;\n    }\n    const pendingItems = this.pendingItems || [];\n    pendingItems.push(message);\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendAnyPending() {\n    const pendingItems = this.pendingItems;\n    if (!pendingItems) {\n      return;\n    }\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendItems(items) {\n    const sendRequest = this.sendRequest = this.createRequest(\n      this.sendUri,\n      null,\n      this.authParams,\n      this.encodeRequest(items),\n      XHRStates_default.REQ_SEND\n    );\n    sendRequest.on(\"complete\", (err, data) => {\n      if (err)\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"CometTransport.sendItems()\",\n          \"on complete: err = \" + inspectError(err)\n        );\n      this.sendRequest = null;\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      if (data) {\n        this.onData(data);\n      }\n      if (this.pendingItems) {\n        Platform.Config.nextTick(() => {\n          if (!this.sendRequest) {\n            this.sendAnyPending();\n          }\n        });\n      }\n    });\n    sendRequest.exec();\n  }\n  recv() {\n    if (this.recvRequest)\n      return;\n    if (!this.isConnected)\n      return;\n    const recvRequest = this.recvRequest = this.createRequest(\n      this.recvUri,\n      null,\n      this.authParams,\n      null,\n      this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL\n    );\n    recvRequest.on(\"data\", (data) => {\n      this.onData(data);\n    });\n    recvRequest.on(\"complete\", (err) => {\n      this.recvRequest = null;\n      this.onActivity();\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      Platform.Config.nextTick(() => {\n        this.recv();\n      });\n    });\n    recvRequest.exec();\n  }\n  onData(responseData) {\n    try {\n      const items = this.decodeResponse(responseData);\n      if (items && items.length)\n        for (let i = 0; i < items.length; i++)\n          this.onProtocolMessage(\n            fromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence)\n          );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"CometTransport.onData()\",\n        \"Unexpected exception handing channel event: \" + e.stack\n      );\n    }\n  }\n  encodeRequest(requestItems) {\n    return JSON.stringify(requestItems);\n  }\n  decodeResponse(responseData) {\n    if (typeof responseData == \"string\")\n      return JSON.parse(responseData);\n    return responseData;\n  }\n};\nvar comettransport_default = CometTransport;\n\n// src/platform/web/lib/http/request/xhrrequest.ts\nfunction isAblyError(responseBody, headers) {\n  return allToLowerCase(keysArray(headers)).includes(\"x-ably-errorcode\");\n}\nfunction getAblyError(responseBody, headers) {\n  if (isAblyError(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\nvar noop3 = function() {\n};\nvar idCounter = 0;\nvar pendingRequests = {};\nfunction getHeader(xhr, header) {\n  return xhr.getResponseHeader && xhr.getResponseHeader(header);\n}\nfunction isEncodingChunked(xhr) {\n  return xhr.getResponseHeader && (xhr.getResponseHeader(\"transfer-encoding\") || !xhr.getResponseHeader(\"content-length\"));\n}\nfunction getHeadersAsObject(xhr) {\n  const headerPairs = xhr.getAllResponseHeaders().trim().split(\"\\r\\n\");\n  const headers = {};\n  for (let i = 0; i < headerPairs.length; i++) {\n    const parts = headerPairs[i].split(\":\").map((x) => x.trim());\n    headers[parts[0].toLowerCase()] = parts[1];\n  }\n  return headers;\n}\nvar XHRRequest = class _XHRRequest extends eventemitter_default {\n  constructor(uri, headers, params, body, requestMode, timeouts, logger, method) {\n    super(logger);\n    params = params || {};\n    params.rnd = cheapRandStr();\n    this.uri = uri + toQueryString(params);\n    this.headers = headers || {};\n    this.body = body;\n    this.method = method ? method.toUpperCase() : isNil(body) ? \"GET\" : \"POST\";\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.timedOut = false;\n    this.requestComplete = false;\n    this.id = String(++idCounter);\n    pendingRequests[this.id] = this;\n  }\n  static createRequest(uri, headers, params, body, requestMode, timeouts, logger, method) {\n    const _timeouts = timeouts || defaults_default.TIMEOUTS;\n    return new _XHRRequest(\n      uri,\n      headers,\n      copy(params),\n      body,\n      requestMode,\n      _timeouts,\n      logger,\n      method\n    );\n  }\n  complete(err, body, headers, unpacked, statusCode) {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (!err && body) {\n        this.emit(\"data\", body);\n      }\n      this.emit(\"complete\", err, body, headers, unpacked, statusCode);\n      this.dispose();\n    }\n  }\n  abort() {\n    this.dispose();\n  }\n  exec() {\n    let headers = this.headers;\n    const timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = this.timer = setTimeout(() => {\n      this.timedOut = true;\n      xhr.abort();\n    }, timeout), method = this.method, xhr = this.xhr = new XMLHttpRequest(), accept = headers[\"accept\"];\n    let body = this.body;\n    let responseType = \"text\";\n    if (!accept) {\n      headers[\"accept\"] = \"application/json\";\n    } else if (accept.indexOf(\"application/x-msgpack\") === 0) {\n      responseType = \"arraybuffer\";\n    }\n    if (body) {\n      const contentType = headers[\"content-type\"] || (headers[\"content-type\"] = \"application/json\");\n      if (contentType.indexOf(\"application/json\") > -1 && typeof body != \"string\")\n        body = JSON.stringify(body);\n    }\n    xhr.open(method, this.uri, true);\n    xhr.responseType = responseType;\n    if (\"authorization\" in headers) {\n      xhr.withCredentials = true;\n    }\n    for (const h in headers)\n      xhr.setRequestHeader(h, headers[h]);\n    const errorHandler = (errorEvent, message, code, statusCode2) => {\n      var _a2;\n      let errorMessage = message + \" (event type: \" + errorEvent.type + \")\";\n      if ((_a2 = this == null ? void 0 : this.xhr) == null ? void 0 : _a2.statusText)\n        errorMessage += \", current statusText is \" + this.xhr.statusText;\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Request.on\" + errorEvent.type + \"()\", errorMessage);\n      this.complete(new PartialErrorInfo(errorMessage, code, statusCode2));\n    };\n    xhr.onerror = function(errorEvent) {\n      errorHandler(errorEvent, \"XHR error occurred\", null, 400);\n    };\n    xhr.onabort = (errorEvent) => {\n      if (this.timedOut) {\n        errorHandler(errorEvent, \"Request aborted due to request timeout expiring\", null, 408);\n      } else {\n        errorHandler(errorEvent, \"Request cancelled\", null, 400);\n      }\n    };\n    xhr.ontimeout = function(errorEvent) {\n      errorHandler(errorEvent, \"Request timed out\", null, 408);\n    };\n    let streaming;\n    let statusCode;\n    let successResponse;\n    let streamPos = 0;\n    let unpacked = false;\n    const onResponse = () => {\n      clearTimeout(timer);\n      successResponse = statusCode < 400;\n      if (statusCode == 204) {\n        this.complete(null, null, null, null, statusCode);\n        return;\n      }\n      streaming = this.requestMode == XHRStates_default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\n    };\n    const onEnd = () => {\n      let parsedResponse;\n      try {\n        const contentType = getHeader(xhr, \"content-type\");\n        const json = contentType ? contentType.indexOf(\"application/json\") >= 0 : xhr.responseType == \"text\";\n        if (json) {\n          const jsonResponseBody = xhr.responseType === \"arraybuffer\" ? Platform.BufferUtils.utf8Decode(xhr.response) : String(xhr.responseText);\n          if (jsonResponseBody.length) {\n            parsedResponse = JSON.parse(jsonResponseBody);\n          } else {\n            parsedResponse = jsonResponseBody;\n          }\n          unpacked = true;\n        } else {\n          parsedResponse = xhr.response;\n        }\n        if (parsedResponse.response !== void 0) {\n          statusCode = parsedResponse.statusCode;\n          successResponse = statusCode < 400;\n          headers = parsedResponse.headers;\n          parsedResponse = parsedResponse.response;\n        } else {\n          headers = getHeadersAsObject(xhr);\n        }\n      } catch (e) {\n        this.complete(new PartialErrorInfo(\"Malformed response body from server: \" + e.message, null, 400));\n        return;\n      }\n      if (successResponse || Array.isArray(parsedResponse)) {\n        this.complete(null, parsedResponse, headers, unpacked, statusCode);\n        return;\n      }\n      let err = getAblyError(parsedResponse, headers);\n      if (!err) {\n        err = new PartialErrorInfo(\n          \"Error response received from server: \" + statusCode + \" body was: \" + Platform.Config.inspect(parsedResponse),\n          null,\n          statusCode\n        );\n      }\n      this.complete(err, parsedResponse, headers, unpacked, statusCode);\n    };\n    function onProgress() {\n      const responseText = xhr.responseText;\n      const bodyEnd = responseText.length - 1;\n      let idx, chunk;\n      while (streamPos < bodyEnd && (idx = responseText.indexOf(\"\\n\", streamPos)) > -1) {\n        chunk = responseText.slice(streamPos, idx);\n        streamPos = idx + 1;\n        onChunk(chunk);\n      }\n    }\n    const onChunk = (chunk) => {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        this.complete(new PartialErrorInfo(\"Malformed response body from server: \" + e.message, null, 400));\n        return;\n      }\n      this.emit(\"data\", chunk);\n    };\n    const onStreamEnd = () => {\n      onProgress();\n      this.streamComplete = true;\n      Platform.Config.nextTick(() => {\n        this.complete();\n      });\n    };\n    xhr.onreadystatechange = function() {\n      const readyState = xhr.readyState;\n      if (readyState < 3)\n        return;\n      if (xhr.status !== 0) {\n        if (statusCode === void 0) {\n          statusCode = xhr.status;\n          onResponse();\n        }\n        if (readyState == 3 && streaming) {\n          onProgress();\n        } else if (readyState == 4) {\n          if (streaming)\n            onStreamEnd();\n          else\n            onEnd();\n        }\n      }\n    };\n    xhr.send(body);\n  }\n  dispose() {\n    const xhr = this.xhr;\n    if (xhr) {\n      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop3;\n      this.xhr = null;\n      const timer = this.timer;\n      if (timer) {\n        clearTimeout(timer);\n        this.timer = null;\n      }\n      if (!this.requestComplete)\n        xhr.abort();\n    }\n    delete pendingRequests[this.id];\n  }\n};\nvar xhrrequest_default = XHRRequest;\n\n// src/platform/web/lib/transport/xhrpollingtransport.ts\nvar shortName2 = TransportNames.XhrPolling;\nvar XHRPollingTransport = class extends comettransport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName2;\n    params.stream = false;\n    this.shortName = shortName2;\n  }\n  static isAvailable() {\n    return !!(Platform.Config.xhrSupported && Platform.Config.allowComet);\n  }\n  toString() {\n    return \"XHRPollingTransport; uri=\" + this.baseUri + \"; isConnected=\" + this.isConnected;\n  }\n  createRequest(uri, headers, params, body, requestMode) {\n    return xhrrequest_default.createRequest(uri, headers, params, body, requestMode, this.timeouts, this.logger);\n  }\n};\nvar xhrpollingtransport_default = XHRPollingTransport;\n\n// src/platform/web/lib/transport/index.ts\nvar order = [\"xhr_polling\"];\nvar defaultTransports = {\n  order,\n  bundledImplementations: {\n    web_socket: websockettransport_default,\n    xhr_polling: xhrpollingtransport_default\n  }\n};\nvar transport_default2 = defaultTransports;\n\n// src/platform/web/lib/util/defaults.ts\nvar Defaults2 = {\n  connectivityCheckUrl: \"https://internet-up.ably-realtime.com/is-the-internet-up.txt\",\n  wsConnectivityUrl: \"wss://ws-up.ably-realtime.com\",\n  /* Order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's\n   * supported. */\n  defaultTransports: [TransportNames.XhrPolling, TransportNames.WebSocket]\n};\nvar defaults_default2 = Defaults2;\n\n// src/platform/web/lib/util/msgpack.ts\nfunction inspect(buffer) {\n  if (buffer === void 0)\n    return \"undefined\";\n  let view;\n  let type;\n  if (buffer instanceof ArrayBuffer) {\n    type = \"ArrayBuffer\";\n    view = new DataView(buffer);\n  } else if (buffer instanceof DataView) {\n    type = \"DataView\";\n    view = buffer;\n  }\n  if (!view)\n    return JSON.stringify(buffer);\n  const bytes = [];\n  for (let i = 0; i < buffer.byteLength; i++) {\n    if (i > 20) {\n      bytes.push(\"...\");\n      break;\n    }\n    let byte_ = view.getUint8(i).toString(16);\n    if (byte_.length === 1)\n      byte_ = \"0\" + byte_;\n    bytes.push(byte_);\n  }\n  return \"<\" + type + \" \" + bytes.join(\" \") + \">\";\n}\nfunction utf8Write(view, offset, string) {\n  for (let i = 0, l = string.length; i < l; i++) {\n    const codePoint = string.charCodeAt(i);\n    if (codePoint < 128) {\n      view.setUint8(offset++, codePoint >>> 0 & 127 | 0);\n      continue;\n    }\n    if (codePoint < 2048) {\n      view.setUint8(offset++, codePoint >>> 6 & 31 | 192);\n      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n      continue;\n    }\n    if (codePoint < 65536) {\n      view.setUint8(offset++, codePoint >>> 12 & 15 | 224);\n      view.setUint8(offset++, codePoint >>> 6 & 63 | 128);\n      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n      continue;\n    }\n    if (codePoint < 1114112) {\n      view.setUint8(offset++, codePoint >>> 18 & 7 | 240);\n      view.setUint8(offset++, codePoint >>> 12 & 63 | 128);\n      view.setUint8(offset++, codePoint >>> 6 & 63 | 128);\n      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n      continue;\n    }\n    throw new Error(\"bad codepoint \" + codePoint);\n  }\n}\nfunction utf8Read(view, offset, length) {\n  let string = \"\";\n  for (let i = offset, end = offset + length; i < end; i++) {\n    const byte_ = view.getUint8(i);\n    if ((byte_ & 128) === 0) {\n      string += String.fromCharCode(byte_);\n      continue;\n    }\n    if ((byte_ & 224) === 192) {\n      string += String.fromCharCode((byte_ & 15) << 6 | view.getUint8(++i) & 63);\n      continue;\n    }\n    if ((byte_ & 240) === 224) {\n      string += String.fromCharCode(\n        (byte_ & 15) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0\n      );\n      continue;\n    }\n    if ((byte_ & 248) === 240) {\n      string += String.fromCharCode(\n        (byte_ & 7) << 18 | (view.getUint8(++i) & 63) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0\n      );\n      continue;\n    }\n    throw new Error(\"Invalid byte \" + byte_.toString(16));\n  }\n  return string;\n}\nfunction utf8ByteCount(string) {\n  let count = 0;\n  for (let i = 0, l = string.length; i < l; i++) {\n    const codePoint = string.charCodeAt(i);\n    if (codePoint < 128) {\n      count += 1;\n      continue;\n    }\n    if (codePoint < 2048) {\n      count += 2;\n      continue;\n    }\n    if (codePoint < 65536) {\n      count += 3;\n      continue;\n    }\n    if (codePoint < 1114112) {\n      count += 4;\n      continue;\n    }\n    throw new Error(\"bad codepoint \" + codePoint);\n  }\n  return count;\n}\nfunction encode2(value, sparse) {\n  const size = sizeof(value, sparse);\n  if (size === 0)\n    return void 0;\n  const buffer = new ArrayBuffer(size);\n  const view = new DataView(buffer);\n  _encode(value, view, 0, sparse);\n  return buffer;\n}\nvar SH_L_32 = (1 << 16) * (1 << 16);\nvar SH_R_32 = 1 / SH_L_32;\nfunction getInt64(view, offset) {\n  offset = offset || 0;\n  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\nfunction getUint64(view, offset) {\n  offset = offset || 0;\n  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\nfunction setInt64(view, offset, val) {\n  if (val < 9223372036854776e3) {\n    view.setInt32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 2147483647);\n    view.setUint32(offset + 4, 2147483647);\n  }\n}\nfunction setUint64(view, offset, val) {\n  if (val < 18446744073709552e3) {\n    view.setUint32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 4294967295);\n    view.setUint32(offset + 4, 4294967295);\n  }\n}\nvar Decoder = class {\n  constructor(view, offset) {\n    this.map = (length) => {\n      const value = {};\n      for (let i = 0; i < length; i++) {\n        const key = this.parse();\n        value[key] = this.parse();\n      }\n      return value;\n    };\n    this.bin = (length) => {\n      const value = new ArrayBuffer(length);\n      new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\n      this.offset += length;\n      return value;\n    };\n    this.buf = this.bin;\n    this.str = (length) => {\n      const value = utf8Read(this.view, this.offset, length);\n      this.offset += length;\n      return value;\n    };\n    this.array = (length) => {\n      const value = new Array(length);\n      for (let i = 0; i < length; i++) {\n        value[i] = this.parse();\n      }\n      return value;\n    };\n    this.ext = (length) => {\n      this.offset += length;\n      return {\n        type: this.view.getInt8(this.offset),\n        data: this.buf(length)\n      };\n    };\n    this.parse = () => {\n      const type = this.view.getUint8(this.offset);\n      let value, length;\n      if ((type & 128) === 0) {\n        this.offset++;\n        return type;\n      }\n      if ((type & 240) === 128) {\n        length = type & 15;\n        this.offset++;\n        return this.map(length);\n      }\n      if ((type & 240) === 144) {\n        length = type & 15;\n        this.offset++;\n        return this.array(length);\n      }\n      if ((type & 224) === 160) {\n        length = type & 31;\n        this.offset++;\n        return this.str(length);\n      }\n      if ((type & 224) === 224) {\n        value = this.view.getInt8(this.offset);\n        this.offset++;\n        return value;\n      }\n      switch (type) {\n        case 192:\n          this.offset++;\n          return null;\n        case 193:\n          this.offset++;\n          return void 0;\n        case 194:\n          this.offset++;\n          return false;\n        case 195:\n          this.offset++;\n          return true;\n        case 196:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.bin(length);\n        case 197:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.bin(length);\n        case 198:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.bin(length);\n        case 199:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.ext(length);\n        case 200:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.ext(length);\n        case 201:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.ext(length);\n        case 202:\n          value = this.view.getFloat32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 203:\n          value = this.view.getFloat64(this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 204:\n          value = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 205:\n          value = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 206:\n          value = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 207:\n          value = getUint64(this.view, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 208:\n          value = this.view.getInt8(this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 209:\n          value = this.view.getInt16(this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 210:\n          value = this.view.getInt32(this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 211:\n          value = getInt64(this.view, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 212:\n          length = 1;\n          this.offset++;\n          return this.ext(length);\n        case 213:\n          length = 2;\n          this.offset++;\n          return this.ext(length);\n        case 214:\n          length = 4;\n          this.offset++;\n          return this.ext(length);\n        case 215:\n          length = 8;\n          this.offset++;\n          return this.ext(length);\n        case 216:\n          length = 16;\n          this.offset++;\n          return this.ext(length);\n        case 217:\n          length = this.view.getUint8(this.offset + 1);\n          this.offset += 2;\n          return this.str(length);\n        case 218:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.str(length);\n        case 219:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.str(length);\n        case 220:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.array(length);\n        case 221:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.array(length);\n        case 222:\n          length = this.view.getUint16(this.offset + 1);\n          this.offset += 3;\n          return this.map(length);\n        case 223:\n          length = this.view.getUint32(this.offset + 1);\n          this.offset += 5;\n          return this.map(length);\n      }\n      throw new Error(\"Unknown type 0x\" + type.toString(16));\n    };\n    this.offset = offset || 0;\n    this.view = view;\n  }\n};\nfunction decode3(buffer) {\n  const view = new DataView(buffer);\n  const decoder = new Decoder(view);\n  const value = decoder.parse();\n  if (decoder.offset !== buffer.byteLength)\n    throw new Error(buffer.byteLength - decoder.offset + \" trailing bytes\");\n  return value;\n}\nfunction encodeableKeys(value, sparse) {\n  return Object.keys(value).filter(function(e) {\n    const val = value[e], type = typeof val;\n    return (!sparse || val !== void 0 && val !== null) && (\"function\" !== type || !!val.toJSON);\n  });\n}\nfunction _encode(value, view, offset, sparse) {\n  const type = typeof value;\n  if (typeof value === \"string\") {\n    const length = utf8ByteCount(value);\n    if (length < 32) {\n      view.setUint8(offset, length | 160);\n      utf8Write(view, offset + 1, value);\n      return 1 + length;\n    }\n    if (length < 256) {\n      view.setUint8(offset, 217);\n      view.setUint8(offset + 1, length);\n      utf8Write(view, offset + 2, value);\n      return 2 + length;\n    }\n    if (length < 65536) {\n      view.setUint8(offset, 218);\n      view.setUint16(offset + 1, length);\n      utf8Write(view, offset + 3, value);\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      view.setUint8(offset, 219);\n      view.setUint32(offset + 1, length);\n      utf8Write(view, offset + 5, value);\n      return 5 + length;\n    }\n  }\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    value = value.buffer;\n  }\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n    if (length < 256) {\n      view.setUint8(offset, 196);\n      view.setUint8(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\n      return 2 + length;\n    }\n    if (length < 65536) {\n      view.setUint8(offset, 197);\n      view.setUint16(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      view.setUint8(offset, 198);\n      view.setUint32(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\n      return 5 + length;\n    }\n  }\n  if (typeof value === \"number\") {\n    if (Math.floor(value) !== value) {\n      view.setUint8(offset, 203);\n      view.setFloat64(offset + 1, value);\n      return 9;\n    }\n    if (value >= 0) {\n      if (value < 128) {\n        view.setUint8(offset, value);\n        return 1;\n      }\n      if (value < 256) {\n        view.setUint8(offset, 204);\n        view.setUint8(offset + 1, value);\n        return 2;\n      }\n      if (value < 65536) {\n        view.setUint8(offset, 205);\n        view.setUint16(offset + 1, value);\n        return 3;\n      }\n      if (value < 4294967296) {\n        view.setUint8(offset, 206);\n        view.setUint32(offset + 1, value);\n        return 5;\n      }\n      if (value < 18446744073709552e3) {\n        view.setUint8(offset, 207);\n        setUint64(view, offset + 1, value);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    if (value >= -32) {\n      view.setInt8(offset, value);\n      return 1;\n    }\n    if (value >= -128) {\n      view.setUint8(offset, 208);\n      view.setInt8(offset + 1, value);\n      return 2;\n    }\n    if (value >= -32768) {\n      view.setUint8(offset, 209);\n      view.setInt16(offset + 1, value);\n      return 3;\n    }\n    if (value >= -2147483648) {\n      view.setUint8(offset, 210);\n      view.setInt32(offset + 1, value);\n      return 5;\n    }\n    if (value >= -9223372036854776e3) {\n      view.setUint8(offset, 211);\n      setInt64(view, offset + 1, value);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + (-value).toString(16).substr(1));\n  }\n  if (type === \"undefined\") {\n    if (sparse)\n      return 0;\n    view.setUint8(offset, 212);\n    view.setUint8(offset + 1, 0);\n    view.setUint8(offset + 2, 0);\n    return 3;\n  }\n  if (value === null) {\n    if (sparse)\n      return 0;\n    view.setUint8(offset, 192);\n    return 1;\n  }\n  if (type === \"boolean\") {\n    view.setUint8(offset, value ? 195 : 194);\n    return 1;\n  }\n  if (\"function\" === typeof value.toJSON)\n    return _encode(value.toJSON(), view, offset, sparse);\n  if (type === \"object\") {\n    let length, size = 0;\n    let keys;\n    const isArray = Array.isArray(value);\n    if (isArray) {\n      length = value.length;\n    } else {\n      keys = encodeableKeys(value, sparse);\n      length = keys.length;\n    }\n    if (length < 16) {\n      view.setUint8(offset, length | (isArray ? 144 : 128));\n      size = 1;\n    } else if (length < 65536) {\n      view.setUint8(offset, isArray ? 220 : 222);\n      view.setUint16(offset + 1, length);\n      size = 3;\n    } else if (length < 4294967296) {\n      view.setUint8(offset, isArray ? 221 : 223);\n      view.setUint32(offset + 1, length);\n      size = 5;\n    }\n    if (isArray) {\n      for (let i = 0; i < length; i++) {\n        size += _encode(value[i], view, offset + size, sparse);\n      }\n    } else if (keys) {\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += _encode(key, view, offset + size);\n        size += _encode(value[key], view, offset + size, sparse);\n      }\n    }\n    return size;\n  }\n  if (type === \"function\")\n    return 0;\n  throw new Error(\"Unknown type \" + type);\n}\nfunction sizeof(value, sparse) {\n  const type = typeof value;\n  if (type === \"string\") {\n    const length = utf8ByteCount(value);\n    if (length < 32) {\n      return 1 + length;\n    }\n    if (length < 256) {\n      return 2 + length;\n    }\n    if (length < 65536) {\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      return 5 + length;\n    }\n  }\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    value = value.buffer;\n  }\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n    if (length < 256) {\n      return 2 + length;\n    }\n    if (length < 65536) {\n      return 3 + length;\n    }\n    if (length < 4294967296) {\n      return 5 + length;\n    }\n  }\n  if (typeof value === \"number\") {\n    if (Math.floor(value) !== value)\n      return 9;\n    if (value >= 0) {\n      if (value < 128)\n        return 1;\n      if (value < 256)\n        return 2;\n      if (value < 65536)\n        return 3;\n      if (value < 4294967296)\n        return 5;\n      if (value < 18446744073709552e3)\n        return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    if (value >= -32)\n      return 1;\n    if (value >= -128)\n      return 2;\n    if (value >= -32768)\n      return 3;\n    if (value >= -2147483648)\n      return 5;\n    if (value >= -9223372036854776e3)\n      return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  if (type === \"boolean\")\n    return 1;\n  if (value === null)\n    return sparse ? 0 : 1;\n  if (value === void 0)\n    return sparse ? 0 : 3;\n  if (\"function\" === typeof value.toJSON)\n    return sizeof(value.toJSON(), sparse);\n  if (type === \"object\") {\n    let length, size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (let i = 0; i < length; i++) {\n        size += sizeof(value[i], sparse);\n      }\n    } else {\n      const keys = encodeableKeys(value, sparse);\n      length = keys.length;\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += sizeof(key) + sizeof(value[key], sparse);\n      }\n    }\n    if (length < 16) {\n      return 1 + size;\n    }\n    if (length < 65536) {\n      return 3 + size;\n    }\n    if (length < 4294967296) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  if (type === \"function\")\n    return 0;\n  throw new Error(\"Unknown type \" + type);\n}\nvar msgpack_default = {\n  encode: encode2,\n  decode: decode3,\n  inspect,\n  utf8Write,\n  utf8Read,\n  utf8ByteCount\n};\n\n// src/platform/web/lib/http/request/fetchrequest.ts\nfunction isAblyError2(responseBody, headers) {\n  return !!headers.get(\"x-ably-errorcode\");\n}\nfunction getAblyError2(responseBody, headers) {\n  if (isAblyError2(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\nfunction convertHeaders(headers) {\n  const result = {};\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\nasync function fetchRequest(method, client, uri, headers, params, body) {\n  const fetchHeaders = new Headers(headers || {});\n  const _method = method ? method.toUpperCase() : isNil(body) ? \"GET\" : \"POST\";\n  const controller = new AbortController();\n  let timeout;\n  const timeoutPromise = new Promise((resolve) => {\n    timeout = setTimeout(\n      () => {\n        controller.abort();\n        resolve({ error: new PartialErrorInfo(\"Request timed out\", null, 408) });\n      },\n      client ? client.options.timeouts.httpRequestTimeout : defaults_default.TIMEOUTS.httpRequestTimeout\n    );\n  });\n  const requestInit = {\n    method: _method,\n    headers: fetchHeaders,\n    body,\n    signal: controller.signal\n  };\n  if (!Platform.Config.isWebworker) {\n    requestInit.credentials = fetchHeaders.has(\"authorization\") ? \"include\" : \"same-origin\";\n  }\n  const resultPromise = (async () => {\n    try {\n      const res = await getGlobalObject().fetch(uri + \"?\" + new URLSearchParams(params || {}), requestInit);\n      clearTimeout(timeout);\n      if (res.status == 204) {\n        return { error: null, statusCode: res.status };\n      }\n      const contentType = res.headers.get(\"Content-Type\");\n      let body2;\n      if (contentType && contentType.indexOf(\"application/x-msgpack\") > -1) {\n        body2 = await res.arrayBuffer();\n      } else if (contentType && contentType.indexOf(\"application/json\") > -1) {\n        body2 = await res.json();\n      } else {\n        body2 = await res.text();\n      }\n      const unpacked = !!contentType && contentType.indexOf(\"application/x-msgpack\") === -1;\n      const headers2 = convertHeaders(res.headers);\n      if (!res.ok) {\n        const error = getAblyError2(body2, res.headers) || new PartialErrorInfo(\n          \"Error response received from server: \" + res.status + \" body was: \" + Platform.Config.inspect(body2),\n          null,\n          res.status\n        );\n        return { error, body: body2, headers: headers2, unpacked, statusCode: res.status };\n      } else {\n        return { error: null, body: body2, headers: headers2, unpacked, statusCode: res.status };\n      }\n    } catch (error) {\n      clearTimeout(timeout);\n      return { error };\n    }\n  })();\n  return Promise.race([timeoutPromise, resultPromise]);\n}\n\n// src/platform/web/lib/http/request/index.ts\nvar defaultBundledRequestImplementations = {\n  XHRRequest: xhrrequest_default,\n  FetchRequest: fetchRequest\n};\n\n// src/platform/web/index.ts\nvar Crypto = createCryptoClass(config_default, bufferutils_default);\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = bufferutils_default;\nPlatform.Http = http_default;\nPlatform.Config = config_default;\nPlatform.Transports = transport_default2;\nPlatform.WebStorage = webstorage_default;\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\n  clientClass.Crypto = Crypto;\n  clientClass._MsgPack = msgpack_default;\n}\nhttp_default.bundledRequestImplementations = defaultBundledRequestImplementations;\nlogger_default.initLogHandlers();\nPlatform.Defaults = getDefaults(defaults_default2);\nif (Platform.Config.agent) {\n  Platform.Defaults.agent += \" \" + Platform.Config.agent;\n}\nvar web_default = {\n  ErrorInfo,\n  Rest: DefaultRest,\n  Realtime: DefaultRealtime,\n  msgpack: msgpack_default\n};\nif (typeof module.exports == \"object\" && typeof exports == \"object\") {\n  var __cp = (to, from, except, desc) => {\n    if ((from && typeof from === \"object\") || typeof from === \"function\") {\n      for (let key of Object.getOwnPropertyNames(from)) {\n        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)\n        Object.defineProperty(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,\n        });\n      }\n    }\n    return to;\n  };\n  module.exports = __cp(module.exports, exports);\n}\nreturn module.exports;\n}))\n//# sourceMappingURL=ably.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L2J1aWxkL2FibHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBdUQ7QUFDL0Q7QUFDQSxNQUFNLEtBQUssRUFNTjtBQUNMLEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHFCQUFNLG1CQUFtQixxQkFBTTtBQUN6RDtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLHlEQUF5RCxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEseUNBQXlDLFFBQVEsdUNBQXVDLFFBQVEsZ0JBQWdCLFFBQVE7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVUsY0FBYyxRQUFRLGtDQUFrQyxRQUFRLHVDQUF1QyxRQUFRLGdCQUFnQixRQUFRO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb1FBQW9RLHdCQUF3QjtBQUM1UjtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsbUJBQW1CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBTTtBQUNuQixXQUFXLHFCQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUIsaUdBQWlHLHVCQUF1QjtBQUNwTCxrRUFBa0Usc0JBQXNCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUIsK0NBQStDO0FBQzdGLHNFQUFzRSxzQkFBc0I7QUFDNUY7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixNQUFNO0FBQ047QUFDQSx1QkFBdUIsdUJBQXVCLGlEQUFpRDtBQUMvRixzRUFBc0Usc0JBQXNCO0FBQzVGO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlCQUFpQix5Q0FBeUMsaURBQWlEO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw0Q0FBNEM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDJCQUEyQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsK0tBQStLLHFCQUFxQixlQUFlLHFFQUFxRSxjQUFjO0FBQ3RTO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFzQztBQUM3RDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0MsOENBQThDLHVDQUF1QztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5REFBeUQsMkJBQTJCLDBCQUEwQixvQkFBb0I7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDZDQUE2QztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixlQUFlLHFEQUFxRCxrQkFBa0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlEQUF5RCwyQkFBMkIsMEJBQTBCLG9CQUFvQjtBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSx3REFBd0Qsa0JBQWtCO0FBQ3pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0oscUJBQXFCLGVBQWU7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBDQUEwQyxhQUFhLDBCQUEwQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVLG1FQUFtRTtBQUM3RTtBQUNBLDBDQUEwQyxhQUFhLHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBdUM7QUFDOUQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQXVDLDhDQUE4Qyx1Q0FBdUM7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekMsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JO0FBQ3BJLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUtBQW1LLFFBQVE7QUFDM0sseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1LQUFtSyxRQUFRO0FBQzNLO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3TEFBd0wsUUFBUTtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyUEFBMlAsUUFBUTtBQUNuUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0xBQXdMLFFBQVEsY0FBYztBQUM5TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0xBQXdMLFFBQVE7QUFDaE07QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtS0FBbUssUUFBUTtBQUMzSztBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMlBBQTJQLFFBQVE7QUFDblE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdMQUF3TCxRQUFRO0FBQ2hNO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDJQQUEyUCxRQUFRO0FBQ25RO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJRQUEyUSxRQUFRO0FBQ25SO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdSQUFnUixRQUFRO0FBQ3hSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaVFBQWlRLFFBQVE7QUFDelE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFFBQVE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1SQUFtUixRQUFRO0FBQzNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxtQ0FBbUMsK0RBQStELG1DQUFtQztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZLQUE2SyxRQUFRO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw2S0FBNkssUUFBUTtBQUNyTDtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYseUJBQXlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlLEdBQUcsZ0JBQWdCO0FBQ2xGLEtBQUs7QUFDTCw2S0FBNkssUUFBUTtBQUNyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLE1BQU07QUFDOUc7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQStDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0EsNkVBQTZFLG1CQUFtQixVQUFVO0FBQzFHO0FBQ0E7QUFDQSwwQ0FBMEMsMkZBQTJGO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFDQUFxQyxDQUFVO0FBQ2hFO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pELHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0REFBNEQ7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDOztBQUV6QztBQUNBLDJCQUEyQixxQkFBTSxtQkFBbUIscUJBQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0IsNkZBQTZGO0FBQzdHLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWiwrQkFBK0IsMENBQTBDO0FBQ3pFO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDLGtFQUFrRTtBQUNuRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCx5Q0FBeUM7QUFDeEs7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCLG1FQUFtRTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0NBQXNDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFxRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RCxNQUFNO0FBQ04seUJBQXlCLDZCQUE2QjtBQUN0RCxNQUFNO0FBQ04sMkVBQTJFO0FBQzNFO0FBQ0EseUJBQXlCLDZEQUE2RDtBQUN0RixNQUFNO0FBQ047QUFDQTtBQUNBLHlCQUF5Qix5RUFBeUU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0IsOEJBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZ0JBQWdCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLGdCQUFnQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBMkM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpS0FBaUs7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJLFdBQVc7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLEVBQUUscUJBQXFCLEdBQUcsa0JBQWtCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0k7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxtQ0FBbUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQ0FBbUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsNkRBQTZEO0FBQ3JJO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQU0sbUJBQW1CLHFCQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlELElBQUk7QUFDSiwwQkFBMEIsMkNBQTJDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZEQUE2RDtBQUMvRSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L2J1aWxkL2FibHkuanM/MTczNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKkBsaWNlbnNlIENvcHlyaWdodCAyMDE1LTIwMjIgQWJseSBSZWFsLXRpbWUgTHRkIChhYmx5LmNvbSlcblxuQWJseSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMy4xXG5odHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzXG5cblJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5jZSB2Mi4wKi8oZnVuY3Rpb24gKGcsIGYpIHtcbiAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZigpO1xuICAgIH0gZWxzZSBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgZGVmaW5lKFtdLCBmKTtcbiAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHNbXCJBYmx5XCJdID0gZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnW1wiQWJseVwiXSA9IGYoKTtcbiAgICB9XG4gIH0odGhpcywgKCkgPT4ge1xudmFyIGV4cG9ydHMgPSB7fTtcbnZhciBtb2R1bGUgPSB7IGV4cG9ydHMgfTtcblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9wbGF0Zm9ybS93ZWIvaW5kZXgudHNcbnZhciB3ZWJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQod2ViX2V4cG9ydHMsIHtcbiAgRXJyb3JJbmZvOiAoKSA9PiBFcnJvckluZm8sXG4gIFJlYWx0aW1lOiAoKSA9PiBEZWZhdWx0UmVhbHRpbWUsXG4gIFJlc3Q6ICgpID0+IERlZmF1bHRSZXN0LFxuICBkZWZhdWx0OiAoKSA9PiB3ZWJfZGVmYXVsdCxcbiAgbXNncGFjazogKCkgPT4gbXNncGFja19kZWZhdWx0LFxuICBwcm90b2NvbE1lc3NhZ2VGcm9tRGVzZXJpYWxpemVkOiAoKSA9PiBmcm9tRGVzZXJpYWxpemVkSW5jbHVkaW5nRGVwZW5kZW5jaWVzXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHdlYl9leHBvcnRzKTtcblxuLy8gc3JjL2NvbW1vbi9wbGF0Zm9ybS50c1xudmFyIFBsYXRmb3JtID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIudHNcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5mdW5jdGlvbiBwYWQodGltZVNlZ21lbnQsIHRocmVlKSB7XG4gIHJldHVybiBgJHt0aW1lU2VnbWVudH1gLnBhZFN0YXJ0KHRocmVlID8gMyA6IDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZXIobG9nZ2VyKSB7XG4gIHJldHVybiBQbGF0Zm9ybS5Db25maWcubG9nVGltZXN0YW1wcyA/IGZ1bmN0aW9uKG1zZykge1xuICAgIGNvbnN0IHRpbWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsb2dnZXIoXG4gICAgICBwYWQodGltZS5nZXRIb3VycygpKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0TWludXRlcygpKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0U2Vjb25kcygpKSArIFwiLlwiICsgcGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDEpICsgXCIgXCIgKyBtc2dcbiAgICApO1xuICB9IDogZnVuY3Rpb24obXNnKSB7XG4gICAgbG9nZ2VyKG1zZyk7XG4gIH07XG59XG52YXIgZ2V0RGVmYXVsdExvZ2dlcnMgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIGxldCBjb25zb2xlTG9nZ2VyO1xuICBsZXQgZXJyb3JMb2dnZXI7XG4gIGlmICh0eXBlb2YgKChfYTIgPSBnbG9iYWxPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbE9iamVjdC5jb25zb2xlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGVMb2dnZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICAgIGVycm9yTG9nZ2VyID0gY29uc29sZS53YXJuID8gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH0gOiBjb25zb2xlTG9nZ2VyO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIFtjb25zb2xlTG9nZ2VyLCBlcnJvckxvZ2dlcl0ubWFwKGdldEhhbmRsZXIpO1xufTtcbnZhciBfTG9nZ2VyID0gY2xhc3MgX0xvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVwcmVjYXRlZCA9IChkZXNjcmlwdGlvbiwgbXNnKSA9PiB7XG4gICAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZyhgJHtkZXNjcmlwdGlvbn0gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uICR7bXNnfWApO1xuICAgIH07XG4gICAgLyogV2hlcmUgYSBsb2dnaW5nIG9wZXJhdGlvbiBpcyBleHBlbnNpdmUsIHN1Y2ggYXMgc2VyaWFsaXNhdGlvbiBvZiBkYXRhLCB1c2Ugc2hvdWxkTG9nIHdpbGwgcHJldmVudFxuICAgICAgdGhlIG9iamVjdCBiZWluZyBzZXJpYWxpc2VkIGlmIHRoZSBsb2cgbGV2ZWwgd2lsbCBub3Qgb3V0cHV0IHRoZSBtZXNzYWdlICovXG4gICAgdGhpcy5zaG91bGRMb2cgPSAobGV2ZWwpID0+IHtcbiAgICAgIHJldHVybiBsZXZlbCA8PSB0aGlzLmxvZ0xldmVsO1xuICAgIH07XG4gICAgdGhpcy5zZXRMb2cgPSAobGV2ZWwsIGhhbmRsZXIpID0+IHtcbiAgICAgIGlmIChsZXZlbCAhPT0gdm9pZCAwKVxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gbGV2ZWw7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gdm9pZCAwKVxuICAgICAgICB0aGlzLmxvZ0hhbmRsZXIgPSB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfTtcbiAgICB0aGlzLmxvZ0xldmVsID0gX0xvZ2dlci5kZWZhdWx0TG9nTGV2ZWw7XG4gICAgdGhpcy5sb2dIYW5kbGVyID0gX0xvZ2dlci5kZWZhdWx0TG9nSGFuZGxlcjtcbiAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IF9Mb2dnZXIuZGVmYXVsdExvZ0Vycm9ySGFuZGxlcjtcbiAgfVxuICBzdGF0aWMgaW5pdExvZ0hhbmRsZXJzKCkge1xuICAgIGNvbnN0IFtsb2dIYW5kbGVyLCBsb2dFcnJvckhhbmRsZXJdID0gZ2V0RGVmYXVsdExvZ2dlcnMoKTtcbiAgICB0aGlzLmRlZmF1bHRMb2dIYW5kbGVyID0gbG9nSGFuZGxlcjtcbiAgICB0aGlzLmRlZmF1bHRMb2dFcnJvckhhbmRsZXIgPSBsb2dFcnJvckhhbmRsZXI7XG4gICAgdGhpcy5kZWZhdWx0TG9nZ2VyID0gbmV3IF9Mb2dnZXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgdG8gdGhpcyBtZXRob2QgYXJlIG5ldmVyIHN0cmlwcGVkIGJ5IHRoZSBgc3RyaXBMb2dzYCBlc2J1aWxkIHBsdWdpbi4gVXNlIGl0IGZvciBsb2cgc3RhdGVtZW50cyB0aGF0IHlvdSB3aXNoIHRvIGFsd2F5cyBiZSBpbmNsdWRlZCBpbiB0aGUgbW9kdWxhciB2YXJpYW50IG9mIHRoZSBTREsuXG4gICAqL1xuICBzdGF0aWMgbG9nQWN0aW9uTm9TdHJpcChsb2dnZXIsIGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICBsb2dnZXIubG9nQWN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICB9XG4gIGxvZ0FjdGlvbihsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9nKGxldmVsKSkge1xuICAgICAgKGxldmVsID09PSAxIC8qIEVycm9yICovID8gdGhpcy5sb2dFcnJvckhhbmRsZXIgOiB0aGlzLmxvZ0hhbmRsZXIpKFwiQWJseTogXCIgKyBhY3Rpb24gKyBcIjogXCIgKyBtZXNzYWdlLCBsZXZlbCk7XG4gICAgfVxuICB9XG4gIHJlbmFtZWRDbGllbnRPcHRpb24ob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nKFxuICAgICAgYFRoZSBcXGAke29sZE5hbWV9XFxgIGNsaWVudCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGAke25ld05hbWV9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgXFxgJHtuZXdOYW1lfVxcYCBpbnN0ZWFkLiBcXGAke29sZE5hbWV9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLmBcbiAgICApO1xuICB9XG4gIHJlbmFtZWRNZXRob2QoY2xhc3NOYW1lLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBgXFxgJHtjbGFzc05hbWV9XFxgXFx1MjAxOXMgXFxgJHtvbGROYW1lfVxcYCBtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGAke25ld05hbWV9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgXFxgJHtuZXdOYW1lfVxcYCBpbnN0ZWFkLiBcXGAke29sZE5hbWV9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLmBcbiAgICApO1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZyhtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9nKDEgLyogRXJyb3IgKi8pKSB7XG4gICAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlcihgQWJseTogRGVwcmVjYXRpb24gd2FybmluZyAtICR7bWVzc2FnZX1gLCAxIC8qIEVycm9yICovKTtcbiAgICB9XG4gIH1cbn07XG5fTG9nZ2VyLmRlZmF1bHRMb2dMZXZlbCA9IDEgLyogRXJyb3IgKi87XG4vLyBwdWJsaWMgY29uc3RhbnRzXG5fTG9nZ2VyLkxPR19OT05FID0gMCAvKiBOb25lICovO1xuX0xvZ2dlci5MT0dfRVJST1IgPSAxIC8qIEVycm9yICovO1xuX0xvZ2dlci5MT0dfTUFKT1IgPSAyIC8qIE1ham9yICovO1xuX0xvZ2dlci5MT0dfTUlOT1IgPSAzIC8qIE1pbm9yICovO1xuX0xvZ2dlci5MT0dfTUlDUk8gPSA0IC8qIE1pY3JvICovO1xuLyogcHVibGljIHN0YXRpYyBmdW5jdGlvbnMgKi9cbi8qKlxuICogSW4gdGhlIG1vZHVsYXIgdmFyaWFudCBvZiB0aGUgU0RLLCB0aGUgYHN0cmlwTG9nc2AgZXNidWlsZCBwbHVnaW4gc3RyaXBzIG91dCBhbGwgY2FsbHMgdG8gdGhpcyBtZXRob2QgKHdoZW4gaW52b2tlZCBhcyBgTG9nZ2VyLmxvZ0FjdGlvbiguLi4pYCkgZXhjZXB0IHdoZW4gY2FsbGVkIHdpdGggbGV2ZWwgYExvZ2dlci5MT0dfRVJST1JgLiBJZiB5b3Ugd2lzaCBmb3IgYSBsb2cgc3RhdGVtZW50IHRvIG5ldmVyIGJlIHN0cmlwcGVkLCB1c2UgdGhlIHtAbGluayBsb2dBY3Rpb25Ob1N0cmlwfSBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBUaGUgYWZvcmVtZW50aW9uZWQgcGx1Z2luIGV4cGVjdHMgYGxldmVsYCB0byBiZSBhbiBleHByZXNzaW9uIG9mIHRoZSBmb3JtIGBMb2dnZXIuTE9HXypgOyB0aGF0IGlzLCB5b3UgY2Fu4oCZdCBkeW5hbWljYWxseSBzcGVjaWZ5IHRoZSBsb2cgbGV2ZWwuXG4gKi9cbl9Mb2dnZXIubG9nQWN0aW9uID0gKGxvZ2dlciwgbGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkgPT4ge1xuICBfTG9nZ2VyLmxvZ0FjdGlvbk5vU3RyaXAobG9nZ2VyLCBsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKTtcbn07XG52YXIgTG9nZ2VyID0gX0xvZ2dlcjtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExvZ2dlcjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC91dGlscy50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgRm9ybWF0OiAoKSA9PiBGb3JtYXQsXG4gIGFsbFNhbWU6ICgpID0+IGFsbFNhbWUsXG4gIGFsbFRvTG93ZXJDYXNlOiAoKSA9PiBhbGxUb0xvd2VyQ2FzZSxcbiAgYWxsVG9VcHBlckNhc2U6ICgpID0+IGFsbFRvVXBwZXJDYXNlLFxuICBhcnJDaG9vc2VOOiAoKSA9PiBhcnJDaG9vc2VOLFxuICBhcnJEZWxldGVWYWx1ZTogKCkgPT4gYXJyRGVsZXRlVmFsdWUsXG4gIGFyckVxdWFsczogKCkgPT4gYXJyRXF1YWxzLFxuICBhcnJJbnRlcnNlY3Q6ICgpID0+IGFyckludGVyc2VjdCxcbiAgYXJySW50ZXJzZWN0T2I6ICgpID0+IGFyckludGVyc2VjdE9iLFxuICBhcnJQb3BSYW5kb21FbGVtZW50OiAoKSA9PiBhcnJQb3BSYW5kb21FbGVtZW50LFxuICBhcnJTdWJ0cmFjdDogKCkgPT4gYXJyU3VidHJhY3QsXG4gIGFycldpdGhvdXRWYWx1ZTogKCkgPT4gYXJyV2l0aG91dFZhbHVlLFxuICBjaGVhcFJhbmRTdHI6ICgpID0+IGNoZWFwUmFuZFN0cixcbiAgY29udGFpbnNWYWx1ZTogKCkgPT4gY29udGFpbnNWYWx1ZSxcbiAgY29weTogKCkgPT4gY29weSxcbiAgY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yOiAoKSA9PiBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IsXG4gIGRhdGFTaXplQnl0ZXM6ICgpID0+IGRhdGFTaXplQnl0ZXMsXG4gIGRlY29kZUJvZHk6ICgpID0+IGRlY29kZUJvZHksXG4gIGVuY29kZUJvZHk6ICgpID0+IGVuY29kZUJvZHksXG4gIGVuc3VyZUFycmF5OiAoKSA9PiBlbnN1cmVBcnJheSxcbiAgZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllczogKCkgPT4gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyxcbiAgZ2V0QmFja29mZkNvZWZmaWNpZW50OiAoKSA9PiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQsXG4gIGdldEdsb2JhbE9iamVjdDogKCkgPT4gZ2V0R2xvYmFsT2JqZWN0LFxuICBnZXRKaXR0ZXJDb2VmZmljaWVudDogKCkgPT4gZ2V0Sml0dGVyQ29lZmZpY2llbnQsXG4gIGdldFJldHJ5VGltZTogKCkgPT4gZ2V0UmV0cnlUaW1lLFxuICBpbmhlcml0czogKCkgPT4gaW5oZXJpdHMsXG4gIGluc3BlY3RCb2R5OiAoKSA9PiBpbnNwZWN0Qm9keSxcbiAgaW5zcGVjdEVycm9yOiAoKSA9PiBpbnNwZWN0RXJyb3IsXG4gIGludGVyc2VjdDogKCkgPT4gaW50ZXJzZWN0LFxuICBpc0VtcHR5OiAoKSA9PiBpc0VtcHR5LFxuICBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbzogKCkgPT4gaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8sXG4gIGlzTmlsOiAoKSA9PiBpc05pbCxcbiAgaXNPYmplY3Q6ICgpID0+IGlzT2JqZWN0LFxuICBrZXlzQXJyYXk6ICgpID0+IGtleXNBcnJheSxcbiAgbWF0Y2hEZXJpdmVkQ2hhbm5lbDogKCkgPT4gbWF0Y2hEZXJpdmVkQ2hhbm5lbCxcbiAgbWl4aW46ICgpID0+IG1peGluLFxuICBwYXJzZVF1ZXJ5U3RyaW5nOiAoKSA9PiBwYXJzZVF1ZXJ5U3RyaW5nLFxuICBwcm90b3R5cGljYWxDbG9uZTogKCkgPT4gcHJvdG90eXBpY2FsQ2xvbmUsXG4gIHJhbmRvbVN0cmluZzogKCkgPT4gcmFuZG9tU3RyaW5nLFxuICBzaGFsbG93Q2xvbmU6ICgpID0+IHNoYWxsb3dDbG9uZSxcbiAgc2hhbGxvd0VxdWFsczogKCkgPT4gc2hhbGxvd0VxdWFscyxcbiAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3I6ICgpID0+IHRocm93TWlzc2luZ1BsdWdpbkVycm9yLFxuICB0b0Jhc2U2NDogKCkgPT4gdG9CYXNlNjQsXG4gIHRvUXVlcnlTdHJpbmc6ICgpID0+IHRvUXVlcnlTdHJpbmcsXG4gIHZhbHVlc0FycmF5OiAoKSA9PiB2YWx1ZXNBcnJheSxcbiAgd2hlblByb21pc2VTZXR0bGVzOiAoKSA9PiB3aGVuUHJvbWlzZVNldHRsZXMsXG4gIHdpdGhUaW1lb3V0QXN5bmM6ICgpID0+IHdpdGhUaW1lb3V0QXN5bmNcbn0pO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8udHNcbmZ1bmN0aW9uIHRvU3RyaW5nKGVycikge1xuICBsZXQgcmVzdWx0ID0gXCJbXCIgKyBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKGVyci5tZXNzYWdlKVxuICAgIHJlc3VsdCArPSBcIjogXCIgKyBlcnIubWVzc2FnZTtcbiAgaWYgKGVyci5zdGF0dXNDb2RlKVxuICAgIHJlc3VsdCArPSBcIjsgc3RhdHVzQ29kZT1cIiArIGVyci5zdGF0dXNDb2RlO1xuICBpZiAoZXJyLmNvZGUpXG4gICAgcmVzdWx0ICs9IFwiOyBjb2RlPVwiICsgZXJyLmNvZGU7XG4gIGlmIChlcnIuY2F1c2UpXG4gICAgcmVzdWx0ICs9IFwiOyBjYXVzZT1cIiArIGluc3BlY3RFcnJvcihlcnIuY2F1c2UpO1xuICBpZiAoZXJyLmhyZWYgJiYgIShlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmRleE9mKFwiaGVscC5hYmx5LmlvXCIpID4gLTEpKVxuICAgIHJlc3VsdCArPSBcIjsgc2VlIFwiICsgZXJyLmhyZWYgKyBcIiBcIjtcbiAgcmVzdWx0ICs9IFwiXVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEVycm9ySW5mbyA9IGNsYXNzIF9FcnJvckluZm8gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfRXJyb3JJbmZvLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSB9ID0gdmFsdWVzO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc3RhdHVzQ29kZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JJbmZvLmZyb21WYWx1ZXMoKTogaW52YWxpZCB2YWx1ZXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QodmFsdWVzKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24obmV3IF9FcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgcmVzdWx0LmhyZWYgPSBcImh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yL1wiICsgcmVzdWx0LmNvZGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgUGFydGlhbEVycm9ySW5mbyA9IGNsYXNzIF9QYXJ0aWFsRXJyb3JJbmZvIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1BhcnRpYWxFcnJvckluZm8ucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlIH0gPSB2YWx1ZXM7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiIHx8ICFpc05pbChjb2RlKSAmJiB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCAhaXNOaWwoc3RhdHVzQ29kZSkgJiYgdHlwZW9mIHN0YXR1c0NvZGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnRpYWxFcnJvckluZm8uZnJvbVZhbHVlcygpOiBpbnZhbGlkIHZhbHVlczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdCh2YWx1ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihuZXcgX1BhcnRpYWxFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgcmVzdWx0LmhyZWYgPSBcImh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yL1wiICsgcmVzdWx0LmNvZGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvdXRpbHMudHNcbmZ1bmN0aW9uIHJhbmRvbVBvc24oYXJyT3JTdHIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyck9yU3RyLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJnc1tpXTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGNvcHkoc3JjKSB7XG4gIHJldHVybiBtaXhpbih7fSwgc3JjKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KG9iaikge1xuICBpZiAoaXNOaWwob2JqKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXR1cm4gW29ial07XG59XG5mdW5jdGlvbiBpc09iamVjdChvYikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iKSA9PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNFbXB0eShvYikge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzTmlsKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2IpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE9iamVjdCgpO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpXG4gICAgcmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwcm90b3R5cGljYWxDbG9uZShvYiwgb3duUHJvcGVydGllcykge1xuICBjbGFzcyBGIHtcbiAgfVxuICBGLnByb3RvdHlwZSA9IG9iO1xuICBjb25zdCByZXN1bHQgPSBuZXcgRigpO1xuICBpZiAob3duUHJvcGVydGllcylcbiAgICBtaXhpbihyZXN1bHQsIG93blByb3BlcnRpZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGlmIChQbGF0Zm9ybS5Db25maWcuaW5oZXJpdHMpIHtcbiAgICBQbGF0Zm9ybS5Db25maWcuaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gcHJvdG90eXBpY2FsQ2xvbmUoc3VwZXJDdG9yLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogY3RvciB9KTtcbn07XG5mdW5jdGlvbiBjb250YWluc1ZhbHVlKG9iLCB2YWwpIHtcbiAgZm9yIChjb25zdCBpIGluIG9iKSB7XG4gICAgaWYgKG9iW2ldID09IHZhbClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdChhcnIsIG9iKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iKSA/IGFyckludGVyc2VjdChhcnIsIG9iKSA6IGFyckludGVyc2VjdE9iKGFyciwgb2IpO1xufVxuZnVuY3Rpb24gYXJySW50ZXJzZWN0KGFycjEsIGFycjIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1lbWJlciA9IGFycjFbaV07XG4gICAgaWYgKGFycjIuaW5kZXhPZihtZW1iZXIpICE9IC0xKVxuICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJySW50ZXJzZWN0T2IoYXJyLCBvYikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZW1iZXIgPSBhcnJbaV07XG4gICAgaWYgKG1lbWJlciBpbiBvYilcbiAgICAgIHJlc3VsdC5wdXNoKG1lbWJlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFyclN1YnRyYWN0KGFycjEsIGFycjIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnIxW2ldO1xuICAgIGlmIChhcnIyLmluZGV4T2YoZWxlbWVudCkgPT0gLTEpXG4gICAgICByZXN1bHQucHVzaChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJyRGVsZXRlVmFsdWUoYXJyLCB2YWwpIHtcbiAgY29uc3QgaWR4ID0gYXJyLmluZGV4T2YodmFsKTtcbiAgY29uc3QgcmVzID0gaWR4ICE9IC0xO1xuICBpZiAocmVzKVxuICAgIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFycldpdGhvdXRWYWx1ZShhcnIsIHZhbCkge1xuICBjb25zdCBuZXdBcnIgPSBhcnIuc2xpY2UoKTtcbiAgYXJyRGVsZXRlVmFsdWUobmV3QXJyLCB2YWwpO1xuICByZXR1cm4gbmV3QXJyO1xufVxuZnVuY3Rpb24ga2V5c0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpIHtcbiAgICBpZiAob3duT25seSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWx1ZXNBcnJheShvYiwgb3duT25seSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKSB7XG4gICAgaWYgKG93bk9ubHkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpXG4gICAgICBjb250aW51ZTtcbiAgICByZXN1bHQucHVzaChvYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMob2IsIGZuKSB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApICYmIG9iW3Byb3BdKSB7XG4gICAgICBmbihwcm9wKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbFNhbWUoYXJyLCBwcm9wKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZmlyc3QgPSBhcnJbMF1bcHJvcF07XG4gIHJldHVybiBhcnIuZXZlcnkoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtW3Byb3BdID09PSBmaXJzdDtcbiAgfSk7XG59XG52YXIgRm9ybWF0ID0gLyogQF9fUFVSRV9fICovICgoRm9ybWF0MikgPT4ge1xuICBGb3JtYXQyW1wibXNncGFja1wiXSA9IFwibXNncGFja1wiO1xuICBGb3JtYXQyW1wianNvblwiXSA9IFwianNvblwiO1xuICByZXR1cm4gRm9ybWF0Mjtcbn0pKEZvcm1hdCB8fCB7fSk7XG5mdW5jdGlvbiBhcnJQb3BSYW5kb21FbGVtZW50KGFycikge1xuICByZXR1cm4gYXJyLnNwbGljZShyYW5kb21Qb3NuKGFyciksIDEpWzBdO1xufVxuZnVuY3Rpb24gdG9RdWVyeVN0cmluZyhwYXJhbXMpIHtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgaWYgKHBhcmFtcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcylcbiAgICAgIHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuICB9XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPyBcIj9cIiArIHBhcnRzLmpvaW4oXCImXCIpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmcocXVlcnkpIHtcbiAgbGV0IG1hdGNoO1xuICBjb25zdCBzZWFyY2ggPSAvKFtePyY9XSspPT8oW14mXSopL2c7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICB3aGlsZSAobWF0Y2ggPSBzZWFyY2guZXhlYyhxdWVyeSkpXG4gICAgcmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzJdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGVycikge1xuICByZXR1cm4gdHlwZW9mIGVyciA9PSBcIm9iamVjdFwiICYmIGVyciAhPT0gbnVsbCAmJiAoZXJyIGluc3RhbmNlb2YgRXJyb3JJbmZvIHx8IGVyciBpbnN0YW5jZW9mIFBhcnRpYWxFcnJvckluZm8pO1xufVxuZnVuY3Rpb24gaW5zcGVjdEVycm9yKGVycikge1xuICB2YXIgX2EyLCBfYjtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8ICgoX2EyID0gZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubmFtZSkgPT09IFwiRXJyb3JJbmZvXCIgfHwgKChfYiA9IGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkgPT09IFwiUGFydGlhbEVycm9ySW5mb1wiKVxuICAgIHJldHVybiBlcnIudG9TdHJpbmcoKTtcbiAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGVycik7XG59XG5mdW5jdGlvbiBpbnNwZWN0Qm9keShib2R5KSB7XG4gIGlmIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYm9keSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRhdGFTaXplQnl0ZXMoZGF0YSkge1xuICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYnl0ZUxlbmd0aChkYXRhKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQ29uZmlnLnN0cmluZ0J5dGVTaXplKGRhdGEpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIFV0aWxzLmRhdGFTaXplQnl0ZXMgdG8gYmUgYSBidWZmZXIgb3Igc3RyaW5nLCBidXQgd2FzOiBcIiArIHR5cGVvZiBkYXRhKTtcbn1cbmZ1bmN0aW9uIGNoZWFwUmFuZFN0cigpIHtcbiAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG59XG52YXIgcmFuZG9tU3RyaW5nID0gYXN5bmMgKG51bUJ5dGVzKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IFBsYXRmb3JtLkNvbmZpZy5nZXRSYW5kb21BcnJheUJ1ZmZlcihudW1CeXRlcyk7XG4gIHJldHVybiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoYnVmZmVyKTtcbn07XG5mdW5jdGlvbiBhcnJDaG9vc2VOKGFyciwgbjIpIHtcbiAgY29uc3QgbnVtSXRlbXMgPSBNYXRoLm1pbihuMiwgYXJyLmxlbmd0aCksIG11dGFibGVBcnIgPSBhcnIuc2xpY2UoKSwgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGFyclBvcFJhbmRvbUVsZW1lbnQobXV0YWJsZUFycikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aGVuUHJvbWlzZVNldHRsZXMocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQgPT0gXCJtc2dwYWNrXCIpIHtcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTXNnUGFja1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1zZ1BhY2suZGVjb2RlKGJvZHkpO1xuICB9XG4gIHJldHVybiBKU09OLnBhcnNlKFN0cmluZyhib2R5KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09IFwibXNncGFja1wiKSB7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgfVxuICAgIHJldHVybiBNc2dQYWNrLmVuY29kZShib2R5LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG59XG5mdW5jdGlvbiBhbGxUb0xvd2VyQ2FzZShhcnIpIHtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhbGxUb1VwcGVyQ2FzZShhcnIpIHtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQoY291bnQpIHtcbiAgcmV0dXJuIE1hdGgubWluKChjb3VudCArIDIpIC8gMywgMik7XG59XG5mdW5jdGlvbiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLnJhbmRvbSgpICogMC4yO1xufVxuZnVuY3Rpb24gZ2V0UmV0cnlUaW1lKGluaXRpYWxUaW1lb3V0LCByZXRyeUF0dGVtcHQpIHtcbiAgcmV0dXJuIGluaXRpYWxUaW1lb3V0ICogZ2V0QmFja29mZkNvZWZmaWNpZW50KHJldHJ5QXR0ZW1wdCkgKiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsT2JqZWN0KCkge1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFscyhzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5ldmVyeSgoa2V5KSA9PiBzb3VyY2Vba2V5XSA9PT0gdGFyZ2V0W2tleV0pICYmIE9iamVjdC5rZXlzKHRhcmdldCkuZXZlcnkoKGtleSkgPT4gdGFyZ2V0W2tleV0gPT09IHNvdXJjZVtrZXldKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRGVyaXZlZENoYW5uZWwobmFtZSkge1xuICBjb25zdCByZWdleCA9IC9eKFxcWyhbXj9dKikoPzooLiopKVxcXSk/KC4rKSQvO1xuICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gocmVnZXgpO1xuICBpZiAoIW1hdGNoIHx8ICFtYXRjaC5sZW5ndGggfHwgbWF0Y2gubGVuZ3RoIDwgNSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJyZWdleCBtYXRjaCBmYWlsZWRcIiwgNDAwLCA0MDAxMCk7XG4gIH1cbiAgaWYgKG1hdGNoWzJdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhgY2Fubm90IHVzZSBhIGRlcml2ZWQgb3B0aW9uIHdpdGggYSAke21hdGNoWzJdfSBjaGFubmVsYCwgNDAwLCA0MDAxMCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBxdWFsaWZpZXJQYXJhbTogbWF0Y2hbM10gfHwgXCJcIixcbiAgICBjaGFubmVsTmFtZTogbWF0Y2hbNF1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0KHN0cikge1xuICBjb25zdCBidWZmZXJVdGlscyA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZShzdHIpO1xuICByZXR1cm4gYnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRleHRCdWZmZXIpO1xufVxuZnVuY3Rpb24gYXJyRXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uKHZhbCwgaSkge1xuICAgIHJldHVybiB2YWwgPT09IGJbaV07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpIHtcbiAgcmV0dXJuIG5ldyBFcnJvckluZm8oYCR7cGx1Z2luTmFtZX0gcGx1Z2luIG5vdCBwcm92aWRlZGAsIDQwMDE5LCA0MDApO1xufVxuZnVuY3Rpb24gdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IocGx1Z2luTmFtZSkge1xuICB0aHJvdyBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IocGx1Z2luTmFtZSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dEFzeW5jKHByb21pc2UsIHRpbWVvdXQgPSA1ZTMsIGVyciA9IFwiVGltZW91dCBleHBpcmVkXCIpIHtcbiAgY29uc3QgZSA9IG5ldyBFcnJvckluZm8oZXJyLCA1ZTQsIDUwMCk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChlKSwgdGltZW91dCkpXSk7XG59XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjIuMy4xXCI7XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvZGVmYXVsdHMudHNcbnZhciBhZ2VudCA9IFwiYWJseS1qcy9cIiArIHZlcnNpb247XG52YXIgRGVmYXVsdHMgPSB7XG4gIEVOVklST05NRU5UOiBcIlwiLFxuICBSRVNUX0hPU1Q6IFwicmVzdC5hYmx5LmlvXCIsXG4gIFJFQUxUSU1FX0hPU1Q6IFwicmVhbHRpbWUuYWJseS5pb1wiLFxuICBGQUxMQkFDS19IT1NUUzogW1xuICAgIFwiQS5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwiQi5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwiQy5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwiRC5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwiRS5hYmx5LXJlYWx0aW1lLmNvbVwiXG4gIF0sXG4gIFBPUlQ6IDgwLFxuICBUTFNfUE9SVDogNDQzLFxuICBUSU1FT1VUUzoge1xuICAgIC8qIERvY3VtZW50ZWQgYXMgb3B0aW9ucyBwYXJhbXM6ICovXG4gICAgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0OiAxNWUzLFxuICAgIHN1c3BlbmRlZFJldHJ5VGltZW91dDogM2U0LFxuICAgIC8qIFVuZG9jdW1lbnRlZCwgYnV0IHBhcnQgb2YgdGhlIGFwaSBhbmQgY2FuIGJlIHVzZWQgYnkgY3VzdG9tZXJzOiAqL1xuICAgIGh0dHBSZXF1ZXN0VGltZW91dDogMWU0LFxuICAgIGh0dHBNYXhSZXRyeUR1cmF0aW9uOiAxNWUzLFxuICAgIGNoYW5uZWxSZXRyeVRpbWVvdXQ6IDE1ZTMsXG4gICAgZmFsbGJhY2tSZXRyeVRpbWVvdXQ6IDZlNSxcbiAgICAvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xuICAgIGNvbm5lY3Rpb25TdGF0ZVR0bDogMTJlNCxcbiAgICByZWFsdGltZVJlcXVlc3RUaW1lb3V0OiAxZTQsXG4gICAgcmVjdlRpbWVvdXQ6IDllNCxcbiAgICB3ZWJTb2NrZXRDb25uZWN0VGltZW91dDogMWU0LFxuICAgIHdlYlNvY2tldFNsb3dUaW1lb3V0OiA0ZTNcbiAgfSxcbiAgaHR0cE1heFJldHJ5Q291bnQ6IDMsXG4gIG1heE1lc3NhZ2VTaXplOiA2NTUzNixcbiAgdmVyc2lvbixcbiAgcHJvdG9jb2xWZXJzaW9uOiAzLFxuICBhZ2VudCxcbiAgZ2V0SG9zdCxcbiAgZ2V0UG9ydCxcbiAgZ2V0SHR0cFNjaGVtZSxcbiAgZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzLFxuICBnZXRGYWxsYmFja0hvc3RzLFxuICBnZXRIb3N0cyxcbiAgY2hlY2tIb3N0LFxuICBvYmplY3RpZnlPcHRpb25zLFxuICBub3JtYWxpc2VPcHRpb25zLFxuICBkZWZhdWx0R2V0SGVhZGVycyxcbiAgZGVmYXVsdFBvc3RIZWFkZXJzXG59O1xuZnVuY3Rpb24gZ2V0SG9zdChvcHRpb25zLCBob3N0LCB3cykge1xuICBpZiAod3MpXG4gICAgaG9zdCA9IGhvc3QgPT0gb3B0aW9ucy5yZXN0SG9zdCAmJiBvcHRpb25zLnJlYWx0aW1lSG9zdCB8fCBob3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuICBlbHNlXG4gICAgaG9zdCA9IGhvc3QgfHwgb3B0aW9ucy5yZXN0SG9zdDtcbiAgcmV0dXJuIGhvc3Q7XG59XG5mdW5jdGlvbiBnZXRQb3J0KG9wdGlvbnMsIHRscykge1xuICByZXR1cm4gdGxzIHx8IG9wdGlvbnMudGxzID8gb3B0aW9ucy50bHNQb3J0IDogb3B0aW9ucy5wb3J0O1xufVxuZnVuY3Rpb24gZ2V0SHR0cFNjaGVtZShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnRscyA/IFwiaHR0cHM6Ly9cIiA6IFwiaHR0cDovL1wiO1xufVxuZnVuY3Rpb24gZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KSB7XG4gIHJldHVybiBbXG4gICAgZW52aXJvbm1lbnQgKyBcIi1hLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgZW52aXJvbm1lbnQgKyBcIi1iLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgZW52aXJvbm1lbnQgKyBcIi1jLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgZW52aXJvbm1lbnQgKyBcIi1kLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgZW52aXJvbm1lbnQgKyBcIi1lLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCJcbiAgXTtcbn1cbmZ1bmN0aW9uIGdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykge1xuICBjb25zdCBmYWxsYmFja0hvc3RzID0gb3B0aW9ucy5mYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCA9IHR5cGVvZiBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50ICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCA6IERlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50O1xuICByZXR1cm4gZmFsbGJhY2tIb3N0cyA/IGFyckNob29zZU4oZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQpIDogW107XG59XG5mdW5jdGlvbiBnZXRIb3N0cyhvcHRpb25zLCB3cykge1xuICBjb25zdCBob3N0cyA9IFtvcHRpb25zLnJlc3RIb3N0XS5jb25jYXQoZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSk7XG4gIHJldHVybiB3cyA/IGhvc3RzLm1hcCgoaG9zdCkgPT4gZ2V0SG9zdChvcHRpb25zLCBob3N0LCB0cnVlKSkgOiBob3N0cztcbn1cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0KSB7XG4gIGlmICh0eXBlb2YgaG9zdCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJob3N0IG11c3QgYmUgYSBzdHJpbmc7IHdhcyBhIFwiICsgdHlwZW9mIGhvc3QsIDRlNCwgNDAwKTtcbiAgfVxuICBpZiAoIWhvc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImhvc3QgbXVzdCBub3QgYmUgemVyby1sZW5ndGhcIiwgNGU0LCA0MDApO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZWFsdGltZUhvc3Qob3B0aW9ucywgcHJvZHVjdGlvbiwgZW52aXJvbm1lbnQsIGxvZ2dlcikge1xuICBpZiAob3B0aW9ucy5yZWFsdGltZUhvc3QpXG4gICAgcmV0dXJuIG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuICBpZiAob3B0aW9ucy5yZXN0SG9zdCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9uc1wiLFxuICAgICAgJ3Jlc3RIb3N0IGlzIHNldCB0byBcIicgKyBvcHRpb25zLnJlc3RIb3N0ICsgJ1wiIGJ1dCByZWFsdGltZUhvc3QgaXMgbm90IHNldCwgc28gc2V0dGluZyByZWFsdGltZUhvc3QgdG8gXCInICsgb3B0aW9ucy5yZXN0SG9zdCArICdcIiB0b28uIElmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQsIHBsZWFzZSBzZXQgcmVhbHRpbWVIb3N0IGV4cGxpY2l0bHkuJ1xuICAgICk7XG4gICAgcmV0dXJuIG9wdGlvbnMucmVzdEhvc3Q7XG4gIH1cbiAgcmV0dXJuIHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5SRUFMVElNRV9IT1NUIDogZW52aXJvbm1lbnQgKyBcIi1cIiArIERlZmF1bHRzLlJFQUxUSU1FX0hPU1Q7XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0cyhvcHRpb25zKSB7XG4gIGNvbnN0IHRpbWVvdXRzID0ge307XG4gIGZvciAoY29uc3QgcHJvcCBpbiBEZWZhdWx0cy5USU1FT1VUUykge1xuICAgIHRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBEZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcbiAgfVxuICByZXR1cm4gdGltZW91dHM7XG59XG5mdW5jdGlvbiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKSB7XG4gIGxldCBhZ2VudFN0ciA9IERlZmF1bHRzLmFnZW50O1xuICBpZiAob3B0aW9ucy5hZ2VudHMpIHtcbiAgICBmb3IgKHZhciBhZ2VudDIgaW4gb3B0aW9ucy5hZ2VudHMpIHtcbiAgICAgIGFnZW50U3RyICs9IFwiIFwiICsgYWdlbnQyICsgXCIvXCIgKyBvcHRpb25zLmFnZW50c1thZ2VudDJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWdlbnRTdHI7XG59XG5mdW5jdGlvbiBvYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGFsbG93S2V5T3JUb2tlbiwgc291cmNlRm9yRXJyb3JNZXNzYWdlLCBsb2dnZXIsIG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBtc2cgPSBhbGxvd0tleU9yVG9rZW4gPyBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgYSBjbGllbnQgb3B0aW9ucyBvYmplY3QsIGFuIEFibHkgQVBJIGtleSwgb3IgYW4gQWJseSBUb2tlbmAgOiBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGNsaWVudCBvcHRpb25zIG9iamVjdGA7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG4gIGxldCBvcHRpb25zT2JqO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob3B0aW9ucy5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xuICAgICAgaWYgKCFhbGxvd0tleU9yVG9rZW4pIHtcbiAgICAgICAgY29uc3QgbXNnID0gYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBqdXN0IGFuIEFibHkgVG9rZW47IHlvdSBtdXN0IHByb3ZpZGUgYSBjbGllbnQgb3B0aW9ucyBvYmplY3Qgd2l0aCBhIFxcYHBsdWdpbnNcXGAgcHJvcGVydHkuIChTZXQgdGhpcyBBYmx5IFRva2VuIGFzIHRoZSBvYmplY3RcXHUyMDE5cyBcXGB0b2tlblxcYCBwcm9wZXJ0eS4pYDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNPYmogPSB7IHRva2VuOiBvcHRpb25zIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYWxsb3dLZXlPclRva2VuKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGAke3NvdXJjZUZvckVycm9yTWVzc2FnZX0gY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGgganVzdCBhbiBBYmx5IEFQSSBrZXk7IHlvdSBtdXN0IHByb3ZpZGUgYSBjbGllbnQgb3B0aW9ucyBvYmplY3Qgd2l0aCBhIFxcYHBsdWdpbnNcXGAgcHJvcGVydHkuIChTZXQgdGhpcyBBYmx5IEFQSSBrZXkgYXMgdGhlIG9iamVjdFxcdTIwMTlzIFxcYGtleVxcYCBwcm9wZXJ0eS4pYDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNPYmogPSB7IGtleTogb3B0aW9ucyB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zT2JqID0gb3B0aW9ucztcbiAgfVxuICBpZiAobW9kdWxhclBsdWdpbnNUb0luY2x1ZGUpIHtcbiAgICBvcHRpb25zT2JqID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9uc09iaiksIHsgcGx1Z2luczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSwgb3B0aW9uc09iai5wbHVnaW5zKSB9KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc09iajtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZU9wdGlvbnMob3B0aW9ucywgTXNnUGFjaywgbG9nZ2VyKSB7XG4gIGNvbnN0IGxvZ2dlclRvVXNlID0gbG9nZ2VyICE9IG51bGwgPyBsb2dnZXIgOiBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyO1xuICBpZiAodHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlclRvVXNlLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zXCIsXG4gICAgICBcImNsb3NlT25VbmxvYWQgd2FzIHRydWUgYW5kIGEgc2Vzc2lvbiByZWNvdmVyeSBmdW5jdGlvbiB3YXMgc2V0IC0gdGhlc2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gdW5zZXR0aW5nIHRoZSBsYXR0ZXJcIlxuICAgICk7XG4gICAgb3B0aW9ucy5yZWNvdmVyID0gdm9pZCAwO1xuICB9XG4gIGlmICghKFwiY2xvc2VPblVubG9hZFwiIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID0gIW9wdGlvbnMucmVjb3ZlcjtcbiAgfVxuICBpZiAoIShcInF1ZXVlTWVzc2FnZXNcIiBpbiBvcHRpb25zKSlcbiAgICBvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSB0cnVlO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQgJiYgU3RyaW5nKG9wdGlvbnMuZW52aXJvbm1lbnQpLnRvTG93ZXJDYXNlKCkgfHwgRGVmYXVsdHMuRU5WSVJPTk1FTlQ7XG4gIGNvbnN0IHByb2R1Y3Rpb24gPSAhZW52aXJvbm1lbnQgfHwgZW52aXJvbm1lbnQgPT09IFwicHJvZHVjdGlvblwiO1xuICBpZiAoIW9wdGlvbnMuZmFsbGJhY2tIb3N0cyAmJiAhb3B0aW9ucy5yZXN0SG9zdCAmJiAhb3B0aW9ucy5yZWFsdGltZUhvc3QgJiYgIW9wdGlvbnMucG9ydCAmJiAhb3B0aW9ucy50bHNQb3J0KSB7XG4gICAgb3B0aW9ucy5mYWxsYmFja0hvc3RzID0gcHJvZHVjdGlvbiA/IERlZmF1bHRzLkZBTExCQUNLX0hPU1RTIDogZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KTtcbiAgfVxuICBjb25zdCByZXN0SG9zdCA9IG9wdGlvbnMucmVzdEhvc3QgfHwgKHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5SRVNUX0hPU1QgOiBlbnZpcm9ubWVudCArIFwiLVwiICsgRGVmYXVsdHMuUkVTVF9IT1NUKTtcbiAgY29uc3QgcmVhbHRpbWVIb3N0ID0gZ2V0UmVhbHRpbWVIb3N0KG9wdGlvbnMsIHByb2R1Y3Rpb24sIGVudmlyb25tZW50LCBsb2dnZXJUb1VzZSk7XG4gIChvcHRpb25zLmZhbGxiYWNrSG9zdHMgfHwgW10pLmNvbmNhdChyZXN0SG9zdCwgcmVhbHRpbWVIb3N0KS5mb3JFYWNoKGNoZWNrSG9zdCk7XG4gIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydCB8fCBEZWZhdWx0cy5QT1JUO1xuICBvcHRpb25zLnRsc1BvcnQgPSBvcHRpb25zLnRsc1BvcnQgfHwgRGVmYXVsdHMuVExTX1BPUlQ7XG4gIGlmICghKFwidGxzXCIgaW4gb3B0aW9ucykpXG4gICAgb3B0aW9ucy50bHMgPSB0cnVlO1xuICBjb25zdCB0aW1lb3V0cyA9IGdldFRpbWVvdXRzKG9wdGlvbnMpO1xuICBpZiAoTXNnUGFjaykge1xuICAgIGlmIChcInVzZUJpbmFyeVByb3RvY29sXCIgaW4gb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IFBsYXRmb3JtLkNvbmZpZy5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gUGxhdGZvcm0uQ29uZmlnLnByZWZlckJpbmFyeTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuY2xpZW50SWQpIHtcbiAgICBoZWFkZXJzW1wiWC1BYmx5LUNsaWVudElkXCJdID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUob3B0aW9ucy5jbGllbnRJZCkpO1xuICB9XG4gIGlmICghKFwiaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nXCIgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHRydWU7XG4gIH1cbiAgbGV0IGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gbnVsbDtcbiAgbGV0IGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgaWYgKG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpIHtcbiAgICBsZXQgW3VyaSwgcXNdID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybC5zcGxpdChcIj9cIik7XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSBxcyA/IHBhcnNlUXVlcnlTdHJpbmcocXMpIDoge307XG4gICAgaWYgKHVyaS5pbmRleE9mKFwiOi8vXCIpID09PSAtMSkge1xuICAgICAgdXJpID0gXCJodHRwczovL1wiICsgdXJpO1xuICAgIH1cbiAgICBjb25uZWN0aXZpdHlDaGVja1VybCA9IHVyaTtcbiAgfVxuICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICByZWFsdGltZUhvc3QsXG4gICAgcmVzdEhvc3QsXG4gICAgbWF4TWVzc2FnZVNpemU6IG9wdGlvbnMubWF4TWVzc2FnZVNpemUgfHwgRGVmYXVsdHMubWF4TWVzc2FnZVNpemUsXG4gICAgdGltZW91dHMsXG4gICAgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMsXG4gICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwsXG4gICAgaGVhZGVyc1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgb3B0aW9ucykge1xuICBjb25zdCBjaGFubmVsT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChjaGFubmVsT3B0aW9ucy5jaXBoZXIpIHtcbiAgICBpZiAoIUNyeXB0bzIpXG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIkNyeXB0b1wiKTtcbiAgICBjb25zdCBjaXBoZXIgPSBDcnlwdG8yLmdldENpcGhlcihjaGFubmVsT3B0aW9ucy5jaXBoZXIsIGxvZ2dlcik7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gY2lwaGVyLmNpcGhlclBhcmFtcztcbiAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcbiAgfSBlbHNlIGlmIChcImNpcGhlclwiIGluIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gdm9pZCAwO1xuICAgIGNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBudWxsO1xuICB9XG4gIHJldHVybiBjaGFubmVsT3B0aW9ucztcbn1cbnZhciBjb250ZW50VHlwZXMgPSB7XG4gIGpzb246IFwiYXBwbGljYXRpb24vanNvblwiLFxuICB4bWw6IFwiYXBwbGljYXRpb24veG1sXCIsXG4gIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gIG1zZ3BhY2s6IFwiYXBwbGljYXRpb24veC1tc2dwYWNrXCIsXG4gIHRleHQ6IFwidGV4dC9wbGFpblwiXG59O1xudmFyIGRlZmF1bHRIZWFkZXJzT3B0aW9ucyA9IHtcbiAgZm9ybWF0OiBcImpzb25cIiAvKiBqc29uICovLFxuICBwcm90b2NvbFZlcnNpb246IERlZmF1bHRzLnByb3RvY29sVmVyc2lvblxufTtcbmZ1bmN0aW9uIGRlZmF1bHRHZXRIZWFkZXJzKG9wdGlvbnMsIHtcbiAgZm9ybWF0ID0gZGVmYXVsdEhlYWRlcnNPcHRpb25zLmZvcm1hdCxcbiAgcHJvdG9jb2xWZXJzaW9uID0gZGVmYXVsdEhlYWRlcnNPcHRpb25zLnByb3RvY29sVmVyc2lvblxufSA9IHt9KSB7XG4gIGNvbnN0IGFjY2VwdCA9IGNvbnRlbnRUeXBlc1tmb3JtYXRdO1xuICByZXR1cm4ge1xuICAgIGFjY2VwdCxcbiAgICBcIlgtQWJseS1WZXJzaW9uXCI6IHByb3RvY29sVmVyc2lvbi50b1N0cmluZygpLFxuICAgIFwiQWJseS1BZ2VudFwiOiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKVxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdFBvc3RIZWFkZXJzKG9wdGlvbnMsIHtcbiAgZm9ybWF0ID0gZGVmYXVsdEhlYWRlcnNPcHRpb25zLmZvcm1hdCxcbiAgcHJvdG9jb2xWZXJzaW9uID0gZGVmYXVsdEhlYWRlcnNPcHRpb25zLnByb3RvY29sVmVyc2lvblxufSA9IHt9KSB7XG4gIGxldCBjb250ZW50VHlwZTtcbiAgY29uc3QgYWNjZXB0ID0gY29udGVudFR5cGUgPSBjb250ZW50VHlwZXNbZm9ybWF0XTtcbiAgcmV0dXJuIHtcbiAgICBhY2NlcHQsXG4gICAgXCJjb250ZW50LXR5cGVcIjogY29udGVudFR5cGUsXG4gICAgXCJYLUFibHktVmVyc2lvblwiOiBwcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICBcIkFibHktQWdlbnRcIjogZ2V0QWdlbnRTdHJpbmcob3B0aW9ucylcbiAgfTtcbn1cbnZhciBkZWZhdWx0c19kZWZhdWx0ID0gRGVmYXVsdHM7XG5mdW5jdGlvbiBnZXREZWZhdWx0cyhwbGF0Zm9ybURlZmF1bHRzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKERlZmF1bHRzLCBwbGF0Zm9ybURlZmF1bHRzKTtcbn1cblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9tdWx0aWNhc3Rlci50c1xudmFyIE11bHRpY2FzdGVyID0gY2xhc3MgX011bHRpY2FzdGVyIHtcbiAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlIHN0YXRpYyBNdWx0aWNhc3Rlci5jcmVhdGUgaW5zdGVhZFxuICBjb25zdHJ1Y3Rvcihsb2dnZXIsIG1lbWJlcnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzIHx8IFtdO1xuICB9XG4gIGNhbGwoZXJyLCByZXN1bHQpIHtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLm1lbWJlcnMpIHtcbiAgICAgIGlmIChtZW1iZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZW1iZXIoZXJyLCByZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIk11bHRpY2FzdGVyIG11bHRpcGxlIGNhbGxiYWNrIGhhbmRsZXJcIixcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb246IFwiICsgZSArIFwiOyBzdGFjayA9IFwiICsgZS5zdGFja1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHVzaCguLi5hcmdzKSB7XG4gICAgdGhpcy5tZW1iZXJzLnB1c2goLi4uYXJncyk7XG4gIH1cbiAgY3JlYXRlUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wdXNoKChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlc29sdmVBbGwocmVzdWx0KSB7XG4gICAgdGhpcy5jYWxsKG51bGwsIHJlc3VsdCk7XG4gIH1cbiAgcmVqZWN0QWxsKGVycikge1xuICAgIHRoaXMuY2FsbChlcnIpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUobG9nZ2VyLCBtZW1iZXJzKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgX011bHRpY2FzdGVyKGxvZ2dlciwgbWVtYmVycyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKGVyciwgcmVzdWx0KSA9PiBpbnN0YW5jZS5jYWxsKGVyciwgcmVzdWx0KSwge1xuICAgICAgcHVzaDogKGZuKSA9PiBpbnN0YW5jZS5wdXNoKGZuKSxcbiAgICAgIGNyZWF0ZVByb21pc2U6ICgpID0+IGluc3RhbmNlLmNyZWF0ZVByb21pc2UoKSxcbiAgICAgIHJlc29sdmVBbGw6IChyZXN1bHQpID0+IGluc3RhbmNlLnJlc29sdmVBbGwocmVzdWx0KSxcbiAgICAgIHJlamVjdEFsbDogKGVycikgPT4gaW5zdGFuY2UucmVqZWN0QWxsKGVycilcbiAgICB9KTtcbiAgfVxufTtcbnZhciBtdWx0aWNhc3Rlcl9kZWZhdWx0ID0gTXVsdGljYXN0ZXI7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL0h0dHBNZXRob2RzLnRzXG52YXIgSHR0cE1ldGhvZHMgPSAvKiBAX19QVVJFX18gKi8gKChIdHRwTWV0aG9kczIpID0+IHtcbiAgSHR0cE1ldGhvZHMyW1wiR2V0XCJdID0gXCJnZXRcIjtcbiAgSHR0cE1ldGhvZHMyW1wiRGVsZXRlXCJdID0gXCJkZWxldGVcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUG9zdFwiXSA9IFwicG9zdFwiO1xuICBIdHRwTWV0aG9kczJbXCJQdXRcIl0gPSBcInB1dFwiO1xuICBIdHRwTWV0aG9kczJbXCJQYXRjaFwiXSA9IFwicGF0Y2hcIjtcbiAgcmV0dXJuIEh0dHBNZXRob2RzMjtcbn0pKEh0dHBNZXRob2RzIHx8IHt9KTtcbnZhciBIdHRwTWV0aG9kc19kZWZhdWx0ID0gSHR0cE1ldGhvZHM7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL0h0dHBTdGF0dXNDb2Rlcy50c1xudmFyIEh0dHBTdGF0dXNDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKEh0dHBTdGF0dXNDb2RlczIpID0+IHtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiU3VjY2Vzc1wiXSA9IDIwMF0gPSBcIlN1Y2Nlc3NcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiTm9Db250ZW50XCJdID0gMjA0XSA9IFwiTm9Db250ZW50XCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIkJhZFJlcXVlc3RcIl0gPSA0MDBdID0gXCJCYWRSZXF1ZXN0XCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlVuYXV0aG9yaXplZFwiXSA9IDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJGb3JiaWRkZW5cIl0gPSA0MDNdID0gXCJGb3JiaWRkZW5cIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiUmVxdWVzdFRpbWVvdXRcIl0gPSA0MDhdID0gXCJSZXF1ZXN0VGltZW91dFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNTAwXSA9IFwiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiO1xuICByZXR1cm4gSHR0cFN0YXR1c0NvZGVzMjtcbn0pKEh0dHBTdGF0dXNDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBpc1N1Y2Nlc3NDb2RlKHN0YXR1c0NvZGUpIHtcbiAgcmV0dXJuIHN0YXR1c0NvZGUgPj0gMjAwIC8qIFN1Y2Nlc3MgKi8gJiYgc3RhdHVzQ29kZSA8IDQwMCAvKiBCYWRSZXF1ZXN0ICovO1xufVxudmFyIEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0ID0gSHR0cFN0YXR1c0NvZGVzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYXV0aC50c1xudmFyIE1BWF9UT0tFTl9MRU5HVEggPSBNYXRoLnBvdygyLCAxNyk7XG5mdW5jdGlvbiByYW5kb20oKSB7XG4gIHJldHVybiAoXCIwMDAwMDBcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTYpKS5zbGljZSgtMTYpO1xufVxuZnVuY3Rpb24gaXNSZWFsdGltZShjbGllbnQpIHtcbiAgcmV0dXJuICEhY2xpZW50LmNvbm5lY3Rpb247XG59XG5mdW5jdGlvbiBub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpIHtcbiAgaWYgKCFpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oaW5zcGVjdEVycm9yKGVyciksIGVyci5jb2RlIHx8IDQwMTcwLCBlcnIuc3RhdHVzQ29kZSB8fCA0MDEpO1xuICB9XG4gIGlmICghZXJyLmNvZGUpIHtcbiAgICBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xuICAgICAgZXJyLmNvZGUgPSA0MDMwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyLmNvZGUgPSA0MDE3MDtcbiAgICAgIGVyci5zdGF0dXNDb2RlID0gNDAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyO1xufVxudmFyIGhtYWMgPSAodGV4dCwga2V5KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlclV0aWxzID0gUGxhdGZvcm0uQnVmZmVyVXRpbHM7XG4gIGNvbnN0IHRleHRCdWZmZXIgPSBidWZmZXJVdGlscy51dGY4RW5jb2RlKHRleHQpO1xuICBjb25zdCBrZXlCdWZmZXIgPSBidWZmZXJVdGlscy51dGY4RW5jb2RlKGtleSk7XG4gIGNvbnN0IGRpZ2VzdCA9IGJ1ZmZlclV0aWxzLmhtYWNTaGEyNTYodGV4dEJ1ZmZlciwga2V5QnVmZmVyKTtcbiAgcmV0dXJuIGJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkaWdlc3QpO1xufTtcbmZ1bmN0aW9uIGMxNG4oY2FwYWJpbGl0eSkge1xuICBpZiAoIWNhcGFiaWxpdHkpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGlmICh0eXBlb2YgY2FwYWJpbGl0eSA9PSBcInN0cmluZ1wiKVxuICAgIGNhcGFiaWxpdHkgPSBKU09OLnBhcnNlKGNhcGFiaWxpdHkpO1xuICBjb25zdCBjMTRuQ2FwYWJpbGl0eSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBrZXlzID0ga2V5c0FycmF5KGNhcGFiaWxpdHksIHRydWUpO1xuICBpZiAoIWtleXMpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGtleXMuc29ydCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjMTRuQ2FwYWJpbGl0eVtrZXlzW2ldXSA9IGNhcGFiaWxpdHlba2V5c1tpXV0uc29ydCgpO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShjMTRuQ2FwYWJpbGl0eSk7XG59XG5mdW5jdGlvbiBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZChhdXRoT3B0aW9ucywgbG9nZ2VyKSB7XG4gIGlmIChhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFja1wiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsXCIpO1xuICB9IGVsc2UgaWYgKGF1dGhPcHRpb25zLmtleSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZ1wiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIHN1cHBsaWVkIHRva2VuIG9ubHlcIik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gXCJhdXRoT3B0aW9ucyBtdXN0IGluY2x1ZGUgdmFsaWQgYXV0aGVudGljYXRpb24gcGFyYW1ldGVyc1wiO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoKClcIiwgbXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFwidXNlVG9rZW5BdXRoXCIgaW4gb3B0aW9ucyAmJiAhb3B0aW9ucy51c2VUb2tlbkF1dGg7XG59XG5mdW5jdGlvbiB1c2VUb2tlbkF1dGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy51c2VUb2tlbkF1dGggfHwgIWJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSAmJiAob3B0aW9ucy5hdXRoQ2FsbGJhY2sgfHwgb3B0aW9ucy5hdXRoVXJsIHx8IG9wdGlvbnMudG9rZW4gfHwgb3B0aW9ucy50b2tlbkRldGFpbHMpO1xufVxuZnVuY3Rpb24gbm9XYXlUb1JlbmV3KG9wdGlvbnMpIHtcbiAgcmV0dXJuICFvcHRpb25zLmtleSAmJiAhb3B0aW9ucy5hdXRoQ2FsbGJhY2sgJiYgIW9wdGlvbnMuYXV0aFVybDtcbn1cbnZhciB0cklkID0gMDtcbmZ1bmN0aW9uIGdldFRva2VuUmVxdWVzdElkKCkge1xuICByZXR1cm4gdHJJZCsrO1xufVxudmFyIEF1dGggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgb3B0aW9ucykge1xuICAgIC8vIFRoaXMgaW5pdGlhbGl6YXRpb24gaXMgYWx3YXlzIG92ZXJ3cml0dGVuIGFuZCBvbmx5IHVzZWQgdG8gcHJldmVudCBhIFR5cGVTY3JpcHQgY29tcGlsZXIgZXJyb3JcbiAgICB0aGlzLmF1dGhPcHRpb25zID0ge307XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy50b2tlblBhcmFtcyA9IG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zIHx8IHt9O1xuICAgIHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuICAgIGlmICh1c2VUb2tlbkF1dGgob3B0aW9ucykpIHtcbiAgICAgIGlmIChub1dheVRvUmVuZXcob3B0aW9ucykpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkF1dGgoKVwiLFxuICAgICAgICAgIFwiV2FybmluZzogbGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHBcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyhvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcywgb3B0aW9ucyk7XG4gICAgICBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb3B0aW9ucy5rZXkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJObyBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHByb3ZpZGVkOyBuZWVkIG9uZSBvZjoga2V5LCBhdXRoVXJsLCBvciBhdXRoQ2FsbGJhY2sgKG9yIGZvciB0ZXN0aW5nIG9ubHksIHRva2VuIG9yIHRva2VuRGV0YWlscylcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aCgpXCIsIG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8obXNnLCA0MDE2MCwgNDAxKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcImFub255bW91cywgdXNpbmcgYmFzaWMgYXV0aFwiKTtcbiAgICAgIHRoaXMuX3NhdmVCYXNpY09wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBhc3luYyBhdXRob3JpemUodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLmtleSAmJiB0aGlzLmF1dGhPcHRpb25zLmtleSAhPT0gYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHVwZGF0ZSBhdXRoIG9wdGlvbnMgd2l0aCBpbmNvbXBhdGlibGUga2V5XCIsIDQwMTAyLCA0MDEpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHRva2VuRGV0YWlscyA9IGF3YWl0IHRoaXMuX2ZvcmNlTmV3VG9rZW4odG9rZW5QYXJhbXMgIT0gbnVsbCA/IHRva2VuUGFyYW1zIDogbnVsbCwgYXV0aE9wdGlvbnMgIT0gbnVsbCA/IGF1dGhPcHRpb25zIDogbnVsbCk7XG4gICAgICBpZiAoaXNSZWFsdGltZSh0aGlzLmNsaWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoXG4gICAgICAgICAgICB0b2tlbkRldGFpbHMsXG4gICAgICAgICAgICAoZXJyLCB0b2tlbkRldGFpbHMyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUodG9rZW5EZXRhaWxzMilcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbkRldGFpbHM7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5jbGllbnQuY29ubmVjdGlvbiAmJiBlcnIuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgLyogRm9yIGludGVybmFsIHVzZSwgZWcgYnkgY29ubmVjdGlvbk1hbmFnZXIgLSB1c2VmdWwgd2hlbiB3YW50IHRvIGNhbGwgYmFja1xuICAgKiBhcyBzb29uIGFzIHdlIGhhdmUgdGhlIG5ldyB0b2tlbiwgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgaXQgdG8gdGFrZVxuICAgKiBlZmZlY3Qgb24gdGhlIGNvbm5lY3Rpb24gYXMgI2F1dGhvcml6ZSBkb2VzICovXG4gIGFzeW5jIF9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucyk7XG4gICAgbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucywgdGhpcy5sb2dnZXIpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHModHJ1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRva2VuUGFyYW1zLnRpbWVzdGFtcDtcbiAgICAgIGRlbGV0ZSB0aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFRva2VuKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIGNvbnN0IHJlc29sdmVkQXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuICAgIGNvbnN0IHJlc29sdmVkVG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCBjb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuICAgIGxldCB0b2tlblJlcXVlc3RDYWxsYmFjaywgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFja1wiKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2s7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybFwiKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gKHBhcmFtcywgY2IpID0+IHtcbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBtaXhpbihcbiAgICAgICAgICB7IGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluXCIgfSxcbiAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhIZWFkZXJzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHVzZVBvc3QgPSByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhNZXRob2QgJiYgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoTWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwicG9zdFwiO1xuICAgICAgICBsZXQgcHJvdmlkZWRRc1BhcmFtcztcbiAgICAgICAgY29uc3QgcXVlcnlJZHggPSByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwuaW5kZXhPZihcIj9cIik7XG4gICAgICAgIGlmIChxdWVyeUlkeCA+IC0xKSB7XG4gICAgICAgICAgcHJvdmlkZWRRc1BhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKHF1ZXJ5SWR4KSk7XG4gICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKDAsIHF1ZXJ5SWR4KTtcbiAgICAgICAgICBpZiAoIXVzZVBvc3QpIHtcbiAgICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFBhcmFtcyA9IG1peGluKFxuICAgICAgICAgICAgICBwcm92aWRlZFFzUGFyYW1zLFxuICAgICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhQYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhQYXJhbXMgPSBtaXhpbih7fSwgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoUGFyYW1zIHx8IHt9LCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrID0gKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICAgIGxldCBib2R5ID0gKF9hMiA9IHJlc3VsdC5ib2R5KSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgICAgICAgICBsZXQgY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlSGVhZGVyT3JIZWFkZXJzID0gKF9iID0gcmVzdWx0LmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycykpIHtcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycy5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlSGVhZGVyT3JIZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZDsgY29udGVudC10eXBlOiBcIiArIGNvbnRlbnRUeXBlICsgXCI7IGJvZHk6IFwiICsgaW5zcGVjdEJvZHkoYm9keSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGNiKHJlc3VsdC5lcnJvciwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQudW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpXG4gICAgICAgICAgICBib2R5ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvckluZm8oXCJhdXRoVXJsIHJlc3BvbnNlIGlzIG1pc3NpbmcgYSBjb250ZW50LXR5cGUgaGVhZGVyXCIsIDQwMTcwLCA0MDEpLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QganNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID4gLTEsIHRleHQgPSBjb250ZW50VHlwZS5pbmRleE9mKFwidGV4dC9wbGFpblwiKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qd3RcIikgPiAtMTtcbiAgICAgICAgICBpZiAoIWpzb24gJiYgIXRleHQpIHtcbiAgICAgICAgICAgIGNiKFxuICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIFwiYXV0aFVybCByZXNwb25kZWQgd2l0aCB1bmFjY2VwdGFibGUgY29udGVudC10eXBlIFwiICsgY29udGVudFR5cGUgKyBcIiwgc2hvdWxkIGJlIGVpdGhlciB0ZXh0L3BsYWluLCBhcHBsaWNhdGlvbi9qd3Qgb3IgYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuICAgICAgICAgICAgICBjYihuZXcgRXJyb3JJbmZvKFwiYXV0aFVybCByZXNwb25zZSBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aFwiLCA0MDE3MCwgNDAxKSwgbnVsbCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjYihcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGVycm9yIHByb2Nlc3NpbmcgYXV0aFVSTCByZXNwb25zZTsgZXJyID0gXCIgKyBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNiKG51bGwsIGJvZHksIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2tcIixcbiAgICAgICAgICBcIlJlcXVlc3RpbmcgdG9rZW4gZnJvbSBcIiArIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCArIFwiOyBQYXJhbXM6IFwiICsgSlNPTi5zdHJpbmdpZnkoYXV0aFBhcmFtcykgKyBcIjsgbWV0aG9kOiBcIiArICh1c2VQb3N0ID8gXCJQT1NUXCIgOiBcIkdFVFwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodXNlUG9zdCkge1xuICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhdXRoSGVhZGVycyB8fCB7fTtcbiAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbiAgICAgICAgICBjb25zdCBib2R5ID0gdG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTtcbiAgICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgICB0aGlzLmNsaWVudC5odHRwLmRvVXJpKFxuICAgICAgICAgICAgICBIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsXG4gICAgICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCxcbiAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgcHJvdmlkZWRRc1BhcmFtc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gYXV0aFVybFJlcXVlc3RDYWxsYmFjayhlcnIpIDogYXV0aFVybFJlcXVlc3RDYWxsYmFjayhyZXN1bHQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgICB0aGlzLmNsaWVudC5odHRwLmRvVXJpKEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwsIGF1dGhIZWFkZXJzIHx8IHt9LCBudWxsLCBhdXRoUGFyYW1zKSxcbiAgICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gYXV0aFVybFJlcXVlc3RDYWxsYmFjayhlcnIpIDogYXV0aFVybFJlcXVlc3RDYWxsYmFjayhyZXN1bHQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLFxuICAgICAgICBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nXCJcbiAgICAgICk7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IChwYXJhbXMsIGNiKSA9PiB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VuUmVxdWVzdChwYXJhbXMsIHJlc29sdmVkQXV0aE9wdGlvbnMpLFxuICAgICAgICAgIChlcnIsIHJlc3VsdCkgPT4gY2IoZXJyLCByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IG51bGwpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBcIk5lZWQgYSBuZXcgdG9rZW4sIGJ1dCBhdXRoT3B0aW9ucyBkb2VzIG5vdCBpbmNsdWRlIGFueSB3YXkgdG8gcmVxdWVzdCBvbmUgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KVwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkF1dGgoKVwiLFxuICAgICAgICBcImxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwXCJcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzEsIDQwMyk7XG4gICAgfVxuICAgIGlmIChcImNhcGFiaWxpdHlcIiBpbiByZXNvbHZlZFRva2VuUGFyYW1zKVxuICAgICAgcmVzb2x2ZWRUb2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bihcbiAgICAgICAgcmVzb2x2ZWRUb2tlblBhcmFtcy5jYXBhYmlsaXR5XG4gICAgICApO1xuICAgIGNvbnN0IHRva2VuUmVxdWVzdCA9IChzaWduZWRUb2tlblBhcmFtcywgdG9rZW5DYikgPT4ge1xuICAgICAgY29uc3Qga2V5TmFtZSA9IHNpZ25lZFRva2VuUGFyYW1zLmtleU5hbWUsIHBhdGggPSBcIi9rZXlzL1wiICsga2V5TmFtZSArIFwiL3JlcXVlc3RUb2tlblwiLCB0b2tlblVyaSA9IGZ1bmN0aW9uKGhvc3QpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5iYXNlVXJpKGhvc3QpICsgcGF0aDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpO1xuICAgICAgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpXG4gICAgICAgIG1peGluKHJlcXVlc3RIZWFkZXJzLCByZXNvbHZlZEF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnJlcXVlc3RUb2tlblwiLFxuICAgICAgICBcIlNlbmRpbmcgUE9TVCB0byBcIiArIHBhdGggKyBcIjsgVG9rZW4gcGFyYW1zOiBcIiArIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKVxuICAgICAgKTtcbiAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIHRva2VuVXJpLCByZXF1ZXN0SGVhZGVycywgSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpLCBudWxsKSxcbiAgICAgICAgKGVyciwgcmVzdWx0KSA9PiBlcnIgPyB0b2tlbkNiKGVycikgOiB0b2tlbkNiKHJlc3VsdC5lcnJvciwgcmVzdWx0LmJvZHksIHJlc3VsdC51bnBhY2tlZClcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSBmYWxzZSwgdGltZW91dExlbmd0aCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCwgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBtc2cgPSBcIlRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZW91dExlbmd0aCAvIDFlMyArIFwiIHNlY29uZHNcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBtc2cpO1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgIH0sIHRpbWVvdXRMZW5ndGgpO1xuICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2socmVzb2x2ZWRUb2tlblBhcmFtcywgKGVyciwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBjb250ZW50VHlwZSkgPT4ge1xuICAgICAgICBpZiAodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsZWFyVGltZW91dCh0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgICAgIFwidG9rZW4gcmVxdWVzdCBzaWduaW5nIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlamVjdChub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUb2tlbiBzdHJpbmcgaXMgZW1wdHlcIiwgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcIlRva2VuIHN0cmluZyBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCAod2FzIFwiICsgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCArIFwiIGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSBcInVuZGVmaW5lZFwiIHx8IHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVG9rZW4gc3RyaW5nIHdhcyBsaXRlcmFsIG51bGwvdW5kZWZpbmVkXCIsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlsc1swXSA9PT0gXCJ7XCIgJiYgIShjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vand0XCIpID4gLTEpKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJUb2tlbiB3YXMgZG91YmxlLWVuY29kZWQ7IG1ha2Ugc3VyZSB5b3UncmUgbm90IEpTT04tZW5jb2RpbmcgYW4gYWxyZWFkeSBlbmNvZGVkIHRva2VuIHJlcXVlc3Qgb3IgZGV0YWlsc1wiLFxuICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgdG9rZW46IHRva2VuUmVxdWVzdE9yRGV0YWlscyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzICE9PSBcIm9iamVjdFwiIHx8IHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IFwiRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZyBvciB0b2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0LCBidXQgZ290IGEgXCIgKyB0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqZWN0U2l6ZSA9IEpTT04uc3RyaW5naWZ5KHRva2VuUmVxdWVzdE9yRGV0YWlscykubGVuZ3RoO1xuICAgICAgICBpZiAob2JqZWN0U2l6ZSA+IE1BWF9UT0tFTl9MRU5HVEggJiYgIXJlc29sdmVkQXV0aE9wdGlvbnMuc3VwcHJlc3NNYXhMZW5ndGhDaGVjaykge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgIFwiVG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCBleGNlZWRlZCBtYXggcGVybWl0dGVkIHN0cmluZ2lmaWVkIHNpemUgKHdhcyBcIiArIG9iamVjdFNpemUgKyBcIiBieXRlcylcIixcbiAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgIDQwMVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImlzc3VlZFwiIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykge1xuICAgICAgICAgIHJlc29sdmUodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJrZXlOYW1lXCIgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IFwiRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0XCI7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBtc2cpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0b2tlblJlcXVlc3QodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCAoZXJyMiwgdG9rZW5SZXNwb25zZSwgdW5wYWNrZWQpID0+IHtcbiAgICAgICAgICBpZiAoZXJyMikge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgICAgICAgXCJ0b2tlbiByZXF1ZXN0IEFQSSBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlamVjdChub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIyKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdW5wYWNrZWQpXG4gICAgICAgICAgICB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLmdldFRva2VuKClcIiwgXCJ0b2tlbiByZWNlaXZlZFwiKTtcbiAgICAgICAgICByZXNvbHZlKHRva2VuUmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHNpZ24gYSB0b2tlbiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBOT1RFIHRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHRoZSBrZXkgdmFsdWUgaXMgYXZhaWxhYmxlIGxvY2FsbHkuXG4gICAqIE90aGVyd2lzZSwgc2lnbmVkIHRva2VuIHJlcXVlc3RzIG11c3QgYmUgb2J0YWluZWQgZnJvbSB0aGUga2V5XG4gICAqIG93bmVyIChlaXRoZXIgdXNpbmcgdGhlIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgb3IgdXJsKS5cbiAgICpcbiAgICogQHBhcmFtIGF1dGhPcHRpb25zXG4gICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XG4gICAqIC0ga2V5OiAgICAgICAgICAgdGhlIGtleSB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQsIGEga2V5IHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmdcbiAgICogICAgICAgICAgICAgICAgICB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG4gICAqXG4gICAqIC0gcXVlcnlUaW1lICAgICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYWJseSBzeXN0ZW0gc2hvdWxkIGJlXG4gICAqICAgICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHlcbiAgICpcbiAgICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW5QYXJhbXNcbiAgICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG4gICAqIC0gdHRsOiAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbXMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG4gICAqICAgICAgICAgICAgICAgICAgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWUgaXMgMjRob3VyczsgYW55IHJlcXVlc3RcbiAgICogICAgICAgICAgICAgICAgICBleGNlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG4gICAqXG4gICAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuICAgKiAgICAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICpcbiAgICogLSBjbGllbnRJZDogICAgICAob3B0aW9uYWwpIGEgY2xpZW50IElEIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlbjsgaWYgbm90XG4gICAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgKlxuICAgKiAtIHRpbWVzdGFtcDogICAgIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcbiAgICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRva2VuUmVxdWVzdCh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICBhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG4gICAgdG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCBjb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuICAgIGNvbnN0IGtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIk5vIGtleSBzcGVjaWZpZWRcIiwgNDAxMDEsIDQwMyk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhcnRzID0ga2V5LnNwbGl0KFwiOlwiKSwga2V5TmFtZSA9IGtleVBhcnRzWzBdLCBrZXlTZWNyZXQgPSBrZXlQYXJ0c1sxXTtcbiAgICBpZiAoIWtleVNlY3JldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkludmFsaWQga2V5IHNwZWNpZmllZFwiLCA0MDEwMSwgNDAzKTtcbiAgICB9XG4gICAgaWYgKHRva2VuUGFyYW1zLmNsaWVudElkID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgY2FuXFx1MjAxOXQgYmUgYW4gZW1wdHkgc3RyaW5nXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICBpZiAoXCJjYXBhYmlsaXR5XCIgaW4gdG9rZW5QYXJhbXMpIHtcbiAgICAgIHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKHRva2VuUGFyYW1zLmNhcGFiaWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gbWl4aW4oeyBrZXlOYW1lIH0sIHRva2VuUGFyYW1zKSwgY2xpZW50SWQgPSB0b2tlblBhcmFtcy5jbGllbnRJZCB8fCBcIlwiLCB0dGwgPSB0b2tlblBhcmFtcy50dGwgfHwgXCJcIiwgY2FwYWJpbGl0eSA9IHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgfHwgXCJcIjtcbiAgICBpZiAoIXJlcXVlc3QudGltZXN0YW1wKSB7XG4gICAgICByZXF1ZXN0LnRpbWVzdGFtcCA9IGF3YWl0IHRoaXMuZ2V0VGltZXN0YW1wKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLnF1ZXJ5VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IG5vbmNlID0gcmVxdWVzdC5ub25jZSB8fCAocmVxdWVzdC5ub25jZSA9IHJhbmRvbSgpKSwgdGltZXN0YW1wID0gcmVxdWVzdC50aW1lc3RhbXA7XG4gICAgY29uc3Qgc2lnblRleHQgPSByZXF1ZXN0LmtleU5hbWUgKyBcIlxcblwiICsgdHRsICsgXCJcXG5cIiArIGNhcGFiaWxpdHkgKyBcIlxcblwiICsgY2xpZW50SWQgKyBcIlxcblwiICsgdGltZXN0YW1wICsgXCJcXG5cIiArIG5vbmNlICsgXCJcXG5cIjtcbiAgICByZXF1ZXN0Lm1hYyA9IHJlcXVlc3QubWFjIHx8IGhtYWMoc2lnblRleHQsIGtleVNlY3JldCk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5nZXRUb2tlblJlcXVlc3QoKVwiLCBcImdlbmVyYXRlZCBzaWduZWQgcmVxdWVzdFwiKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhdXRoIHF1ZXJ5IHBhcmFtcyB0byB1c2UgZm9yIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24sXG4gICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0QXV0aFBhcmFtcygpIHtcbiAgICBpZiAodGhpcy5tZXRob2QgPT0gXCJiYXNpY1wiKVxuICAgICAgcmV0dXJuIHsga2V5OiB0aGlzLmtleSB9O1xuICAgIGVsc2Uge1xuICAgICAgbGV0IHRva2VuRGV0YWlscyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlKTtcbiAgICAgIGlmICghdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGguZ2V0QXV0aFBhcmFtcygpOiBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgcmV0dXJuZWQgbm8gZXJyb3Igb3IgdG9rZW5EZXRhaWxzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgYWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW4gfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXIgdG8gdXNlIGZvciBhIFJFU1Qgb3IgY29tZXQgcmVxdWVzdCxcbiAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRBdXRoSGVhZGVycygpIHtcbiAgICBpZiAodGhpcy5tZXRob2QgPT0gXCJiYXNpY1wiKSB7XG4gICAgICByZXR1cm4geyBhdXRob3JpemF0aW9uOiBcIkJhc2ljIFwiICsgdGhpcy5iYXNpY0tleSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b2tlbkRldGFpbHMgPSBhd2FpdCB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSk7XG4gICAgICBpZiAoIXRva2VuRGV0YWlscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRoLmdldEF1dGhQYXJhbXMoKTogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIHJldHVybmVkIG5vIGVycm9yIG9yIHRva2VuRGV0YWlsc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGF1dGhvcml6YXRpb246IFwiQmVhcmVyIFwiICsgdG9CYXNlNjQodG9rZW5EZXRhaWxzLnRva2VuKSB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHRpbWUgYmFzZWQgb24gdGhlIGxvY2FsIGNsb2NrLFxuICAgKiBvciBpZiB0aGUgb3B0aW9uIHF1ZXJ5VGltZSBpcyB0cnVlLCByZXR1cm4gdGhlIHNlcnZlciB0aW1lLlxuICAgKiBUaGUgc2VydmVyIHRpbWUgb2Zmc2V0IGZyb20gdGhlIGxvY2FsIHRpbWUgaXMgc3RvcmVkIHNvIHRoYXRcbiAgICogb25seSBvbmUgcmVxdWVzdCB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgdGltZSBpcyBldmVyIG5lZWRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0VGltZXN0YW1wKHF1ZXJ5VGltZSkge1xuICAgIGlmICghdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSAmJiAocXVlcnlUaW1lIHx8IHRoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnRpbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCkgKyAodGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCB8fCAwKTtcbiAgfVxuICBpc1RpbWVPZmZzZXRTZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQgIT09IG51bGw7XG4gIH1cbiAgX3NhdmVCYXNpY09wdGlvbnMoYXV0aE9wdGlvbnMpIHtcbiAgICB0aGlzLm1ldGhvZCA9IFwiYmFzaWNcIjtcbiAgICB0aGlzLmtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICB0aGlzLmJhc2ljS2V5ID0gdG9CYXNlNjQoYXV0aE9wdGlvbnMua2V5KTtcbiAgICB0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwge307XG4gICAgaWYgKFwiY2xpZW50SWRcIiBpbiBhdXRoT3B0aW9ucykge1xuICAgICAgdGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcbiAgICB9XG4gIH1cbiAgX3NhdmVUb2tlbk9wdGlvbnModG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgdGhpcy5tZXRob2QgPSBcInRva2VuXCI7XG4gICAgaWYgKHRva2VuUGFyYW1zKSB7XG4gICAgICB0aGlzLnRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXM7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucykge1xuICAgICAgaWYgKGF1dGhPcHRpb25zLnRva2VuKSB7XG4gICAgICAgIGF1dGhPcHRpb25zLnRva2VuRGV0YWlscyA9IHR5cGVvZiBhdXRoT3B0aW9ucy50b2tlbiA9PT0gXCJzdHJpbmdcIiA/IHsgdG9rZW46IGF1dGhPcHRpb25zLnRva2VuIH0gOiBhdXRoT3B0aW9ucy50b2tlbjtcbiAgICAgIH1cbiAgICAgIGlmIChhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50b2tlbkRldGFpbHMgPSBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHM7XG4gICAgICB9XG4gICAgICBpZiAoXCJjbGllbnRJZFwiIGluIGF1dGhPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnM7XG4gICAgfVxuICB9XG4gIC8qIEBwYXJhbSBmb3JjZVN1cGVyc2VkZTogZm9yY2UgYSBuZXcgdG9rZW4gcmVxdWVzdCBldmVuIGlmIHRoZXJlJ3Mgb25lIGluXG4gICAqIHByb2dyZXNzLCBtYWtpbmcgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIHdhaXQgZm9yIHRoZSBuZXcgb25lICovXG4gIGFzeW5jIF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmb3JjZVN1cGVyc2VkZSkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbkRldGFpbHM7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKHRva2VuLmNsaWVudElkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwiTWlzbWF0Y2ggYmV0d2VlbiBjbGllbnRJZCBpbiB0b2tlbiAoXCIgKyB0b2tlbi5jbGllbnRJZCArIFwiKSBhbmQgY3VycmVudCBjbGllbnRJZCAoXCIgKyB0aGlzLmNsaWVudElkICsgXCIpXCIsXG4gICAgICAgICAgNDAxMDIsXG4gICAgICAgICAgNDAzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNUaW1lT2Zmc2V0U2V0KCkgfHwgIXRva2VuLmV4cGlyZXMgfHwgdG9rZW4uZXhwaXJlcyA+PSB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkF1dGguZ2V0VG9rZW4oKVwiLFxuICAgICAgICAgIFwidXNpbmcgY2FjaGVkIHRva2VuOyBleHBpcmVzID0gXCIgKyB0b2tlbi5leHBpcmVzXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGguZ2V0VG9rZW4oKVwiLCBcImRlbGV0aW5nIGV4cGlyZWQgdG9rZW5cIik7XG4gICAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSAodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBtdWx0aWNhc3Rlcl9kZWZhdWx0LmNyZWF0ZSh0aGlzLmxvZ2dlcikpKS5jcmVhdGVQcm9taXNlKCk7XG4gICAgaWYgKHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkICE9PSBudWxsICYmICFmb3JjZVN1cGVyc2VkZSkge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuUmVxdWVzdElkID0gdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBnZXRUb2tlblJlcXVlc3RJZCgpO1xuICAgIGxldCB0b2tlblJlc3BvbnNlLCBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHRva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RUb2tlbih0aGlzLnRva2VuUGFyYW1zLCB0aGlzLmF1dGhPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhdWdodEVycm9yID0gZXJyO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPiB0b2tlblJlcXVlc3RJZCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkF1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKClcIixcbiAgICAgICAgXCJEaXNjYXJkaW5nIHRva2VuIHJlcXVlc3QgcmVzcG9uc2U7IG92ZXJ0YWtlbiBieSBuZXdlciBvbmVcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgY29uc3QgbXVsdGljYXN0ZXIgPSB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3Q7XG4gICAgdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIG11bHRpY2FzdGVyID09IG51bGwgPyB2b2lkIDAgOiBtdWx0aWNhc3Rlci5yZWplY3RBbGwoY2F1Z2h0RXJyb3IpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIG11bHRpY2FzdGVyID09IG51bGwgPyB2b2lkIDAgOiBtdWx0aWNhc3Rlci5yZXNvbHZlQWxsKHRoaXMudG9rZW5EZXRhaWxzID0gdG9rZW5SZXNwb25zZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyogVXNlci1zZXQ6IGNoZWNrIHR5cGVzLCAnKicgaXMgZGlzYWxsb3dlZCwgdGhyb3cgYW55IGVycm9ycyAqL1xuICBfdXNlclNldENsaWVudElkKGNsaWVudElkKSB7XG4gICAgaWYgKCEodHlwZW9mIGNsaWVudElkID09PSBcInN0cmluZ1wiIHx8IGNsaWVudElkID09PSBudWxsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfSBlbHNlIGlmIChjbGllbnRJZCA9PT0gXCIqXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICdDYW5cXHUyMDE5dCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgaW5zdGFudGlhdGUgdGhlIGxpYnJhcnkgd2l0aCB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pLCBvciBpZiBjYWxsaW5nIGF1dGhvcml6ZSgpLCBwYXNzIGl0IGluIGFzIGEgdG9rZW5QYXJhbTogYXV0aG9yaXplKHtjbGllbnRJZDogXCIqXCJ9LCBhdXRoT3B0aW9ucyknLFxuICAgICAgICA0MDAxMixcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG4gICAgICBpZiAoZXJyKVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIC8qIEFibHktc2V0OiBubyB0eXBlY2hlY2tpbmcsICcqJyBpcyBhbGxvd2VkIGJ1dCBub3Qgc2V0IG9uIHRoaXMuY2xpZW50SWQpLCByZXR1cm4gZXJyb3JzIHRvIHRoZSBjYWxsZXIgKi9cbiAgX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKSB7XG4gICAgaWYgKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaChjbGllbnRJZCkpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiVW5leHBlY3RlZCBjbGllbnRJZCBtaXNtYXRjaDogY2xpZW50IGhhcyBcIiArIHRoaXMuY2xpZW50SWQgKyBcIiwgcmVxdWVzdGVkIFwiICsgY2xpZW50SWQ7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKG1zZywgNDAxMDIsIDQwMSk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZCgpXCIsIG1zZyk7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsaWVudElkID0gdGhpcy50b2tlblBhcmFtcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIF90b2tlbkNsaWVudElkTWlzbWF0Y2godG9rZW5DbGllbnRJZCkge1xuICAgIHJldHVybiAhISh0aGlzLmNsaWVudElkICYmIHRoaXMuY2xpZW50SWQgIT09IFwiKlwiICYmIHRva2VuQ2xpZW50SWQgJiYgdG9rZW5DbGllbnRJZCAhPT0gXCIqXCIgJiYgdGhpcy5jbGllbnRJZCAhPT0gdG9rZW5DbGllbnRJZCk7XG4gIH1cbiAgc3RhdGljIGlzVG9rZW5FcnIoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSAmJiBlcnJvci5jb2RlID49IDQwMTQwICYmIGVycm9yLmNvZGUgPCA0MDE1MDtcbiAgfVxuICByZXZva2VUb2tlbnMoc3BlY2lmaWVycywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LnJldm9rZVRva2VucyhzcGVjaWZpZXJzLCBvcHRpb25zKTtcbiAgfVxufTtcbnZhciBhdXRoX2RlZmF1bHQgPSBBdXRoO1xuXG4vLyBzcmMvY29tbW9uL3R5cGVzL2h0dHAudHNcbmZ1bmN0aW9uIHBhcmFtU3RyaW5nKHBhcmFtcykge1xuICBjb25zdCBwYXJhbVBhaXJzID0gW107XG4gIGlmIChwYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IG5lZWRsZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtUGFpcnMucHVzaChuZWVkbGUgKyBcIj1cIiArIHBhcmFtc1tuZWVkbGVdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtUGFpcnMuam9pbihcIiZcIik7XG59XG5mdW5jdGlvbiBhcHBlbmRpbmdQYXJhbXModXJpLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHVyaSArIChwYXJhbXMgPyBcIj9cIiA6IFwiXCIpICsgcGFyYW1TdHJpbmcocGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGxvZ1Jlc3VsdChyZXN1bHQsIG1ldGhvZCwgdXJpLCBwYXJhbXMsIGxvZ2dlcikge1xuICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiSHR0cC5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQgRXJyb3I7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IocmVzdWx0LmVycm9yKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiSHR0cC5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQ7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBIZWFkZXJzOiBcIiArIHBhcmFtU3RyaW5nKHJlc3VsdC5oZWFkZXJzKSArIFwiOyBTdGF0dXNDb2RlOiBcIiArIHJlc3VsdC5zdGF0dXNDb2RlICsgXCI7IEJvZHlcIiArIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihyZXN1bHQuYm9keSkgPyBcIiAoQmFzZTY0KTogXCIgKyBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUocmVzdWx0LmJvZHkpIDogXCI6IFwiICsgcmVzdWx0LmJvZHkpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbG9nUmVxdWVzdChtZXRob2QsIHVyaSwgYm9keSwgcGFyYW1zLCBsb2dnZXIpIHtcbiAgaWYgKGxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlNlbmRpbmc7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSArIFwiOyBCb2R5XCIgKyAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkgPyBcIiAoQmFzZTY0KTogXCIgKyBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoYm9keSkgOiBcIjogXCIgKyBib2R5KVxuICAgICk7XG4gIH1cbn1cbnZhciBIdHRwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnBsYXRmb3JtSHR0cCA9IG5ldyBQbGF0Zm9ybS5IdHRwKGNsaWVudCk7XG4gICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IHRoaXMucGxhdGZvcm1IdHRwLmNoZWNrQ29ubmVjdGl2aXR5ID8gKCkgPT4gdGhpcy5wbGF0Zm9ybUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKSA6IHZvaWQgMDtcbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EyID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9nZ2VyKSAhPSBudWxsID8gX2IgOiBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyO1xuICB9XG4gIGdldCBzdXBwb3J0c0F1dGhIZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXRmb3JtSHR0cC5zdXBwb3J0c0F1dGhIZWFkZXJzO1xuICB9XG4gIGdldCBzdXBwb3J0c0xpbmtIZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXRmb3JtSHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzO1xuICB9XG4gIF9nZXRIb3N0cyhjbGllbnQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gY2xpZW50LmNvbm5lY3Rpb24sIGNvbm5lY3Rpb25Ib3N0ID0gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmhvc3Q7XG4gICAgaWYgKGNvbm5lY3Rpb25Ib3N0KSB7XG4gICAgICByZXR1cm4gW2Nvbm5lY3Rpb25Ib3N0XS5jb25jYXQoZGVmYXVsdHNfZGVmYXVsdC5nZXRGYWxsYmFja0hvc3RzKGNsaWVudC5vcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0c19kZWZhdWx0LmdldEhvc3RzKGNsaWVudC5vcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBub3QgdGhyb3cgYW55IGVycm9yczsgcmF0aGVyLCBpdCB3aWxsIGNvbW11bmljYXRlIGFueSBlcnJvciBieSBwb3B1bGF0aW5nIHRoZSB7QGxpbmsgUmVxdWVzdFJlc3VsdC5lcnJvcn0gcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIHtAbGluayBSZXF1ZXN0UmVzdWx0fS5cbiAgICovXG4gIGFzeW5jIGRvKG1ldGhvZCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBFcnJvckluZm8oXCJodHRwLmRvIGNhbGxlZCB3aXRob3V0IGNsaWVudFwiLCA1ZTQsIDUwMCkgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVyaUZyb21Ib3N0ID0gdHlwZW9mIHBhdGggPT09IFwiZnVuY3Rpb25cIiA/IHBhdGggOiBmdW5jdGlvbihob3N0KSB7XG4gICAgICAgIHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICB9O1xuICAgICAgY29uc3QgY3VycmVudEZhbGxiYWNrID0gY2xpZW50Ll9jdXJyZW50RmFsbGJhY2s7XG4gICAgICBpZiAoY3VycmVudEZhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjdXJyZW50RmFsbGJhY2sudmFsaWRVbnRpbCA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRvVXJpKG1ldGhvZCwgdXJpRnJvbUhvc3QoY3VycmVudEZhbGxiYWNrLmhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IgJiYgdGhpcy5wbGF0Zm9ybUh0dHAuc2hvdWxkRmFsbGJhY2socmVzdWx0LmVycm9yKSkge1xuICAgICAgICAgICAgY2xpZW50Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG8obWV0aG9kLCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaG9zdHMgPSB0aGlzLl9nZXRIb3N0cyhjbGllbnQpO1xuICAgICAgaWYgKGhvc3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGhvc3RzWzBdKSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGxldCB0cnlBSG9zdFN0YXJ0ZWRBdCA9IG51bGw7XG4gICAgICBjb25zdCB0cnlBSG9zdCA9IGFzeW5jIChjYW5kaWRhdGVIb3N0cywgcGVyc2lzdE9uU3VjY2VzcykgPT4ge1xuICAgICAgICBjb25zdCBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcbiAgICAgICAgdHJ5QUhvc3RTdGFydGVkQXQgPSB0cnlBSG9zdFN0YXJ0ZWRBdCAhPSBudWxsID8gdHJ5QUhvc3RTdGFydGVkQXQgOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yICYmIHRoaXMucGxhdGZvcm1IdHRwLnNob3VsZEZhbGxiYWNrKHJlc3VsdC5lcnJvcikgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gdHJ5QUhvc3RTdGFydGVkQXQuZ2V0VGltZSgpO1xuICAgICAgICAgIGlmIChlbGFwc2VkVGltZSA+IGNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmh0dHBNYXhSZXRyeUR1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBgVGltZW91dCBmb3IgdHJ5aW5nIGZhbGxiYWNrIGhvc3RzIHJldHJpZXMuIFRvdGFsIGVsYXBzZWQgdGltZSBleGNlZWRlZCB0aGUgJHtjbGllbnQub3B0aW9ucy50aW1lb3V0cy5odHRwTWF4UmV0cnlEdXJhdGlvbn1tcyBsaW1pdGAsXG4gICAgICAgICAgICAgICAgNTAwMDMsXG4gICAgICAgICAgICAgICAgNTAwXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnlBSG9zdChjYW5kaWRhdGVIb3N0cywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcnNpc3RPblN1Y2Nlc3MpIHtcbiAgICAgICAgICBjbGllbnQuX2N1cnJlbnRGYWxsYmFjayA9IHtcbiAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICB2YWxpZFVudGlsOiBEYXRlLm5vdygpICsgY2xpZW50Lm9wdGlvbnMudGltZW91dHMuZmFsbGJhY2tSZXRyeVRpbWVvdXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyeUFIb3N0KGhvc3RzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgRXJyb3JJbmZvKGBVbmV4cGVjdGVkIGVycm9yIGluIEh0dHAuZG86ICR7aW5zcGVjdEVycm9yKGVycil9YCwgNTAwLCA1ZTQpIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIG5vdCB0aHJvdyBhbnkgZXJyb3JzOyByYXRoZXIsIGl0IHdpbGwgY29tbXVuaWNhdGUgYW55IGVycm9yIGJ5IHBvcHVsYXRpbmcgdGhlIHtAbGluayBSZXF1ZXN0UmVzdWx0LmVycm9yfSBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQge0BsaW5rIFJlcXVlc3RSZXN1bHR9LlxuICAgKi9cbiAgYXN5bmMgZG9VcmkobWV0aG9kLCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBsb2dSZXF1ZXN0KG1ldGhvZCwgdXJpLCBib2R5LCBwYXJhbXMsIHRoaXMubG9nZ2VyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGxhdGZvcm1IdHRwLmRvVXJpKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgIGxvZ1Jlc3VsdChyZXN1bHQsIG1ldGhvZCwgdXJpLCBwYXJhbXMsIHRoaXMubG9nZ2VyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogbmV3IEVycm9ySW5mbyhgVW5leHBlY3RlZCBlcnJvciBpbiBIdHRwLmRvVXJpOiAke2luc3BlY3RFcnJvcihlcnIpfWAsIDUwMCwgNWU0KSB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2Jhc2VjbGllbnQudHNcbnZhciBCYXNlQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogVGhlc2UgZXhwb3J0cyBhcmUgZm9yIHVzZSBieSBVTUQgcGx1Z2luczsgcmVhc29uIGJlaW5nIHNvIHRoYXQgY29uc3RydWN0b3JzIGFuZCBzdGF0aWMgbWV0aG9kcyBjYW4gYmUgYWNjZXNzZWQgYnkgdGhlc2UgcGx1Z2lucyB3aXRob3V0IG5lZWRpbmcgdG8gaW1wb3J0IHRoZSBjbGFzc2VzIGRpcmVjdGx5IGFuZCByZXN1bHQgaW4gdGhlIGNsYXNzIGV4aXN0aW5nIGluIGJvdGggdGhlIHBsdWdpbiBhbmQgdGhlIGNvcmUgbGlicmFyeS5cbiAgICAgKi9cbiAgICB0aGlzLlBsYXRmb3JtID0gUGxhdGZvcm07XG4gICAgdGhpcy5FcnJvckluZm8gPSBFcnJvckluZm87XG4gICAgdGhpcy5Mb2dnZXIgPSBsb2dnZXJfZGVmYXVsdDtcbiAgICB0aGlzLkRlZmF1bHRzID0gZGVmYXVsdHNfZGVmYXVsdDtcbiAgICB0aGlzLlV0aWxzID0gdXRpbHNfZXhwb3J0cztcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICB0aGlzLl9hZGRpdGlvbmFsSFRUUFJlcXVlc3RJbXBsZW1lbnRhdGlvbnMgPSAoX2EyID0gb3B0aW9ucy5wbHVnaW5zKSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgICB0aGlzLmxvZ2dlciA9IG5ldyBsb2dnZXJfZGVmYXVsdCgpO1xuICAgIHRoaXMubG9nZ2VyLnNldExvZyhvcHRpb25zLmxvZ0xldmVsLCBvcHRpb25zLmxvZ0hhbmRsZXIpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJCYXNlQ2xpZW50KClcIixcbiAgICAgIFwiaW5pdGlhbGl6ZWQgd2l0aCBjbGllbnRPcHRpb25zIFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3Qob3B0aW9ucylcbiAgICApO1xuICAgIHRoaXMuX01zZ1BhY2sgPSAoX2MgPSAoX2IgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5Nc2dQYWNrKSAhPSBudWxsID8gX2MgOiBudWxsO1xuICAgIGNvbnN0IG5vcm1hbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0c19kZWZhdWx0Lm5vcm1hbGlzZU9wdGlvbnMob3B0aW9ucywgdGhpcy5fTXNnUGFjaywgdGhpcy5sb2dnZXIpO1xuICAgIGlmIChub3JtYWxPcHRpb25zLmtleSkge1xuICAgICAgY29uc3Qga2V5TWF0Y2ggPSBub3JtYWxPcHRpb25zLmtleS5tYXRjaCgvXihbXjpcXHNdKyk6KFteOi5cXHNdKykkLyk7XG4gICAgICBpZiAoIWtleU1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiaW52YWxpZCBrZXkgcGFyYW1ldGVyXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkJhc2VDbGllbnQoKVwiLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDA0MDAsIDQwNCk7XG4gICAgICB9XG4gICAgICBub3JtYWxPcHRpb25zLmtleU5hbWUgPSBrZXlNYXRjaFsxXTtcbiAgICAgIG5vcm1hbE9wdGlvbnMua2V5U2VjcmV0ID0ga2V5TWF0Y2hbMl07XG4gICAgfVxuICAgIGlmIChcImNsaWVudElkXCIgaW4gbm9ybWFsT3B0aW9ucykge1xuICAgICAgaWYgKCEodHlwZW9mIG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IFwic3RyaW5nXCIgfHwgbm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gbnVsbCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsXCIsIDQwMDEyLCA0MDApO1xuICAgICAgZWxzZSBpZiAobm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gXCIqXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgJ0NhblxcdTIwMTl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCB1c2Uge2RlZmF1bHRUb2tlblBhcmFtczoge2NsaWVudElkOiBcIipcIn19KScsXG4gICAgICAgICAgNDAwMTIsXG4gICAgICAgICAgNDAwXG4gICAgICAgICk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkJhc2VDbGllbnQoKVwiLCBcInN0YXJ0ZWQ7IHZlcnNpb24gPSBcIiArIGRlZmF1bHRzX2RlZmF1bHQudmVyc2lvbik7XG4gICAgdGhpcy5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMuaHR0cCA9IG5ldyBIdHRwKHRoaXMpO1xuICAgIHRoaXMuYXV0aCA9IG5ldyBhdXRoX2RlZmF1bHQodGhpcywgbm9ybWFsT3B0aW9ucyk7XG4gICAgdGhpcy5fcmVzdCA9ICgoX2QgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5SZXN0KSA/IG5ldyBvcHRpb25zLnBsdWdpbnMuUmVzdCh0aGlzKSA6IG51bGw7XG4gICAgdGhpcy5fQ3J5cHRvID0gKF9mID0gKF9lID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2UuQ3J5cHRvKSAhPSBudWxsID8gX2YgOiBudWxsO1xuICAgIHRoaXMuX19GaWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSAoX2ggPSAoX2cgPSBvcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5NZXNzYWdlSW50ZXJhY3Rpb25zKSAhPSBudWxsID8gX2ggOiBudWxsO1xuICB9XG4gIGdldCByZXN0KCkge1xuICAgIGlmICghdGhpcy5fcmVzdCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJSZXN0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVzdDtcbiAgfVxuICBnZXQgX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucygpIHtcbiAgICBpZiAoIXRoaXMuX19GaWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTWVzc2FnZUludGVyYWN0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19GaWx0ZXJlZFN1YnNjcmlwdGlvbnM7XG4gIH1cbiAgZ2V0IGNoYW5uZWxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3QuY2hhbm5lbHM7XG4gIH1cbiAgZ2V0IHB1c2goKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5wdXNoO1xuICB9XG4gIGdldCBkZXZpY2UoKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoISgoX2EyID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkgfHwgIXRoaXMucHVzaC5Mb2NhbERldmljZSkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RldmljZSkge1xuICAgICAgdGhpcy5fZGV2aWNlID0gdGhpcy5wdXNoLkxvY2FsRGV2aWNlLmxvYWQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kZXZpY2U7XG4gIH1cbiAgYmFzZVVyaShob3N0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzX2RlZmF1bHQuZ2V0SHR0cFNjaGVtZSh0aGlzLm9wdGlvbnMpICsgaG9zdCArIFwiOlwiICsgZGVmYXVsdHNfZGVmYXVsdC5nZXRQb3J0KHRoaXMub3B0aW9ucywgZmFsc2UpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlc3Quc3RhdHMocGFyYW1zKTtcbiAgfVxuICBhc3luYyB0aW1lKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlc3QudGltZShwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QobWV0aG9kLCBwYXRoLCB2ZXJzaW9uMiwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5yZXF1ZXN0KG1ldGhvZCwgcGF0aCwgdmVyc2lvbjIsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycyk7XG4gIH1cbiAgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5iYXRjaFB1Ymxpc2goc3BlY09yU3BlY3MpO1xuICB9XG4gIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpO1xuICB9XG4gIHNldExvZyhsb2dPcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIuc2V0TG9nKGxvZ09wdGlvbnMubGV2ZWwsIGxvZ09wdGlvbnMuaGFuZGxlcik7XG4gIH1cbn07XG5CYXNlQ2xpZW50LlBsYXRmb3JtID0gUGxhdGZvcm07XG52YXIgYmFzZWNsaWVudF9kZWZhdWx0ID0gQmFzZUNsaWVudDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGV2aWNlZGV0YWlscy50c1xudmFyIERldmljZURldGFpbHMgPSBjbGFzcyBfRGV2aWNlRGV0YWlscyB7XG4gIHRvSlNPTigpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZGV2aWNlU2VjcmV0OiB0aGlzLmRldmljZVNlY3JldCxcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgZm9ybUZhY3RvcjogdGhpcy5mb3JtRmFjdG9yLFxuICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICBtZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgIGRldmljZUlkZW50aXR5VG9rZW46IHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbixcbiAgICAgIHB1c2g6IHtcbiAgICAgICAgcmVjaXBpZW50OiAoX2EyID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlY2lwaWVudCxcbiAgICAgICAgc3RhdGU6IChfYiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXRlLFxuICAgICAgICBlcnJvcjogKF9jID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZXJyb3JcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHZhciBfYTIsIF9iLCBfYywgX2Q7XG4gICAgbGV0IHJlc3VsdCA9IFwiW0RldmljZURldGFpbHNcIjtcbiAgICBpZiAodGhpcy5pZClcbiAgICAgIHJlc3VsdCArPSBcIjsgaWQ9XCIgKyB0aGlzLmlkO1xuICAgIGlmICh0aGlzLnBsYXRmb3JtKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwbGF0Zm9ybT1cIiArIHRoaXMucGxhdGZvcm07XG4gICAgaWYgKHRoaXMuZm9ybUZhY3RvcilcbiAgICAgIHJlc3VsdCArPSBcIjsgZm9ybUZhY3Rvcj1cIiArIHRoaXMuZm9ybUZhY3RvcjtcbiAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgIHJlc3VsdCArPSBcIjsgY2xpZW50SWQ9XCIgKyB0aGlzLmNsaWVudElkO1xuICAgIGlmICh0aGlzLm1ldGFkYXRhKVxuICAgICAgcmVzdWx0ICs9IFwiOyBtZXRhZGF0YT1cIiArIHRoaXMubWV0YWRhdGE7XG4gICAgaWYgKHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbilcbiAgICAgIHJlc3VsdCArPSBcIjsgZGV2aWNlSWRlbnRpdHlUb2tlbj1cIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbik7XG4gICAgaWYgKChfYTIgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVjaXBpZW50KVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLnJlY2lwaWVudD1cIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5yZWNpcGllbnQpO1xuICAgIGlmICgoX2IgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zdGF0ZSlcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5zdGF0ZT1cIiArIHRoaXMucHVzaC5zdGF0ZTtcbiAgICBpZiAoKF9jID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZXJyb3IpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2guZXJyb3I9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2guZXJyb3IpO1xuICAgIGlmICgoX2QgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfZC5tZXRhZGF0YSlcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5tZXRhZGF0YT1cIiArIHRoaXMucHVzaC5tZXRhZGF0YTtcbiAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgdG9SZXF1ZXN0Qm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZW5jb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICB9XG4gIHN0YXRpYyBmcm9tUmVzcG9uc2VCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIGJvZHkgPSBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGJvZHkpKSB7XG4gICAgICByZXR1cm4gX0RldmljZURldGFpbHMuZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX0RldmljZURldGFpbHMuZnJvbVZhbHVlcyhib2R5KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgdmFsdWVzLmVycm9yID0gdmFsdWVzLmVycm9yICYmIEVycm9ySW5mby5mcm9tVmFsdWVzKHZhbHVlcy5lcnJvcik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9EZXZpY2VEZXRhaWxzKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21Mb2NhbERldmljZShkZXZpY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX0RldmljZURldGFpbHMoKSwgZGV2aWNlKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICByZXN1bHRbaV0gPSBfRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBkZXZpY2VkZXRhaWxzX2RlZmF1bHQgPSBEZXZpY2VEZXRhaWxzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzb3VyY2UudHNcbmFzeW5jIGZ1bmN0aW9uIHdpdGhBdXRoRGV0YWlscyhjbGllbnQsIGhlYWRlcnMsIHBhcmFtcywgb3BDYWxsYmFjaykge1xuICBpZiAoY2xpZW50Lmh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycykge1xuICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgY2xpZW50LmF1dGguZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICByZXR1cm4gb3BDYWxsYmFjayhtaXhpbihhdXRoSGVhZGVycywgaGVhZGVycyksIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYXV0aFBhcmFtcyA9IGF3YWl0IGNsaWVudC5hdXRoLmdldEF1dGhQYXJhbXMoKTtcbiAgICByZXR1cm4gb3BDYWxsYmFjayhoZWFkZXJzLCBtaXhpbihhdXRoUGFyYW1zLCBwYXJhbXMpKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5lbnZlbG9wZShyZXN1bHQsIE1zZ1BhY2ssIGZvcm1hdCkge1xuICBpZiAocmVzdWx0LmVyciAmJiAhcmVzdWx0LmJvZHkpIHtcbiAgICByZXR1cm4geyBlcnI6IHJlc3VsdC5lcnIgfTtcbiAgfVxuICBpZiAocmVzdWx0LnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0Lk5vQ29udGVudCkge1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQpLCB7IGJvZHk6IFtdLCB1bnBhY2tlZDogdHJ1ZSB9KTtcbiAgfVxuICBsZXQgYm9keSA9IHJlc3VsdC5ib2R5O1xuICBpZiAoIXJlc3VsdC51bnBhY2tlZCkge1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlKSkge1xuICAgICAgICByZXR1cm4geyBlcnI6IGUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGVycjogbmV3IFBhcnRpYWxFcnJvckluZm8oaW5zcGVjdEVycm9yKGUpLCBudWxsKSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWJvZHkpIHtcbiAgICByZXR1cm4geyBlcnI6IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwidW5lbnZlbG9wZSgpOiBSZXNwb25zZSBib2R5IGlzIG1pc3NpbmdcIiwgbnVsbCkgfTtcbiAgfVxuICBjb25zdCB7IHN0YXR1c0NvZGU6IHdyYXBwZWRTdGF0dXNDb2RlLCByZXNwb25zZSwgaGVhZGVyczogd3JhcHBlZEhlYWRlcnMgfSA9IGJvZHk7XG4gIGlmICh3cmFwcGVkU3RhdHVzQ29kZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdCksIHsgYm9keSwgdW5wYWNrZWQ6IHRydWUgfSk7XG4gIH1cbiAgaWYgKHdyYXBwZWRTdGF0dXNDb2RlIDwgMjAwIHx8IHdyYXBwZWRTdGF0dXNDb2RlID49IDMwMCkge1xuICAgIGxldCB3cmFwcGVkRXJyID0gcmVzcG9uc2UgJiYgcmVzcG9uc2UuZXJyb3IgfHwgcmVzdWx0LmVycjtcbiAgICBpZiAoIXdyYXBwZWRFcnIpIHtcbiAgICAgIHdyYXBwZWRFcnIgPSBuZXcgRXJyb3IoXCJFcnJvciBpbiB1bmVudmVsb3BpbmcgXCIgKyBib2R5KTtcbiAgICAgIHdyYXBwZWRFcnIuc3RhdHVzQ29kZSA9IHdyYXBwZWRTdGF0dXNDb2RlO1xuICAgIH1cbiAgICByZXR1cm4geyBlcnI6IHdyYXBwZWRFcnIsIGJvZHk6IHJlc3BvbnNlLCBoZWFkZXJzOiB3cmFwcGVkSGVhZGVycywgdW5wYWNrZWQ6IHRydWUsIHN0YXR1c0NvZGU6IHdyYXBwZWRTdGF0dXNDb2RlIH07XG4gIH1cbiAgcmV0dXJuIHsgZXJyOiByZXN1bHQuZXJyLCBib2R5OiByZXNwb25zZSwgaGVhZGVyczogd3JhcHBlZEhlYWRlcnMsIHVucGFja2VkOiB0cnVlLCBzdGF0dXNDb2RlOiB3cmFwcGVkU3RhdHVzQ29kZSB9O1xufVxuZnVuY3Rpb24gbG9nUmVzdWx0MihyZXN1bHQsIG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBsb2dnZXIpIHtcbiAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJSZWNlaXZlZCBFcnJvcjsgXCIgKyBhcHBlbmRpbmdQYXJhbXMocGF0aCwgcGFyYW1zKSArIFwiOyBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IocmVzdWx0LmVycilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVzb3VyY2UuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkOyBcIiArIGFwcGVuZGluZ1BhcmFtcyhwYXRoLCBwYXJhbXMpICsgXCI7IEhlYWRlcnM6IFwiICsgcGFyYW1TdHJpbmcocmVzdWx0LmhlYWRlcnMpICsgXCI7IFN0YXR1c0NvZGU6IFwiICsgcmVzdWx0LnN0YXR1c0NvZGUgKyBcIjsgQm9keTogXCIgKyAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIocmVzdWx0LmJvZHkpID8gXCIgKEJhc2U2NCk6IFwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHJlc3VsdC5ib2R5KSA6IFwiOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KHJlc3VsdC5ib2R5KSlcbiAgICApO1xuICB9XG59XG52YXIgUmVzb3VyY2UgPSBjbGFzcyBfUmVzb3VyY2Uge1xuICBzdGF0aWMgYXN5bmMgZ2V0KGNsaWVudCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsIGNsaWVudCwgcGF0aCwgbnVsbCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvciAhPSBudWxsID8gdGhyb3dFcnJvciA6IGZhbHNlKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVsZXRlKGNsaWVudCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5EZWxldGUsIGNsaWVudCwgcGF0aCwgbnVsbCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHBvc3QoY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHBhdGNoKGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5QYXRjaCwgY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcHV0KGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5QdXQsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRvKG1ldGhvZCwgY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgaWYgKGVudmVsb3BlKSB7XG4gICAgICAocGFyYW1zID0gcGFyYW1zIHx8IHt9KVtcImVudmVsb3BlXCJdID0gZW52ZWxvcGU7XG4gICAgfVxuICAgIGNvbnN0IGxvZ2dlciA9IGNsaWVudC5sb2dnZXI7XG4gICAgYXN5bmMgZnVuY3Rpb24gZG9SZXF1ZXN0KGhlYWRlcnMyLCBwYXJhbXMyKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKGxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICBsZXQgZGVjb2RlZEJvZHkgPSBib2R5O1xuICAgICAgICBpZiAoKChfYTIgPSBoZWFkZXJzMltcImNvbnRlbnQtdHlwZVwiXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pbmRleE9mKFwibXNncGFja1wiKSkgPiAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY2xpZW50Ll9Nc2dQYWNrKSB7XG4gICAgICAgICAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTXNnUGFja1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRCb2R5ID0gY2xpZW50Ll9Nc2dQYWNrLmRlY29kZShib2R5KTtcbiAgICAgICAgICB9IGNhdGNoIChkZWNvZGVFcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgICAgIFwiUmVzb3VyY2UuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICAgICAgICAgIFwiU2VuZGluZyBNc2dQYWNrIERlY29kaW5nIEVycm9yOiBcIiArIGluc3BlY3RFcnJvcihkZWNvZGVFcnIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgICAgIFwiU2VuZGluZzsgXCIgKyBhcHBlbmRpbmdQYXJhbXMocGF0aCwgcGFyYW1zMikgKyBcIjsgQm9keTogXCIgKyBkZWNvZGVkQm9keVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgaHR0cFJlc3VsdCA9IGF3YWl0IGNsaWVudC5odHRwLmRvKG1ldGhvZCwgcGF0aCwgaGVhZGVyczIsIGJvZHksIHBhcmFtczIpO1xuICAgICAgaWYgKGh0dHBSZXN1bHQuZXJyb3IgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoaHR0cFJlc3VsdC5lcnJvcikpIHtcbiAgICAgICAgYXdhaXQgY2xpZW50LmF1dGguYXV0aG9yaXplKG51bGwsIG51bGwpO1xuICAgICAgICByZXR1cm4gd2l0aEF1dGhEZXRhaWxzKGNsaWVudCwgaGVhZGVyczIsIHBhcmFtczIsIGRvUmVxdWVzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnI6IGh0dHBSZXN1bHQuZXJyb3IsXG4gICAgICAgIGJvZHk6IGh0dHBSZXN1bHQuYm9keSxcbiAgICAgICAgaGVhZGVyczogaHR0cFJlc3VsdC5oZWFkZXJzLFxuICAgICAgICB1bnBhY2tlZDogaHR0cFJlc3VsdC51bnBhY2tlZCxcbiAgICAgICAgc3RhdHVzQ29kZTogaHR0cFJlc3VsdC5zdGF0dXNDb2RlXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgd2l0aEF1dGhEZXRhaWxzKGNsaWVudCwgaGVhZGVycywgcGFyYW1zLCBkb1JlcXVlc3QpO1xuICAgIGlmIChlbnZlbG9wZSkge1xuICAgICAgcmVzdWx0ID0gdW5lbnZlbG9wZShyZXN1bHQsIGNsaWVudC5fTXNnUGFjaywgZW52ZWxvcGUpO1xuICAgIH1cbiAgICBpZiAobG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dSZXN1bHQyKHJlc3VsdCwgbWV0aG9kLCBwYXRoLCBwYXJhbXMsIGxvZ2dlcik7XG4gICAgfVxuICAgIGlmICh0aHJvd0Vycm9yKSB7XG4gICAgICBpZiAocmVzdWx0LmVycikge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBfX3NwcmVhZFZhbHVlcyh7fSwgcmVzdWx0KTtcbiAgICAgICAgZGVsZXRlIHJlc3BvbnNlLmVycjtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIHJlc291cmNlX2RlZmF1bHQgPSBSZXNvdXJjZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3BhZ2luYXRlZHJlc291cmNlLnRzXG5mdW5jdGlvbiBnZXRSZWxQYXJhbXMobGlua1VybCkge1xuICBjb25zdCB1cmxNYXRjaCA9IGxpbmtVcmwubWF0Y2goL15cXC5cXC8oXFx3KylcXD8oLiopJC8pO1xuICByZXR1cm4gdXJsTWF0Y2ggJiYgdXJsTWF0Y2hbMl0gJiYgcGFyc2VRdWVyeVN0cmluZyh1cmxNYXRjaFsyXSk7XG59XG5mdW5jdGlvbiBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpIHtcbiAgaWYgKHR5cGVvZiBsaW5rSGVhZGVyID09IFwic3RyaW5nXCIpXG4gICAgbGlua0hlYWRlciA9IGxpbmtIZWFkZXIuc3BsaXQoXCIsXCIpO1xuICBjb25zdCByZWxQYXJhbXMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5rSGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGlua01hdGNoID0gbGlua0hlYWRlcltpXS5tYXRjaCgvXlxccyo8KC4rKT47XFxzKnJlbD1cIihcXHcrKVwiJC8pO1xuICAgIGlmIChsaW5rTWF0Y2gpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGdldFJlbFBhcmFtcyhsaW5rTWF0Y2hbMV0pO1xuICAgICAgaWYgKHBhcmFtcylcbiAgICAgICAgcmVsUGFyYW1zW2xpbmtNYXRjaFsyXV0gPSBwYXJhbXM7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxQYXJhbXM7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJPbmx5KGVyciwgYm9keSwgdXNlSFBSKSB7XG4gIHJldHVybiAhKHVzZUhQUiAmJiAoYm9keSB8fCB0eXBlb2YgZXJyLmNvZGUgPT09IFwibnVtYmVyXCIpKTtcbn1cbnZhciBQYWdpbmF0ZWRSZXNvdXJjZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgYm9keUhhbmRsZXIsIHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmVudmVsb3BlID0gZW52ZWxvcGUgIT0gbnVsbCA/IGVudmVsb3BlIDogbnVsbDtcbiAgICB0aGlzLmJvZHlIYW5kbGVyID0gYm9keUhhbmRsZXI7XG4gICAgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgfHwgZmFsc2U7XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyO1xuICB9XG4gIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5kZWxldGUodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgcG9zdChwYXJhbXMsIGJvZHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgcHV0KHBhcmFtcywgYm9keSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucHV0KHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIHBhdGNoKHBhcmFtcywgYm9keSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucGF0Y2godGhpcy5jbGllbnQsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgaGFuZGxlUGFnZShyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmVyciAmJiByZXR1cm5FcnJPbmx5KHJlc3VsdC5lcnIsIHJlc3VsdC5ib2R5LCB0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJQYWdpbmF0ZWRSZXNvdXJjZS5oYW5kbGVQYWdlKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGVycm9yIGdldHRpbmcgcmVzb3VyY2U6IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnIpXG4gICAgICApO1xuICAgICAgdGhyb3cgcmVzdWx0LmVycjtcbiAgICB9XG4gICAgbGV0IGl0ZW1zLCBsaW5rSGVhZGVyLCByZWxQYXJhbXM7XG4gICAgdHJ5IHtcbiAgICAgIGl0ZW1zID0gcmVzdWx0LnN0YXR1c0NvZGUgPT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuTm9Db250ZW50ID8gW10gOiBhd2FpdCB0aGlzLmJvZHlIYW5kbGVyKHJlc3VsdC5ib2R5LCByZXN1bHQuaGVhZGVycyB8fCB7fSwgcmVzdWx0LnVucGFja2VkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyByZXN1bHQuZXJyIHx8IGU7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuaGVhZGVycyAmJiAobGlua0hlYWRlciA9IHJlc3VsdC5oZWFkZXJzW1wiTGlua1wiXSB8fCByZXN1bHQuaGVhZGVyc1tcImxpbmtcIl0pKSB7XG4gICAgICByZWxQYXJhbXMgPSBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBuZXcgSHR0cFBhZ2luYXRlZFJlc3BvbnNlKFxuICAgICAgICB0aGlzLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgcmVzdWx0LmhlYWRlcnMgfHwge30sXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlLFxuICAgICAgICByZWxQYXJhbXMsXG4gICAgICAgIHJlc3VsdC5lcnJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUGFnaW5hdGVkUmVzdWx0KHRoaXMsIGl0ZW1zLCByZWxQYXJhbXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBQYWdpbmF0ZWRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKSB7XG4gICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgaWYgKHJlbFBhcmFtcykge1xuICAgICAgaWYgKFwiZmlyc3RcIiBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmMi5nZXQocmVsUGFyYW1zLmZpcnN0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChcImN1cnJlbnRcIiBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYyLmdldChyZWxQYXJhbXMuY3VycmVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFwibmV4dFwiIGluIHJlbFBhcmFtcykge1xuICAgICAgICAgIHJldHVybiBzZWxmMi5nZXQocmVsUGFyYW1zLm5leHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIm5leHRcIiBpbiByZWxQYXJhbXM7XG4gICAgICB9O1xuICAgICAgdGhpcy5pc0xhc3QgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAhKChfYTIgPSB0aGlzLmhhc05leHQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbCh0aGlzKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiBXZSBhc3N1bWUgdGhhdCBvbmx5IHRoZSBpbml0aWFsIHJlcXVlc3QgY2FuIGJlIGEgUE9TVCwgYW5kIHRoYXQgYWNjZXNzaW5nXG4gICAqIHRoZSByZXN0IG9mIGEgbXVsdGlwYWdlIHNldCBvZiByZXN1bHRzIGNhbiBhbHdheXMgYmUgZG9uZSB3aXRoIEdFVCAqL1xuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5yZXNvdXJjZTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChyZXMuY2xpZW50LCByZXMucGF0aCwgcmVzLmhlYWRlcnMsIHBhcmFtcywgcmVzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHJlcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbn07XG52YXIgSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBQYWdpbmF0ZWRSZXN1bHQge1xuICBjb25zdHJ1Y3RvcihyZXNvdXJjZSwgaXRlbXMsIGhlYWRlcnMsIHN0YXR1c0NvZGUsIHJlbFBhcmFtcywgZXJyKSB7XG4gICAgc3VwZXIocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5zdWNjZXNzID0gc3RhdHVzQ29kZSA8IDMwMCAmJiBzdGF0dXNDb2RlID49IDIwMDtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyICYmIGVyci5jb2RlO1xuICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gZXJyICYmIGVyci5tZXNzYWdlO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgICBzdWNjZXNzOiB0aGlzLnN1Y2Nlc3MsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBlcnJvckNvZGU6IHRoaXMuZXJyb3JDb2RlLFxuICAgICAgZXJyb3JNZXNzYWdlOiB0aGlzLmVycm9yTWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG52YXIgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdCA9IFBhZ2luYXRlZFJlc291cmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wdXNoY2hhbm5lbHN1YnNjcmlwdGlvbi50c1xudmFyIF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbiA9IGNsYXNzIF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbiB7XG4gIC8qKlxuICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFubmVsOiB0aGlzLmNoYW5uZWwsXG4gICAgICBkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcbiAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkXG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJbUHVzaENoYW5uZWxTdWJzY3JpcHRpb25cIjtcbiAgICBpZiAodGhpcy5jaGFubmVsKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjaGFubmVsPVwiICsgdGhpcy5jaGFubmVsO1xuICAgIGlmICh0aGlzLmRldmljZUlkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBkZXZpY2VJZD1cIiArIHRoaXMuZGV2aWNlSWQ7XG4gICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNsaWVudElkPVwiICsgdGhpcy5jbGllbnRJZDtcbiAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgZnJvbVJlc3BvbnNlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgcmV0dXJuIF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyhib2R5KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbigpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgIHJlc3VsdFtpXSA9IF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbl9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi50b1JlcXVlc3RCb2R5ID0gZW5jb2RlQm9keTtcbnZhciBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbiA9IF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcbnZhciBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0ID0gUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9wdXNoLnRzXG52YXIgUHVzaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdmFyIF9hMjtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmFkbWluID0gbmV3IEFkbWluKGNsaWVudCk7XG4gICAgaWYgKFBsYXRmb3JtLkNvbmZpZy5wdXNoICYmICgoX2EyID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5QdXNoKSkge1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUgPSBuZXcgY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLkFjdGl2YXRpb25TdGF0ZU1hY2hpbmUoY2xpZW50KTtcbiAgICAgIHRoaXMuTG9jYWxEZXZpY2UgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2gubG9jYWxEZXZpY2VGYWN0b3J5KGRldmljZWRldGFpbHNfZGVmYXVsdCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFjdGl2YXRlKHJlZ2lzdGVyQ2FsbGJhY2ssIHVwZGF0ZUZhaWxlZENhbGxiYWNrKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICghKChfYTIgPSB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkpIHtcbiAgICAgICAgcmVqZWN0KGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcihcIlB1c2hcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVNYWNoaW5lKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVGhpcyBwbGF0Zm9ybSBpcyBub3Qgc3VwcG9ydGVkIGFzIGEgdGFyZ2V0IG9mIHB1c2ggbm90aWZpY2F0aW9uc1wiLCA0ZTQsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZU1hY2hpbmUuYWN0aXZhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJBY3RpdmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuYWN0aXZhdGVkQ2FsbGJhY2sgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLnVwZGF0ZUZhaWxlZENhbGxiYWNrID0gdXBkYXRlRmFpbGVkQ2FsbGJhY2s7XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS5oYW5kbGVFdmVudChcbiAgICAgICAgbmV3IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLkNhbGxlZEFjdGl2YXRlKHRoaXMuc3RhdGVNYWNoaW5lLCByZWdpc3RlckNhbGxiYWNrKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBkZWFjdGl2YXRlKGRlcmVnaXN0ZXJDYWxsYmFjaykge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoISgoX2EyID0gdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlTWFjaGluZSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRoaXMgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZCBhcyBhIHRhcmdldCBvZiBwdXNoIG5vdGlmaWNhdGlvbnNcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGVNYWNoaW5lLmRlYWN0aXZhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJEZWFjdGl2YXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiLCA0ZTQsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS5kZWFjdGl2YXRlZENhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS5oYW5kbGVFdmVudChcbiAgICAgICAgbmV3IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLkNhbGxlZERlYWN0aXZhdGUodGhpcy5zdGF0ZU1hY2hpbmUsIGRlcmVnaXN0ZXJDYWxsYmFjaylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgQWRtaW4gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuZGV2aWNlUmVnaXN0cmF0aW9ucyA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25zKGNsaWVudCk7XG4gICAgdGhpcy5jaGFubmVsU3Vic2NyaXB0aW9ucyA9IG5ldyBDaGFubmVsU3Vic2NyaXB0aW9ucyhjbGllbnQpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2gocmVjaXBpZW50LCBwYXlsb2FkKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KSwgcGFyYW1zID0ge307XG4gICAgY29uc3QgYm9keSA9IG1peGluKHsgcmVjaXBpZW50IH0sIHBheWxvYWQpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KGNsaWVudCwgXCIvcHVzaC9wdWJsaXNoXCIsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIHRydWUpO1xuICB9XG59O1xudmFyIERldmljZVJlZ2lzdHJhdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIGFzeW5jIHNhdmUoZGV2aWNlKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgYm9keSA9IGRldmljZWRldGFpbHNfZGVmYXVsdC5mcm9tVmFsdWVzKGRldmljZSk7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KSwgcGFyYW1zID0ge307XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucHV0KFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZS5pZCksXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIGRldmljZWRldGFpbHNfZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgIHJlc3BvbnNlLnVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXQoZGV2aWNlSWRPckRldGFpbHMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pLCBkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgIT09IFwic3RyaW5nXCIgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI2dldCBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHNcIixcbiAgICAgICAgNGU0LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQoXG4gICAgICBjbGllbnQsXG4gICAgICBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICByZXNwb25zZS51bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICk7XG4gIH1cbiAgYXN5bmMgbGlzdChwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSB0aGlzLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoY2xpZW50LCBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgcmV0dXJuIGRldmljZWRldGFpbHNfZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICAgIHVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgICApO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHJlbW92ZShkZXZpY2VJZE9yRGV0YWlscykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSksIHBhcmFtcyA9IHt9LCBkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgIT09IFwic3RyaW5nXCIgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI3JlbW92ZSBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHNcIixcbiAgICAgICAgNGU0LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHRbXCJkZWxldGVcIl0oXG4gICAgICBjbGllbnQsXG4gICAgICBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuICBhc3luYyByZW1vdmVXaGVyZShwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHRbXCJkZWxldGVcIl0oY2xpZW50LCBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnNcIiwgaGVhZGVycywgcGFyYW1zLCBudWxsLCB0cnVlKTtcbiAgfVxufTtcbnZhciBDaGFubmVsU3Vic2NyaXB0aW9ucyA9IGNsYXNzIF9DaGFubmVsU3Vic2NyaXB0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIC8qIENoYW5uZWxTdWJzY3JpcHRpb25zIGhhdmUgbm8gdW5pcXVlIGlkOyByZW1vdmluZyBvbmUgaXMgZXF1aXZhbGVudCB0byByZW1vdmVXaGVyZSBieSBpdHMgcHJvcGVydGllcyAqL1xuICAgIHRoaXMucmVtb3ZlID0gX0NoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICBhc3luYyBzYXZlKHN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGJvZHkgPSBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0LmZyb21WYWx1ZXMoc3Vic2NyaXB0aW9uKTtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pLCBwYXJhbXMgPSB7fTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9uc1wiLFxuICAgICAgcmVxdWVzdEJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgcmVzcG9uc2UudW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICApO1xuICB9XG4gIGFzeW5jIGxpc3QocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgXCIvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9uc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICByZXR1cm4gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICAgIHVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgICApO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHJlbW92ZVdoZXJlKHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdFtcImRlbGV0ZVwiXShjbGllbnQsIFwiL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnNcIiwgaGVhZGVycywgcGFyYW1zLCBudWxsLCB0cnVlKTtcbiAgfVxuICBhc3luYyBsaXN0Q2hhbm5lbHMocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgXCIvcHVzaC9jaGFubmVsc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICBjb25zdCBwYXJzZWRCb2R5ID0gIXVucGFja2VkICYmIGZvcm1hdCA/IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpIDogYm9keTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkQm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJzZWRCb2R5W2ldID0gU3RyaW5nKHBhcnNlZEJvZHlbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZEJvZHk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcHVzaF9kZWZhdWx0ID0gUHVzaDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvbWVzc2FnZS50c1xuZnVuY3Rpb24gbm9ybWFsaXNlQ29udGV4dChjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCB8fCAhY29udGV4dC5jaGFubmVsT3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFubmVsT3B0aW9uczogY29udGV4dCxcbiAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaXBoZXJPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgIGlmICghQ3J5cHRvMilcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiQ3J5cHRvXCIpO1xuICAgIGNvbnN0IGNpcGhlciA9IENyeXB0bzIuZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyLCBsb2dnZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBjaXBoZXI6IGNpcGhlci5jaXBoZXJQYXJhbXMsXG4gICAgICBjaGFubmVsQ2lwaGVyOiBjaXBoZXIuY2lwaGVyXG4gICAgfTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZVNpemUobXNnKSB7XG4gIGxldCBzaXplID0gMDtcbiAgaWYgKG1zZy5uYW1lKSB7XG4gICAgc2l6ZSArPSBtc2cubmFtZS5sZW5ndGg7XG4gIH1cbiAgaWYgKG1zZy5jbGllbnRJZCkge1xuICAgIHNpemUgKz0gbXNnLmNsaWVudElkLmxlbmd0aDtcbiAgfVxuICBpZiAobXNnLmV4dHJhcykge1xuICAgIHNpemUgKz0gSlNPTi5zdHJpbmdpZnkobXNnLmV4dHJhcykubGVuZ3RoO1xuICB9XG4gIGlmIChtc2cuZGF0YSkge1xuICAgIHNpemUgKz0gZGF0YVNpemVCeXRlcyhtc2cuZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZChsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICBjb25zdCBtc2cgPSBmcm9tVmFsdWVzKGVuY29kZWQpO1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIGlucHV0T3B0aW9ucyAhPSBudWxsID8gaW5wdXRPcHRpb25zIDogbnVsbCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZGVjb2RlKG1zZywgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiTWVzc2FnZS5mcm9tRW5jb2RlZCgpXCIsIGUudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIG1zZztcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkQXJyYXkobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIGZyb21FbmNvZGVkKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQobXNnLCBvcHRpb25zKSB7XG4gIGxldCBkYXRhID0gbXNnLmRhdGEsIGVuY29kaW5nID0gbXNnLmVuY29kaW5nLCBjaXBoZXIgPSBvcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArIFwiL1wiIDogXCJcIjtcbiAgaWYgKCFQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgIGRhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKFN0cmluZyhkYXRhKSk7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyArIFwidXRmLTgvXCI7XG4gIH1cbiAgY29uc3QgY2lwaGVydGV4dCA9IGF3YWl0IGNpcGhlci5lbmNyeXB0KGRhdGEpO1xuICBtc2cuZGF0YSA9IGNpcGhlcnRleHQ7XG4gIG1zZy5lbmNvZGluZyA9IGVuY29kaW5nICsgXCJjaXBoZXIrXCIgKyBjaXBoZXIuYWxnb3JpdGhtO1xuICByZXR1cm4gbXNnO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jb2RlKG1zZywgb3B0aW9ucykge1xuICBjb25zdCBkYXRhID0gbXNnLmRhdGE7XG4gIGNvbnN0IG5hdGl2ZURhdGFUeXBlID0gdHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiB8fCBQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMDtcbiAgaWYgKCFuYXRpdmVEYXRhVHlwZSkge1xuICAgIGlmIChpc09iamVjdChkYXRhKSB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBtc2cuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgbXNnLmVuY29kaW5nID0gbXNnLmVuY29kaW5nID8gbXNnLmVuY29kaW5nICsgXCIvanNvblwiIDogXCJqc29uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJEYXRhIHR5cGUgaXMgdW5zdXBwb3J0ZWRcIiwgNDAwMTMsIDQwMCk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5jaXBoZXIpIHtcbiAgICByZXR1cm4gZW5jcnlwdChtc2csIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtc2c7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY29kZUFycmF5KG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IGVuY29kZShtZXNzYWdlLCBvcHRpb25zKSkpO1xufVxudmFyIHNlcmlhbGl6ZSA9IGVuY29kZUJvZHk7XG5hc3luYyBmdW5jdGlvbiBkZWNvZGUobWVzc2FnZSwgaW5wdXRDb250ZXh0KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBub3JtYWxpc2VDb250ZXh0KGlucHV0Q29udGV4dCk7XG4gIGxldCBsYXN0UGF5bG9hZCA9IG1lc3NhZ2UuZGF0YTtcbiAgY29uc3QgZW5jb2RpbmcgPSBtZXNzYWdlLmVuY29kaW5nO1xuICBpZiAoZW5jb2RpbmcpIHtcbiAgICBjb25zdCB4Zm9ybXMgPSBlbmNvZGluZy5zcGxpdChcIi9cIik7XG4gICAgbGV0IGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4LCBlbmNvZGluZ3NUb1Byb2Nlc3MgPSB4Zm9ybXMubGVuZ3RoLCBkYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgIGxldCB4Zm9ybSA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICgobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSBlbmNvZGluZ3NUb1Byb2Nlc3MpID4gMCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHhmb3Jtc1stLWVuY29kaW5nc1RvUHJvY2Vzc10ubWF0Y2goLyhbLVxcd10rKShcXCsoW1xcdy1dKykpPy8pO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB4Zm9ybSA9IG1hdGNoWzFdO1xuICAgICAgICBzd2l0Y2ggKHhmb3JtKSB7XG4gICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NERlY29kZShTdHJpbmcoZGF0YSkpO1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID09IHhmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbGFzdFBheWxvYWQgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICBkYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMudXRmOERlY29kZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJjaXBoZXJcIjpcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmNoYW5uZWxPcHRpb25zICE9IG51bGwgJiYgY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaXBoZXIgJiYgY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHhmb3JtQWxnb3JpdGhtID0gbWF0Y2hbM10sIGNpcGhlciA9IGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcjtcbiAgICAgICAgICAgICAgaWYgKHhmb3JtQWxnb3JpdGhtICE9IGNpcGhlci5hbGdvcml0aG0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlIHdpdGggZ2l2ZW4gY2lwaGVyOyBpbmNvbXBhdGlibGUgY2lwaGVyIHBhcmFtc1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgY2lwaGVyLmRlY3J5cHQoZGF0YSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZTsgbm90IGFuIGVuY3J5cHRlZCBjaGFubmVsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ2Y2RpZmZcIjpcbiAgICAgICAgICAgIGlmICghY29udGV4dC5wbHVnaW5zIHx8ICFjb250ZXh0LnBsdWdpbnMudmNkaWZmKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJNaXNzaW5nIFZjZGlmZiBkZWNvZGVyIChodHRwczovL2dpdGh1Yi5jb20vYWJseS1mb3Jrcy92Y2RpZmYtZGVjb2RlcilcIiwgNDAwMTksIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcIkRlbHRhIGRlY29kaW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyIChuZWVkIEFycmF5QnVmZmVyICYgVWludDhBcnJheSlcIixcbiAgICAgICAgICAgICAgICA0MDAyMCxcbiAgICAgICAgICAgICAgICA0MDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCBkZWx0YUJhc2UgPSBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlbHRhQmFzZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGRlbHRhQmFzZSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkZWx0YUJhc2VCdWZmZXIgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy50b0J1ZmZlcihkZWx0YUJhc2UpO1xuICAgICAgICAgICAgICBkYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMudG9CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGRhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy5hcnJheUJ1ZmZlclZpZXdUb0J1ZmZlcihjb250ZXh0LnBsdWdpbnMudmNkaWZmLmRlY29kZShkYXRhLCBkZWx0YUJhc2VCdWZmZXIpKTtcbiAgICAgICAgICAgICAgbGFzdFBheWxvYWQgPSBkYXRhO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVmNkaWZmIGRlbHRhIGRlY29kZSBmYWlsZWQgd2l0aCBcIiArIGUsIDQwMDE4LCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJFcnJvciBwcm9jZXNzaW5nIHRoZSBcIiArIHhmb3JtICsgXCIgZW5jb2RpbmcsIGRlY29kZXIgcmV0dXJuZWQgXFx1MjAxOFwiICsgZXJyLm1lc3NhZ2UgKyBcIlxcdTIwMTlcIixcbiAgICAgICAgZXJyLmNvZGUgfHwgNDAwMTMsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbWVzc2FnZS5lbmNvZGluZyA9IGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4IDw9IDAgPyBudWxsIDogeGZvcm1zLnNsaWNlKDAsIGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4KS5qb2luKFwiL1wiKTtcbiAgICAgIG1lc3NhZ2UuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG4gIGNvbnRleHQuYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQgPSBsYXN0UGF5bG9hZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgbG9nZ2VyLCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCkge1xuICAgIGJvZHkgPSBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbXNnID0gYm9keVtpXSA9IGZyb21WYWx1ZXMoYm9keVtpXSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGRlY29kZShtc2csIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkoKVwiLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm9keTtcbn1cbmZ1bmN0aW9uIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBNZXNzYWdlKCksIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgIHJlc3VsdFtpXSA9IGZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcykge1xuICBsZXQgbXNnLCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBtc2cgPSBtZXNzYWdlc1tpXTtcbiAgICB0b3RhbCArPSBtc2cuc2l6ZSB8fCAobXNnLnNpemUgPSBnZXRNZXNzYWdlU2l6ZShtc2cpKTtcbiAgfVxuICByZXR1cm4gdG90YWw7XG59XG52YXIgTWVzc2FnZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgbGV0IGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcbiAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoZGF0YSAmJiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArIFwiL2Jhc2U2NFwiIDogXCJiYXNlNjRcIjtcbiAgICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy50b0J1ZmZlcihkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICBjb25uZWN0aW9uSWQ6IHRoaXMuY29ubmVjdGlvbklkLFxuICAgICAgY29ubmVjdGlvbktleTogdGhpcy5jb25uZWN0aW9uS2V5LFxuICAgICAgZXh0cmFzOiB0aGlzLmV4dHJhcyxcbiAgICAgIGVuY29kaW5nLFxuICAgICAgZGF0YVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiW01lc3NhZ2VcIjtcbiAgICBpZiAodGhpcy5uYW1lKVxuICAgICAgcmVzdWx0ICs9IFwiOyBuYW1lPVwiICsgdGhpcy5uYW1lO1xuICAgIGlmICh0aGlzLmlkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBpZD1cIiArIHRoaXMuaWQ7XG4gICAgaWYgKHRoaXMudGltZXN0YW1wKVxuICAgICAgcmVzdWx0ICs9IFwiOyB0aW1lc3RhbXA9XCIgKyB0aGlzLnRpbWVzdGFtcDtcbiAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgIHJlc3VsdCArPSBcIjsgY2xpZW50SWQ9XCIgKyB0aGlzLmNsaWVudElkO1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZClcbiAgICAgIHJlc3VsdCArPSBcIjsgY29ubmVjdGlvbklkPVwiICsgdGhpcy5jb25uZWN0aW9uSWQ7XG4gICAgaWYgKHRoaXMuZW5jb2RpbmcpXG4gICAgICByZXN1bHQgKz0gXCI7IGVuY29kaW5nPVwiICsgdGhpcy5lbmNvZGluZztcbiAgICBpZiAodGhpcy5leHRyYXMpXG4gICAgICByZXN1bHQgKz0gXCI7IGV4dHJhcyA9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhcyk7XG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhPVwiICsgdGhpcy5kYXRhO1xuICAgICAgZWxzZSBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIodGhpcy5kYXRhKSlcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhIChidWZmZXIpPVwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YSAoanNvbik9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5leHRyYXMpXG4gICAgICByZXN1bHQgKz0gXCI7IGV4dHJhcz1cIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcbiAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBtZXNzYWdlX2RlZmF1bHQgPSBNZXNzYWdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wcmVzZW5jZW1lc3NhZ2UudHNcbnZhciBhY3Rpb25zID0gW1wiYWJzZW50XCIsIFwicHJlc2VudFwiLCBcImVudGVyXCIsIFwibGVhdmVcIiwgXCJ1cGRhdGVcIl07XG5mdW5jdGlvbiB0b0FjdGlvblZhbHVlKGFjdGlvblN0cmluZykge1xuICByZXR1cm4gYWN0aW9ucy5pbmRleE9mKGFjdGlvblN0cmluZyk7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZDIobG9nZ2VyLCBlbmNvZGVkLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1zZyA9IGZyb21WYWx1ZXMyKGVuY29kZWQsIHRydWUpO1xuICB0cnkge1xuICAgIGF3YWl0IGRlY29kZTIobXNnLCBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge30pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIlByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZCgpXCIsIGUudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIG1zZztcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkQXJyYXkyKGxvZ2dlciwgZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHJldHVybiBmcm9tRW5jb2RlZDIobG9nZ2VyLCBlbmNvZGVkLCBvcHRpb25zKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gZnJvbVZhbHVlczIodmFsdWVzLCBzdHJpbmdpZnlBY3Rpb24pIHtcbiAgaWYgKHN0cmluZ2lmeUFjdGlvbikge1xuICAgIHZhbHVlcy5hY3Rpb24gPSBhY3Rpb25zW3ZhbHVlcy5hY3Rpb25dO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcbn1cbnZhciBkZWNvZGUyID0gZGVjb2RlO1xuYXN5bmMgZnVuY3Rpb24gZnJvbVJlc3BvbnNlQm9keTIoYm9keSwgb3B0aW9ucywgbG9nZ2VyLCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgaWYgKGZvcm1hdCkge1xuICAgIGJvZHkgPSBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbXNnID0gbWVzc2FnZXNbaV0gPSBmcm9tVmFsdWVzMihib2R5W2ldLCB0cnVlKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlMihtc2csIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSgpXCIsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXNzYWdlcztcbn1cbmZ1bmN0aW9uIGZyb21WYWx1ZXNBcnJheTIodmFsdWVzKSB7XG4gIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgIHJlc3VsdFtpXSA9IGZyb21WYWx1ZXMyKHZhbHVlc1tpXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmcm9tRGF0YShkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUHJlc2VuY2VNZXNzYWdlKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIGZyb21WYWx1ZXMyKHtcbiAgICBkYXRhXG4gIH0pO1xufVxudmFyIFByZXNlbmNlTWVzc2FnZSA9IGNsYXNzIHtcbiAgLyogUmV0dXJucyB3aGV0aGVyIHRoaXMgcHJlc2VuY2VNZXNzYWdlIGlzIHN5bnRoZXNpemVkLCBpLmUuIHdhcyBub3QgYWN0dWFsbHlcbiAgICogc2VudCBieSB0aGUgY29ubmVjdGlvbiAodXN1YWxseSBtZWFucyBhIGxlYXZlIGV2ZW50IHNlbnQgMTVzIGFmdGVyIGFcbiAgICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXG4gICAqIGNvbXBhcmVkIGZvciBuZXduZXNzIGJ5IGlkIGxleGljb2dyYXBoaWNhbGx5IC0gUlRQMmIxXG4gICAqL1xuICBpc1N5bnRoZXNpemVkKCkge1xuICAgIGlmICghdGhpcy5pZCB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcodGhpcy5jb25uZWN0aW9uSWQubGVuZ3RoLCAwKSAhPT0gdGhpcy5jb25uZWN0aW9uSWQ7XG4gIH1cbiAgLyogUlRQMmIyICovXG4gIHBhcnNlSWQoKSB7XG4gICAgaWYgKCF0aGlzLmlkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFyc2VJZCgpOiBQcmVzZW5jZSBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYW4gaWRcIik7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLmlkLnNwbGl0KFwiOlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29ubmVjdGlvbklkOiBwYXJ0c1swXSxcbiAgICAgIG1zZ1NlcmlhbDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIGluZGV4OiBwYXJzZUludChwYXJ0c1syXSwgMTApXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBsZXQgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuICAgIGlmIChkYXRhICYmIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvYmFzZTY0XCIgOiBcImJhc2U2NFwiO1xuICAgICAgICBkYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgIC8qIENvbnZlcnQgcHJlc2VuY2UgYWN0aW9uIGJhY2sgdG8gYW4gaW50IGZvciBzZW5kaW5nIHRvIEFibHkgKi9cbiAgICAgIGFjdGlvbjogdG9BY3Rpb25WYWx1ZSh0aGlzLmFjdGlvbiksXG4gICAgICBkYXRhLFxuICAgICAgZW5jb2RpbmcsXG4gICAgICBleHRyYXM6IHRoaXMuZXh0cmFzXG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJbUHJlc2VuY2VNZXNzYWdlXCI7XG4gICAgcmVzdWx0ICs9IFwiOyBhY3Rpb249XCIgKyB0aGlzLmFjdGlvbjtcbiAgICBpZiAodGhpcy5pZClcbiAgICAgIHJlc3VsdCArPSBcIjsgaWQ9XCIgKyB0aGlzLmlkO1xuICAgIGlmICh0aGlzLnRpbWVzdGFtcClcbiAgICAgIHJlc3VsdCArPSBcIjsgdGltZXN0YW1wPVwiICsgdGhpcy50aW1lc3RhbXA7XG4gICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNsaWVudElkPVwiICsgdGhpcy5jbGllbnRJZDtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uSWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNvbm5lY3Rpb25JZD1cIiArIHRoaXMuY29ubmVjdGlvbklkO1xuICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgcmVzdWx0ICs9IFwiOyBlbmNvZGluZz1cIiArIHRoaXMuZW5jb2Rpbmc7XG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhPVwiICsgdGhpcy5kYXRhO1xuICAgICAgZWxzZSBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIodGhpcy5kYXRhKSlcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhIChidWZmZXIpPVwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YSAoanNvbik9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5leHRyYXMpIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgZXh0cmFzPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuICAgIH1cbiAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdCA9IFByZXNlbmNlTWVzc2FnZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RwcmVzZW5jZS50c1xudmFyIFJlc3RQcmVzZW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmxvZ2dlcjtcbiAgfVxuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVzdFByZXNlbmNlLmdldCgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUpO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2hhbm5lbC5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jaGFubmVsLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jaGFubmVsLmNoYW5uZWxPcHRpb25zO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChcbiAgICAgIGNsaWVudCxcbiAgICAgIHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluLmJhc2VQYXRoKHRoaXMpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgZnJvbVJlc3BvbnNlQm9keTIoXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgICAgICB1bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgaGlzdG9yeShwYXJhbXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZXN0UHJlc2VuY2UuaGlzdG9yeSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuY2xpZW50LnJlc3QucHJlc2VuY2VNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcmVzdHByZXNlbmNlX2RlZmF1bHQgPSBSZXN0UHJlc2VuY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0Y2hhbm5lbC50c1xudmFyIE1TR19JRF9FTlRST1BZX0JZVEVTID0gOTtcbmZ1bmN0aW9uIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSB7XG4gIHJldHVybiBtZXNzYWdlcy5ldmVyeShmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgcmV0dXJuICFtZXNzYWdlLmlkO1xuICB9KTtcbn1cbnZhciBSZXN0Q2hhbm5lbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihjbGllbnQubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVzdENoYW5uZWwoKVwiLCBcInN0YXJ0ZWQ7IG5hbWUgPSBcIiArIG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVzZW5jZSA9IG5ldyByZXN0cHJlc2VuY2VfZGVmYXVsdCh0aGlzKTtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IGNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIGNoYW5uZWxPcHRpb25zKTtcbiAgICBpZiAoKF9iID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLlB1c2gpIHtcbiAgICAgIHRoaXMuX3B1c2ggPSBuZXcgY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLlB1c2hDaGFubmVsKHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQgcHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX3B1c2gpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1c2g7XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyO1xuICB9XG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfYTI7XG4gICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKChfYTIgPSB0aGlzLmNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGhpc3RvcnkocGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVzdENoYW5uZWwuaGlzdG9yeSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uaGlzdG9yeSh0aGlzLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goLi4uYXJncykge1xuICAgIGNvbnN0IGZpcnN0ID0gYXJnc1swXSwgc2Vjb25kID0gYXJnc1sxXTtcbiAgICBsZXQgbWVzc2FnZXM7XG4gICAgbGV0IHBhcmFtcztcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiIHx8IGZpcnN0ID09PSBudWxsKSB7XG4gICAgICBtZXNzYWdlcyA9IFtmcm9tVmFsdWVzKHsgbmFtZTogZmlyc3QsIGRhdGE6IHNlY29uZCB9KV07XG4gICAgICBwYXJhbXMgPSBhcmdzWzJdO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlyc3QpKSB7XG4gICAgICBtZXNzYWdlcyA9IFtmcm9tVmFsdWVzKGZpcnN0KV07XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gZnJvbVZhbHVlc0FycmF5KGZpcnN0KTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzXCIsXG4gICAgICAgIDQwMDEzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIG9wdGlvbnMgPSBjbGllbnQub3B0aW9ucywgZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSBjbGllbnQub3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nICYmIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSkge1xuICAgICAgY29uc3QgbXNnSWRCYXNlID0gYXdhaXQgcmFuZG9tU3RyaW5nKE1TR19JRF9FTlRST1BZX0JZVEVTKTtcbiAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24obWVzc2FnZSwgaW5kZXgpIHtcbiAgICAgICAgbWVzc2FnZS5pZCA9IG1zZ0lkQmFzZSArIFwiOlwiICsgaW5kZXgudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBlbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucyk7XG4gICAgY29uc3Qgc2l6ZSA9IGdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyksIG1heE1lc3NhZ2VTaXplID0gb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICBpZiAoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIk1heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyBcIiArIHNpemUgKyBcIiBieXRlczsgbGltaXQgaXMgXCIgKyBtYXhNZXNzYWdlU2l6ZSArIFwiIGJ5dGVzKVwiLFxuICAgICAgICA0MDAwOSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9wdWJsaXNoKHNlcmlhbGl6ZShtZXNzYWdlcywgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpLCBoZWFkZXJzLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIF9wdWJsaXNoKHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMpIHtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoXG4gICAgICB0aGlzLmNsaWVudCxcbiAgICAgIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmJhc2VQYXRoKHRoaXMpICsgXCIvbWVzc2FnZXNcIixcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuICBhc3luYyBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnN0YXR1cyh0aGlzKTtcbiAgfVxufTtcbnZhciByZXN0Y2hhbm5lbF9kZWZhdWx0ID0gUmVzdENoYW5uZWw7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3N0YXRzLnRzXG52YXIgU3RhdHMgPSBjbGFzcyBfU3RhdHMge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICB0aGlzLmVudHJpZXMgPSB2YWx1ZXMgJiYgdmFsdWVzLmVudHJpZXMgfHwgdm9pZCAwO1xuICAgIHRoaXMuc2NoZW1hID0gdmFsdWVzICYmIHZhbHVlcy5zY2hlbWEgfHwgdm9pZCAwO1xuICAgIHRoaXMuYXBwSWQgPSB2YWx1ZXMgJiYgdmFsdWVzLmFwcElkIHx8IHZvaWQgMDtcbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSB2YWx1ZXMgJiYgdmFsdWVzLmluUHJvZ3Jlc3MgfHwgdm9pZCAwO1xuICAgIHRoaXMudW5pdCA9IHZhbHVlcyAmJiB2YWx1ZXMudW5pdCB8fCB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcnZhbElkID0gdmFsdWVzICYmIHZhbHVlcy5pbnRlcnZhbElkIHx8IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IF9TdGF0cyh2YWx1ZXMpO1xuICB9XG59O1xudmFyIHN0YXRzX2RlZmF1bHQgPSBTdGF0cztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RjaGFubmVsbWl4aW4udHNcbnZhciBSZXN0Q2hhbm5lbE1peGluID0gY2xhc3Mge1xuICBzdGF0aWMgYmFzZVBhdGgoY2hhbm5lbCkge1xuICAgIHJldHVybiBcIi9jaGFubmVscy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChjaGFubmVsLm5hbWUpO1xuICB9XG4gIHN0YXRpYyBoaXN0b3J5KGNoYW5uZWwsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IGNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IGNoYW5uZWwuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBjaGFubmVsLmNoYW5uZWxPcHRpb25zO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIHRoaXMuYmFzZVBhdGgoY2hhbm5lbCkgKyBcIi9tZXNzYWdlc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZnJvbVJlc3BvbnNlQm9keShcbiAgICAgICAgYm9keSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY2hhbm5lbC5sb2dnZXIsXG4gICAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgICAgdW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICAgICk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHN0YXR1cyhjaGFubmVsKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gY2hhbm5lbC5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjaGFubmVsLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KFxuICAgICAgY2hhbm5lbC5jbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKGNoYW5uZWwpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgZm9ybWF0LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0cHJlc2VuY2VtaXhpbi50c1xudmFyIFJlc3RQcmVzZW5jZU1peGluID0gY2xhc3Mge1xuICBzdGF0aWMgYmFzZVBhdGgocHJlc2VuY2UpIHtcbiAgICByZXR1cm4gUmVzdENoYW5uZWxNaXhpbi5iYXNlUGF0aChwcmVzZW5jZS5jaGFubmVsKSArIFwiL3ByZXNlbmNlXCI7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGhpc3RvcnkocHJlc2VuY2UsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHByZXNlbmNlLmNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHByZXNlbmNlLmNoYW5uZWwuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBwcmVzZW5jZS5jaGFubmVsLmNoYW5uZWxPcHRpb25zO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIHRoaXMuYmFzZVBhdGgocHJlc2VuY2UpICsgXCIvaGlzdG9yeVwiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZnJvbVJlc3BvbnNlQm9keTIoXG4gICAgICAgIGJvZHksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHByZXNlbmNlLmxvZ2dlcixcbiAgICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgICB1bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICAgKTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3QudHNcbnZhciBSZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNoYW5uZWxNaXhpbiA9IFJlc3RDaGFubmVsTWl4aW47XG4gICAgdGhpcy5wcmVzZW5jZU1peGluID0gUmVzdFByZXNlbmNlTWl4aW47XG4gICAgLy8gZXhwb3NlZCBmb3IgcGx1Z2lucyBidXQgc2hvdWxkbid0IGJlIGJ1bmRsZWQgd2l0aCBtaW5pbWFsIHJlYWx0aW1lXG4gICAgdGhpcy5SZXNvdXJjZSA9IHJlc291cmNlX2RlZmF1bHQ7XG4gICAgdGhpcy5EZXZpY2VEZXRhaWxzID0gZGV2aWNlZGV0YWlsc19kZWZhdWx0O1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcy5jbGllbnQpO1xuICAgIHRoaXMucHVzaCA9IG5ldyBwdXNoX2RlZmF1bHQodGhpcy5jbGllbnQpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpLCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KHRoaXMuY2xpZW50LCBcIi9zdGF0c1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICBjb25zdCBzdGF0c1ZhbHVlcyA9IHVucGFja2VkID8gYm9keSA6IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRzVmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdGF0c1ZhbHVlc1tpXSA9IHN0YXRzX2RlZmF1bHQuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG4gICAgICByZXR1cm4gc3RhdHNWYWx1ZXM7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgdGltZShwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCB0aW1lVXJpID0gKGhvc3QpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5iYXNlVXJpKGhvc3QpICsgXCIvdGltZVwiO1xuICAgIH07XG4gICAgbGV0IHsgZXJyb3IsIGJvZHksIHVucGFja2VkIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5odHRwLmRvKFxuICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsXG4gICAgICB0aW1lVXJpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG51bGwsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICghdW5wYWNrZWQpXG4gICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICBjb25zdCB0aW1lID0gYm9keVswXTtcbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSlcIiwgNWU0LCA1MDApO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ID0gdGltZSAtIERhdGUubm93KCk7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChtZXRob2QsIHBhdGgsIHZlcnNpb24yLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtlbmNvZGVyLCBkZWNvZGVyLCBmb3JtYXRdID0gKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQuX01zZ1BhY2spIHtcbiAgICAgICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmNsaWVudC5fTXNnUGFjay5lbmNvZGUsIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLmRlY29kZSwgXCJtc2dwYWNrXCIgLyogbXNncGFjayAqL107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW0pTT04uc3RyaW5naWZ5LCBKU09OLnBhcnNlLCBcImpzb25cIiAvKiBqc29uICovXTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIGNvbnN0IGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb25zdCBfbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IF9tZXRob2QgPT0gXCJnZXRcIiA/IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQsIHByb3RvY29sVmVyc2lvbjogdmVyc2lvbjIgfSkgOiBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCwgcHJvdG9jb2xWZXJzaW9uOiB2ZXJzaW9uMiB9KTtcbiAgICBpZiAodHlwZW9mIGJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvZHkgPSAoX2EyID0gZW5jb2Rlcihib2R5KSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGN1c3RvbUhlYWRlcnMpIHtcbiAgICAgIG1peGluKGhlYWRlcnMsIGN1c3RvbUhlYWRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgdGhpcy5jbGllbnQsXG4gICAgICBwYXRoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgZnVuY3Rpb24ocmVzYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVBcnJheSh1bnBhY2tlZCA/IHJlc2JvZHkgOiBkZWNvZGVyKHJlc2JvZHkpKTtcbiAgICAgIH0sXG4gICAgICAvKiB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2U6ICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoIVBsYXRmb3JtLkh0dHAubWV0aG9kcy5pbmNsdWRlcyhfbWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuc3VwcG9ydGVkIG1ldGhvZCBcIiArIF9tZXRob2QsIDQwNTAwLCA0MDUpO1xuICAgIH1cbiAgICBpZiAoUGxhdGZvcm0uSHR0cC5tZXRob2RzV2l0aEJvZHkuaW5jbHVkZXMoX21ldGhvZCkpIHtcbiAgICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZVtfbWV0aG9kXShwYXJhbXMsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgbGV0IHJlcXVlc3RCb2R5RFRPO1xuICAgIGxldCBzaW5nbGVTcGVjTW9kZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjT3JTcGVjcykpIHtcbiAgICAgIHJlcXVlc3RCb2R5RFRPID0gc3BlY09yU3BlY3M7XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0Qm9keURUTyA9IFtzcGVjT3JTcGVjc107XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIFwiL21lc3NhZ2VzXCIsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB7fSwgbnVsbCwgdHJ1ZSk7XG4gICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBpZiAoc2luZ2xlU3BlY01vZGUpIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHM7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBjaGFubmVsc1BhcmFtID0gY2hhbm5lbHMuam9pbihcIixcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldCh0aGlzLmNsaWVudCwgXCIvcHJlc2VuY2VcIiwgaGVhZGVycywgeyBjaGFubmVsczogY2hhbm5lbHNQYXJhbSB9LCBudWxsLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgfVxuICBhc3luYyByZXZva2VUb2tlbnMoc3BlY2lmaWVycywgb3B0aW9ucykge1xuICAgIGlmICh1c2VUb2tlbkF1dGgodGhpcy5jbGllbnQub3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJDYW5ub3QgcmV2b2tlIHRva2VucyB3aGVuIHVzaW5nIHRva2VuIGF1dGhcIiwgNDAxNjIsIDQwMSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU5hbWUgPSB0aGlzLmNsaWVudC5vcHRpb25zLmtleU5hbWU7XG4gICAgbGV0IHJlc29sdmVkT3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keURUTyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHRhcmdldHM6IHNwZWNpZmllcnMubWFwKChzcGVjaWZpZXIpID0+IGAke3NwZWNpZmllci50eXBlfToke3NwZWNpZmllci52YWx1ZX1gKVxuICAgIH0sIHJlc29sdmVkT3B0aW9ucyk7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KHJlcXVlc3RCb2R5RFRPLCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIHRoaXMuY2xpZW50LFxuICAgICAgYC9rZXlzLyR7a2V5TmFtZX0vcmV2b2tlVG9rZW5zYCxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS51bnBhY2tlZCA/IHJlc3BvbnNlLmJvZHkgOiBkZWNvZGVCb2R5KHJlc3BvbnNlLmJvZHksIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICB9XG59O1xudmFyIENoYW5uZWxzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmFsbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHRoaXMuYWxsW25hbWVdID0gY2hhbm5lbCA9IG5ldyByZXN0Y2hhbm5lbF9kZWZhdWx0KHRoaXMuY2xpZW50LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbiAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gIHJlbGVhc2UobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmFsbFtTdHJpbmcobmFtZSldO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZXJlc3QudHNcbnZhciBCYXNlUmVzdCA9IGNsYXNzIGV4dGVuZHMgYmFzZWNsaWVudF9kZWZhdWx0IHtcbiAgLypcbiAgICogVGhlIHB1YmxpYyB0eXBpbmdzIGRlY2xhcmUgdGhhdCB0aGlzIG9ubHkgYWNjZXB0cyBhbiBvYmplY3QsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgb25lIG9mIHRoZXNlIHRoaW5nczpcbiAgICpcbiAgICogMS4gcGFzc2VzIGEgc3RyaW5nICh3aGljaCBpcyBxdWl0ZSBsaWtlbHkgaWYgdGhleeKAmXJlIGUuZy4gbWlncmF0aW5nIGZyb20gdGhlIGRlZmF1bHQgdmFyaWFudCB0byB0aGUgbW9kdWxhciB2YXJpYW50KVxuICAgKiAyLiBwYXNzZXMgbm8gYXJndW1lbnQgYXQgYWxsXG4gICAqXG4gICAqIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhlc2UgY2FzZXMgYXJlIHBvc3NpYmxlIHNvIHRoYXQgaXQgZm9yY2VzIHVzIHRvIGhhbmRsZSB0aGVtLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBmYWxzZSwgXCJCYXNlUmVzdFwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCB7IFJlc3QgfSkpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvbW9kdWxhcnBsdWdpbnMudHNcbnZhciBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyA9IHsgUmVzdCB9O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0bWVzc2FnZS50c1xudmFyIERlZmF1bHRNZXNzYWdlID0gY2xhc3MgZXh0ZW5kcyBtZXNzYWdlX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkKGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIFBsYXRmb3JtLkNyeXB0bywgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheShsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWRBcnJheSwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gVXNlZCBieSB0ZXN0c1xuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgbWVzc2FnZV9kZWZhdWx0KCksIHZhbHVlcyk7XG4gIH1cbiAgLy8gVXNlZCBieSB0ZXN0c1xuICBzdGF0aWMgYXN5bmMgZW5jb2RlKG1zZywgb3B0aW9ucykge1xuICAgIHJldHVybiBlbmNvZGUobXNnLCBvcHRpb25zKTtcbiAgfVxuICAvLyBVc2VkIGJ5IHRlc3RzXG4gIHN0YXRpYyBhc3luYyBkZWNvZGUobWVzc2FnZSwgaW5wdXRDb250ZXh0KSB7XG4gICAgcmV0dXJuIGRlY29kZShtZXNzYWdlLCBpbnB1dENvbnRleHQpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0cHJlc2VuY2VtZXNzYWdlLnRzXG52YXIgRGVmYXVsdFByZXNlbmNlTWVzc2FnZSA9IGNsYXNzIGV4dGVuZHMgcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkMihsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBlbmNvZGVkLCBpbnB1dE9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tRW5jb2RlZEFycmF5KGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZEFycmF5Mihsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcywgc3RyaW5naWZ5QWN0aW9uKSB7XG4gICAgcmV0dXJuIGZyb21WYWx1ZXMyKHZhbHVlcywgc3RyaW5naWZ5QWN0aW9uKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2RlZmF1bHRyZXN0LnRzXG52YXIgX0RlZmF1bHRSZXN0ID0gY2xhc3MgX0RlZmF1bHRSZXN0IGV4dGVuZHMgQmFzZVJlc3Qge1xuICAvLyBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgcmVxdWlyZXMgYW4gYXJndW1lbnQgdG8gYmUgcGFzc2VkLCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG5vdCBwYXNzIGFuIGFyZ3VtZW50LCB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoaXMgaXMgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIGl0LlxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3QgTXNnUGFjayA9IF9EZWZhdWx0UmVzdC5fTXNnUGFjaztcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIERlZmF1bHRSZXN0Ll9Nc2dQYWNrIHRvIGhhdmUgYmVlbiBzZXRcIik7XG4gICAgfVxuICAgIHN1cGVyKFxuICAgICAgZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIHRydWUsIFwiUmVzdFwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyksIHtcbiAgICAgICAgQ3J5cHRvOiAoX2EyID0gX0RlZmF1bHRSZXN0LkNyeXB0bykgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCxcbiAgICAgICAgTXNnUGFjazogKF9iID0gX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrKSAhPSBudWxsID8gX2IgOiB2b2lkIDBcbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGdldCBDcnlwdG8oKSB7XG4gICAgaWYgKHRoaXMuX0NyeXB0byA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fQ3J5cHRvO1xuICB9XG4gIHN0YXRpYyBzZXQgQ3J5cHRvKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fQ3J5cHRvID0gbmV3VmFsdWU7XG4gIH1cbn07XG5fRGVmYXVsdFJlc3QuX0NyeXB0byA9IG51bGw7XG5fRGVmYXVsdFJlc3QuTWVzc2FnZSA9IERlZmF1bHRNZXNzYWdlO1xuX0RlZmF1bHRSZXN0LlByZXNlbmNlTWVzc2FnZSA9IERlZmF1bHRQcmVzZW5jZU1lc3NhZ2U7XG5fRGVmYXVsdFJlc3QuX01zZ1BhY2sgPSBudWxsO1xuLy8gVXNlZCBieSB0ZXN0c1xuX0RlZmF1bHRSZXN0Ll9IdHRwID0gSHR0cDtcbnZhciBEZWZhdWx0UmVzdCA9IF9EZWZhdWx0UmVzdDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9ldmVudGVtaXR0ZXIudHNcbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsb2dnZXIsIGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICBsaXN0ZW5lci5hcHBseShldmVudFRoaXMsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJFdmVudEVtaXR0ZXIuZW1pdCgpXCIsXG4gICAgICBcIlVuZXhwZWN0ZWQgbGlzdGVuZXIgZXhjZXB0aW9uOiBcIiArIGUgKyBcIjsgc3RhY2sgPSBcIiArIChlICYmIGUuc3RhY2spXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodGFyZ2V0TGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnRGaWx0ZXIpIHtcbiAgbGV0IGxpc3RlbmVycztcbiAgbGV0IGluZGV4O1xuICBsZXQgZXZlbnROYW1lO1xuICBmb3IgKGxldCB0YXJnZXRMaXN0ZW5lcnNJbmRleCA9IDA7IHRhcmdldExpc3RlbmVyc0luZGV4IDwgdGFyZ2V0TGlzdGVuZXJzLmxlbmd0aDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXgrKykge1xuICAgIGxpc3RlbmVycyA9IHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF07XG4gICAgaWYgKGV2ZW50RmlsdGVyKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbZXZlbnRGaWx0ZXJdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICB3aGlsZSAoKGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRGaWx0ZXIgJiYgbGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0TGlzdGVuZXJzW3RhcmdldExpc3RlbmVyc0luZGV4XVtldmVudEZpbHRlcl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0ZW5lcnMpKSB7XG4gICAgICBmb3IgKGV2ZW50TmFtZSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsaXN0ZW5lcnMsIGV2ZW50TmFtZSkgJiYgQXJyYXkuaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcihbbGlzdGVuZXJzXSwgbGlzdGVuZXIsIGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBFdmVudEVtaXR0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuYW55ID0gW107XG4gICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICB0aGlzLmV2ZW50c09uY2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBvbiguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGFyZ3NbMF07XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5hbnkucHVzaChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSA9IGFyZ3M7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOaWwoZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBldmVudC5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdKTtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvZmYoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwIHx8IGlzTmlsKGFyZ3NbMF0pICYmIGlzTmlsKGFyZ3NbMV0pKSB7XG4gICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgICAgdGhpcy5ldmVudHNPbmNlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IGFyZ3M7XG4gICAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgICBsZXQgZXZlbnQgPSBudWxsO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSB8fCAhc2Vjb25kQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBmaXJzdEFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZmlyc3RBcmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czpcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIFtldmVudCwgbGlzdGVuZXJdID0gW2ZpcnN0QXJnLCBzZWNvbmRBcmddO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXIgJiYgaXNOaWwoZXZlbnQpKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5hbnksIHRoaXMuZXZlbnRzLCB0aGlzLmFueU9uY2UsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBldmVudC5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBldmVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czpcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5ldmVudHMsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyLCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50OyBleGNsdWRlcyBvbmNlIGV2ZW50c1xuICAgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQsIG9yIG5vbmUgZm9yICdhbnknXG4gICAqIEByZXR1cm4gYXJyYXkgb2YgZXZlbnRzLCBvciBudWxsIGlmIG5vbmVcbiAgICovXG4gIGxpc3RlbmVycyhldmVudCkge1xuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgaWYgKHRoaXMuZXZlbnRzT25jZVtldmVudF0pXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5ldmVudHNPbmNlW2V2ZW50XSk7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aCA/IGxpc3RlbmVycyA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFueS5sZW5ndGggPyB0aGlzLmFueSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAgICovXG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBldmVudFRoaXMgPSB7IGV2ZW50IH07XG4gICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgaWYgKHRoaXMuYW55T25jZS5sZW5ndGgpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnlPbmNlKTtcbiAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbnkubGVuZ3RoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55KTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzT25jZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgaWYgKGV2ZW50c09uY2VMaXN0ZW5lcnMpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzT25jZUxpc3RlbmVycyk7XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzTGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgIGlmIChldmVudHNMaXN0ZW5lcnMpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBjYWxsTGlzdGVuZXIodGhpcy5sb2dnZXIsIGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG4gIG9uY2UoLi4uYXJncykge1xuICAgIGNvbnN0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGFyZ0NvdW50ID09PSAwIHx8IGFyZ0NvdW50ID09PSAxICYmIHR5cGVvZiBhcmdzWzBdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLm9uY2UoZXZlbnQsIHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IGFyZ3M7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLmFueU9uY2UucHVzaChmaXJzdEFyZyk7XG4gICAgfSBlbHNlIGlmIChpc05pbChmaXJzdEFyZykpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFueU9uY2UucHVzaChzZWNvbmRBcmcpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdEFyZykpIHtcbiAgICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICAgIGNvbnN0IGxpc3RlbmVyV3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBpbm5lckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBmaXJzdEFyZy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHNlbGYyLm9mZihldmVudE5hbWUsIGxpc3RlbmVyV3JhcHBlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vjb25kQXJnLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICB9O1xuICAgICAgZmlyc3RBcmcuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgc2VsZjIub24oZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddIHx8ICh0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddID0gW10pO1xuICAgICAgaWYgKHNlY29uZEFyZykge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXJzLnB1c2goc2Vjb25kQXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhIHN0YXRlIGV2ZW50IGFuZCBmaXJlIGltbWVkaWF0ZWx5IGlmIGN1cnJlbnRTdGF0ZSBtYXRjaGVzIHRhcmdldFN0YXRlXG4gICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gICAqIEBwYXJhbSBjdXJyZW50U3RhdGUgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBvYmplY3RcbiAgICovXG4gIGFzeW5jIHdoZW5TdGF0ZSh0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRTdGF0ZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY3VycmVudFN0YXRlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3aGVuU3RhdGUgcmVxdWlyZXMgYSB2YWxpZCBzdGF0ZSBTdHJpbmcgYXJndW1lbnRcIik7XG4gICAgfVxuICAgIGlmICh0YXJnZXRTdGF0ZSA9PT0gY3VycmVudFN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub25jZSh0YXJnZXRTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xudmFyIGV2ZW50ZW1pdHRlcl9kZWZhdWx0ID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wcm90b2NvbG1lc3NhZ2UudHNcbnZhciBhY3Rpb25zMiA9IHtcbiAgSEVBUlRCRUFUOiAwLFxuICBBQ0s6IDEsXG4gIE5BQ0s6IDIsXG4gIENPTk5FQ1Q6IDMsXG4gIENPTk5FQ1RFRDogNCxcbiAgRElTQ09OTkVDVDogNSxcbiAgRElTQ09OTkVDVEVEOiA2LFxuICBDTE9TRTogNyxcbiAgQ0xPU0VEOiA4LFxuICBFUlJPUjogOSxcbiAgQVRUQUNIOiAxMCxcbiAgQVRUQUNIRUQ6IDExLFxuICBERVRBQ0g6IDEyLFxuICBERVRBQ0hFRDogMTMsXG4gIFBSRVNFTkNFOiAxNCxcbiAgTUVTU0FHRTogMTUsXG4gIFNZTkM6IDE2LFxuICBBVVRIOiAxNyxcbiAgQUNUSVZBVEU6IDE4XG59O1xudmFyIEFjdGlvbk5hbWUgPSBbXTtcbk9iamVjdC5rZXlzKGFjdGlvbnMyKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgQWN0aW9uTmFtZVthY3Rpb25zMltuYW1lXV0gPSBuYW1lO1xufSk7XG52YXIgZmxhZ3MgPSB7XG4gIC8qIENoYW5uZWwgYXR0YWNoIHN0YXRlIGZsYWdzICovXG4gIEhBU19QUkVTRU5DRTogMSA8PCAwLFxuICBIQVNfQkFDS0xPRzogMSA8PCAxLFxuICBSRVNVTUVEOiAxIDw8IDIsXG4gIFRSQU5TSUVOVDogMSA8PCA0LFxuICBBVFRBQ0hfUkVTVU1FOiAxIDw8IDUsXG4gIC8qIENoYW5uZWwgbW9kZSBmbGFncyAqL1xuICBQUkVTRU5DRTogMSA8PCAxNixcbiAgUFVCTElTSDogMSA8PCAxNyxcbiAgU1VCU0NSSUJFOiAxIDw8IDE4LFxuICBQUkVTRU5DRV9TVUJTQ1JJQkU6IDEgPDwgMTlcbn07XG52YXIgZmxhZ05hbWVzID0gT2JqZWN0LmtleXMoZmxhZ3MpO1xuZmxhZ3MuTU9ERV9BTEwgPSBmbGFncy5QUkVTRU5DRSB8IGZsYWdzLlBVQkxJU0ggfCBmbGFncy5TVUJTQ1JJQkUgfCBmbGFncy5QUkVTRU5DRV9TVUJTQ1JJQkU7XG5mdW5jdGlvbiB0b1N0cmluZ0FycmF5KGFycmF5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAoYXJyYXkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpXS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiWyBcIiArIHJlc3VsdC5qb2luKFwiLCBcIikgKyBcIiBdXCI7XG59XG52YXIgY2hhbm5lbE1vZGVzID0gW1wiUFJFU0VOQ0VcIiwgXCJQVUJMSVNIXCIsIFwiU1VCU0NSSUJFXCIsIFwiUFJFU0VOQ0VfU1VCU0NSSUJFXCJdO1xudmFyIHNlcmlhbGl6ZTIgPSBlbmNvZGVCb2R5O1xuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCwgTXNnUGFjaywgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBmb3JtYXQpIHtcbiAgY29uc3QgZGVzZXJpYWxpemVkID0gZGVjb2RlQm9keShzZXJpYWxpemVkLCBNc2dQYWNrLCBmb3JtYXQpO1xuICByZXR1cm4gZnJvbURlc2VyaWFsaXplZChkZXNlcmlhbGl6ZWQsIHByZXNlbmNlTWVzc2FnZVBsdWdpbik7XG59XG5mdW5jdGlvbiBmcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCwgcHJlc2VuY2VNZXNzYWdlUGx1Z2luKSB7XG4gIGNvbnN0IGVycm9yID0gZGVzZXJpYWxpemVkLmVycm9yO1xuICBpZiAoZXJyb3IpXG4gICAgZGVzZXJpYWxpemVkLmVycm9yID0gRXJyb3JJbmZvLmZyb21WYWx1ZXMoZXJyb3IpO1xuICBjb25zdCBtZXNzYWdlcyA9IGRlc2VyaWFsaXplZC5tZXNzYWdlcztcbiAgaWYgKG1lc3NhZ2VzKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspXG4gICAgICBtZXNzYWdlc1tpXSA9IGZyb21WYWx1ZXMobWVzc2FnZXNbaV0pO1xuICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlTWVzc2FnZVBsdWdpbiA/IGRlc2VyaWFsaXplZC5wcmVzZW5jZSA6IHZvaWQgMDtcbiAgaWYgKHByZXNlbmNlTWVzc2FnZVBsdWdpbikge1xuICAgIGlmIChwcmVzZW5jZSAmJiBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXNlbmNlLmxlbmd0aDsgaSsrKVxuICAgICAgICBwcmVzZW5jZVtpXSA9IHByZXNlbmNlTWVzc2FnZVBsdWdpbi5wcmVzZW5jZU1lc3NhZ2VGcm9tVmFsdWVzKHByZXNlbmNlW2ldLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGRlc2VyaWFsaXplZCksIHsgcHJlc2VuY2UgfSkpO1xufVxuZnVuY3Rpb24gZnJvbURlc2VyaWFsaXplZEluY2x1ZGluZ0RlcGVuZGVuY2llcyhkZXNlcmlhbGl6ZWQpIHtcbiAgcmV0dXJuIGZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkLCB7IHByZXNlbmNlTWVzc2FnZUZyb21WYWx1ZXM6IGZyb21WYWx1ZXMyLCBwcmVzZW5jZU1lc3NhZ2VzRnJvbVZhbHVlc0FycmF5OiBmcm9tVmFsdWVzQXJyYXkyIH0pO1xufVxuZnVuY3Rpb24gZnJvbVZhbHVlczModmFsdWVzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcm90b2NvbE1lc3NhZ2UoKSwgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShtc2csIHByZXNlbmNlTWVzc2FnZVBsdWdpbikge1xuICBsZXQgcmVzdWx0ID0gXCJbUHJvdG9jb2xNZXNzYWdlXCI7XG4gIGlmIChtc2cuYWN0aW9uICE9PSB2b2lkIDApXG4gICAgcmVzdWx0ICs9IFwiOyBhY3Rpb249XCIgKyBBY3Rpb25OYW1lW21zZy5hY3Rpb25dIHx8IG1zZy5hY3Rpb247XG4gIGNvbnN0IHNpbXBsZUF0dHJpYnV0ZXMgPSBbXCJpZFwiLCBcImNoYW5uZWxcIiwgXCJjaGFubmVsU2VyaWFsXCIsIFwiY29ubmVjdGlvbklkXCIsIFwiY291bnRcIiwgXCJtc2dTZXJpYWxcIiwgXCJ0aW1lc3RhbXBcIl07XG4gIGxldCBhdHRyaWJ1dGU7XG4gIGZvciAobGV0IGF0dHJpYkluZGV4ID0gMDsgYXR0cmliSW5kZXggPCBzaW1wbGVBdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cmliSW5kZXgrKykge1xuICAgIGF0dHJpYnV0ZSA9IHNpbXBsZUF0dHJpYnV0ZXNbYXR0cmliSW5kZXhdO1xuICAgIGlmIChtc2dbYXR0cmlidXRlXSAhPT0gdm9pZCAwKVxuICAgICAgcmVzdWx0ICs9IFwiOyBcIiArIGF0dHJpYnV0ZSArIFwiPVwiICsgbXNnW2F0dHJpYnV0ZV07XG4gIH1cbiAgaWYgKG1zZy5tZXNzYWdlcylcbiAgICByZXN1bHQgKz0gXCI7IG1lc3NhZ2VzPVwiICsgdG9TdHJpbmdBcnJheShmcm9tVmFsdWVzQXJyYXkobXNnLm1lc3NhZ2VzKSk7XG4gIGlmIChtc2cucHJlc2VuY2UgJiYgcHJlc2VuY2VNZXNzYWdlUGx1Z2luKVxuICAgIHJlc3VsdCArPSBcIjsgcHJlc2VuY2U9XCIgKyB0b1N0cmluZ0FycmF5KHByZXNlbmNlTWVzc2FnZVBsdWdpbi5wcmVzZW5jZU1lc3NhZ2VzRnJvbVZhbHVlc0FycmF5KG1zZy5wcmVzZW5jZSkpO1xuICBpZiAobXNnLmVycm9yKVxuICAgIHJlc3VsdCArPSBcIjsgZXJyb3I9XCIgKyBFcnJvckluZm8uZnJvbVZhbHVlcyhtc2cuZXJyb3IpLnRvU3RyaW5nKCk7XG4gIGlmIChtc2cuYXV0aCAmJiBtc2cuYXV0aC5hY2Nlc3NUb2tlbilcbiAgICByZXN1bHQgKz0gXCI7IHRva2VuPVwiICsgbXNnLmF1dGguYWNjZXNzVG9rZW47XG4gIGlmIChtc2cuZmxhZ3MpXG4gICAgcmVzdWx0ICs9IFwiOyBmbGFncz1cIiArIGZsYWdOYW1lcy5maWx0ZXIobXNnLmhhc0ZsYWcpLmpvaW4oXCIsXCIpO1xuICBpZiAobXNnLnBhcmFtcykge1xuICAgIGxldCBzdHJpbmdpZmllZFBhcmFtcyA9IFwiXCI7XG4gICAgZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyhtc2cucGFyYW1zLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdHJpbmdpZmllZFBhcmFtcyArPSBcIjsgXCI7XG4gICAgICB9XG4gICAgICBzdHJpbmdpZmllZFBhcmFtcyArPSBwcm9wICsgXCI9XCIgKyBtc2cucGFyYW1zW3Byb3BdO1xuICAgIH0pO1xuICAgIGlmIChzdHJpbmdpZmllZFBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQgKz0gXCI7IHBhcmFtcz1bXCIgKyBzdHJpbmdpZmllZFBhcmFtcyArIFwiXVwiO1xuICAgIH1cbiAgfVxuICByZXN1bHQgKz0gXCJdXCI7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgUHJvdG9jb2xNZXNzYWdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhhc0ZsYWcgPSAoZmxhZykgPT4ge1xuICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgZmxhZ3NbZmxhZ10pID4gMDtcbiAgICB9O1xuICB9XG4gIHNldEZsYWcoZmxhZykge1xuICAgIHJldHVybiB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8IGZsYWdzW2ZsYWddO1xuICB9XG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ3MgJiYgdGhpcy5mbGFncyAmIGZsYWdzLk1PREVfQUxMO1xuICB9XG4gIGVuY29kZU1vZGVzVG9GbGFncyhtb2Rlcykge1xuICAgIG1vZGVzLmZvckVhY2goKG1vZGUpID0+IHRoaXMuc2V0RmxhZyhtb2RlKSk7XG4gIH1cbiAgZGVjb2RlTW9kZXNGcm9tRmxhZ3MoKSB7XG4gICAgY29uc3QgbW9kZXMgPSBbXTtcbiAgICBjaGFubmVsTW9kZXMuZm9yRWFjaCgobW9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzRmxhZyhtb2RlKSkge1xuICAgICAgICBtb2Rlcy5wdXNoKG1vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2Rlcy5sZW5ndGggPiAwID8gbW9kZXMgOiB2b2lkIDA7XG4gIH1cbn07XG52YXIgcHJvdG9jb2xtZXNzYWdlX2RlZmF1bHQgPSBQcm90b2NvbE1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9tZXNzYWdlcXVldWUudHNcbnZhciBNZXNzYWdlUXVldWUgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgc3VwZXIobG9nZ2VyKTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gIH1cbiAgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICB9XG4gIHB1c2gobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgfVxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5zaGlmdCgpO1xuICB9XG4gIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXNbdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBjb3B5QWxsKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNsaWNlKCk7XG4gIH1cbiAgYXBwZW5kKG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoLmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgfVxuICBwcmVwZW5kKG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5tZXNzYWdlcy51bnNoaWZ0LmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgfVxuICBjb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJNZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcygpXCIsXG4gICAgICBcInNlcmlhbCA9IFwiICsgc2VyaWFsICsgXCI7IGNvdW50ID0gXCIgKyBjb3VudFxuICAgICk7XG4gICAgZXJyID0gZXJyIHx8IG51bGw7XG4gICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKCk6IGNvbXBsZXRlTWVzc2FnZXMgY2FsbGVkIG9uIGFueSBlbXB0eSBNZXNzYWdlUXVldWVcIik7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gbWVzc2FnZXNbMF07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjb25zdCBzdGFydFNlcmlhbCA9IGZpcnN0Lm1lc3NhZ2UubXNnU2VyaWFsO1xuICAgICAgY29uc3QgZW5kU2VyaWFsID0gc2VyaWFsICsgY291bnQ7XG4gICAgICBpZiAoZW5kU2VyaWFsID4gc3RhcnRTZXJpYWwpIHtcbiAgICAgICAgY29uc3QgY29tcGxldGVNZXNzYWdlcyA9IG1lc3NhZ2VzLnNwbGljZSgwLCBlbmRTZXJpYWwgLSBzdGFydFNlcmlhbCk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBjb21wbGV0ZU1lc3NhZ2VzKSB7XG4gICAgICAgICAgbWVzc2FnZS5jYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09IDApXG4gICAgICAgIHRoaXMuZW1pdChcImlkbGVcIik7XG4gICAgfVxuICB9XG4gIGNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKSB7XG4gICAgdGhpcy5jb21wbGV0ZU1lc3NhZ2VzKDAsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE51bWJlci5NQVhfVkFMVUUsIGVycik7XG4gIH1cbiAgcmVzZXRTZW5kQXR0ZW1wdGVkKCkge1xuICAgIGZvciAobGV0IG1zZyBvZiB0aGlzLm1lc3NhZ2VzKSB7XG4gICAgICBtc2cuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiTWVzc2FnZVF1ZXVlLmNsZWFyKClcIixcbiAgICAgIFwiY2xlYXJpbmcgXCIgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArIFwiIG1lc3NhZ2VzXCJcbiAgICApO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLmVtaXQoXCJpZGxlXCIpO1xuICB9XG59O1xudmFyIG1lc3NhZ2VxdWV1ZV9kZWZhdWx0ID0gTWVzc2FnZVF1ZXVlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvcHJvdG9jb2wudHNcbnZhciBQZW5kaW5nTWVzc2FnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLm1lcmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdGlvbiA9IG1lc3NhZ2UuYWN0aW9uO1xuICAgIHRoaXMuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuYWNrUmVxdWlyZWQgPSBhY3Rpb24gPT0gYWN0aW9uczIuTUVTU0FHRSB8fCBhY3Rpb24gPT0gYWN0aW9uczIuUFJFU0VOQ0U7XG4gIH1cbn07XG52YXIgUHJvdG9jb2wgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LmxvZ2dlcik7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgbWVzc2FnZXF1ZXVlX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRyYW5zcG9ydC5vbihcImFja1wiLCAoc2VyaWFsLCBjb3VudCkgPT4ge1xuICAgICAgdGhpcy5vbkFjayhzZXJpYWwsIGNvdW50KTtcbiAgICB9KTtcbiAgICB0cmFuc3BvcnQub24oXCJuYWNrXCIsIChzZXJpYWwsIGNvdW50LCBlcnIpID0+IHtcbiAgICAgIHRoaXMub25OYWNrKHNlcmlhbCwgY291bnQsIGVycik7XG4gICAgfSk7XG4gIH1cbiAgb25BY2soc2VyaWFsLCBjb3VudCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlByb3RvY29sLm9uQWNrKClcIiwgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnQpO1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCk7XG4gIH1cbiAgb25OYWNrKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJQcm90b2NvbC5vbk5hY2soKVwiLFxuICAgICAgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnQgKyBcIjsgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICk7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gc2VuZCBtZXNzYWdlOyBjaGFubmVsIG5vdCByZXNwb25kaW5nXCIsIDUwMDAxLCA1MDApO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQsIGVycik7XG4gIH1cbiAgb25jZUlkbGUobGlzdGVuZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlUXVldWUgPSB0aGlzLm1lc3NhZ2VRdWV1ZTtcbiAgICBpZiAobWVzc2FnZVF1ZXVlLmNvdW50KCkgPT09IDApIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lc3NhZ2VRdWV1ZS5vbmNlKFwiaWRsZVwiLCBsaXN0ZW5lcik7XG4gIH1cbiAgc2VuZChwZW5kaW5nTWVzc2FnZSkge1xuICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCkge1xuICAgICAgdGhpcy5tZXNzYWdlUXVldWUucHVzaChwZW5kaW5nTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJQcm90b2NvbC5zZW5kKClcIixcbiAgICAgICAgXCJzZW5kaW5nIG1zZzsgXCIgKyBzdHJpbmdpZnkocGVuZGluZ01lc3NhZ2UubWVzc2FnZSwgdGhpcy50cmFuc3BvcnQuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UpXG4gICAgICApO1xuICAgIH1cbiAgICBwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuICB9XG4gIGdldFRyYW5zcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0UGVuZGluZ01lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jb3B5QWxsKCk7XG4gIH1cbiAgY2xlYXJQZW5kaW5nTWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNsZWFyKCk7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0O1xuICAgIHRoaXMub25jZUlkbGUoZnVuY3Rpb24oKSB7XG4gICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHByb3RvY29sX2RlZmF1bHQgPSBQcm90b2NvbDtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZS50c1xudmFyIENvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJldmlvdXMsIGN1cnJlbnQsIHJldHJ5SW4sIHJlYXNvbikge1xuICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgIGlmIChyZXRyeUluKVxuICAgICAgdGhpcy5yZXRyeUluID0gcmV0cnlJbjtcbiAgICBpZiAocmVhc29uKVxuICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIH1cbn07XG52YXIgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQgPSBDb25uZWN0aW9uU3RhdGVDaGFuZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9uZXJyb3JzLnRzXG52YXIgQ29ubmVjdGlvbkVycm9yQ29kZXMgPSB7XG4gIERJU0NPTk5FQ1RFRDogODAwMDMsXG4gIFNVU1BFTkRFRDogODAwMDIsXG4gIEZBSUxFRDogOGU0LFxuICBDTE9TSU5HOiA4MDAxNyxcbiAgQ0xPU0VEOiA4MDAxNyxcbiAgVU5LTk9XTl9DT05ORUNUSU9OX0VSUjogNTAwMDIsXG4gIFVOS05PV05fQ0hBTk5FTF9FUlI6IDUwMDAxXG59O1xudmFyIENvbm5lY3Rpb25FcnJvcnMgPSB7XG4gIGRpc2Nvbm5lY3RlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5ESVNDT05ORUNURUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIHRvIHNlcnZlciB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZVwiXG4gIH0pLFxuICBzdXNwZW5kZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuU1VTUEVOREVELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdW5hdmFpbGFibGVcIlxuICB9KSxcbiAgZmFpbGVkOiAoKSA9PiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgc3RhdHVzQ29kZTogNDAwLFxuICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLkZBSUxFRCxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gZmFpbGVkIG9yIGRpc2Nvbm5lY3RlZCBieSBzZXJ2ZXJcIlxuICB9KSxcbiAgY2xvc2luZzogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TSU5HLFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBjbG9zaW5nXCJcbiAgfSksXG4gIGNsb3NlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TRUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGNsb3NlZFwiXG4gIH0pLFxuICB1bmtub3duQ29ubmVjdGlvbkVycjogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvclwiXG4gIH0pLFxuICB1bmtub3duQ2hhbm5lbEVycjogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgY2hhbm5lbCBlcnJvclwiXG4gIH0pXG59O1xuZnVuY3Rpb24gaXNSZXRyaWFibGUoZXJyKSB7XG4gIGlmICghZXJyLnN0YXR1c0NvZGUgfHwgIWVyci5jb2RlIHx8IGVyci5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBPYmplY3QudmFsdWVzKENvbm5lY3Rpb25FcnJvckNvZGVzKS5pbmNsdWRlcyhlcnIuY29kZSk7XG59XG52YXIgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0ID0gQ29ubmVjdGlvbkVycm9ycztcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L3RyYW5zcG9ydC50c1xudmFyIGNsb3NlTWVzc2FnZSA9IGZyb21WYWx1ZXMzKHsgYWN0aW9uOiBhY3Rpb25zMi5DTE9TRSB9KTtcbnZhciBkaXNjb25uZWN0TWVzc2FnZSA9IGZyb21WYWx1ZXMzKHsgYWN0aW9uOiBhY3Rpb25zMi5ESVNDT05ORUNUIH0pO1xudmFyIFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBmb3JjZUpzb25Qcm90b2NvbCkge1xuICAgIHN1cGVyKGNvbm5lY3Rpb25NYW5hZ2VyLmxvZ2dlcik7XG4gICAgaWYgKGZvcmNlSnNvblByb3RvY29sKSB7XG4gICAgICBwYXJhbXMuZm9ybWF0ID0gdm9pZCAwO1xuICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLnRpbWVvdXRzID0gcGFyYW1zLm9wdGlvbnMudGltZW91dHM7XG4gICAgdGhpcy5mb3JtYXQgPSBwYXJhbXMuZm9ybWF0O1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgfVxuICBjb25uZWN0KCkge1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImNsb3NlZFwiLCBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQuY2xvc2VkKCkpO1xuICB9XG4gIGRpc2Nvbm5lY3QoZXJyKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyIHx8IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5kaXNjb25uZWN0ZWQoKSk7XG4gIH1cbiAgZmFpbChlcnIpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImZhaWxlZFwiLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmZhaWxlZCgpKTtcbiAgfVxuICBmaW5pc2goZXZlbnQsIGVycikge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KChfYTIgPSB0aGlzLmlkbGVUaW1lcikgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCk7XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuZW1pdChldmVudCwgZXJyKTtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuICBvblByb3RvY29sTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlRyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpXCIsXG4gICAgICAgIFwicmVjZWl2ZWQgb24gXCIgKyB0aGlzLnNob3J0TmFtZSArIFwiOiBcIiArIHN0cmluZ2lmeShtZXNzYWdlLCB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlKSArIFwiOyBjb25uZWN0aW9uSWQgPSBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UuYWN0aW9uKSB7XG4gICAgICBjYXNlIGFjdGlvbnMyLkhFQVJUQkVBVDpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgIHRoaXMuc2hvcnROYW1lICsgXCIgaGVhcnRiZWF0OyBjb25uZWN0aW9uSWQgPSBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW1pdChcImhlYXJ0YmVhdFwiLCBtZXNzYWdlLmlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMyLkNPTk5FQ1RFRDpcbiAgICAgICAgdGhpcy5vbkNvbm5lY3QobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RlZFwiLCBtZXNzYWdlLmVycm9yLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscywgbWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zMi5DTE9TRUQ6XG4gICAgICAgIHRoaXMub25DbG9zZShtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMyLkRJU0NPTk5FQ1RFRDpcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QobWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zMi5BQ0s6XG4gICAgICAgIHRoaXMuZW1pdChcImFja1wiLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zMi5OQUNLOlxuICAgICAgICB0aGlzLmVtaXQoXCJuYWNrXCIsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50LCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMyLlNZTkM6XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMyLkFDVElWQVRFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9uczIuQVVUSDpcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuYXV0aC5hdXRob3JpemUoKSwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgICAgICBcIkFibHkgcmVxdWVzdGVkIHJlLWF1dGhlbnRpY2F0aW9uLCBidXQgdW5hYmxlIHRvIG9idGFpbiBhIG5ldyB0b2tlbjogXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9uczIuRVJST1I6XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgIFwicmVjZWl2ZWQgZXJyb3IgYWN0aW9uOyBjb25uZWN0aW9uSWQgPSBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkICsgXCI7IGVyciA9IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QobWVzc2FnZS5lcnJvcikgKyAobWVzc2FnZS5jaGFubmVsID8gXCIsIGNoYW5uZWw6IFwiICsgbWVzc2FnZS5jaGFubmVsIDogXCJcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY2hhbm5lbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5vbkZhdGFsRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25Db25uZWN0KG1lc3NhZ2UpIHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICBpZiAoIW1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydC5vbkNvbm5lY3QoKTogQ29ubmVjdCBtZXNzYWdlIHJlY2lldmVkIHdpdGhvdXQgY29ubmVjdGlvbkRldGFpbHNcIik7XG4gICAgfVxuICAgIGNvbnN0IG1heFByb21pc2VkSWRsZSA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuICAgIGlmIChtYXhQcm9taXNlZElkbGUpIHtcbiAgICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbWF4UHJvbWlzZWRJZGxlICsgdGhpcy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG4gIG9uRGlzY29ubmVjdChtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5vbkRpc2Nvbm5lY3QoKVwiLCBcImVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycikpO1xuICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gIH1cbiAgb25GYXRhbEVycm9yKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uRmF0YWxFcnJvcigpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJmYWlsZWRcIiwgZXJyKTtcbiAgfVxuICBvbkNsb3NlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uQ2xvc2UoKVwiLCBcImVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycikpO1xuICAgIHRoaXMuZmluaXNoKFwiY2xvc2VkXCIsIGVycik7XG4gIH1cbiAgcmVxdWVzdENsb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLnNlbmQoY2xvc2VNZXNzYWdlKTtcbiAgfVxuICByZXF1ZXN0RGlzY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLnNlbmQoZGlzY29ubmVjdE1lc3NhZ2UpO1xuICB9XG4gIHBpbmcoaWQpIHtcbiAgICBjb25zdCBtc2cgPSB7IGFjdGlvbjogYWN0aW9uczIuSEVBUlRCRUFUIH07XG4gICAgaWYgKGlkKVxuICAgICAgbXNnLmlkID0gaWQ7XG4gICAgdGhpcy5zZW5kKGZyb21WYWx1ZXMzKG1zZykpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbiAgb25BY3Rpdml0eSgpIHtcbiAgICBpZiAoIXRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5sYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRoaXMubWF4SWRsZUludGVydmFsICsgMTAwKTtcbiAgfVxuICBzZXRJZGxlVGltZXIodGltZW91dCkge1xuICAgIGlmICghdGhpcy5pZGxlVGltZXIpIHtcbiAgICAgIHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub25JZGxlVGltZXJFeHBpcmUoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBvbklkbGVUaW1lckV4cGlyZSgpIHtcbiAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCk6IGxhc3RBY3Rpdml0eS9tYXhJZGxlSW50ZXJ2YWwgbm90IHNldFwiKTtcbiAgICB9XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIGNvbnN0IHNpbmNlTGFzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICBjb25zdCB0aW1lUmVtYWluaW5nID0gdGhpcy5tYXhJZGxlSW50ZXJ2YWwgLSBzaW5jZUxhc3Q7XG4gICAgaWYgKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuICAgICAgY29uc3QgbXNnID0gXCJObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gXCIgKyBzaW5jZUxhc3QgKyBcIm1zOyBhc3N1bWluZyBjb25uZWN0aW9uIGhhcyBkcm9wcGVkXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KG5ldyBFcnJvckluZm8obXNnLCA4MDAwMywgNDA4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdHJ5Q29ubmVjdCh0cmFuc3BvcnRDdG9yLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRDdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgIGxldCB0cmFuc3BvcnRBdHRlbXB0VGltZXI7XG4gICAgY29uc3QgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zcG9ydEF0dGVtcHRUaW1lcik7XG4gICAgICBjYWxsYmFjayh7IGV2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCA9IGNvbm5lY3Rpb25NYW5hZ2VyLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICB0cmFuc3BvcnRBdHRlbXB0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRyYW5zcG9ydC5vZmYoW1wicHJlY29ubmVjdFwiLCBcImRpc2Nvbm5lY3RlZFwiLCBcImZhaWxlZFwiXSk7XG4gICAgICB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgZXJyb3JDYi5jYWxsKFxuICAgICAgICB7IGV2ZW50OiBcImRpc2Nvbm5lY3RlZFwiIH0sXG4gICAgICAgIG5ldyBFcnJvckluZm8oXCJUaW1lb3V0IHdhaXRpbmcgZm9yIHRyYW5zcG9ydCB0byBpbmRpY2F0ZSBpdHNlbGYgdmlhYmxlXCIsIDVlNCwgNTAwKVxuICAgICAgKTtcbiAgICB9LCByZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICB0cmFuc3BvcnQub24oW1wiZmFpbGVkXCIsIFwiZGlzY29ubmVjdGVkXCJdLCBlcnJvckNiKTtcbiAgICB0cmFuc3BvcnQub24oXCJwcmVjb25uZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJUcmFuc3BvcnQudHJ5Q29ubmVjdCgpXCIsXG4gICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgdHJhbnNwb3J0Lm9mZihbXCJmYWlsZWRcIiwgXCJkaXNjb25uZWN0ZWRcIl0sIGVycm9yQ2IpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcbiAgICB9KTtcbiAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJpc0F2YWlsYWJsZSBub3QgaW1wbGVtZW50ZWQgZm9yIHRyYW5zcG9ydFwiLCA1ZTQsIDUwMCk7XG4gIH1cbn07XG52YXIgdHJhbnNwb3J0X2RlZmF1bHQgPSBUcmFuc3BvcnQ7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL1RyYW5zcG9ydE5hbWUudHNcbnZhciBUcmFuc3BvcnROYW1lcztcbigoVHJhbnNwb3J0TmFtZXMyKSA9PiB7XG4gIFRyYW5zcG9ydE5hbWVzMi5XZWJTb2NrZXQgPSBcIndlYl9zb2NrZXRcIjtcbiAgVHJhbnNwb3J0TmFtZXMyLkNvbWV0ID0gXCJjb21ldFwiO1xuICBUcmFuc3BvcnROYW1lczIuWGhyUG9sbGluZyA9IFwieGhyX3BvbGxpbmdcIjtcbn0pKFRyYW5zcG9ydE5hbWVzIHx8IChUcmFuc3BvcnROYW1lcyA9IHt9KSk7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9ubWFuYWdlci50c1xudmFyIGdsb2JhbE9iamVjdDIgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG52YXIgaGF2ZVdlYlN0b3JhZ2UgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiB0eXBlb2YgUGxhdGZvcm0uV2ViU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9jYWxTdXBwb3J0ZWQpO1xufTtcbnZhciBoYXZlU2Vzc2lvblN0b3JhZ2UgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiB0eXBlb2YgUGxhdGZvcm0uV2ViU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Vzc2lvblN1cHBvcnRlZCk7XG59O1xudmFyIG5vb3AgPSBmdW5jdGlvbigpIHtcbn07XG52YXIgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUgPSBcImFibHktdHJhbnNwb3J0LXByZWZlcmVuY2VcIjtcbmZ1bmN0aW9uIGJ1bmRsZVdpdGgoZGVzdCwgc3JjLCBtYXhTaXplKSB7XG4gIGxldCBhY3Rpb247XG4gIGlmIChkZXN0LmNoYW5uZWwgIT09IHNyYy5jaGFubmVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoYWN0aW9uID0gZGVzdC5hY3Rpb24pICE9PSBhY3Rpb25zMi5QUkVTRU5DRSAmJiBhY3Rpb24gIT09IGFjdGlvbnMyLk1FU1NBR0UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFjdGlvbiAhPT0gc3JjLmFjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBraW5kID0gYWN0aW9uID09PSBhY3Rpb25zMi5QUkVTRU5DRSA/IFwicHJlc2VuY2VcIiA6IFwibWVzc2FnZXNcIiwgcHJvcG9zZWQgPSBkZXN0W2tpbmRdLmNvbmNhdChzcmNba2luZF0pLCBzaXplID0gZ2V0TWVzc2FnZXNTaXplKHByb3Bvc2VkKTtcbiAgaWYgKHNpemUgPiBtYXhTaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghYWxsU2FtZShwcm9wb3NlZCwgXCJjbGllbnRJZFwiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXByb3Bvc2VkLmV2ZXJ5KGZ1bmN0aW9uKG1zZykge1xuICAgIHJldHVybiAhbXNnLmlkO1xuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZXN0W2tpbmRdID0gcHJvcG9zZWQ7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVjb2RlUmVjb3ZlcnlLZXkocmVjb3ZlcnlLZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZWNvdmVyeUtleSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxudmFyIFRyYW5zcG9ydFBhcmFtcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaG9zdCwgbW9kZSwgY29ubmVjdGlvbktleSkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25LZXk7XG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi87XG4gIH1cbiAgZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gYXV0aFBhcmFtcyA/IGNvcHkoYXV0aFBhcmFtcykgOiB7fTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICBjYXNlIFwicmVzdW1lXCI6XG4gICAgICAgIHBhcmFtcy5yZXN1bWUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlY292ZXJcIjoge1xuICAgICAgICBjb25zdCByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleShvcHRpb25zLnJlY292ZXIpO1xuICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgcGFyYW1zLnJlY292ZXIgPSByZWNvdmVyeUNvbnRleHQuY29ubmVjdGlvbktleTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNsaWVudElkICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVjaG9NZXNzYWdlcyA9PT0gZmFsc2UpIHtcbiAgICAgIHBhcmFtcy5lY2hvID0gXCJmYWxzZVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb3JtYXQgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJlYW0gIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLnN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuICAgIH1cbiAgICBpZiAodGhpcy5oZWFydGJlYXRzICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5oZWFydGJlYXRzID0gdGhpcy5oZWFydGJlYXRzO1xuICAgIH1cbiAgICBwYXJhbXMudiA9IGRlZmF1bHRzX2RlZmF1bHQucHJvdG9jb2xWZXJzaW9uO1xuICAgIHBhcmFtcy5hZ2VudCA9IGdldEFnZW50U3RyaW5nKHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICAgIG1peGluKHBhcmFtcywgb3B0aW9ucy50cmFuc3BvcnRQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCByZXN1bHQgPSBcIlttb2RlPVwiICsgdGhpcy5tb2RlO1xuICAgIGlmICh0aGlzLmhvc3QpIHtcbiAgICAgIHJlc3VsdCArPSBcIixob3N0PVwiICsgdGhpcy5ob3N0O1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICByZXN1bHQgKz0gXCIsY29ubmVjdGlvbktleT1cIiArIHRoaXMuY29ubmVjdGlvbktleTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZm9ybWF0KSB7XG4gICAgICByZXN1bHQgKz0gXCIsZm9ybWF0PVwiICsgdGhpcy5mb3JtYXQ7XG4gICAgfVxuICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gY2xhc3MgX0Nvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihyZWFsdGltZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKHJlYWx0aW1lLmxvZ2dlcik7XG4gICAgdGhpcy5zdXBwb3J0ZWRUcmFuc3BvcnRzID0ge307XG4gICAgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZSA9IHsgaXNQcm9jZXNzaW5nOiBmYWxzZSwgcXVldWU6IFtdIH07XG4gICAgdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgIHRoaXMuaW5pdFRyYW5zcG9ydHMoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGNvbnN0IHRpbWVvdXRzID0gb3B0aW9ucy50aW1lb3V0cztcbiAgICBjb25zdCBjb25uZWN0aW5nVGltZW91dCA9IHRpbWVvdXRzLndlYlNvY2tldENvbm5lY3RUaW1lb3V0ICsgdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICB0aGlzLnN0YXRlcyA9IHtcbiAgICAgIGluaXRpYWxpemVkOiB7XG4gICAgICAgIHN0YXRlOiBcImluaXRpYWxpemVkXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICBmYWlsU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBjb25uZWN0aW5nOiB7XG4gICAgICAgIHN0YXRlOiBcImNvbm5lY3RpbmdcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IGNvbm5lY3RpbmdUaW1lb3V0LFxuICAgICAgICBmYWlsU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwiY29ubmVjdGVkXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICBzZW5kRXZlbnRzOiB0cnVlLFxuICAgICAgICBmYWlsU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBkaXNjb25uZWN0ZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5kaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgfSxcbiAgICAgIHN1c3BlbmRlZDoge1xuICAgICAgICBzdGF0ZTogXCJzdXNwZW5kZWRcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5zdXNwZW5kZWRSZXRyeVRpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJzdXNwZW5kZWRcIlxuICAgICAgfSxcbiAgICAgIGNsb3Npbmc6IHtcbiAgICAgICAgc3RhdGU6IFwiY2xvc2luZ1wiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG4gICAgICAgIGZhaWxTdGF0ZTogXCJjbG9zZWRcIlxuICAgICAgfSxcbiAgICAgIGNsb3NlZDogeyBzdGF0ZTogXCJjbG9zZWRcIiwgdGVybWluYWw6IHRydWUsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogXCJjbG9zZWRcIiB9LFxuICAgICAgZmFpbGVkOiB7IHN0YXRlOiBcImZhaWxlZFwiLCB0ZXJtaW5hbDogdHJ1ZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiBcImZhaWxlZFwiIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5pbml0aWFsaXplZDtcbiAgICB0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzID0gbmV3IG1lc3NhZ2VxdWV1ZV9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgdGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25JZCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25LZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSB0aW1lb3V0cy5jb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0cyA9IGludGVyc2VjdChvcHRpb25zLnRyYW5zcG9ydHMgfHwgZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0VHJhbnNwb3J0cywgdGhpcy5zdXBwb3J0ZWRUcmFuc3BvcnRzKTtcbiAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuICAgIGlmICh0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXMoVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0KSkge1xuICAgICAgdGhpcy53ZWJTb2NrZXRUcmFuc3BvcnRBdmFpbGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFuc3BvcnRzLmluY2x1ZGVzKFRyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmcpKSB7XG4gICAgICB0aGlzLmJhc2VUcmFuc3BvcnQgPSBUcmFuc3BvcnROYW1lcy5YaHJQb2xsaW5nO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc3BvcnRzLmluY2x1ZGVzKFRyYW5zcG9ydE5hbWVzLkNvbWV0KSkge1xuICAgICAgdGhpcy5iYXNlVHJhbnNwb3J0ID0gVHJhbnNwb3J0TmFtZXMuQ29tZXQ7XG4gICAgfVxuICAgIHRoaXMuaHR0cEhvc3RzID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhvcHRpb25zKTtcbiAgICB0aGlzLndzSG9zdHMgPSBkZWZhdWx0c19kZWZhdWx0LmdldEhvc3RzKG9wdGlvbnMsIHRydWUpO1xuICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wgPSBudWxsO1xuICAgIHRoaXMuaG9zdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBudWxsO1xuICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgICB0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gZmFsc2U7XG4gICAgdGhpcy5jb25uZWN0Q291bnRlciA9IDA7XG4gICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLndlYlNvY2tldFNsb3dUaW1lciA9IG51bGw7XG4gICAgdGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lciA9IG51bGw7XG4gICAgdGhpcy5hYmFuZG9uZWRXZWJTb2NrZXQgPSBmYWxzZTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsIFwic3RhcnRlZFwiKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLFxuICAgICAgXCJyZXF1ZXN0ZWQgdHJhbnNwb3J0cyA9IFtcIiArIChvcHRpb25zLnRyYW5zcG9ydHMgfHwgZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0VHJhbnNwb3J0cykgKyBcIl1cIlxuICAgICk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgIFwiYXZhaWxhYmxlIHRyYW5zcG9ydHMgPSBbXCIgKyB0aGlzLnRyYW5zcG9ydHMgKyBcIl1cIlxuICAgICk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgIFwiaHR0cCBob3N0cyA9IFtcIiArIHRoaXMuaHR0cEhvc3RzICsgXCJdXCJcbiAgICApO1xuICAgIGlmICghdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbXNnID0gXCJubyByZXF1ZXN0ZWQgdHJhbnNwb3J0cyBhdmFpbGFibGVcIjtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcInJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIiwgbXNnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBjb25zdCBhZGRFdmVudExpc3RlbmVyID0gUGxhdGZvcm0uQ29uZmlnLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgaWYgKGFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGlmIChoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiB0eXBlb2Ygb3B0aW9ucy5yZWNvdmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLnBlcnNpc3RDb25uZWN0aW9uLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsICgpID0+IHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLFxuICAgICAgICAgICAgXCJiZWZvcmV1bmxvYWQgZXZlbnQgaGFzIHRyaWdnZXJlZCB0aGUgY29ubmVjdGlvbiB0byBjbG9zZSBhcyBjbG9zZU9uVW5sb2FkIGlzIHRydWVcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjbG9zaW5nXCIgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLmRpc2Nvbm5lY3RlZCB8fCB0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLnN1c3BlbmRlZCkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciBcXHUyMDE4b25saW5lXFx1MjAxOSBldmVudFwiLFxuICAgICAgICAgICAgXCJyZWF0dGVtcHRpbmcgY29ubmVjdGlvblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAoX2EyID0gdGhpcy5wZW5kaW5nVHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm9mZigpO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIGNhdWdodCBicm93c2VyIFxcdTIwMThvZmZsaW5lXFx1MjAxOSBldmVudFwiLFxuICAgICAgICAgICAgXCJkaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgKiB0cmFuc3BvcnQgbWFuYWdlbWVudFxuICAgKioqKioqKioqKioqKioqKioqKioqL1xuICAvLyBVc2VkIGJ5IHRlc3RzXG4gIHN0YXRpYyBzdXBwb3J0ZWRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0geyBzdXBwb3J0ZWRUcmFuc3BvcnRzOiB7fSB9O1xuICAgIHRoaXMuaW5pdFRyYW5zcG9ydHMoYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucywgc3RvcmFnZSk7XG4gICAgcmV0dXJuIHN0b3JhZ2Uuc3VwcG9ydGVkVHJhbnNwb3J0cztcbiAgfVxuICBzdGF0aWMgaW5pdFRyYW5zcG9ydHMoYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucywgc3RvcmFnZSkge1xuICAgIGNvbnN0IGltcGxlbWVudGF0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBQbGF0Zm9ybS5UcmFuc3BvcnRzLmJ1bmRsZWRJbXBsZW1lbnRhdGlvbnMpLCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKTtcbiAgICBbVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0LCAuLi5QbGF0Zm9ybS5UcmFuc3BvcnRzLm9yZGVyXS5mb3JFYWNoKCh0cmFuc3BvcnROYW1lKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBpbXBsZW1lbnRhdGlvbnNbdHJhbnNwb3J0TmFtZV07XG4gICAgICBpZiAodHJhbnNwb3J0ICYmIHRyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc3VwcG9ydGVkVHJhbnNwb3J0c1t0cmFuc3BvcnROYW1lXSA9IHRyYW5zcG9ydDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpbml0VHJhbnNwb3J0cygpIHtcbiAgICBfQ29ubmVjdGlvbk1hbmFnZXIuaW5pdFRyYW5zcG9ydHModGhpcy5yZWFsdGltZS5fYWRkaXRpb25hbFRyYW5zcG9ydEltcGxlbWVudGF0aW9ucywgdGhpcyk7XG4gIH1cbiAgY3JlYXRlVHJhbnNwb3J0UGFyYW1zKGhvc3QsIG1vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zcG9ydFBhcmFtcyh0aGlzLm9wdGlvbnMsIGhvc3QsIG1vZGUsIHRoaXMuY29ubmVjdGlvbktleSk7XG4gIH1cbiAgZ2V0VHJhbnNwb3J0UGFyYW1zKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZGVjaWRlTW9kZSA9IChtb2RlQ2IpID0+IHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgbW9kZUNiKFwicmVzdW1lXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5yZWNvdmVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1vZGVDYihcInJlY292ZXJcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlY292ZXJGbiA9IHRoaXMub3B0aW9ucy5yZWNvdmVyLCBsYXN0U2Vzc2lvbkRhdGEgPSB0aGlzLmdldFNlc3Npb25SZWNvdmVyRGF0YSgpLCBzZXNzaW9uUmVjb3ZlcnlOYW1lID0gdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCk7XG4gICAgICBpZiAobGFzdFNlc3Npb25EYXRhICYmIHR5cGVvZiByZWNvdmVyRm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKClcIixcbiAgICAgICAgICBcIkNhbGxpbmcgY2xpZW50T3B0aW9ucy1wcm92aWRlZCByZWNvdmVyIGZ1bmN0aW9uIHdpdGggbGFzdCBzZXNzaW9uIGRhdGEgKHJlY292ZXJ5IHNjb3BlOiBcIiArIHNlc3Npb25SZWNvdmVyeU5hbWUgKyBcIilcIlxuICAgICAgICApO1xuICAgICAgICByZWNvdmVyRm4obGFzdFNlc3Npb25EYXRhLCAoc2hvdWxkUmVjb3ZlcikgPT4ge1xuICAgICAgICAgIGlmIChzaG91bGRSZWNvdmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVjb3ZlciA9IGxhc3RTZXNzaW9uRGF0YS5yZWNvdmVyeUtleTtcbiAgICAgICAgICAgIG1vZGVDYihcInJlY292ZXJcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVDYihcImNsZWFuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1vZGVDYihcImNsZWFuXCIpO1xuICAgIH07XG4gICAgZGVjaWRlTW9kZSgobW9kZSkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0gdGhpcy5jcmVhdGVUcmFuc3BvcnRQYXJhbXMobnVsbCwgbW9kZSk7XG4gICAgICBpZiAobW9kZSA9PT0gXCJyZWNvdmVyXCIpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpXCIsXG4gICAgICAgICAgXCJUcmFuc3BvcnQgcmVjb3ZlcnkgbW9kZSA9IHJlY292ZXI7IHJlY292ZXJ5S2V5ID0gXCIgKyB0aGlzLm9wdGlvbnMucmVjb3ZlclxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleSh0aGlzLm9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLm1zZ1NlcmlhbCA9IHJlY292ZXJ5Q29udGV4dC5tc2dTZXJpYWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKVwiLFxuICAgICAgICAgIFwiVHJhbnNwb3J0IHBhcmFtcyA9IFwiICsgdHJhbnNwb3J0UGFyYW1zLnRvU3RyaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gY29ubmVjdCB1c2luZyBhIGdpdmVuIHRyYW5zcG9ydFxuICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAqIEBwYXJhbSBjYW5kaWRhdGUsIHRoZSB0cmFuc3BvcnQgdG8gdHJ5XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgdHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KClcIiwgXCJ0cnlpbmcgXCIgKyBjYW5kaWRhdGUpO1xuICAgIHRoaXMucHJvcG9zZWRUcmFuc3BvcnQgPSB0cmFuc3BvcnRfZGVmYXVsdC50cnlDb25uZWN0KFxuICAgICAgdGhpcy5zdXBwb3J0ZWRUcmFuc3BvcnRzW2NhbmRpZGF0ZV0sXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5yZWFsdGltZS5hdXRoLFxuICAgICAgdHJhbnNwb3J0UGFyYW1zLFxuICAgICAgKHdyYXBwZWRFcnIsIHRyYW5zcG9ydCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zaW5nIHx8IHN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3NlZCB8fCBzdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQpIHtcbiAgICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpXCIsXG4gICAgICAgICAgICAgIFwiY29ubmVjdGlvbiBcIiArIHN0YXRlLnN0YXRlICsgXCIgd2hpbGUgd2Ugd2VyZSBhdHRlbXB0aW5nIHRoZSB0cmFuc3BvcnQ7IGNsb3NpbmcgXCIgKyB0cmFuc3BvcnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwcGVkRXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgICAgXCJ0cmFuc3BvcnQgXCIgKyBjYW5kaWRhdGUgKyBcIiBcIiArIHdyYXBwZWRFcnIuZXZlbnQgKyBcIiwgZXJyOiBcIiArIHdyYXBwZWRFcnIuZXJyb3IudG9TdHJpbmcoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKHdyYXBwZWRFcnIuZXJyb3IpICYmICEodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSB3cmFwcGVkRXJyLmVycm9yO1xuICAgICAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMucmVhbHRpbWUuYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsKSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAod3JhcHBlZEVyci5ldmVudCA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImZhaWxlZFwiLCBlcnJvcjogd3JhcHBlZEVyci5lcnJvciB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAod3JhcHBlZEVyci5ldmVudCA9PT0gXCJkaXNjb25uZWN0ZWRcIikge1xuICAgICAgICAgICAgaWYgKCFpc1JldHJpYWJsZSh3cmFwcGVkRXJyLmVycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogd3JhcHBlZEVyci5lcnJvciB9KTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpXCIsXG4gICAgICAgICAgXCJ2aWFibGUgdHJhbnNwb3J0IFwiICsgY2FuZGlkYXRlICsgXCI7IHNldHRpbmcgcGVuZGluZ1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0UGVuZGluZyh0cmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgaW5kaWNhdGVkIHRvIGJlIHZpYWJsZSwgYW5kIHRoZSBDb25uZWN0aW9uTWFuYWdlclxuICAgKiBleHBlY3RzIHRvIGFjdGl2YXRlIHRoaXMgdHJhbnNwb3J0IGFzIHNvb24gYXMgaXQgaXMgY29ubmVjdGVkLlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0XG4gICAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcbiAgICovXG4gIHNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpIHtcbiAgICBjb25zdCBtb2RlID0gdHJhbnNwb3J0UGFyYW1zLm1vZGU7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNldFRyYW5zcG9ydFBlbmRpbmcoKVwiLFxuICAgICAgXCJ0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydCArIFwiOyBtb2RlID0gXCIgKyBtb2RlXG4gICAgKTtcbiAgICB0aGlzLnBlbmRpbmdUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoXCJjb25uZWN0ZWRcIiwgKGVycm9yLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2YXRlVHJhbnNwb3J0KGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpO1xuICAgICAgaWYgKG1vZGUgPT09IFwicmVjb3ZlclwiICYmIHRoaXMub3B0aW9ucy5yZWNvdmVyKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMucmVjb3ZlcjtcbiAgICAgICAgdGhpcy51bnBlcnNpc3RDb25uZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzO1xuICAgIHRyYW5zcG9ydC5vbihbXCJkaXNjb25uZWN0ZWRcIiwgXCJjbG9zZWRcIiwgXCJmYWlsZWRcIl0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBzZWxmMi5kZWFjdGl2YXRlVHJhbnNwb3J0KHRyYW5zcG9ydCwgdGhpcy5ldmVudCwgZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5wZW5kaW5nXCIsIHRyYW5zcG9ydCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCwgYW5kIHRoZSBjb25uZWN0aW9ubWFuYWdlciBkZWNpZGVzIHRoYXRcbiAgICogaXQgd2lsbCBub3cgYmUgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFJldHVybnMgd2hldGhlciBvciBub3QgaXQgYWN0aXZhdGVkXG4gICAqIHRoZSB0cmFuc3BvcnQgKGlmIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmcvY2xvc2VkIGl0IHdpbGwgY2hvb3NlIG5vdCB0bykuXG4gICAqIEBwYXJhbSB0cmFuc3BvcnQgdGhlIHRyYW5zcG9ydCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIHRoZSBpZCBvZiB0aGUgbmV3IGFjdGl2ZSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uRGV0YWlscyB0aGUgZGV0YWlscyBvZiB0aGUgbmV3IGFjdGl2ZSBjb25uZWN0aW9uXG4gICAqL1xuICBhY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnRcbiAgICApO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLCBcImVycm9yID0gXCIgKyBlcnJvcik7XG4gICAgfVxuICAgIGlmIChjb25uZWN0aW9uSWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiY29ubmVjdGlvbklkID0gIFwiICsgY29ubmVjdGlvbklkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiY29ubmVjdGlvbkRldGFpbHMgPSAgXCIgKyBKU09OLnN0cmluZ2lmeShjb25uZWN0aW9uRGV0YWlscylcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0KTtcbiAgICBjb25zdCBleGlzdGluZ1N0YXRlID0gdGhpcy5zdGF0ZSwgY29ubmVjdGVkU3RhdGUgPSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGU7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwiY3VycmVudCBzdGF0ZSA9IFwiICsgZXhpc3RpbmdTdGF0ZS5zdGF0ZVxuICAgICk7XG4gICAgaWYgKGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZy5zdGF0ZSB8fCBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3NlZC5zdGF0ZSB8fCBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmZhaWxlZC5zdGF0ZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIHRyYW5zcG9ydCBhbmQgYWJhbmRvbmluZ1wiXG4gICAgICApO1xuICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgICAgXCJEZWNsaW5pbmcgdG8gYWN0aXZhdGUgdHJhbnNwb3J0IFwiICsgdHJhbnNwb3J0ICsgXCIgc2luY2UgaXQgYXBwZWFycyB0byBubyBsb25nZXIgYmUgY29ubmVjdGVkXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sO1xuICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wgPSBuZXcgcHJvdG9jb2xfZGVmYXVsdCh0cmFuc3BvcnQpO1xuICAgIHRoaXMuaG9zdCA9IHRyYW5zcG9ydC5wYXJhbXMuaG9zdDtcbiAgICBjb25zdCBjb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcbiAgICBpZiAoY29ubmVjdGlvbktleSAmJiB0aGlzLmNvbm5lY3Rpb25LZXkgIT0gY29ubmVjdGlvbktleSkge1xuICAgICAgdGhpcy5zZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsICEhZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCk7XG4gICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRyYW5zcG9ydC5vbihcbiAgICAgICAgXCJjb25uZWN0ZWRcIixcbiAgICAgICAgKGNvbm5lY3RlZEVyciwgX2Nvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMyKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzMiwgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0KGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgY29ubmVjdGVkRXJyKSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgaWYgKGV4aXN0aW5nU3RhdGUuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBlcnJvcjtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGVycm9yKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0ZWRcIiwgZXJyb3IgfSk7XG4gICAgICB0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3IgfHwgbnVsbDtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwidHJhbnNwb3J0LmFjdGl2ZVwiLCB0cmFuc3BvcnQpO1xuICAgIGlmIChleGlzdGluZ0FjdGl2ZVByb3RvY29sKSB7XG4gICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSA+IDApIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgICAgICBcIlByZXZpb3VzIGFjdGl2ZSBwcm90b2NvbCAoZm9yIHRyYW5zcG9ydCBcIiArIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wudHJhbnNwb3J0LnNob3J0TmFtZSArIFwiLCBuZXcgb25lIGlzIFwiICsgdHJhbnNwb3J0LnNob3J0TmFtZSArIFwiKSBmaW5pc2hpbmcgd2l0aCBcIiArIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgKyBcIiBtZXNzYWdlcyBzdGlsbCBwZW5kaW5nXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IHdhcyBhbHNvIHRoZSB0cmFuc3BvcnQgZm9yIHRoZSBwcmV2aW91cyBhY3RpdmUgcHJvdG9jb2w7IHRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0LnNob3J0TmFtZSArIFwiOyBzdGFjayA9IFwiICsgbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIiwgbXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wuZmluaXNoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBubyBsb25nZXIgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFRoaXMgY2FuIG9jY3VyXG4gICAqIGluIGFueSB0cmFuc3BvcnQgY29ubmVjdGlvbiBzdGF0ZS5cbiAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgKi9cbiAgZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHN0YXRlLCBlcnJvcikge1xuICAgIGNvbnN0IGN1cnJlbnRQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wsIHdhc0FjdGl2ZSA9IGN1cnJlbnRQcm90b2NvbCAmJiBjdXJyZW50UHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkgPT09IHRyYW5zcG9ydCwgd2FzUGVuZGluZyA9IHRyYW5zcG9ydCA9PT0gdGhpcy5wZW5kaW5nVHJhbnNwb3J0LCBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gdGhpcy5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKCk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgXCJ0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydFxuICAgICk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgXCJzdGF0ZSA9IFwiICsgc3RhdGUgKyAod2FzQWN0aXZlID8gXCI7IHdhcyBhY3RpdmVcIiA6IHdhc1BlbmRpbmcgPyBcIjsgd2FzIHBlbmRpbmdcIiA6IFwiXCIpICsgKG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPyBcIlwiIDogXCI7IGFub3RoZXIgdHJhbnNwb3J0IGlzIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvblwiKVxuICAgICk7XG4gICAgaWYgKGVycm9yICYmIGVycm9yLm1lc3NhZ2UpXG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwicmVhc29uID0gIFwiICsgZXJyb3IubWVzc2FnZVxuICAgICAgKTtcbiAgICBpZiAod2FzQWN0aXZlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiR2V0dGluZywgY2xlYXJpbmcsIGFuZCByZXF1ZXVpbmcgXCIgKyB0aGlzLmFjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgXCIgcGVuZGluZyBtZXNzYWdlc1wiXG4gICAgICApO1xuICAgICAgdGhpcy5xdWV1ZVBlbmRpbmdNZXNzYWdlcyhjdXJyZW50UHJvdG9jb2wuZ2V0UGVuZGluZ01lc3NhZ2VzKCkpO1xuICAgICAgY3VycmVudFByb3RvY29sLmNsZWFyUGVuZGluZ01lc3NhZ2VzKCk7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gdGhpcy5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwidHJhbnNwb3J0LmluYWN0aXZlXCIsIHRyYW5zcG9ydCk7XG4gICAgaWYgKHdhc0FjdGl2ZSAmJiBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uIHx8IHdhc0FjdGl2ZSAmJiBzdGF0ZSA9PT0gXCJmYWlsZWRcIiB8fCBzdGF0ZSA9PT0gXCJjbG9zZWRcIiB8fCBjdXJyZW50UHJvdG9jb2wgPT09IG51bGwgJiYgd2FzUGVuZGluZykge1xuICAgICAgaWYgKHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiICYmIGVycm9yICYmIGVycm9yLnN0YXR1c0NvZGUgPiA1MDAgJiYgdGhpcy5odHRwSG9zdHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IHRydWU7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZSwgZXJyb3IsIHJldHJ5SW1tZWRpYXRlbHk6IHRydWUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlID09PSBcImZhaWxlZFwiICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGVycm9yKSA/IFwiZGlzY29ubmVjdGVkXCIgOiBzdGF0ZTtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogbmV3Q29ubmVjdGlvblN0YXRlLCBlcnJvciB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLyogSGVscGVyIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIHdoaWNoIGFyZSBwZW5kaW5nLFxuICAgKiBoYXZlIGJlZW4gY29ubmVjdGVkLCBhbmQgYXJlIGp1c3Qgd2FpdGluZyBmb3Igb25jZU5vUGVuZGluZyB0byBmaXJlIGJlZm9yZVxuICAgKiBiZWluZyBhY3RpdmF0ZWQgKi9cbiAgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMucGVuZGluZ1RyYW5zcG9ydCB8fCAhdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmlzQ29ubmVjdGVkO1xuICB9XG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgaGFzQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgY29uc3QgcHJldkNvbm5JZCA9IHRoaXMuY29ubmVjdGlvbklkLCBjb25uSWRDaGFuZ2VkID0gcHJldkNvbm5JZCAmJiBwcmV2Q29ubklkICE9PSBjb25uZWN0aW9uSWQsIHJlY292ZXJGYWlsdXJlID0gIXByZXZDb25uSWQgJiYgaGFzQ29ubmVjdGlvbkVycm9yO1xuICAgIGlmIChjb25uSWRDaGFuZ2VkIHx8IHJlY292ZXJGYWlsdXJlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKClcIiwgXCJSZXNldHRpbmcgbXNnU2VyaWFsXCIpO1xuICAgICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5yZXNldFNlbmRBdHRlbXB0ZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbklkICE9PSBjb25uZWN0aW9uSWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKClcIixcbiAgICAgICAgXCJOZXcgY29ubmVjdGlvbklkOyByZWF0dGFjaGluZyBhbnkgYXR0YWNoZWQgY2hhbm5lbHNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gIH1cbiAgY2xlYXJDb25uZWN0aW9uKCkge1xuICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gdm9pZCAwO1xuICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgIHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuICB9XG4gIGNyZWF0ZVJlY292ZXJ5S2V5KCkge1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGNvbm5lY3Rpb25LZXk6IHRoaXMuY29ubmVjdGlvbktleSxcbiAgICAgIG1zZ1NlcmlhbDogdGhpcy5tc2dTZXJpYWwsXG4gICAgICBjaGFubmVsU2VyaWFsczogdGhpcy5yZWFsdGltZS5jaGFubmVscy5jaGFubmVsU2VyaWFscygpXG4gICAgfSk7XG4gIH1cbiAgY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RBY3Rpdml0eSB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2luY2VMYXN0ID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEFjdGl2aXR5O1xuICAgIGlmIChzaW5jZUxhc3QgPiB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCArIHRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKVwiLFxuICAgICAgICBcIkxhc3Qga25vd24gYWN0aXZpdHkgZnJvbSByZWFsdGltZSB3YXMgXCIgKyBzaW5jZUxhc3QgKyBcIm1zIGFnbzsgZGlzY2FyZGluZyBjb25uZWN0aW9uIHN0YXRlXCJcbiAgICAgICk7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuICAgICAgdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSBcInN1c3BlbmRlZFwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XG4gICAqIHN0YXRlIGZvciBsYXRlciByZWNvdmVyeS4gT25seSBhcHBsaWNhYmxlIGluIHRoZSBicm93c2VyIGNvbnRleHQuXG4gICAqL1xuICBwZXJzaXN0Q29ubmVjdGlvbigpIHtcbiAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkpIHtcbiAgICAgIGNvbnN0IHJlY292ZXJ5S2V5ID0gdGhpcy5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICAgICAgaWYgKHJlY292ZXJ5S2V5KSB7XG4gICAgICAgIHRoaXMuc2V0U2Vzc2lvblJlY292ZXJEYXRhKHtcbiAgICAgICAgICByZWNvdmVyeUtleSxcbiAgICAgICAgICBkaXNjb25uZWN0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBsb2NhdGlvbjogZ2xvYmFsT2JqZWN0Mi5sb2NhdGlvbixcbiAgICAgICAgICBjbGllbnRJZDogdGhpcy5yZWFsdGltZS5hdXRoLmNsaWVudElkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XG4gICAqIHN0YXRlIGZvciBsYXRlciByZWNvdmVyeS4gT25seSBhcHBsaWNhYmxlIGluIHRoZSBicm93c2VyIGNvbnRleHQuXG4gICAqL1xuICB1bnBlcnNpc3RDb25uZWN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKTtcbiAgfVxuICAvKioqKioqKioqKioqKioqKioqKioqXG4gICAqIHN0YXRlIG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgZ2V0RXJyb3IoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3JSZWFzb24pIHtcbiAgICAgIGNvbnN0IG5ld0Vycm9yID0gUGFydGlhbEVycm9ySW5mby5mcm9tVmFsdWVzKHRoaXMuZXJyb3JSZWFzb24pO1xuICAgICAgbmV3RXJyb3IuY2F1c2UgPSB0aGlzLmVycm9yUmVhc29uO1xuICAgICAgcmV0dXJuIG5ld0Vycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZUVycm9yKCk7XG4gIH1cbiAgZ2V0U3RhdGVFcnJvcigpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbdGhpcy5zdGF0ZS5zdGF0ZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMik7XG4gIH1cbiAgYWN0aXZlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucXVldWVFdmVudHMgfHwgdGhpcy5zdGF0ZS5zZW5kRXZlbnRzO1xuICB9XG4gIGVuYWN0U3RhdGVDaGFuZ2Uoc3RhdGVDaGFuZ2UpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBcIkNvbm5lY3Rpb24gc3RhdGVcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gc3RhdGVDaGFuZ2UuY3VycmVudCArIChzdGF0ZUNoYW5nZS5yZWFzb24gPyBcIjsgcmVhc29uOiBcIiArIHN0YXRlQ2hhbmdlLnJlYXNvbiA6IFwiXCIpO1xuICAgIGlmIChzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYWN0aW9uLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5lbmFjdFN0YXRlQ2hhbmdlXCIsXG4gICAgICBcInNldHRpbmcgbmV3IHN0YXRlOiBcIiArIHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyBcIjsgcmVhc29uID0gXCIgKyAoc3RhdGVDaGFuZ2UucmVhc29uICYmIHN0YXRlQ2hhbmdlLnJlYXNvbi5tZXNzYWdlKVxuICAgICk7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVDaGFuZ2UuY3VycmVudF07XG4gICAgaWYgKHN0YXRlQ2hhbmdlLnJlYXNvbikge1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcbiAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcbiAgICB9XG4gICAgaWYgKG5ld1N0YXRlLnRlcm1pbmFsIHx8IG5ld1N0YXRlLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uc3RhdGVcIiwgc3RhdGVDaGFuZ2UpO1xuICB9XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIENvbm5lY3Rpb25NYW5hZ2VyIGNvbm5lY3Rpb24gbGlmZWN5Y2xlXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICBzdGFydFRyYW5zaXRpb25UaW1lcih0cmFuc2l0aW9uU3RhdGUpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKVwiLFxuICAgICAgXCJ0cmFuc2l0aW9uU3RhdGU6IFwiICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlXG4gICAgKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpXCIsXG4gICAgICAgIFwiY2xlYXJpbmcgYWxyZWFkeS1ydW5uaW5nIHRpbWVyXCJcbiAgICAgICk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFwiICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlICsgXCIgdGltZXIgZXhwaXJlZFwiLFxuICAgICAgICAgIFwicmVxdWVzdGluZyBuZXcgc3RhdGU6IFwiICsgdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGUgfSk7XG4gICAgICB9XG4gICAgfSwgdHJhbnNpdGlvblN0YXRlLnJldHJ5RGVsYXkpO1xuICB9XG4gIGNhbmNlbFRyYW5zaXRpb25UaW1lcigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKVwiLCBcIlwiKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG4gICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0U3VzcGVuZFRpbWVyKCkge1xuICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIHN1c3BlbmQgdGltZXIgZXhwaXJlZFwiLFxuICAgICAgICAgIFwicmVxdWVzdGluZyBuZXcgc3RhdGU6IHN1c3BlbmRlZFwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gXCJzdXNwZW5kZWRcIjtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcInN1c3BlbmRlZFwiIH0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcbiAgfVxuICBjaGVja1N1c3BlbmRUaW1lcihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAhPT0gXCJkaXNjb25uZWN0ZWRcIiAmJiBzdGF0ZSAhPT0gXCJzdXNwZW5kZWRcIiAmJiBzdGF0ZSAhPT0gXCJjb25uZWN0aW5nXCIpXG4gICAgICB0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuICB9XG4gIGNhbmNlbFN1c3BlbmRUaW1lcigpIHtcbiAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zdXNwZW5kVGltZXIpO1xuICAgICAgdGhpcy5zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFJldHJ5VGltZXIoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyIHJldHJ5IHRpbWVyIGV4cGlyZWRcIiwgXCJyZXRyeWluZ1wiKTtcbiAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH1cbiAgY2FuY2VsUmV0cnlUaW1lcigpIHtcbiAgICBpZiAodGhpcy5yZXRyeVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcbiAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0V2ViU29ja2V0U2xvd1RpbWVyKCkge1xuICAgIHRoaXMud2ViU29ja2V0U2xvd1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgXCJjaGVja2luZyBjb25uZWN0aXZpdHlcIlxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLndzQ2hlY2tSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGVja1dzQ29ubmVjdGl2aXR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgICBcIndzIGNvbm5lY3Rpdml0eSBjaGVjayBzdWNjZWVkZWRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgXCJ3cyBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbGVkXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMud3NDaGVja1Jlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkpIHtcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpLCAoZXJyLCBjb25uZWN0aXZpdHkpID0+IHtcbiAgICAgICAgICBpZiAoZXJyIHx8ICFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgICBcImh0dHAgY29ubmVjdGl2aXR5IGNoZWNrIGZhaWxlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7XG4gICAgICAgICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKVwiLCA4MDAwMywgNDA0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgICBcImh0dHAgY29ubmVjdGl2aXR5IGNoZWNrIHN1Y2NlZWRlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLndlYlNvY2tldFNsb3dUaW1lb3V0KTtcbiAgfVxuICBjYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKSB7XG4gICAgaWYgKHRoaXMud2ViU29ja2V0U2xvd1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53ZWJTb2NrZXRTbG93VGltZXIpO1xuICAgICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFdlYlNvY2tldEdpdmVVcFRpbWVyKHRyYW5zcG9ydFBhcmFtcykge1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgaWYgKCF0aGlzLndzQ2hlY2tSZXN1bHQpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBnaXZlIHVwIHRpbWVyXCIsXG4gICAgICAgICAgXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiB0b29rIG1vcmUgdGhhbiAxMHM7IFwiICsgKHRoaXMuYmFzZVRyYW5zcG9ydCA/IFwidHJ5aW5nIGJhc2UgdHJhbnNwb3J0XCIgOiBcIlwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5iYXNlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgdGhpcy5hYmFuZG9uZWRXZWJTb2NrZXQgPSB0cnVlO1xuICAgICAgICAgIChfYTIgPSB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAoX2IgPSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsICsrdGhpcy5jb25uZWN0Q291bnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBnaXZlIHVwIHRpbWVyXCIsXG4gICAgICAgICAgICBcIndlYnNvY2tldCBjb25uZWN0aXZpdHkgYXBwZWFycyB0byBiZSB1bmF2YWlsYWJsZSBidXQgbm8gb3RoZXIgdHJhbnNwb3J0cyB0byB0cnlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dHMud2ViU29ja2V0Q29ubmVjdFRpbWVvdXQpO1xuICB9XG4gIGNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCkge1xuICAgIGlmICh0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lcik7XG4gICAgICB0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgbm90aWZ5U3RhdGUoaW5kaWNhdGVkKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3Qgc3RhdGUgPSBpbmRpY2F0ZWQuc3RhdGU7XG4gICAgY29uc3QgcmV0cnlJbW1lZGlhdGVseSA9IHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiICYmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgfHwgaW5kaWNhdGVkLnJldHJ5SW1tZWRpYXRlbHkgfHwgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZyAmJiBpbmRpY2F0ZWQuZXJyb3IgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoaW5kaWNhdGVkLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgXCJuZXcgc3RhdGU6IFwiICsgc3RhdGUgKyAocmV0cnlJbW1lZGlhdGVseSA/IFwiOyB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gaW1tZWRpYXRlbHlcIiA6IFwiXCIpXG4gICAgKTtcbiAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoaW5kaWNhdGVkLnN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgfHwgc3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLnRlcm1pbmFsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbaW5kaWNhdGVkLnN0YXRlXTtcbiAgICBsZXQgcmV0cnlEZWxheSA9IG5ld1N0YXRlLnJldHJ5RGVsYXk7XG4gICAgaWYgKG5ld1N0YXRlLnN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQrKztcbiAgICAgIHJldHJ5RGVsYXkgPSBnZXRSZXRyeVRpbWUobmV3U3RhdGUucmV0cnlEZWxheSwgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0KFxuICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSxcbiAgICAgIG5ld1N0YXRlLnN0YXRlLFxuICAgICAgcmV0cnlEZWxheSxcbiAgICAgIGluZGljYXRlZC5lcnJvciB8fCAoKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpKVxuICAgICk7XG4gICAgaWYgKHJldHJ5SW1tZWRpYXRlbHkpIHtcbiAgICAgIGNvbnN0IGF1dG9SZWNvbm5lY3QgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzaW5jZUxhc3QgPSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCAmJiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgKyAxO1xuICAgICAgaWYgKHNpbmNlTGFzdCAmJiBzaW5jZUxhc3QgPCAxZTMpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKClcIixcbiAgICAgICAgICBcIkxhc3QgcmVjb25uZWN0IGF0dGVtcHQgd2FzIG9ubHkgXCIgKyBzaW5jZUxhc3QgKyBcIm1zIGFnbywgd2FpdGluZyBhbm90aGVyIFwiICsgKDFlMyAtIHNpbmNlTGFzdCkgKyBcIm1zIGJlZm9yZSB0cnlpbmcgYWdhaW5cIlxuICAgICAgICApO1xuICAgICAgICBzZXRUaW1lb3V0KGF1dG9SZWNvbm5lY3QsIDFlMyAtIHNpbmNlTGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soYXV0b1JlY29ubmVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiB8fCBzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5zdGFydFJldHJ5VGltZXIocmV0cnlEZWxheSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiAhcmV0cnlJbW1lZGlhdGVseSB8fCBzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiB8fCBuZXdTdGF0ZS50ZXJtaW5hbCkge1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PSBcImNvbm5lY3RlZFwiICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgICBcIkJyb2tlbiBpbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBnbyBpbnRvIGNvbm5lY3RlZCBzdGF0ZSwgYnV0IHRoZXJlIGlzIG5vIGFjdGl2ZSBwcm90b2NvbFwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUucXVldWVFdmVudHMpIHtcbiAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihzdGF0ZSwgY2hhbmdlLnJlYXNvbik7XG4gICAgICB0aGlzLmZhaWxRdWV1ZWRNZXNzYWdlcyhjaGFuZ2UucmVhc29uKTtcbiAgICB9XG4gIH1cbiAgcmVxdWVzdFN0YXRlKHJlcXVlc3QpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBzdGF0ZSA9IHJlcXVlc3Quc3RhdGU7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSgpXCIsXG4gICAgICBcInJlcXVlc3RlZCBzdGF0ZTogXCIgKyBzdGF0ZSArIFwiOyBjdXJyZW50IHN0YXRlOiBcIiArIHRoaXMuc3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGluZ1wiICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gXCJjb25uZWN0ZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUgPT0gXCJjbG9zaW5nXCIgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSBcImNsb3NlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVdLCBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoXG4gICAgICB0aGlzLnN0YXRlLnN0YXRlLFxuICAgICAgbmV3U3RhdGUuc3RhdGUsXG4gICAgICBudWxsLFxuICAgICAgcmVxdWVzdC5lcnJvciB8fCAoKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpKVxuICAgICk7XG4gICAgdGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PSBcImNsb3NpbmdcIikge1xuICAgICAgdGhpcy5jbG9zZUltcGwoKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRDb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KClcIixcbiAgICAgICAgXCJNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyBcIiArIHRoaXMuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1dGggPSB0aGlzLnJlYWx0aW1lLmF1dGg7XG4gICAgY29uc3QgY29ubmVjdENvdW50ID0gKyt0aGlzLmNvbm5lY3RDb3VudGVyO1xuICAgIGNvbnN0IGNvbm5lY3QgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCk7XG4gICAgICB0aGlzLmdldFRyYW5zcG9ydFBhcmFtcygodHJhbnNwb3J0UGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFuc3BvcnRQYXJhbXMubW9kZSA9PT0gXCJyZWNvdmVyXCIgJiYgdHJhbnNwb3J0UGFyYW1zLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICAgIGNvbnN0IHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KHRyYW5zcG9ydFBhcmFtcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucmVjb3ZlckNoYW5uZWxzKHJlY292ZXJ5Q29udGV4dC5jaGFubmVsU2VyaWFscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpXCIsIFwic3RhcnRpbmcgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG4gICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcbiAgICBpZiAoYXV0aC5tZXRob2QgPT09IFwiYmFzaWNcIikge1xuICAgICAgY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhdXRoQ2IgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsKSwgYXV0aENiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhhdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSksIGF1dGhDYik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIHRoZXJlIGFyZSwgYXQgbW9zdCwgdHdvIHRyYW5zcG9ydHMgYXZhaWxhYmxlIHdpdGggd2hpY2ggYSBjb25uZWN0aW9uIG1heVxuICAgKiBiZSBhdHRlbXB0ZWQ6IHdlYl9zb2NrZXQgYW5kL29yIGEgYmFzZSB0cmFuc3BvcnQgKHhocl9wb2xsaW5nIGluIGJyb3dzZXJzLFxuICAgKiBjb21ldCBpbiBub2RlanMpLiB3ZWJfc29ja2V0IGlzIGFsd2F5cyBwcmVmZXJyZWQsIGFuZCB0aGUgYmFzZSB0cmFuc3BvcnQgaXNcbiAgICogb25seSB1c2VkIGluIGNhc2Ugd2ViX3NvY2tldCBjb25uZWN0aXZpdHkgYXBwZWFycyB0byBiZSB1bmF2YWlsYWJsZS5cbiAgICpcbiAgICogY29ubmVjdEltcGwgYmVnaW5zIHRoZSB0cmFuc3BvcnQgc2VsZWN0aW9uIHByb2Nlc3MgYnkgY2hlY2tpbmcgd2hpY2ggdHJhbnNwb3J0c1xuICAgKiBhcmUgYXZhaWxhYmxlLCBhbmQgaWYgdGhlcmUgaXMgYSBjYWNoZWQgcHJlZmVyZW5jZS4gSXQgdGhlbiBkZWZlcnMgdG8gdGhlXG4gICAqIHRyYW5zcG9ydC1zcGVjaWZpYyBjb25uZWN0IG1ldGhvZHM6IGNvbm5lY3RXcyBhbmQgY29ubmVjdEJhc2UuXG4gICAqXG4gICAqIEl0IGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGludmFsaWRhdGluZyB0aGUgY2FjaGUgaW4gdGhlIGNhc2UgdGhhdCBhIGJhc2VcbiAgICogdHJhbnNwb3J0IHByZWZlcmVuY2UgaXMgc3RvcmVkIGJ1dCB3ZWIgc29ja2V0IGNvbm5lY3Rpdml0eSBpcyBub3cgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBoYW5kbGluZyBvZiB0aGUgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIGZhaWxvdmVyIGZyb20gd2ViX3NvY2tldCB0byB0aGUgYmFzZVxuICAgKiB0cmFuc3BvcnQgaXMgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbm5lY3RXcyBtZXRob2QuXG4gICAqL1xuICBjb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3Rpbmcuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpXCIsXG4gICAgICAgIFwiTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QsIGJ1dCB3YXMgXCIgKyBzdGF0ZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgIGlmICh0cmFuc3BvcnRQcmVmZXJlbmNlICYmIHRyYW5zcG9ydFByZWZlcmVuY2UgPT09IHRoaXMuYmFzZVRyYW5zcG9ydCAmJiB0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5jaGVja1dzQ29ubmVjdGl2aXR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMud3NDaGVja1Jlc3VsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpOlwiLFxuICAgICAgICAgICAgXCJ3ZWIgc29ja2V0IGNvbm5lY3Rpdml0eSBhdmFpbGFibGUsIGNhbmNlbGxpbmcgY29ubmVjdGlvbiBhdHRlbXB0IHdpdGggXCIgKyB0aGlzLmJhc2VUcmFuc3BvcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RXcyh0cmFuc3BvcnRQYXJhbXMsICsrdGhpcy5jb25uZWN0Q291bnRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKG5vb3ApO1xuICAgIH1cbiAgICBpZiAodHJhbnNwb3J0UHJlZmVyZW5jZSAmJiB0cmFuc3BvcnRQcmVmZXJlbmNlID09PSB0aGlzLmJhc2VUcmFuc3BvcnQgfHwgdGhpcy5iYXNlVHJhbnNwb3J0ICYmICF0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICogY29ubmVjdFdzIHN0YXJ0cyB0d28gdGltZXJzIHRvIG1vbml0b3IgdGhlIHN1Y2Nlc3Mgb2YgYSB3ZWJfc29ja2V0IGNvbm5lY3Rpb24gYXR0ZW1wdDpcbiAgICogLSB3ZWJTb2NrZXRTbG93VGltZXI6IGlmIHRoaXMgdGltZXIgZmlyZXMgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHN1Y2NlZWRzLFxuICAgKiAgIGNtIHdpbGwgc2ltdWx0YW5lb3VzbHkgY2hlY2sgd2Vic29ja2V0IGFuZCBodHRwL3hociBjb25uZWN0aXZpdHkuIGlmIHRoZSBodHRwXG4gICAqICAgY29ubmVjdGl2aXR5IGNoZWNrIGZhaWxzLCB3ZSBnaXZlIHVwIHRoZSBjb25uZWN0aW9uIHNlcXVlbmNlIGVudGlyZWx5IGFuZFxuICAgKiAgIHRyYW5zaXRpb24gdG8gZGlzY29ubmVjdGVkLiBpZiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpdml0eSBjaGVjayBmYWlscyB0aGVuXG4gICAqICAgd2UgYXNzdW1lIG5vIHdzIGNvbm5lY3Rpdml0eSBhbmQgZmFpbG92ZXIgdG8gYmFzZSB0cmFuc3BvcnQuIGluIHRoZSBjYXNlIHRoYXRcbiAgICogICB0aGUgY2hlY2tzIHN1Y2NlZWQsIHdlIGNvbnRpbnVlIHdpdGggd2Vic29ja2V0IGFuZCB3YWl0IGZvciBpdCB0byB0cnkgZmFsbGJhY2sgaG9zdHNcbiAgICogICBhbmQsIGlmIHVuc3VjY2Vzc2Z1bCwgdWx0aW1hdGVseSB0cmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZC5cbiAgICogLSB3ZWJTb2NrZXRHaXZlVXBUaW1lcjogaWYgdGhpcyB0aW1lciBmaXJlcywgYW5kIHRoZSBwcmVjZWRpbmcgd2Vic29ja2V0XG4gICAqICAgY29ubmVjdGl2aXR5IGNoZWNrIGlzIHN0aWxsIHBlbmRpbmcgdGhlbiB3ZSBhc3N1bWUgdGhhdCB0aGVyZSBpcyBhbiBpc3N1ZVxuICAgKiAgIHdpdGggdGhlIHRyYW5zcG9ydCBhbmQgZmFsbGJhY2sgdG8gYmFzZSB0cmFuc3BvcnQuXG4gICAqL1xuICBjb25uZWN0V3ModHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0V3MoKVwiKTtcbiAgICB0aGlzLnN0YXJ0V2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5zdGFydFdlYlNvY2tldEdpdmVVcFRpbWVyKHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgdGhpcy50cnlUcmFuc3BvcnRXaXRoRmFsbGJhY2tzKFwid2ViX3NvY2tldFwiLCB0cmFuc3BvcnRQYXJhbXMsIHRydWUsIGNvbm5lY3RDb3VudCwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMud3NDaGVja1Jlc3VsdCAhPT0gZmFsc2UgJiYgIXRoaXMuYWJhbmRvbmVkV2ViU29ja2V0O1xuICAgIH0pO1xuICB9XG4gIGNvbm5lY3RCYXNlKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEJhc2UoKVwiKTtcbiAgICBpZiAodGhpcy5iYXNlVHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLnRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3ModGhpcy5iYXNlVHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMsIGZhbHNlLCBjb25uZWN0Q291bnQsICgpID0+IHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHtcbiAgICAgICAgc3RhdGU6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JJbmZvKFwiTm8gdHJhbnNwb3J0cyBsZWZ0IHRvIHRyeVwiLCA4ZTQsIDQwNClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0cnlUcmFuc3BvcnRXaXRoRmFsbGJhY2tzKHRyYW5zcG9ydE5hbWUsIHRyYW5zcG9ydFBhcmFtcywgd3MsIGNvbm5lY3RDb3VudCwgc2hvdWxkQ29udGludWUpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcygpXCIsXG4gICAgICB0cmFuc3BvcnROYW1lXG4gICAgKTtcbiAgICBjb25zdCBnaXZlVXAgPSAoZXJyKSA9PiB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogZXJyIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2FuZGlkYXRlSG9zdHMgPSB3cyA/IHRoaXMud3NIb3N0cy5zbGljZSgpIDogdGhpcy5odHRwSG9zdHMuc2xpY2UoKTtcbiAgICBjb25zdCBob3N0QXR0ZW1wdENiID0gKGZhdGFsLCB0cmFuc3BvcnQpID0+IHtcbiAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFzaG91bGRDb250aW51ZSgpKSB7XG4gICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNwb3J0ICYmICFmYXRhbCkge1xuICAgICAgICB0cnlGYWxsYmFja0hvc3RzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcbiAgICBpZiAoIWhvc3QpIHtcbiAgICAgIGdpdmVVcChuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKG5vIGF2YWlsYWJsZSBob3N0KVwiLCA4MDAwMywgNDA0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gaG9zdDtcbiAgICBjb25zdCB0cnlGYWxsYmFja0hvc3RzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgICAgZ2l2ZVVwKG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gY29ubmVjdCAoYW5kIG5vIG1vcmUgZmFsbGJhY2sgaG9zdHMgdG8gdHJ5KVwiLCA4MDAwMywgNDA0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5yZWFsdGltZS5odHRwLmNoZWNrQ29ubmVjdGl2aXR5KSB7XG4gICAgICAgIGdpdmVVcChuZXcgUGFydGlhbEVycm9ySW5mbyhcIkludGVybmFsIGVycm9yOiBIdHRwLmNoZWNrQ29ubmVjdGl2aXR5IG5vdCBzZXRcIiwgbnVsbCwgNTAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgdGhpcy5yZWFsdGltZS5odHRwLmNoZWNrQ29ubmVjdGl2aXR5KCksXG4gICAgICAgIChlcnIsIGNvbm5lY3Rpdml0eSkgPT4ge1xuICAgICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzaG91bGRDb250aW51ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGdpdmVVcChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgZ2l2ZVVwKG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gY29ubmVjdCAobmV0d29yayB1bnJlYWNoYWJsZSlcIiwgODAwMDMsIDQwNCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IGFyclBvcFJhbmRvbUVsZW1lbnQoY2FuZGlkYXRlSG9zdHMpO1xuICAgICAgICAgIHRoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHRyYW5zcG9ydE5hbWUsIGhvc3RBdHRlbXB0Q2IpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gZmFsc2U7XG4gICAgICB0cnlGYWxsYmFja0hvc3RzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHRyYW5zcG9ydE5hbWUsIGhvc3RBdHRlbXB0Q2IpO1xuICB9XG4gIGNsb3NlSW1wbCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKVwiLCBcImNsb3NpbmcgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuICAgIHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY2xvc2luZyk7XG4gICAgaWYgKHRoaXMucGVuZGluZ1RyYW5zcG9ydCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpXCIsXG4gICAgICAgIFwiQ2xvc2luZyBwZW5kaW5nIHRyYW5zcG9ydDogXCIgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRcbiAgICAgICk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKVwiLFxuICAgICAgICBcIkNsb3NpbmcgYWN0aXZlIHRyYW5zcG9ydDogXCIgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpXG4gICAgICApO1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiY2xvc2VkXCIgfSk7XG4gIH1cbiAgb25BdXRoVXBkYXRlZCh0b2tlbkRldGFpbHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9hMjtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJjb25uZWN0ZWRcIjoge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpXCIsXG4gICAgICAgICAgXCJTZW5kaW5nIEFVVEggbWVzc2FnZSBvbiBhY3RpdmUgdHJhbnNwb3J0XCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgYWN0aXZlVHJhbnNwb3J0ID0gKF9hMiA9IHRoaXMuYWN0aXZlUHJvdG9jb2wpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VHJhbnNwb3J0KCk7XG4gICAgICAgIGlmIChhY3RpdmVUcmFuc3BvcnQgJiYgYWN0aXZlVHJhbnNwb3J0Lm9uQXV0aFVwZGF0ZWQpIHtcbiAgICAgICAgICBhY3RpdmVUcmFuc3BvcnQub25BdXRoVXBkYXRlZCh0b2tlbkRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhNc2cgPSBmcm9tVmFsdWVzMyh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25zMi5BVVRILFxuICAgICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmQoYXV0aE1zZyk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihmYWlsdXJlTGlzdGVuZXIpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZhaWx1cmVMaXN0ZW5lciA9IChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9mZihzdWNjZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoXCJjb25uZWN0aW9uZGV0YWlsc1wiLCBzdWNjZXNzTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIGZhaWx1cmVMaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiQWJvcnRpbmcgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIGluIG9yZGVyIHRvIHN0YXJ0IGFnYWluIHdpdGggdGhlIG5ldyBhdXRoIGRldGFpbHNcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKClcIixcbiAgICAgICAgICBcIkNvbm5lY3Rpb24gc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLnN0YXRlICsgXCI7IHdhaXRpbmcgdW50aWwgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoc3RhdGVDaGFuZ2UuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOlxuICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgPT09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgXCJEaXNjb25uZWN0aW5nIGFsbCB0cmFuc3BvcnRzXCJcbiAgICApO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIrKztcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgcGVuZGluZyB0cmFuc3BvcnQ6IFwiICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0XG4gICAgICApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAodGhpcy5wcm9wb3NlZFRyYW5zcG9ydCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIHByb3Bvc2VkIHRyYW5zcG9ydDogXCIgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRcbiAgICAgICk7XG4gICAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6IFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuICAvKioqKioqKioqKioqKioqKioqXG4gICAqIGV2ZW50IHF1ZXVlaW5nXG4gICAqKioqKioqKioqKioqKioqKiovXG4gIHNlbmQobXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKVwiLCBcInNlbmRpbmcgZXZlbnRcIik7XG4gICAgICB0aGlzLnNlbmRJbXBsKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFF1ZXVlID0gcXVldWVFdmVudCAmJiBzdGF0ZS5xdWV1ZUV2ZW50cztcbiAgICBpZiAoIXNob3VsZFF1ZXVlKSB7XG4gICAgICBjb25zdCBlcnIgPSBcInJlamVjdGluZyBldmVudCwgcXVldWVFdmVudCB3YXMgXCIgKyBxdWV1ZUV2ZW50ICsgXCIsIHN0YXRlIHdhcyBcIiArIHN0YXRlLnN0YXRlO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpXCIsIGVycik7XG4gICAgICBjYWxsYmFjayh0aGlzLmVycm9yUmVhc29uIHx8IG5ldyBFcnJvckluZm8oZXJyLCA5ZTQsIDQwMCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kKClcIixcbiAgICAgICAgXCJxdWV1ZWluZyBtc2c7IFwiICsgc3RyaW5naWZ5KG1zZywgdGhpcy5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucXVldWUobXNnLCBjYWxsYmFjayk7XG4gIH1cbiAgc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpIHtcbiAgICBjb25zdCBtc2cgPSBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlO1xuICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCAmJiAhcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCkge1xuICAgICAgbXNnLm1zZ1NlcmlhbCA9IHRoaXMubXNnU2VyaWFsKys7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLnNlbmQocGVuZGluZ01lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kSW1wbCgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gaW4gdHJhbnNwb3J0LnNlbmQoKTogXCIgKyBlLnN0YWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBxdWV1ZShtc2csIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIucXVldWUoKVwiLCBcInF1ZXVlaW5nIGV2ZW50XCIpO1xuICAgIGNvbnN0IGxhc3RRdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmxhc3QoKTtcbiAgICBjb25zdCBtYXhTaXplID0gdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgIGlmIChsYXN0UXVldWVkICYmICFsYXN0UXVldWVkLnNlbmRBdHRlbXB0ZWQgJiYgYnVuZGxlV2l0aChsYXN0UXVldWVkLm1lc3NhZ2UsIG1zZywgbWF4U2l6ZSkpIHtcbiAgICAgIGlmICghbGFzdFF1ZXVlZC5tZXJnZWQpIHtcbiAgICAgICAgbGFzdFF1ZXVlZC5jYWxsYmFjayA9IG11bHRpY2FzdGVyX2RlZmF1bHQuY3JlYXRlKHRoaXMubG9nZ2VyLCBbbGFzdFF1ZXVlZC5jYWxsYmFja10pO1xuICAgICAgICBsYXN0UXVldWVkLm1lcmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsYXN0UXVldWVkLmNhbGxiYWNrLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnB1c2gobmV3IFBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcbiAgICB9XG4gIH1cbiAgc2VuZFF1ZXVlZE1lc3NhZ2VzKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kUXVldWVkTWVzc2FnZXMoKVwiLFxuICAgICAgXCJzZW5kaW5nIFwiICsgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpICsgXCIgcXVldWVkIG1lc3NhZ2VzXCJcbiAgICApO1xuICAgIGxldCBwZW5kaW5nTWVzc2FnZTtcbiAgICB3aGlsZSAocGVuZGluZ01lc3NhZ2UgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnNoaWZ0KCkpXG4gICAgICB0aGlzLnNlbmRJbXBsKHBlbmRpbmdNZXNzYWdlKTtcbiAgfVxuICBxdWV1ZVBlbmRpbmdNZXNzYWdlcyhwZW5kaW5nTWVzc2FnZXMpIHtcbiAgICBpZiAocGVuZGluZ01lc3NhZ2VzICYmIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5xdWV1ZVBlbmRpbmdNZXNzYWdlcygpXCIsXG4gICAgICAgIFwicXVldWVpbmcgXCIgKyBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoICsgXCIgcGVuZGluZyBtZXNzYWdlc1wiXG4gICAgICApO1xuICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5wcmVwZW5kKHBlbmRpbmdNZXNzYWdlcyk7XG4gICAgfVxuICB9XG4gIGZhaWxRdWV1ZWRNZXNzYWdlcyhlcnIpIHtcbiAgICBjb25zdCBudW1RdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCk7XG4gICAgaWYgKG51bVF1ZXVlZCA+IDApIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5mYWlsUXVldWVkTWVzc2FnZXMoKVwiLFxuICAgICAgICBcImZhaWxpbmcgXCIgKyBudW1RdWV1ZWQgKyBcIiBxdWV1ZWQgbWVzc2FnZXMsIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICk7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKTtcbiAgICB9XG4gIH1cbiAgb25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5xdWV1ZS5wdXNoKHsgbWVzc2FnZSwgdHJhbnNwb3J0IH0pO1xuICAgIGlmICghdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUuaXNQcm9jZXNzaW5nKSB7XG4gICAgICB0aGlzLnByb2Nlc3NOZXh0UGVuZGluZ0NoYW5uZWxNZXNzYWdlKCk7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NOZXh0UGVuZGluZ0NoYW5uZWxNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgcGVuZGluZ0NoYW5uZWxNZXNzYWdlID0gdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUucXVldWUuc2hpZnQoKTtcbiAgICAgIHRoaXMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKHBlbmRpbmdDaGFubmVsTWVzc2FnZS5tZXNzYWdlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5wcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpIHJlY2VpdmVkIGVycm9yIFwiLFxuICAgICAgICAgIGVyclxuICAgICAgICApO1xuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NOZXh0UGVuZGluZ0NoYW5uZWxNZXNzYWdlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBhd2FpdCB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnByb2Nlc3NDaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICBhc3luYyBwaW5nKCkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gcGluZyBzZXJ2aWNlOyBub3QgY29ubmVjdGVkXCIsIDRlNCwgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gKF9hMiA9IHRoaXMuYWN0aXZlUHJvdG9jb2wpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VHJhbnNwb3J0KCk7XG4gICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgIHRocm93IHRoaXMuZ2V0U3RhdGVFcnJvcigpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5waW5nKClcIiwgXCJ0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydCk7XG4gICAgY29uc3QgcGluZ1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBpZCA9IGNoZWFwUmFuZFN0cigpO1xuICAgIHJldHVybiB3aXRoVGltZW91dEFzeW5jKFxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3Qgb25IZWFydGJlYXQgPSAocmVzcG9uc2VJZCkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwb25zZUlkID09PSBpZCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9mZihcImhlYXJ0YmVhdFwiLCBvbkhlYXJ0YmVhdCk7XG4gICAgICAgICAgICByZXNvbHZlKERhdGUubm93KCkgLSBwaW5nU3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFwiaGVhcnRiZWF0XCIsIG9uSGVhcnRiZWF0KTtcbiAgICAgICAgdHJhbnNwb3J0LnBpbmcoaWQpO1xuICAgICAgfSksXG4gICAgICB0aGlzLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCxcbiAgICAgIFwiVGltZW91dCB3YWl0aW5nIGZvciBoZWFydGJlYXQgcmVzcG9uc2VcIlxuICAgICk7XG4gIH1cbiAgYWJvcnQoZXJyb3IpIHtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmZhaWwoZXJyb3IpO1xuICB9XG4gIGdldFRyYW5zcG9ydFByZWZlcmVuY2UoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSB8fCBoYXZlV2ViU3RvcmFnZSgpICYmICgoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpKTtcbiAgfVxuICBwZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnQpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSB0cmFuc3BvcnQuc2hvcnROYW1lO1xuICAgIGlmIChoYXZlV2ViU3RvcmFnZSgpKSB7XG4gICAgICAoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUsIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuICAgIH1cbiAgfVxuICB1bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG4gICAgaWYgKGhhdmVXZWJTdG9yYWdlKCkpIHtcbiAgICAgIChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlbW92ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSk7XG4gICAgfVxuICB9XG4gIC8qIFRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBkdXJpbmcgY29ubmVjdGlvbiBhdHRlbXB0cywgc28gaW1wbGVtZW50cyBSU0E0YzEsIFJTQTRjMixcbiAgICogYW5kIFJTQTRkLiBJdCBpcyBnZW5lcmFsbHkgbm90IGludm9rZWQgZm9yIHNlcnZlcnNpZGUtdHJpZ2dlcmVkIHJlYXV0aHMgb3IgbWFudWFsXG4gICAqIHJlYXV0aHMsIHNvIFJTQTRjMyBkb2VzIG5vdCBhcHBseSwgZXhjZXB0IChwZXIgcGVyIFJTQTRkMSkgaW4gdGhlIGNhc2UgdGhhdCB0aGUgYXV0aFxuICAgKiBzZXJ2ZXIgcmV0dXJucyA0MDMuICovXG4gIGFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gNDAxNzEpIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IGVyciB9KTtcbiAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSA0MDEwMikge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImZhaWxlZFwiLCBlcnJvcjogZXJyIH0pO1xuICAgIH0gZWxzZSBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0LkZvcmJpZGRlbikge1xuICAgICAgY29uc3QgbXNnID0gXCJDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXR1cm5lZCA0MDM7IGZhaWxpbmcgdGhlIGNvbm5lY3Rpb25cIjtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKClcIiwgbXNnKTtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IG5ldyBFcnJvckluZm8obXNnLCA4MDAxOSwgNDAzLCBlcnIpIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBcIkNsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJlcXVlc3QgZmFpbGVkXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZVwiLCBtc2cpO1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlLmZhaWxTdGF0ZSwgZXJyb3I6IG5ldyBFcnJvckluZm8obXNnLCA4MDAxOSwgNDAxLCBlcnIpIH0pO1xuICAgIH1cbiAgfVxuICBvbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpIHtcbiAgICBpZiAoIWNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGlvbkRldGFpbHMgPSBjb25uZWN0aW9uRGV0YWlscztcbiAgICBpZiAoY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnRJZCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNsaWVudElkO1xuICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5yZWFsdGltZS5hdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoKVwiLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIHRyYW5zcG9ydC5mYWlsKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvblN0YXRlVHRsO1xuICAgIGlmIChjb25uZWN0aW9uU3RhdGVUdGwpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvblN0YXRlVHRsO1xuICAgIH1cbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uZGV0YWlsc1wiLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gIH1cbiAgY2hlY2tXc0Nvbm5lY3Rpdml0eSgpIHtcbiAgICBjb25zdCB3cyA9IG5ldyBQbGF0Zm9ybS5Db25maWcuV2ViU29ja2V0KGRlZmF1bHRzX2RlZmF1bHQud3NDb25uZWN0aXZpdHlVcmwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdzLm9uY2xvc2UgPSB3cy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHNlc3Npb25SZWNvdmVyeU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZWNvdmVyeUtleVN0b3JhZ2VOYW1lIHx8IFwiYWJseS1jb25uZWN0aW9uLXJlY292ZXJ5XCI7XG4gIH1cbiAgZ2V0U2Vzc2lvblJlY292ZXJEYXRhKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0U2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0aGlzLnNlc3Npb25SZWNvdmVyeU5hbWUoKSkpO1xuICB9XG4gIHNldFNlc3Npb25SZWNvdmVyRGF0YSh2YWx1ZSkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2V0U2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0aGlzLnNlc3Npb25SZWNvdmVyeU5hbWUoKSwgdmFsdWUpKTtcbiAgfVxuICBjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlbW92ZVNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCkpKTtcbiAgfVxufTtcbnZhciBjb25uZWN0aW9ubWFuYWdlcl9kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jb25uZWN0aW9uLnRzXG52YXIgQ29ubmVjdGlvbiA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihhYmx5LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoYWJseS5sb2dnZXIpO1xuICAgIHRoaXMud2hlblN0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRlbWl0dGVyX2RlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIHRoaXMuYWJseSA9IGFibHk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBjb25uZWN0aW9ubWFuYWdlcl9kZWZhdWx0KGFibHksIG9wdGlvbnMpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbihcImNvbm5lY3Rpb25zdGF0ZVwiLCAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQ7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIHN0YXRlQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oXCJ1cGRhdGVcIiwgKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgc3RhdGVDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLmNvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgfVxuICBhc3luYyBwaW5nKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb24ucGluZygpXCIsIFwiXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnBpbmcoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLmNsb3NlKClcIiwgXCJjb25uZWN0aW9uS2V5ID0gXCIgKyB0aGlzLmtleSk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjbG9zaW5nXCIgfSk7XG4gIH1cbiAgZ2V0IHJlY292ZXJ5S2V5KCkge1xuICAgIHRoaXMubG9nZ2VyLmRlcHJlY2F0aW9uV2FybmluZyhcbiAgICAgIFwiVGhlIGBDb25uZWN0aW9uLnJlY292ZXJ5S2V5YCBhdHRyaWJ1dGUgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIGBDb25uZWN0aW9uLmNyZWF0ZVJlY292ZXJ5S2V5KClgIG1ldGhvZC4gUmVwbGFjZSB5b3VyIHVzYWdlIG9mIGByZWNvdmVyeUtleWAgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIGBjcmVhdGVSZWNvdmVyeUtleSgpYC4gYHJlY292ZXJ5S2V5YCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgfVxuICBjcmVhdGVSZWNvdmVyeUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICB9XG59O1xudmFyIGNvbm5lY3Rpb25fZGVmYXVsdCA9IENvbm5lY3Rpb247XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jaGFubmVsc3RhdGVjaGFuZ2UudHNcbnZhciBDaGFubmVsU3RhdGVDaGFuZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBjdXJyZW50LCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICBpZiAoY3VycmVudCA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICB0aGlzLnJlc3VtZWQgPSByZXN1bWVkO1xuICAgICAgdGhpcy5oYXNCYWNrbG9nID0gaGFzQmFja2xvZztcbiAgICB9XG4gICAgaWYgKHJlYXNvbilcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59O1xudmFyIGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0ID0gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVjaGFubmVsLnRzXG52YXIgbm9vcDIgPSBmdW5jdGlvbigpIHtcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgXCJwYXJhbXNcIiBpbiBvcHRpb25zICYmICFpc09iamVjdChvcHRpb25zLnBhcmFtcykpIHtcbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcIm9wdGlvbnMucGFyYW1zIG11c3QgYmUgYW4gb2JqZWN0XCIsIDRlNCwgNDAwKTtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBcIm1vZGVzXCIgaW4gb3B0aW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLm1vZGVzKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXCJvcHRpb25zLm1vZGVzIG11c3QgYmUgYW4gYXJyYXlcIiwgNGU0LCA0MDApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubW9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gb3B0aW9ucy5tb2Rlc1tpXTtcbiAgICAgIGlmICghY3VycmVudE1vZGUgfHwgdHlwZW9mIGN1cnJlbnRNb2RlICE9PSBcInN0cmluZ1wiIHx8ICFjaGFubmVsTW9kZXMuaW5jbHVkZXMoU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZS5jYWxsKGN1cnJlbnRNb2RlKSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXCJJbnZhbGlkIGNoYW5uZWwgbW9kZTogXCIgKyBjdXJyZW50TW9kZSwgNGU0LCA0MDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIFJlYWx0aW1lQ2hhbm5lbCA9IGNsYXNzIF9SZWFsdGltZUNoYW5uZWwgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgbmFtZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHN1cGVyKGNsaWVudC5sb2dnZXIpO1xuICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgdGhpcy5oaXN0b3J5ID0gYXN5bmMgZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwuaGlzdG9yeSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICAgIGNvbnN0IHJlc3RNaXhpbiA9IHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluO1xuICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJvcHRpb24gdW50aWxBdHRhY2ggcmVxdWlyZXMgdGhlIGNoYW5uZWwgdG8gYmUgYXR0YWNoZWRcIiwgNGU0LCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICBcInVudGlsQXR0YWNoIHdhcyBzcGVjaWZpZWQgYW5kIGNoYW5uZWwgaXMgYXR0YWNoZWQsIGJ1dCBhdHRhY2hTZXJpYWwgaXMgbm90IGRlZmluZWRcIixcbiAgICAgICAgICAgIDRlNCxcbiAgICAgICAgICAgIDQwMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcbiAgICAgICAgcGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN0TWl4aW4uaGlzdG9yeSh0aGlzLCBwYXJhbXMpO1xuICAgIH07XG4gICAgdGhpcy53aGVuU3RhdGUgPSAoc3RhdGUpID0+IHtcbiAgICAgIHJldHVybiBldmVudGVtaXR0ZXJfZGVmYXVsdC5wcm90b3R5cGUud2hlblN0YXRlLmNhbGwodGhpcywgc3RhdGUsIHRoaXMuc3RhdGUpO1xuICAgIH07XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWVDaGFubmVsKClcIiwgXCJzdGFydGVkOyBuYW1lID0gXCIgKyBuYW1lKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBub3JtYWxpc2VDaGFubmVsT3B0aW9ucygoX2EyID0gY2xpZW50Ll9DcnlwdG8pICE9IG51bGwgPyBfYTIgOiBudWxsLCB0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5fcHJlc2VuY2UgPSBjbGllbnQuX1JlYWx0aW1lUHJlc2VuY2UgPyBuZXcgY2xpZW50Ll9SZWFsdGltZVByZXNlbmNlLlJlYWx0aW1lUHJlc2VuY2UodGhpcykgOiBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICB0aGlzLnN0YXRlID0gXCJpbml0aWFsaXplZFwiO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICBhdHRhY2hTZXJpYWw6IHZvaWQgMCxcbiAgICAgIGNoYW5uZWxTZXJpYWw6IHZvaWQgMFxuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RlZEZsYWdzID0gbnVsbDtcbiAgICB0aGlzLl9tb2RlID0gbnVsbDtcbiAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWNvZGluZ0NvbnRleHQgPSB7XG4gICAgICBjaGFubmVsT3B0aW9uczogdGhpcy5jaGFubmVsT3B0aW9ucyxcbiAgICAgIHBsdWdpbnM6IGNsaWVudC5vcHRpb25zLnBsdWdpbnMgfHwge30sXG4gICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLl9sYXN0UGF5bG9hZCA9IHtcbiAgICAgIG1lc3NhZ2VJZDogbnVsbCxcbiAgICAgIHByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw6IG51bGwsXG4gICAgICBkZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcyA9IG5ldyBldmVudGVtaXR0ZXJfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgaWYgKChfYiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5QdXNoKSB7XG4gICAgICB0aGlzLl9wdXNoID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5QdXNoQ2hhbm5lbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHByZXNlbmNlKCkge1xuICAgIGlmICghdGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUmVhbHRpbWVQcmVzZW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNlbmNlO1xuICB9XG4gIGdldCBwdXNoKCkge1xuICAgIGlmICghdGhpcy5fcHVzaCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVzaDtcbiAgfVxuICBpbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2hhbm5lbCBvcGVyYXRpb24gZmFpbGVkIGFzIGNoYW5uZWwgc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLFxuICAgICAgOTAwMDEsXG4gICAgICA0MDAsXG4gICAgICB0aGlzLmVycm9yUmVhc29uIHx8IHZvaWQgMFxuICAgICk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncykge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuICBhc3luYyBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgIGNvbnN0IGVyciA9IHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IHRoaXMuY2xpZW50Ll9DcnlwdG8pICE9IG51bGwgPyBfYTIgOiBudWxsLCB0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuX2RlY29kaW5nQ29udGV4dClcbiAgICAgIHRoaXMuX2RlY29kaW5nQ29udGV4dC5jaGFubmVsT3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgaWYgKHRoaXMuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMsIHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICB0aGlzLmF0dGFjaEltcGwoKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLm9uY2UoXG4gICAgICAgICAgW1wiYXR0YWNoZWRcIiwgXCJ1cGRhdGVcIiwgXCJkZXRhY2hlZFwiLCBcImZhaWxlZFwiXSxcbiAgICAgICAgICBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdChzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMob3B0aW9ucywgcHJldk9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ZWRQYXJhbXMgPSBvbWl0QWdlbnQob3B0aW9ucy5wYXJhbXMpO1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbXMgPSBvbWl0QWdlbnQocHJldk9wdGlvbnMucGFyYW1zKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQYXJhbXMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoZXhpc3RpbmdQYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2hhbGxvd0VxdWFscyhleGlzdGluZ1BhcmFtcywgcmVxdWVzdGVkUGFyYW1zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZXMpIHtcbiAgICAgIGlmICghcHJldk9wdGlvbnMubW9kZXMgfHwgIWFyckVxdWFscyhvcHRpb25zLm1vZGVzLCBwcmV2T3B0aW9ucy5tb2RlcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBsZXQgbWVzc2FnZXMgPSBhcmdzWzBdO1xuICAgIGxldCBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGlmIChhcmdDb3VudCA9PSAxKSB7XG4gICAgICBpZiAoaXNPYmplY3QobWVzc2FnZXMpKVxuICAgICAgICBtZXNzYWdlcyA9IFtmcm9tVmFsdWVzKG1lc3NhZ2VzKV07XG4gICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSlcbiAgICAgICAgbWVzc2FnZXMgPSBmcm9tVmFsdWVzQXJyYXkobWVzc2FnZXMpO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwiVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzXCIsXG4gICAgICAgICAgNDAwMTMsXG4gICAgICAgICAgNDAwXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VzID0gW2Zyb21WYWx1ZXMoeyBuYW1lOiBhcmdzWzBdLCBkYXRhOiBhcmdzWzFdIH0pXTtcbiAgICB9XG4gICAgY29uc3QgbWF4TWVzc2FnZVNpemUgPSB0aGlzLmNsaWVudC5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgIGF3YWl0IGVuY29kZUFycmF5KG1lc3NhZ2VzLCB0aGlzLmNoYW5uZWxPcHRpb25zKTtcbiAgICBjb25zdCBzaXplID0gZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKTtcbiAgICBpZiAoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIk1heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyBcIiArIHNpemUgKyBcIiBieXRlczsgbGltaXQgaXMgXCIgKyBtYXhNZXNzYWdlU2l6ZSArIFwiIGJ5dGVzKVwiLFxuICAgICAgICA0MDAwOSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcHVibGlzaChtZXNzYWdlcywgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpO1xuICAgIH0pO1xuICB9XG4gIF9wdWJsaXNoKG1lc3NhZ2VzLCBjYWxsYmFjaykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKClcIiwgXCJtZXNzYWdlIGNvdW50ID0gXCIgKyBtZXNzYWdlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgIGNhbGxiYWNrKEVycm9ySW5mby5mcm9tVmFsdWVzKHRoaXMuaW52YWxpZFN0YXRlRXJyb3IoKSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKClcIixcbiAgICAgICAgICBcInNlbmRpbmcgbWVzc2FnZTsgY2hhbm5lbCBzdGF0ZSBpcyBcIiArIHN0YXRlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG1zZyA9IG5ldyBwcm90b2NvbG1lc3NhZ2VfZGVmYXVsdCgpO1xuICAgICAgICBtc2cuYWN0aW9uID0gYWN0aW9uczIuTUVTU0FHRTtcbiAgICAgICAgbXNnLmNoYW5uZWwgPSB0aGlzLm5hbWU7XG4gICAgICAgIG1zZy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25FdmVudChtZXNzYWdlcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5vbkV2ZW50KClcIiwgXCJyZWNlaXZlZCBtZXNzYWdlXCIpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuICAgICAgc3Vic2NyaXB0aW9ucy5lbWl0KG1lc3NhZ2UubmFtZSwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGF0dGFjaCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2F0dGFjaChmYWxzZSwgbnVsbCwgKGVyciwgcmVzdWx0KSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzdWx0KSk7XG4gICAgfSk7XG4gIH1cbiAgX2F0dGFjaChmb3JjZVJlYXR0YWNoLCBhdHRhY2hSZWFzb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLl9hdHRhY2goKVwiLFxuICAgICAgICAgICAgXCJDaGFubmVsIGF0dGFjaCBmYWlsZWQ6IFwiICsgZXJyLnRvU3RyaW5nKClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICBjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFwiYXR0YWNoaW5nXCIgfHwgZm9yY2VSZWF0dGFjaCkge1xuICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoXCJhdHRhY2hpbmdcIiwgYXR0YWNoUmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhcbiAgICAgICAgICAgIHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gYXR0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSBcIiArIHRoaXMuZXZlbnQsIDllNCwgNTAwKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2sobmV3IEVycm9ySW5mbyhcIkF0dGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGRldGFjaCByZXF1ZXN0XCIsIDllNCwgNDA5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoSW1wbCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwuYXR0YWNoSW1wbCgpXCIsIFwic2VuZGluZyBBVFRBQ0ggbWVzc2FnZVwiKTtcbiAgICBjb25zdCBhdHRhY2hNc2cgPSBmcm9tVmFsdWVzMyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMyLkFUVEFDSCxcbiAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgIHBhcmFtczogdGhpcy5jaGFubmVsT3B0aW9ucy5wYXJhbXMsXG4gICAgICAvLyBSVEw0YzE6IEluY2x1ZGVzIHRoZSBjaGFubmVsIHNlcmlhbCB0byByZXN1bWUgZnJvbSBhIHByZXZpb3VzIG1lc3NhZ2VcbiAgICAgIC8vIG9yIGF0dGFjaG1lbnQuXG4gICAgICBjaGFubmVsU2VyaWFsOiB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbFxuICAgIH0pO1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0ZWRGbGFncykge1xuICAgICAgYXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyh0aGlzLl9yZXF1ZXN0ZWRGbGFncyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNoYW5uZWxPcHRpb25zLm1vZGVzKSB7XG4gICAgICBhdHRhY2hNc2cuZW5jb2RlTW9kZXNUb0ZsYWdzKGFsbFRvVXBwZXJDYXNlKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2F0dGFjaFJlc3VtZSkge1xuICAgICAgYXR0YWNoTXNnLnNldEZsYWcoXCJBVFRBQ0hfUkVTVU1FXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgYXR0YWNoTXNnLmNoYW5uZWxTZXJpYWwgPSB0aGlzLl9sYXN0UGF5bG9hZC5wcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsO1xuICAgIH1cbiAgICB0aGlzLnNlbmRNZXNzYWdlKGF0dGFjaE1zZywgbm9vcDIpO1xuICB9XG4gIGFzeW5jIGRldGFjaCgpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGRldGFjaDsgY2hhbm5lbCBzdGF0ZSA9IGZhaWxlZFwiLCA5MDAwMSwgNDAwKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiZGV0YWNoaW5nXCIpO1xuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgIHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gZGV0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSBcIiArIHRoaXMuZXZlbnQsIDllNCwgNTAwKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIkRldGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGF0dGFjaCByZXF1ZXN0XCIsIDllNCwgNDA5KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkZXRhY2hJbXBsKGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmRldGFjaCgpXCIsIFwic2VuZGluZyBERVRBQ0ggbWVzc2FnZVwiKTtcbiAgICBjb25zdCBtc2cgPSBmcm9tVmFsdWVzMyh7IGFjdGlvbjogYWN0aW9uczIuREVUQUNILCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgdGhpcy5zZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrIHx8IG5vb3AyKTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoLi4uYXJncykge1xuICAgIGNvbnN0IFtldmVudCwgbGlzdGVuZXJdID0gX1JlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aHJvdyBFcnJvckluZm8uZnJvbVZhbHVlcyh0aGlzLmludmFsaWRTdGF0ZUVycm9yKCkpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgJiYgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgdGhpcy5jbGllbnQuX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucy5zdWJzY3JpYmVGaWx0ZXIodGhpcywgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmF0dGFjaCgpO1xuICB9XG4gIHVuc3Vic2NyaWJlKC4uLmFyZ3MpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtldmVudCwgbGlzdGVuZXJdID0gX1JlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgIWxpc3RlbmVyIHx8ICgoX2EyID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGFzKGxpc3RlbmVyKSkpIHtcbiAgICAgIHRoaXMuY2xpZW50Ll9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcikuZm9yRWFjaCgobCkgPT4gdGhpcy5zdWJzY3JpcHRpb25zLm9mZihsKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBzeW5jKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgdGhyb3cgbmV3IFBhcnRpYWxFcnJvckluZm8oXCJVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWRcIiwgNGU0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IHN5bmNNZXNzYWdlID0gZnJvbVZhbHVlczMoeyBhY3Rpb246IGFjdGlvbnMyLlNZTkMsIGNoYW5uZWw6IHRoaXMubmFtZSB9KTtcbiAgICBpZiAodGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCkge1xuICAgICAgc3luY01lc3NhZ2UuY2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWw7XG4gICAgfVxuICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoc3luY01lc3NhZ2UpO1xuICB9XG4gIHNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQobXNnLCB0aGlzLmNsaWVudC5vcHRpb25zLnF1ZXVlTWVzc2FnZXMsIGNhbGxiYWNrKTtcbiAgfVxuICBzZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbXNnID0gZnJvbVZhbHVlczMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zMi5QUkVTRU5DRSxcbiAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgIHByZXNlbmNlOiBBcnJheS5pc0FycmF5KHByZXNlbmNlKSA/IHRoaXMuY2xpZW50Ll9SZWFsdGltZVByZXNlbmNlLnByZXNlbmNlTWVzc2FnZXNGcm9tVmFsdWVzQXJyYXkocHJlc2VuY2UpIDogW3RoaXMuY2xpZW50Ll9SZWFsdGltZVByZXNlbmNlLnByZXNlbmNlTWVzc2FnZUZyb21WYWx1ZXMocHJlc2VuY2UpXVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XG4gIH1cbiAgLy8gQWNjZXNzIHRvIHRoaXMgbWV0aG9kIGlzIHN5bmNocm9uaXNlZCBieSBDb25uZWN0aW9uTWFuYWdlciNwcm9jZXNzQ2hhbm5lbE1lc3NhZ2UsIGluIG9yZGVyIHRvIHN5bmNocm9uaXNlIGFjY2VzcyB0byB0aGUgc3RhdGUgc3RvcmVkIGluIF9kZWNvZGluZ0NvbnRleHQuXG4gIGFzeW5jIHByb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMyLkFUVEFDSEVEIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zMi5NRVNTQUdFIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zMi5QUkVTRU5DRSkge1xuICAgICAgdGhpcy5zZXRDaGFubmVsU2VyaWFsKG1lc3NhZ2UuY2hhbm5lbFNlcmlhbCk7XG4gICAgfVxuICAgIGxldCBzeW5jQ2hhbm5lbFNlcmlhbCwgaXNTeW5jID0gZmFsc2U7XG4gICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgY2FzZSBhY3Rpb25zMi5BVFRBQ0hFRDoge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICB0aGlzLl9tb2RlID0gbWVzc2FnZS5nZXRNb2RlKCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gbWVzc2FnZS5wYXJhbXMgfHwge307XG4gICAgICAgIGNvbnN0IG1vZGVzRnJvbUZsYWdzID0gbWVzc2FnZS5kZWNvZGVNb2Rlc0Zyb21GbGFncygpO1xuICAgICAgICB0aGlzLm1vZGVzID0gbW9kZXNGcm9tRmxhZ3MgJiYgYWxsVG9Mb3dlckNhc2UobW9kZXNGcm9tRmxhZ3MpIHx8IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcmVzdW1lZCA9IG1lc3NhZ2UuaGFzRmxhZyhcIlJFU1VNRURcIik7XG4gICAgICAgIGNvbnN0IGhhc1ByZXNlbmNlID0gbWVzc2FnZS5oYXNGbGFnKFwiSEFTX1BSRVNFTkNFXCIpO1xuICAgICAgICBjb25zdCBoYXNCYWNrbG9nID0gbWVzc2FnZS5oYXNGbGFnKFwiSEFTX0JBQ0tMT0dcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgICBpZiAoIXJlc3VtZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgICAgICAgICB0aGlzLl9wcmVzZW5jZS5vbkF0dGFjaGVkKGhhc1ByZXNlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuc3RhdGUsIHRoaXMuc3RhdGUsIHJlc3VtZWQsIGhhc0JhY2tsb2csIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgICAgICBpZiAoIXJlc3VtZWQgfHwgdGhpcy5jaGFubmVsT3B0aW9ucy51cGRhdGVPbkF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgY2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJkZXRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiYXR0YWNoZWRcIiwgbWVzc2FnZS5lcnJvciwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2cpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zMi5ERVRBQ0hFRDoge1xuICAgICAgICBjb25zdCBkZXRhY2hFcnIgPSBtZXNzYWdlLmVycm9yID8gRXJyb3JJbmZvLmZyb21WYWx1ZXMobWVzc2FnZS5lcnJvcikgOiBuZXcgRXJyb3JJbmZvKFwiQ2hhbm5lbCBkZXRhY2hlZFwiLCA5MDAwMSwgNDA0KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZGV0YWNoaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZGV0YWNoZWRcIiwgZGV0YWNoRXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImF0dGFjaGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcInN1c3BlbmRlZFwiLCBkZXRhY2hFcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoZWRcIiB8fCB0aGlzLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoXCJhdHRhY2hpbmdcIiwgZGV0YWNoRXJyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgYWN0aW9uczIuU1lOQzpcbiAgICAgICAgaXNTeW5jID0gdHJ1ZTtcbiAgICAgICAgc3luY0NoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICBpZiAoIW1lc3NhZ2UucHJlc2VuY2UpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMyLlBSRVNFTkNFOiB7XG4gICAgICAgIGNvbnN0IHByZXNlbmNlID0gbWVzc2FnZS5wcmVzZW5jZTtcbiAgICAgICAgaWYgKCFwcmVzZW5jZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQsIGNvbm5lY3Rpb25JZCwgdGltZXN0YW1wIH0gPSBtZXNzYWdlO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgbGV0IHByZXNlbmNlTXNnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXNlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByZXNlbmNlTXNnID0gcHJlc2VuY2VbaV07XG4gICAgICAgICAgICBhd2FpdCBkZWNvZGUyKHByZXNlbmNlTXNnLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICghcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkKVxuICAgICAgICAgICAgICBwcmVzZW5jZU1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICBpZiAoIXByZXNlbmNlTXNnLnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgcHJlc2VuY2VNc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKCFwcmVzZW5jZU1zZy5pZClcbiAgICAgICAgICAgICAgcHJlc2VuY2VNc2cuaWQgPSBpZCArIFwiOlwiICsgaTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgICAgICAgZS50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgICAgICB0aGlzLl9wcmVzZW5jZS5zZXRQcmVzZW5jZShwcmVzZW5jZSwgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMyLk1FU1NBR0U6IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwucHJvY2Vzc01lc3NhZ2UoKVwiLFxuICAgICAgICAgICAgJ01lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBza2lwcGVkIGFzIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgc3RhdGUgaXMgbm90IFwiYXR0YWNoZWRcIiAoc3RhdGUgaXMgXCInICsgdGhpcy5zdGF0ZSArICdcIikuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZS5tZXNzYWdlcywgZmlyc3RNZXNzYWdlID0gbWVzc2FnZXNbMF0sIGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0sIGlkID0gbWVzc2FnZS5pZCwgY29ubmVjdGlvbklkID0gbWVzc2FnZS5jb25uZWN0aW9uSWQsIHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuICAgICAgICBpZiAoZmlyc3RNZXNzYWdlLmV4dHJhcyAmJiBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEuZnJvbSAhPT0gdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ0RlbHRhIG1lc3NhZ2UgZGVjb2RlIGZhaWx1cmUgLSBwcmV2aW91cyBtZXNzYWdlIG5vdCBhdmFpbGFibGUgZm9yIG1lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBvbiB0aGlzIGNoYW5uZWwgXCInICsgdGhpcy5uYW1lICsgJ1wiLic7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIiwgbXNnKTtcbiAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShuZXcgRXJyb3JJbmZvKG1zZywgNDAwMTgsIDQwMCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBtZXNzYWdlc1tpXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZGVjb2RlKG1zZywgdGhpcy5fZGVjb2RpbmdDb250ZXh0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgICAgICAgZS50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3dpdGNoIChlLmNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA0MDAxODpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGNhc2UgNDAwMTk6XG4gICAgICAgICAgICAgIGNhc2UgNDAwMjE6XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImZhaWxlZFwiLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbXNnLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgIG1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgICAgICAgaWYgKCFtc2cudGltZXN0YW1wKVxuICAgICAgICAgICAgbXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICBpZiAoIW1zZy5pZClcbiAgICAgICAgICAgIG1zZy5pZCA9IGlkICsgXCI6XCIgKyBpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLm1lc3NhZ2VJZCA9IGxhc3RNZXNzYWdlLmlkO1xuICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5wcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICB0aGlzLm9uRXZlbnQobWVzc2FnZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgYWN0aW9uczIuRVJST1I6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PSA4MDAxNikge1xuICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZmFpbGVkXCIsIEVycm9ySW5mby5mcm9tVmFsdWVzKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgICAgXCJGYXRhbCBwcm90b2NvbCBlcnJvcjogdW5yZWNvZ25pc2VkIGFjdGlvbiAoXCIgKyBtZXNzYWdlLmFjdGlvbiArIFwiKVwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWJvcnQoY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LnVua25vd25DaGFubmVsRXJyKCkpO1xuICAgIH1cbiAgfVxuICBfc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgXCJTdGFydGluZyBkZWNvZGUgZmFpbHVyZSByZWNvdmVyeSBwcm9jZXNzLlwiXG4gICAgICApO1xuICAgICAgdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICB0aGlzLl9hdHRhY2godHJ1ZSwgcmVhc29uLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkF0dGFjaGVkKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwub25BdHRhY2hlZFwiLFxuICAgICAgXCJhY3RpdmF0aW5nIGNoYW5uZWw7IG5hbWUgPSBcIiArIHRoaXMubmFtZVxuICAgICk7XG4gIH1cbiAgbm90aWZ5U3RhdGUoc3RhdGUsIHJlYXNvbiwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2cpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLm5vdGlmeVN0YXRlXCIsXG4gICAgICBcIm5hbWUgPSBcIiArIHRoaXMubmFtZSArIFwiLCBjdXJyZW50IHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlICsgXCIsIG5vdGlmeWluZyBzdGF0ZSBcIiArIHN0YXRlXG4gICAgKTtcbiAgICB0aGlzLmNsZWFyU3RhdGVUaW1lcigpO1xuICAgIGlmIChbXCJkZXRhY2hlZFwiLCBcInN1c3BlbmRlZFwiLCBcImZhaWxlZFwiXS5pbmNsdWRlcyhzdGF0ZSkpIHtcbiAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgdGhpcy5fcHJlc2VuY2UuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc1ByZXNlbmNlLCByZWFzb24pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuc3RhdGUsIHN0YXRlLCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pO1xuICAgIGNvbnN0IGFjdGlvbiA9ICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIic7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlICsgKHJlYXNvbiA/IFwiOyByZWFzb246IFwiICsgcmVhc29uIDogXCJcIik7XG4gICAgaWYgKHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYWN0aW9uLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSAhPT0gXCJhdHRhY2hpbmdcIiAmJiBzdGF0ZSAhPT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHRoaXMub25BdHRhY2hlZCgpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImRldGFjaGluZ1wiIHx8IHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG4gICAgdGhpcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICB9XG4gIHJlcXVlc3RTdGF0ZShzdGF0ZSwgcmVhc29uKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5yZXF1ZXN0U3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyBzdGF0ZVxuICAgICk7XG4gICAgdGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcbiAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gIH1cbiAgY2hlY2tQZW5kaW5nU3RhdGUoKSB7XG4gICAgY29uc3QgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XG4gICAgaWYgKCFjbVN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgICAgXCJzZW5kRXZlbnRzIGlzIGZhbHNlOyBzdGF0ZSBpcyBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlXG4gICAgKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgICB0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuICAgICAgICB0aGlzLmRldGFjaEltcGwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRpbWVvdXRQZW5kaW5nU3RhdGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgYXR0YWNoIHRpbWVkIG91dFwiLCA5MDAwNywgNDA4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcInN1c3BlbmRlZFwiLCBlcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiQ2hhbm5lbCBkZXRhY2ggdGltZWQgb3V0XCIsIDkwMDA3LCA0MDgpO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiYXR0YWNoZWRcIiwgZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlVGltZXIpIHtcbiAgICAgIHRoaXMuc3RhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZUNoYW5uZWwuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nXCIsIFwidGltZXIgZXhwaXJlZFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0UGVuZGluZ1N0YXRlKCk7XG4gICAgICB9LCB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclN0YXRlVGltZXIoKSB7XG4gICAgY29uc3Qgc3RhdGVUaW1lciA9IHRoaXMuc3RhdGVUaW1lcjtcbiAgICBpZiAoc3RhdGVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKCkge1xuICAgIGlmICh0aGlzLnJldHJ5VGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXRyeUNvdW50Kys7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IGdldFJldHJ5VGltZSh0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQsIHRoaXMucmV0cnlDb3VudCk7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkXCIsXG4gICAgICAgICAgXCJhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaFwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIpO1xuICAgICAgfVxuICAgIH0sIHJldHJ5RGVsYXkpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xuICBnZXRSZWxlYXNlRXJyKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzID09PSBcImluaXRpYWxpemVkXCIgfHwgcyA9PT0gXCJkZXRhY2hlZFwiIHx8IHMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2FuIG9ubHkgcmVsZWFzZSBhIGNoYW5uZWwgaW4gYSBzdGF0ZSB3aGVyZSB0aGVyZSBpcyBubyBwb3NzaWJpbGl0eSBvZiBmdXJ0aGVyIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyIGJlaW5nIHJlY2VpdmVkIChpbml0aWFsaXplZCwgZGV0YWNoZWQsIG9yIGZhaWxlZCk7IHdhcyBcIiArIHMsXG4gICAgICA5MDAwMSxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgc2V0Q2hhbm5lbFNlcmlhbChjaGFubmVsU2VyaWFsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5zZXRDaGFubmVsU2VyaWFsKClcIixcbiAgICAgIFwiVXBkYXRpbmcgY2hhbm5lbCBzZXJpYWw7IHNlcmlhbCA9IFwiICsgY2hhbm5lbFNlcmlhbCArIFwiOyBwcmV2aW91cyA9IFwiICsgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWxcbiAgICApO1xuICAgIGlmIChjaGFubmVsU2VyaWFsKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWw7XG4gICAgfVxuICB9XG4gIGFzeW5jIHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uc3RhdHVzKHRoaXMpO1xuICB9XG59O1xuZnVuY3Rpb24gb21pdEFnZW50KGNoYW5uZWxQYXJhbXMpIHtcbiAgY29uc3QgX2EyID0gY2hhbm5lbFBhcmFtcyB8fCB7fSwgeyBhZ2VudDogXyB9ID0gX2EyLCBwYXJhbXNXaXRob3V0QWdlbnQgPSBfX29ialJlc3QoX2EyLCBbXCJhZ2VudFwiXSk7XG4gIHJldHVybiBwYXJhbXNXaXRob3V0QWdlbnQ7XG59XG52YXIgcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQgPSBSZWFsdGltZUNoYW5uZWw7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9iYXNlcmVhbHRpbWUudHNcbnZhciBfQmFzZVJlYWx0aW1lID0gY2xhc3MgX0Jhc2VSZWFsdGltZSBleHRlbmRzIGJhc2VjbGllbnRfZGVmYXVsdCB7XG4gIC8qXG4gICAqIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyBvbmx5IGFjY2VwdHMgYW4gb2JqZWN0LCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG9uZSBvZiB0aGVzZSB0aGluZ3M6XG4gICAqXG4gICAqIDEuIHBhc3NlcyBhIHN0cmluZyAod2hpY2ggaXMgcXVpdGUgbGlrZWx5IGlmIHRoZXnigJlyZSBlLmcuIG1pZ3JhdGluZyBmcm9tIHRoZSBkZWZhdWx0IHZhcmlhbnQgdG8gdGhlIG1vZHVsYXIgdmFyaWFudClcbiAgICogMi4gcGFzc2VzIG5vIGFyZ3VtZW50IGF0IGFsbFxuICAgKlxuICAgKiB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoZXNlIGNhc2VzIGFyZSBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgdGhlbS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBzdXBlcihkZWZhdWx0c19kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucywgZmFsc2UsIFwiQmFzZVJlYWx0aW1lXCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIpKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZSgpXCIsIFwiXCIpO1xuICAgIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIGBBYmx5LlJlYWx0aW1lIGluc3RhbmNlIGNhbm5vdCBiZSB1c2VkIGluIFZlcmNlbCBFZGdlIHJ1bnRpbWUuIElmIHlvdSBhcmUgcnVubmluZyBWZXJjZWwgRWRnZSBmdW5jdGlvbnMsIHBsZWFzZSByZXBsYWNlIHlvdXIgXCJuZXcgQWJseS5SZWFsdGltZSgpXCIgd2l0aCBcIm5ldyBBYmx5LlJlc3QoKVwiIGFuZCB1c2UgQWJseSBSZXN0IEFQSSBpbnN0ZWFkIG9mIHRoZSBSZWFsdGltZSBBUEkuIElmIHlvdSBhcmUgc2VydmVyLXJlbmRlcmluZyB5b3VyIGFwcGxpY2F0aW9uIGluIHRoZSBWZXJjZWwgRWRnZSBydW50aW1lLCBwbGVhc2UgdXNlIHRoZSBjb25kaXRpb24gXCJpZiAodHlwZW9mIEVkZ2VSdW50aW1lID09PSAnc3RyaW5nJylcIiB0byBwcmV2ZW50IGluc3RhbnRpYXRpbmcgQWJseS5SZWFsdGltZSBpbnN0YW5jZSBkdXJpbmcgU1NSIGluIHRoZSBWZXJjZWwgRWRnZSBydW50aW1lLmAsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9hZGRpdGlvbmFsVHJhbnNwb3J0SW1wbGVtZW50YXRpb25zID0gX0Jhc2VSZWFsdGltZS50cmFuc3BvcnRJbXBsZW1lbnRhdGlvbnNGcm9tUGx1Z2lucyh0aGlzLm9wdGlvbnMucGx1Z2lucyk7XG4gICAgdGhpcy5fUmVhbHRpbWVQcmVzZW5jZSA9IChfYiA9IChfYTIgPSB0aGlzLm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5SZWFsdGltZVByZXNlbmNlKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBjb25uZWN0aW9uX2RlZmF1bHQodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLl9jaGFubmVscyA9IG5ldyBDaGFubmVsczIodGhpcyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvQ29ubmVjdCAhPT0gZmFsc2UpXG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBzdGF0aWMgdHJhbnNwb3J0SW1wbGVtZW50YXRpb25zRnJvbVBsdWdpbnMocGx1Z2lucykge1xuICAgIGNvbnN0IHRyYW5zcG9ydHMgPSB7fTtcbiAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5XZWJTb2NrZXRUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydHNbVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0XSA9IHBsdWdpbnMuV2ViU29ja2V0VHJhbnNwb3J0O1xuICAgIH1cbiAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5YSFJQb2xsaW5nKSB7XG4gICAgICB0cmFuc3BvcnRzW1RyYW5zcG9ydE5hbWVzLlhoclBvbGxpbmddID0gcGx1Z2lucy5YSFJQb2xsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuICBnZXQgY2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWxzO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuY29ubmVjdCgpXCIsIFwiXCIpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuY2xvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgfVxufTtcbi8vIGludGVybmFsIEFQSSB0byBtYWtlIEV2ZW50RW1pdHRlciB1c2FibGUgaW4gb3RoZXIgU0RLc1xuX0Jhc2VSZWFsdGltZS5FdmVudEVtaXR0ZXIgPSBldmVudGVtaXR0ZXJfZGVmYXVsdDtcbnZhciBCYXNlUmVhbHRpbWUgPSBfQmFzZVJlYWx0aW1lO1xudmFyIENoYW5uZWxzMiA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihyZWFsdGltZSkge1xuICAgIHN1cGVyKHJlYWx0aW1lLmxvZ2dlcik7XG4gICAgdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgIHRoaXMuYWxsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbihcInRyYW5zcG9ydC5hY3RpdmVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vblRyYW5zcG9ydEFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG4gIGNoYW5uZWxTZXJpYWxzKCkge1xuICAgIGxldCBzZXJpYWxzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGtleXNBcnJheSh0aGlzLmFsbCwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICAgIGlmIChjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCkge1xuICAgICAgICBzZXJpYWxzW25hbWVdID0gY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxzO1xuICB9XG4gIC8vIHJlY292ZXJDaGFubmVscyBnZXRzIHRoZSBnaXZlbiBjaGFubmVscyBhbmQgc2V0cyB0aGVpciBjaGFubmVsIHNlcmlhbHMuXG4gIHJlY292ZXJDaGFubmVscyhjaGFubmVsU2VyaWFscykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBrZXlzQXJyYXkoY2hhbm5lbFNlcmlhbHMsIHRydWUpKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICBjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWxzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvLyBBY2Nlc3MgdG8gdGhpcyBtZXRob2QgaXMgc3luY2hyb25pc2VkIGJ5IENvbm5lY3Rpb25NYW5hZ2VyI3Byb2Nlc3NDaGFubmVsTWVzc2FnZS5cbiAgYXN5bmMgcHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1zZykge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gbXNnLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWxOYW1lID09PSB2b2lkIDApIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIGV2ZW50IHVuc3BlY2lmaWVkIGNoYW5uZWwsIGFjdGlvbiA9IFwiICsgbXNnLmFjdGlvblxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIGV2ZW50IGZvciBub24tZXhpc3RlbnQgY2hhbm5lbDogXCIgKyBjaGFubmVsTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgY2hhbm5lbC5wcm9jZXNzTWVzc2FnZShtc2cpO1xuICB9XG4gIC8qIGNhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGJlY29tZXMgY29ubmVjdGVkOyByZWF0dGVtcHQgYXR0YWNoL2RldGFjaFxuICAgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy4gKi9cbiAgb25UcmFuc3BvcnRBY3RpdmUoKSB7XG4gICAgZm9yIChjb25zdCBjaGFubmVsTmFtZSBpbiB0aGlzLmFsbCkge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICAgIGlmIChjaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGluZ1wiIHx8IGNoYW5uZWwuc3RhdGUgPT09IFwiZGV0YWNoaW5nXCIpIHtcbiAgICAgICAgY2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICAgIGNoYW5uZWwuX2F0dGFjaChmYWxzZSwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICBjaGFubmVsLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogQ29ubmVjdGlvbiBpbnRlcnJ1cHRpb25zIChpZSB3aGVuIHRoZSBjb25uZWN0aW9uIHdpbGwgbm8gbG9uZ2VyIHF1ZXVlXG4gICAqIGV2ZW50cykgaW1wbHkgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzIGZvciBhbnkgY2hhbm5lbCB3aGljaCBpcyBlaXRoZXJcbiAgICogYXR0YWNoZWQsIHBlbmRpbmcsIG9yIHdpbGwgYXR0ZW1wdCB0byBiZWNvbWUgYXR0YWNoZWQgaW4gdGhlIGZ1dHVyZSAqL1xuICBwcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKGNvbm5lY3Rpb25TdGF0ZSwgcmVhc29uKSB7XG4gICAgY29uc3QgY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGUgPSB7XG4gICAgICBjbG9zaW5nOiBcImRldGFjaGVkXCIsXG4gICAgICBjbG9zZWQ6IFwiZGV0YWNoZWRcIixcbiAgICAgIGZhaWxlZDogXCJmYWlsZWRcIixcbiAgICAgIHN1c3BlbmRlZDogXCJzdXNwZW5kZWRcIlxuICAgIH07XG4gICAgY29uc3QgZnJvbUNoYW5uZWxTdGF0ZXMgPSBbXCJhdHRhY2hpbmdcIiwgXCJhdHRhY2hlZFwiLCBcImRldGFjaGluZ1wiLCBcInN1c3BlbmRlZFwiXTtcbiAgICBjb25zdCB0b0NoYW5uZWxTdGF0ZSA9IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlW2Nvbm5lY3Rpb25TdGF0ZV07XG4gICAgZm9yIChjb25zdCBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuICAgICAgaWYgKGZyb21DaGFubmVsU3RhdGVzLmluY2x1ZGVzKGNoYW5uZWwuc3RhdGUpKSB7XG4gICAgICAgIGNoYW5uZWwubm90aWZ5U3RhdGUodG9DaGFubmVsU3RhdGUsIHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXSA9IG5ldyByZWFsdGltZWNoYW5uZWxfZGVmYXVsdCh0aGlzLnJlYWx0aW1lLCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgaWYgKGNoYW5uZWwuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zLCBjaGFubmVsLmNoYW5uZWxPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgIFwiQ2hhbm5lbHMuZ2V0KCkgY2Fubm90IGJlIHVzZWQgdG8gc2V0IGNoYW5uZWwgb3B0aW9ucyB0aGF0IHdvdWxkIGNhdXNlIHRoZSBjaGFubmVsIHRvIHJlYXR0YWNoLiBQbGVhc2UsIHVzZSBSZWFsdGltZUNoYW5uZWwuc2V0T3B0aW9ucygpIGluc3RlYWQuXCIsXG4gICAgICAgICAgNGU0LFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbiAgZ2V0RGVyaXZlZChuYW1lLCBkZXJpdmVPcHRpb25zLCBjaGFubmVsT3B0aW9ucykge1xuICAgIGlmIChkZXJpdmVPcHRpb25zLmZpbHRlcikge1xuICAgICAgY29uc3QgZmlsdGVyID0gdG9CYXNlNjQoZGVyaXZlT3B0aW9ucy5maWx0ZXIpO1xuICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpO1xuICAgICAgbmFtZSA9IGBbZmlsdGVyPSR7ZmlsdGVyfSR7bWF0Y2gucXVhbGlmaWVyUGFyYW19XSR7bWF0Y2guY2hhbm5lbE5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgfVxuICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cbiAgcmVsZWFzZShuYW1lKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGVhc2VFcnIgPSBjaGFubmVsLmdldFJlbGVhc2VFcnIoKTtcbiAgICBpZiAocmVsZWFzZUVycikge1xuICAgICAgdGhyb3cgcmVsZWFzZUVycjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuYWxsW25hbWVdO1xuICB9XG59O1xudmFyIGJhc2VyZWFsdGltZV9kZWZhdWx0ID0gQmFzZVJlYWx0aW1lO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVwcmVzZW5jZS50c1xuZnVuY3Rpb24gZ2V0Q2xpZW50SWQocmVhbHRpbWVQcmVzZW5jZSkge1xuICByZXR1cm4gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLmNsaWVudC5hdXRoLmNsaWVudElkO1xufVxuZnVuY3Rpb24gaXNBbm9ueW1vdXNPcldpbGRjYXJkKHJlYWx0aW1lUHJlc2VuY2UpIHtcbiAgY29uc3QgcmVhbHRpbWUgPSByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwuY2xpZW50O1xuICBjb25zdCBjbGllbnRJZCA9IHJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG4gIHJldHVybiAoIWNsaWVudElkIHx8IGNsaWVudElkID09PSBcIipcIikgJiYgcmVhbHRpbWUuY29ubmVjdGlvbi5zdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIjtcbn1cbmZ1bmN0aW9uIHdhaXRBdHRhY2hlZChjaGFubmVsLCBjYWxsYmFjaywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgIGFjdGlvbigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhjaGFubmVsLmF0dGFjaCgpLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYWN0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYWxsYmFjayhFcnJvckluZm8uZnJvbVZhbHVlcyhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgfVxufVxuZnVuY3Rpb24gbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nKSB7XG4gIGlmIChpdGVtLmlzU3ludGhlc2l6ZWQoKSB8fCBleGlzdGluZy5pc1N5bnRoZXNpemVkKCkpIHtcbiAgICByZXR1cm4gaXRlbS50aW1lc3RhbXAgPj0gZXhpc3RpbmcudGltZXN0YW1wO1xuICB9XG4gIGNvbnN0IGl0ZW1PcmRlcmluZ3MgPSBpdGVtLnBhcnNlSWQoKSwgZXhpc3RpbmdPcmRlcmluZ3MgPSBleGlzdGluZy5wYXJzZUlkKCk7XG4gIGlmIChpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA9PT0gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsKSB7XG4gICAgcmV0dXJuIGl0ZW1PcmRlcmluZ3MuaW5kZXggPiBleGlzdGluZ09yZGVyaW5ncy5pbmRleDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPiBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWw7XG4gIH1cbn1cbnZhciBSZWFsdGltZVByZXNlbmNlID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICBzdXBlcihjaGFubmVsLmxvZ2dlcik7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICB0aGlzLnN5bmNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMubWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzLCAoaXRlbSkgPT4gaXRlbS5jbGllbnRJZCArIFwiOlwiICsgaXRlbS5jb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX215TWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzLCAoaXRlbSkgPT4gaXRlbS5jbGllbnRJZCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcl9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICB9XG4gIGFzeW5jIGVudGVyKGRhdGEpIHtcbiAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gZW50ZXIgYSBwcmVzZW5jZSBjaGFubmVsXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIHZvaWQgMCwgZGF0YSwgXCJlbnRlclwiKTtcbiAgfVxuICBhc3luYyB1cGRhdGUoZGF0YSkge1xuICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byB1cGRhdGUgcHJlc2VuY2UgZGF0YVwiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodm9pZCAwLCB2b2lkIDAsIGRhdGEsIFwidXBkYXRlXCIpO1xuICB9XG4gIGFzeW5jIGVudGVyQ2xpZW50KGNsaWVudElkLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodm9pZCAwLCBjbGllbnRJZCwgZGF0YSwgXCJlbnRlclwiKTtcbiAgfVxuICBhc3luYyB1cGRhdGVDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIGNsaWVudElkLCBkYXRhLCBcInVwZGF0ZVwiKTtcbiAgfVxuICBhc3luYyBfZW50ZXJPclVwZGF0ZUNsaWVudChpZCwgY2xpZW50SWQsIGRhdGEsIGFjdGlvbikge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2UuXCIgKyBhY3Rpb24gKyBcIkNsaWVudCgpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIGNoYW5uZWwubmFtZSArIFwiLCBpZCA9IFwiICsgaWQgKyBcIiwgY2xpZW50ID0gXCIgKyAoY2xpZW50SWQgfHwgXCIoaW1wbGljaXQpIFwiICsgZ2V0Q2xpZW50SWQodGhpcykpXG4gICAgKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IGZyb21EYXRhKGRhdGEpO1xuICAgIHByZXNlbmNlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHByZXNlbmNlLmlkID0gaWQ7XG4gICAgfVxuICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgcHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICB9XG4gICAgYXdhaXQgZW5jb2RlKHByZXNlbmNlLCBjaGFubmVsLmNoYW5uZWxPcHRpb25zKTtcbiAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlLCAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgY2hhbm5lbC5hdHRhY2goKTtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgIHByZXNlbmNlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcbiAgICAgICAgICBcIlVuYWJsZSB0byBcIiArIGFjdGlvbiArIFwiIHByZXNlbmNlIGNoYW5uZWwgd2hpbGUgaW4gXCIgKyBjaGFubmVsLnN0YXRlICsgXCIgc3RhdGVcIixcbiAgICAgICAgICA5MDAwMVxuICAgICAgICApO1xuICAgICAgICBlcnIuY29kZSA9IDkwMDAxO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGxlYXZlKGRhdGEpIHtcbiAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBoYXZlIGJlZW4gc3BlY2lmaWVkIHRvIGVudGVyIG9yIGxlYXZlIGEgcHJlc2VuY2UgY2hhbm5lbFwiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVhdmVDbGllbnQodm9pZCAwLCBkYXRhKTtcbiAgfVxuICBhc3luYyBsZWF2ZUNsaWVudChjbGllbnRJZCwgZGF0YSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2UubGVhdmVDbGllbnQoKVwiLFxuICAgICAgXCJsZWF2aW5nOyBjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBjbGllbnQgPSBcIiArIGNsaWVudElkXG4gICAgKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IGZyb21EYXRhKGRhdGEpO1xuICAgIHByZXNlbmNlLmFjdGlvbiA9IFwibGVhdmVcIjtcbiAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImF0dGFjaGluZ1wiOlxuICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuICAgICAgICAgICAgcHJlc2VuY2UsXG4gICAgICAgICAgICBjYWxsYmFjazogKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjoge1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGxlYXZlIHByZXNlbmNlIGNoYW5uZWwgKGluY29tcGF0aWJsZSBzdGF0ZSlcIiwgOTAwMDEpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVqZWN0KGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoXCJ3YWl0Rm9yU3luY1wiIGluIHBhcmFtcyA/IHBhcmFtcy53YWl0Rm9yU3luYyA6IHRydWUpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmdW5jdGlvbiByZXR1cm5NZW1iZXJzKG1lbWJlcnMpIHtcbiAgICAgICAgcmVzb2x2ZShwYXJhbXMgPyBtZW1iZXJzLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMudmFsdWVzKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgICAgY29kZTogOTEwMDUsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUHJlc2VuY2Ugc3RhdGUgaXMgb3V0IG9mIHN5bmMgZHVlIHRvIGNoYW5uZWwgYmVpbmcgaW4gdGhlIFNVU1BFTkRFRCBzdGF0ZVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuTWVtYmVycyh0aGlzLm1lbWJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdhaXRBdHRhY2hlZChcbiAgICAgICAgdGhpcy5jaGFubmVsLFxuICAgICAgICAoZXJyKSA9PiByZWplY3QoZXJyKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLm1lbWJlcnM7XG4gICAgICAgICAgaWYgKHdhaXRGb3JTeW5jKSB7XG4gICAgICAgICAgICBtZW1iZXJzLndhaXRTeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybk1lbWJlcnMobWVtYmVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGhpc3RvcnkocGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVQcmVzZW5jZS5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlc3RNaXhpbiA9IHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluO1xuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICBpZiAodGhpcy5jaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcbiAgICAgICAgcGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5jaGFubmVsLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZCwgd2FzOiBcIiArIHRoaXMuY2hhbm5lbC5zdGF0ZSxcbiAgICAgICAgICA0ZTQsXG4gICAgICAgICAgNDAwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN0TWl4aW4uaGlzdG9yeSh0aGlzLCBwYXJhbXMpO1xuICB9XG4gIHNldFByZXNlbmNlKHByZXNlbmNlU2V0LCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2Uuc2V0UHJlc2VuY2UoKVwiLFxuICAgICAgXCJyZWNlaXZlZCBwcmVzZW5jZSBmb3IgXCIgKyBwcmVzZW5jZVNldC5sZW5ndGggKyBcIiBwYXJ0aWNpcGFudHM7IHN5bmNDaGFubmVsU2VyaWFsID0gXCIgKyBzeW5jQ2hhbm5lbFNlcmlhbFxuICAgICk7XG4gICAgbGV0IHN5bmNDdXJzb3IsIG1hdGNoO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycywgYnJvYWRjYXN0TWVzc2FnZXMgPSBbXSwgY29ubklkID0gdGhpcy5jaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZDtcbiAgICBpZiAoaXNTeW5jKSB7XG4gICAgICB0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG4gICAgICBpZiAoc3luY0NoYW5uZWxTZXJpYWwgJiYgKG1hdGNoID0gc3luY0NoYW5uZWxTZXJpYWwubWF0Y2goL15bXFx3LV0rOiguKikkLykpKSB7XG4gICAgICAgIHN5bmNDdXJzb3IgPSBtYXRjaFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVzZW5jZVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJlc2VuY2UgPSBmcm9tVmFsdWVzMihwcmVzZW5jZVNldFtpXSk7XG4gICAgICBzd2l0Y2ggKHByZXNlbmNlLmFjdGlvbikge1xuICAgICAgICBjYXNlIFwibGVhdmVcIjpcbiAgICAgICAgICBpZiAobWVtYmVycy5yZW1vdmUocHJlc2VuY2UpKSB7XG4gICAgICAgICAgICBicm9hZGNhc3RNZXNzYWdlcy5wdXNoKHByZXNlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkICYmICFwcmVzZW5jZS5pc1N5bnRoZXNpemVkKCkpIHtcbiAgICAgICAgICAgIG15TWVtYmVycy5yZW1vdmUocHJlc2VuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVudGVyXCI6XG4gICAgICAgIGNhc2UgXCJwcmVzZW50XCI6XG4gICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICBpZiAobWVtYmVycy5wdXQocHJlc2VuY2UpKSB7XG4gICAgICAgICAgICBicm9hZGNhc3RNZXNzYWdlcy5wdXNoKHByZXNlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkKSB7XG4gICAgICAgICAgICBteU1lbWJlcnMucHV0KHByZXNlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1N5bmMgJiYgIXN5bmNDdXJzb3IpIHtcbiAgICAgIG1lbWJlcnMuZW5kU3luYygpO1xuICAgICAgdGhpcy5jaGFubmVsLnN5bmNDaGFubmVsU2VyaWFsID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBicm9hZGNhc3RNZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJlc2VuY2UgPSBicm9hZGNhc3RNZXNzYWdlc1tpXTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5lbWl0KHByZXNlbmNlLmFjdGlvbiwgcHJlc2VuY2UpO1xuICAgIH1cbiAgfVxuICBvbkF0dGFjaGVkKGhhc1ByZXNlbmNlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZCgpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lICsgXCIsIGhhc1ByZXNlbmNlID0gXCIgKyBoYXNQcmVzZW5jZVxuICAgICk7XG4gICAgaWYgKGhhc1ByZXNlbmNlKSB7XG4gICAgICB0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N5bnRoZXNpemVMZWF2ZXModGhpcy5tZW1iZXJzLnZhbHVlcygpKTtcbiAgICAgIHRoaXMubWVtYmVycy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCk7XG4gICAgY29uc3QgcGVuZGluZ1ByZXNlbmNlID0gdGhpcy5wZW5kaW5nUHJlc2VuY2UsIHBlbmRpbmdQcmVzQ291bnQgPSBwZW5kaW5nUHJlc2VuY2UubGVuZ3RoO1xuICAgIGlmIChwZW5kaW5nUHJlc0NvdW50KSB7XG4gICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICAgICAgY29uc3QgcHJlc2VuY2VBcnJheSA9IFtdO1xuICAgICAgY29uc3QgbXVsdGljYXN0ZXIgPSBtdWx0aWNhc3Rlcl9kZWZhdWx0LmNyZWF0ZSh0aGlzLmxvZ2dlcik7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkXCIsXG4gICAgICAgIFwic2VuZGluZyBcIiArIHBlbmRpbmdQcmVzQ291bnQgKyBcIiBxdWV1ZWQgcHJlc2VuY2UgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVuZGluZ1ByZXNDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gcGVuZGluZ1ByZXNlbmNlW2ldO1xuICAgICAgICBwcmVzZW5jZUFycmF5LnB1c2goZXZlbnQucHJlc2VuY2UpO1xuICAgICAgICBtdWx0aWNhc3Rlci5wdXNoKGV2ZW50LmNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2VBcnJheSwgbXVsdGljYXN0ZXIpO1xuICAgIH1cbiAgfVxuICBhY3RPbkNoYW5uZWxTdGF0ZShzdGF0ZSwgaGFzUHJlc2VuY2UsIGVycikge1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICB0aGlzLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICB0aGlzLl9jbGVhck15TWVtYmVycygpO1xuICAgICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgdGhpcy5mYWlsUGVuZGluZ1ByZXNlbmNlKGVycik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmYWlsUGVuZGluZ1ByZXNlbmNlKGVycikge1xuICAgIGlmICh0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuZmFpbFBlbmRpbmdQcmVzZW5jZVwiLFxuICAgICAgICBcImNoYW5uZWw7IG5hbWUgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lICsgXCIsIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aDsgaSsrKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlW2ldLmNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICB9XG4gIH1cbiAgX2NsZWFyTXlNZW1iZXJzKCkge1xuICAgIHRoaXMuX215TWVtYmVycy5jbGVhcigpO1xuICB9XG4gIF9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCkge1xuICAgIGNvbnN0IG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycywgcmVlbnRlckNiID0gKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zdCBtc2cgPSBcIlByZXNlbmNlIGF1dG8tcmUtZW50ZXIgZmFpbGVkOiBcIiArIGVyci50b1N0cmluZygpO1xuICAgICAgICBjb25zdCB3cmFwcGVkRXJyID0gbmV3IEVycm9ySW5mbyhtc2csIDkxMDA0LCA0MDApO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KClcIiwgbXNnKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuY2hhbm5lbC5zdGF0ZSwgdGhpcy5jaGFubmVsLnN0YXRlLCB0cnVlLCBmYWxzZSwgd3JhcHBlZEVycik7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5lbWl0KFwidXBkYXRlXCIsIGNoYW5nZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1lbWJlcktleSBpbiBteU1lbWJlcnMubWFwKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IG15TWVtYmVycy5tYXBbbWVtYmVyS2V5XTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KClcIixcbiAgICAgICAgJ0F1dG8tcmVlbnRlcmluZyBjbGllbnRJZCBcIicgKyBlbnRyeS5jbGllbnRJZCArICdcIiBpbnRvIHRoZSBwcmVzZW5jZSBzZXQnXG4gICAgICApO1xuICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoZW50cnkuaWQsIGVudHJ5LmNsaWVudElkLCBlbnRyeS5kYXRhLCBcImVudGVyXCIpLCByZWVudGVyQ2IpO1xuICAgIH1cbiAgfVxuICBfc3ludGhlc2l6ZUxlYXZlcyhpdGVtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBjb25zdCBwcmVzZW5jZSA9IGZyb21WYWx1ZXMyKHtcbiAgICAgICAgYWN0aW9uOiBcImxlYXZlXCIsXG4gICAgICAgIGNvbm5lY3Rpb25JZDogaXRlbS5jb25uZWN0aW9uSWQsXG4gICAgICAgIGNsaWVudElkOiBpdGVtLmNsaWVudElkLFxuICAgICAgICBkYXRhOiBpdGVtLmRhdGEsXG4gICAgICAgIGVuY29kaW5nOiBpdGVtLmVuY29kaW5nLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgICAgc3Vic2NyaXB0aW9ucy5lbWl0KFwibGVhdmVcIiwgcHJlc2VuY2UpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIGF3YWl0IGNoYW5uZWwuYXR0YWNoKCk7XG4gIH1cbiAgdW5zdWJzY3JpYmUoLi4uX2FyZ3MpIHtcbiAgICBjb25zdCBhcmdzID0gcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn07XG52YXIgUHJlc2VuY2VNYXAgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocHJlc2VuY2UsIG1lbWJlcktleSkge1xuICAgIHN1cGVyKHByZXNlbmNlLmxvZ2dlcik7XG4gICAgdGhpcy5wcmVzZW5jZSA9IHByZXNlbmNlO1xuICAgIHRoaXMubWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcbiAgICB0aGlzLm1lbWJlcktleSA9IG1lbWJlcktleTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW2tleV07XG4gIH1cbiAgZ2V0Q2xpZW50KGNsaWVudElkKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgY29uc3QgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgaWYgKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gXCJhYnNlbnRcIilcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGlzdChwYXJhbXMpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgY2xpZW50SWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNsaWVudElkLCBjb25uZWN0aW9uSWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbm5lY3Rpb25JZCwgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWFwW2tleV07XG4gICAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiYWJzZW50XCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNsaWVudElkICYmIGNsaWVudElkICE9IGl0ZW0uY2xpZW50SWQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNvbm5lY3Rpb25JZCAmJiBjb25uZWN0aW9uSWQgIT0gaXRlbS5jb25uZWN0aW9uSWQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHV0KGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiZW50ZXJcIiB8fCBpdGVtLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgaXRlbSA9IGZyb21WYWx1ZXMyKGl0ZW0pO1xuICAgICAgaXRlbS5hY3Rpb24gPSBcInByZXNlbnRcIjtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIGtleSA9IHRoaXMubWVtYmVyS2V5KGl0ZW0pO1xuICAgIGlmICh0aGlzLnJlc2lkdWFsTWVtYmVycylcbiAgICAgIGRlbGV0ZSB0aGlzLnJlc2lkdWFsTWVtYmVyc1trZXldO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuICAgIGlmIChleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcFtrZXldID0gaXRlbTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgY29uc3QgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgaWYgKGl0ZW0uYWN0aW9uICE9IFwiYWJzZW50XCIpXG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlbW92ZShpdGVtKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIGtleSA9IHRoaXMubWVtYmVyS2V5KGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuICAgIGlmIChleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICBpdGVtID0gZnJvbVZhbHVlczIoaXRlbSk7XG4gICAgICBpdGVtLmFjdGlvbiA9IFwiYWJzZW50XCI7XG4gICAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhcnRTeW5jKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlByZXNlbmNlTWFwLnN0YXJ0U3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IGNvcHkobWFwKTtcbiAgICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgZW5kU3luYygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC5lbmRTeW5jKClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyBcIjsgc3luY0luUHJvZ3Jlc3MgPSBcIiArIHN5bmNJblByb2dyZXNzXG4gICAgKTtcbiAgICBpZiAoc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyS2V5IGluIG1hcCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG1hcFttZW1iZXJLZXldO1xuICAgICAgICBpZiAoZW50cnkuYWN0aW9uID09PSBcImFic2VudFwiKSB7XG4gICAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnByZXNlbmNlLl9zeW50aGVzaXplTGVhdmVzKHZhbHVlc0FycmF5KHRoaXMucmVzaWR1YWxNZW1iZXJzKSk7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlcktleSBpbiB0aGlzLnJlc2lkdWFsTWVtYmVycykge1xuICAgICAgICBkZWxldGUgbWFwW21lbWJlcktleV07XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJzeW5jXCIpO1xuICB9XG4gIHdhaXRTeW5jKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC53YWl0U3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKCFzeW5jSW5Qcm9ncmVzcykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vbmNlKFwic3luY1wiLCBjYWxsYmFjayk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgIHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcbiAgfVxuICBzZXRJblByb2dyZXNzKGluUHJvZ3Jlc3MpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJQcmVzZW5jZU1hcC5zZXRJblByb2dyZXNzKClcIiwgXCJpblByb2dyZXNzID0gXCIgKyBpblByb2dyZXNzKTtcbiAgICB0aGlzLnN5bmNJblByb2dyZXNzID0gaW5Qcm9ncmVzcztcbiAgICB0aGlzLnByZXNlbmNlLnN5bmNDb21wbGV0ZSA9ICFpblByb2dyZXNzO1xuICB9XG59O1xudmFyIHJlYWx0aW1lcHJlc2VuY2VfZGVmYXVsdCA9IFJlYWx0aW1lUHJlc2VuY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC93ZWJzb2NrZXR0cmFuc3BvcnQudHNcbnZhciBzaG9ydE5hbWUgPSBUcmFuc3BvcnROYW1lcy5XZWJTb2NrZXQ7XG5mdW5jdGlvbiBpc05vZGVXZWJTb2NrZXQod3MpIHtcbiAgcmV0dXJuICEhd3Mub247XG59XG52YXIgV2ViU29ja2V0VHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyB0cmFuc3BvcnRfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcbiAgICB0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcbiAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IFBsYXRmb3JtLkNvbmZpZy51c2VQcm90b2NvbEhlYXJ0YmVhdHM7XG4gICAgdGhpcy53c0hvc3QgPSBwYXJhbXMuaG9zdDtcbiAgfVxuICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuICEhUGxhdGZvcm0uQ29uZmlnLldlYlNvY2tldDtcbiAgfVxuICBjcmVhdGVXZWJTb2NrZXQodXJpLCBjb25uZWN0UGFyYW1zKSB7XG4gICAgdGhpcy51cmkgPSB1cmkgKyB0b1F1ZXJ5U3RyaW5nKGNvbm5lY3RQYXJhbXMpO1xuICAgIHJldHVybiBuZXcgUGxhdGZvcm0uQ29uZmlnLldlYlNvY2tldCh0aGlzLnVyaSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiV2ViU29ja2V0VHJhbnNwb3J0OyB1cmk9XCIgKyB0aGlzLnVyaTtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJzdGFydGluZ1wiKTtcbiAgICB0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcywgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICBjb25zdCB3c1NjaGVtZSA9IG9wdGlvbnMudGxzID8gXCJ3c3M6Ly9cIiA6IFwid3M6Ly9cIjtcbiAgICBjb25zdCB3c1VyaSA9IHdzU2NoZW1lICsgdGhpcy53c0hvc3QgKyBcIjpcIiArIGRlZmF1bHRzX2RlZmF1bHQuZ2V0UG9ydChvcHRpb25zKSArIFwiL1wiO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJ1cmk6IFwiICsgd3NVcmkpO1xuICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgIHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKCksXG4gICAgICBmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcbiAgICAgICAgaWYgKHNlbGYyLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtU3RyID0gXCJcIjtcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbSBpbiBhdXRoUGFyYW1zKVxuICAgICAgICAgIHBhcmFtU3RyICs9IFwiIFwiICsgcGFyYW0gKyBcIjogXCIgKyBhdXRoUGFyYW1zW3BhcmFtXSArIFwiO1wiO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgc2VsZjIubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIldlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KClcIixcbiAgICAgICAgICBcImF1dGhQYXJhbXM6XCIgKyBwYXJhbVN0ciArIFwiIGVycjogXCIgKyBlcnJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHNlbGYyLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdFBhcmFtcyA9IHBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHdzQ29ubmVjdGlvbiA9IHNlbGYyLndzQ29ubmVjdGlvbiA9IHNlbGYyLmNyZWF0ZVdlYlNvY2tldCh3c1VyaSwgY29ubmVjdFBhcmFtcyk7XG4gICAgICAgICAgd3NDb25uZWN0aW9uLmJpbmFyeVR5cGUgPSBQbGF0Zm9ybS5Db25maWcuYmluYXJ5VHlwZTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmMi5vbldzT3BlbigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9uY2xvc2UgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgc2VsZjIub25Xc0Nsb3NlKGV2KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgc2VsZjIub25Xc0RhdGEoZXYuZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBzZWxmMi5vbldzRXJyb3IoZXYpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzTm9kZVdlYlNvY2tldCh3c0Nvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub24oXCJwaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmMi5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICBzZWxmMi5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIldlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KClcIixcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gY3JlYXRpbmcgd2Vic29ja2V0OiBlcnIgPSBcIiArIChlLnN0YWNrIHx8IGUubWVzc2FnZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYyLmRpc2Nvbm5lY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHNlbmQobWVzc2FnZSkge1xuICAgIGNvbnN0IHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xuICAgIGlmICghd3NDb25uZWN0aW9uKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpXCIsIFwiTm8gc29ja2V0IGNvbm5lY3Rpb25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB3c0Nvbm5lY3Rpb24uc2VuZChcbiAgICAgICAgc2VyaWFsaXplMihtZXNzYWdlLCB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Nc2dQYWNrLCB0aGlzLnBhcmFtcy5mb3JtYXQpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiRXhjZXB0aW9uIGZyb20gd3MgY29ubmVjdGlvbiB3aGVuIHRyeWluZyB0byBzZW5kOiBcIiArIGluc3BlY3RFcnJvcihlKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5zZW5kKClcIiwgbXNnKTtcbiAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIG5ldyBFcnJvckluZm8obXNnLCA1ZTQsIDUwMCkpO1xuICAgIH1cbiAgfVxuICBvbldzRGF0YShkYXRhKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpXCIsXG4gICAgICBcImRhdGEgcmVjZWl2ZWQ7IGxlbmd0aCA9IFwiICsgZGF0YS5sZW5ndGggKyBcIjsgdHlwZSA9IFwiICsgdHlwZW9mIGRhdGFcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKFxuICAgICAgICBkZXNlcmlhbGl6ZShcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX01zZ1BhY2ssXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICB0aGlzLmZvcm1hdFxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKVwiLFxuICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBtZXNzYWdlOiBcIiArIGUuc3RhY2tcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG9uV3NPcGVuKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzT3BlbigpXCIsIFwib3BlbmVkIFdlYlNvY2tldFwiKTtcbiAgICB0aGlzLmVtaXQoXCJwcmVjb25uZWN0XCIpO1xuICB9XG4gIG9uV3NDbG9zZShldikge1xuICAgIGxldCB3YXNDbGVhbiwgY29kZTtcbiAgICBpZiAodHlwZW9mIGV2ID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvZGUgPSBldi5jb2RlO1xuICAgICAgd2FzQ2xlYW4gPSBldi53YXNDbGVhbiB8fCBjb2RlID09PSAxZTM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSBldjtcbiAgICAgIHdhc0NsZWFuID0gY29kZSA9PSAxZTM7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICBpZiAod2FzQ2xlYW4pIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKVwiLCBcIkNsZWFubHkgY2xvc2VkIFdlYlNvY2tldFwiKTtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckluZm8oXCJXZWJzb2NrZXQgY2xvc2VkXCIsIDgwMDAzLCA0MDApO1xuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gXCJVbmNsZWFuIGRpc2Nvbm5lY3Rpb24gb2YgV2ViU29ja2V0IDsgY29kZSA9IFwiICsgY29kZSwgZXJyID0gbmV3IEVycm9ySW5mbyhtc2csIDgwMDAzLCA0MDApO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpXCIsIG1zZyk7XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJkaXNwb3NlZFwiKTtcbiAgfVxuICBvbldzRXJyb3IoZXJyKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIldlYlNvY2tldFRyYW5zcG9ydC5vbkVycm9yKClcIixcbiAgICAgIFwiRXJyb3IgZnJvbSBXZWJTb2NrZXQ6IFwiICsgZXJyLm1lc3NhZ2VcbiAgICApO1xuICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoRXJyb3IoZXJyLm1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICBpZiAod3NDb25uZWN0aW9uKSB7XG4gICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcImNsb3Npbmcgd2Vic29ja2V0XCIpO1xuICAgICAgICBpZiAoIXdzQ29ubmVjdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCk6IHdzQ29ubmVjdGlvbiBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB3c0Nvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbnZhciB3ZWJzb2NrZXR0cmFuc3BvcnRfZGVmYXVsdCA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2ZpbHRlcmVkc3Vic2NyaXB0aW9ucy50c1xudmFyIEZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IGNsYXNzIHtcbiAgc3RhdGljIHN1YnNjcmliZUZpbHRlcihjaGFubmVsLCBmaWx0ZXIsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgZmlsdGVyZWRMaXN0ZW5lciA9IChtKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgICBuYW1lOiBtLm5hbWUsXG4gICAgICAgIHJlZlRpbWVzZXJpYWw6IChfYiA9IChfYTIgPSBtLmV4dHJhcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfYi50aW1lc2VyaWFsLFxuICAgICAgICByZWZUeXBlOiAoX2QgPSAoX2MgPSBtLmV4dHJhcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnR5cGUsXG4gICAgICAgIGlzUmVmOiAhISgoX2YgPSAoX2UgPSBtLmV4dHJhcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnJlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnRpbWVzZXJpYWwpLFxuICAgICAgICBjbGllbnRJZDogbS5jbGllbnRJZFxuICAgICAgfTtcbiAgICAgIGlmIChPYmplY3QuZW50cmllcyhmaWx0ZXIpLmZpbmQoXG4gICAgICAgIChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgPyBtYXBwaW5nW2tleV0gIT09IHZhbHVlIDogZmFsc2VcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIobSk7XG4gICAgfTtcbiAgICB0aGlzLmFkZEZpbHRlcmVkU3Vic2NyaXB0aW9uKGNoYW5uZWwsIGZpbHRlciwgbGlzdGVuZXIsIGZpbHRlcmVkTGlzdGVuZXIpO1xuICAgIGNoYW5uZWwuc3Vic2NyaXB0aW9ucy5vbihmaWx0ZXJlZExpc3RlbmVyKTtcbiAgfVxuICAvLyBBZGRzIGEgbmV3IGZpbHRlcmVkIHN1YnNjcmlwdGlvblxuICBzdGF0aWMgYWRkRmlsdGVyZWRTdWJzY3JpcHRpb24oY2hhbm5lbCwgZmlsdGVyLCByZWFsTGlzdGVuZXIsIGZpbHRlcmVkTGlzdGVuZXIpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgaWYgKGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmhhcyhyZWFsTGlzdGVuZXIpKSB7XG4gICAgICBjb25zdCByZWFsTGlzdGVuZXJNYXAgPSBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5nZXQocmVhbExpc3RlbmVyKTtcbiAgICAgIHJlYWxMaXN0ZW5lck1hcC5zZXQoZmlsdGVyLCAoKF9hMiA9IHJlYWxMaXN0ZW5lck1hcCA9PSBudWxsID8gdm9pZCAwIDogcmVhbExpc3RlbmVyTWFwLmdldChmaWx0ZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbmNhdChmaWx0ZXJlZExpc3RlbmVyKSkgfHwgW2ZpbHRlcmVkTGlzdGVuZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuc2V0KFxuICAgICAgICByZWFsTGlzdGVuZXIsXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbZmlsdGVyLCBbZmlsdGVyZWRMaXN0ZW5lcl1dXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRBbmREZWxldGVGaWx0ZXJlZFN1YnNjcmlwdGlvbnMoY2hhbm5lbCwgZmlsdGVyLCByZWFsTGlzdGVuZXIpIHtcbiAgICBpZiAoIWNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghcmVhbExpc3RlbmVyICYmIGZpbHRlcikge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZW50cmllcygpKS5tYXAoKFtrZXksIGZpbHRlck1hcHNdKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGxldCBsaXN0ZW5lck1hcHMgPSBmaWx0ZXJNYXBzLmdldChmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXJNYXBzLmRlbGV0ZShmaWx0ZXIpO1xuICAgICAgICBpZiAoZmlsdGVyTWFwcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgKF9hMiA9IGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lck1hcHM7XG4gICAgICB9KS5yZWR1Y2UoXG4gICAgICAgIChwcmV2LCBjdXIpID0+IGN1ciA/IHByZXYuY29uY2F0KC4uLmN1cikgOiBwcmV2LFxuICAgICAgICBbXVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZWFsTGlzdGVuZXIgfHwgIWNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmhhcyhyZWFsTGlzdGVuZXIpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHJlYWxMaXN0ZW5lck1hcCA9IGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldChyZWFsTGlzdGVuZXIpO1xuICAgIGlmICghZmlsdGVyKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMyID0gQXJyYXkuZnJvbShyZWFsTGlzdGVuZXJNYXAudmFsdWVzKCkpLnJlZHVjZSgocHJldiwgY3VyKSA9PiBwcmV2LmNvbmNhdCguLi5jdXIpLCBbXSk7XG4gICAgICBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5kZWxldGUocmVhbExpc3RlbmVyKTtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMyO1xuICAgIH1cbiAgICBsZXQgbGlzdGVuZXJzID0gcmVhbExpc3RlbmVyTWFwLmdldChmaWx0ZXIpO1xuICAgIHJlYWxMaXN0ZW5lck1hcC5kZWxldGUoZmlsdGVyKTtcbiAgICByZXR1cm4gbGlzdGVuZXJzIHx8IFtdO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvZGVmYXVsdHJlYWx0aW1lLnRzXG52YXIgX0RlZmF1bHRSZWFsdGltZSA9IGNsYXNzIF9EZWZhdWx0UmVhbHRpbWUgZXh0ZW5kcyBiYXNlcmVhbHRpbWVfZGVmYXVsdCB7XG4gIC8vIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyByZXF1aXJlcyBhbiBhcmd1bWVudCB0byBiZSBwYXNzZWQsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgbm90IHBhc3MgYW4gYXJndW1lbnQsIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhpcyBpcyBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgaXQuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IE1zZ1BhY2sgPSBfRGVmYXVsdFJlYWx0aW1lLl9Nc2dQYWNrO1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGVmYXVsdFJlYWx0aW1lLl9Nc2dQYWNrIHRvIGhhdmUgYmVlbiBzZXRcIik7XG4gICAgfVxuICAgIHN1cGVyKFxuICAgICAgZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIHRydWUsIFwiUmVhbHRpbWVcIiwgbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYWxsQ29tbW9uTW9kdWxhclBsdWdpbnMpLCB7XG4gICAgICAgIENyeXB0bzogKF9hMiA9IF9EZWZhdWx0UmVhbHRpbWUuQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogdm9pZCAwLFxuICAgICAgICBNc2dQYWNrLFxuICAgICAgICBSZWFsdGltZVByZXNlbmNlOiB7XG4gICAgICAgICAgUmVhbHRpbWVQcmVzZW5jZTogcmVhbHRpbWVwcmVzZW5jZV9kZWZhdWx0LFxuICAgICAgICAgIHByZXNlbmNlTWVzc2FnZUZyb21WYWx1ZXM6IGZyb21WYWx1ZXMyLFxuICAgICAgICAgIHByZXNlbmNlTWVzc2FnZXNGcm9tVmFsdWVzQXJyYXk6IGZyb21WYWx1ZXNBcnJheTJcbiAgICAgICAgfSxcbiAgICAgICAgV2ViU29ja2V0VHJhbnNwb3J0OiB3ZWJzb2NrZXR0cmFuc3BvcnRfZGVmYXVsdCxcbiAgICAgICAgTWVzc2FnZUludGVyYWN0aW9uczogRmlsdGVyZWRTdWJzY3JpcHRpb25zXG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIHN0YXRpYyBnZXQgQ3J5cHRvKCkge1xuICAgIGlmICh0aGlzLl9DcnlwdG8gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX0NyeXB0bztcbiAgfVxuICBzdGF0aWMgc2V0IENyeXB0byhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX0NyeXB0byA9IG5ld1ZhbHVlO1xuICB9XG59O1xuX0RlZmF1bHRSZWFsdGltZS5VdGlscyA9IHV0aWxzX2V4cG9ydHM7XG5fRGVmYXVsdFJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdDtcbl9EZWZhdWx0UmVhbHRpbWUuUHJvdG9jb2xNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlX2RlZmF1bHQ7XG5fRGVmYXVsdFJlYWx0aW1lLl9DcnlwdG8gPSBudWxsO1xuX0RlZmF1bHRSZWFsdGltZS5NZXNzYWdlID0gRGVmYXVsdE1lc3NhZ2U7XG5fRGVmYXVsdFJlYWx0aW1lLlByZXNlbmNlTWVzc2FnZSA9IERlZmF1bHRQcmVzZW5jZU1lc3NhZ2U7XG5fRGVmYXVsdFJlYWx0aW1lLl9Nc2dQYWNrID0gbnVsbDtcbi8vIFVzZWQgYnkgdGVzdHNcbl9EZWZhdWx0UmVhbHRpbWUuX0h0dHAgPSBIdHRwO1xudmFyIERlZmF1bHRSZWFsdGltZSA9IF9EZWZhdWx0UmVhbHRpbWU7XG5cbi8vIHNyYy9wbGF0Zm9ybS93ZWIvbGliL3V0aWwvaG1hYy1zaGEyNTYudHNcbnZhciB1aW50OEFycmF5ID0gVWludDhBcnJheTtcbnZhciB1aW50MzJBcnJheSA9IFVpbnQzMkFycmF5O1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIERFRkFVTFRfU1RBVEUgPSBuZXcgdWludDMyQXJyYXkoOCk7XG52YXIgUk9VTkRfQ09OU1RBTlRTID0gW107XG52YXIgTSA9IG5ldyB1aW50MzJBcnJheSg2NCk7XG5mdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuMikge1xuICByZXR1cm4gKG4yIC0gKG4yIHwgMCkpICogcG93KDIsIDMyKSB8IDA7XG59XG52YXIgbiA9IDI7XG52YXIgblByaW1lID0gMDtcbndoaWxlIChuUHJpbWUgPCA2NCkge1xuICBpc1ByaW1lID0gdHJ1ZTtcbiAgZm9yIChmYWN0b3IgPSAyOyBmYWN0b3IgPD0gbiAvIDI7IGZhY3RvcisrKSB7XG4gICAgaWYgKG4gJSBmYWN0b3IgPT09IDApIHtcbiAgICAgIGlzUHJpbWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUHJpbWUpIHtcbiAgICBpZiAoblByaW1lIDwgOCkge1xuICAgICAgREVGQVVMVF9TVEFURVtuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMocG93KG4sIDEgLyAyKSk7XG4gICAgfVxuICAgIFJPVU5EX0NPTlNUQU5UU1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMocG93KG4sIDEgLyAzKSk7XG4gICAgblByaW1lKys7XG4gIH1cbiAgbisrO1xufVxudmFyIGlzUHJpbWU7XG52YXIgZmFjdG9yO1xudmFyIExpdHRsZUVuZGlhbiA9ICEhbmV3IHVpbnQ4QXJyYXkobmV3IHVpbnQzMkFycmF5KFsxXSkuYnVmZmVyKVswXTtcbmZ1bmN0aW9uIGNvbnZlcnRFbmRpYW4od29yZCkge1xuICBpZiAoTGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGJ5dGUgMSAtPiBieXRlIDRcbiAgICAgIHdvcmQgPj4+IDI0IHwgLy8gYnl0ZSAyIC0+IGJ5dGUgM1xuICAgICAgKHdvcmQgPj4+IDE2ICYgMjU1KSA8PCA4IHwgLy8gYnl0ZSAzIC0+IGJ5dGUgMlxuICAgICAgKHdvcmQgJiA2NTI4MCkgPDwgOCB8IC8vIGJ5dGUgNCAtPiBieXRlIDFcbiAgICAgIHdvcmQgPDwgMjRcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3b3JkO1xuICB9XG59XG5mdW5jdGlvbiByaWdodFJvdGF0ZSh3b3JkLCBiaXRzKSB7XG4gIHJldHVybiB3b3JkID4+PiBiaXRzIHwgd29yZCA8PCAzMiAtIGJpdHM7XG59XG5mdW5jdGlvbiBzaGEyNTYoZGF0YSkge1xuICB2YXIgU1RBVEUgPSBERUZBVUxUX1NUQVRFLnNsaWNlKCk7XG4gIHZhciBsZWd0aCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgYml0TGVuZ3RoID0gbGVndGggKiA4O1xuICB2YXIgbmV3Qml0TGVuZ3RoID0gNTEyIC0gKGJpdExlbmd0aCArIDY0KSAlIDUxMiAtIDEgKyBiaXRMZW5ndGggKyA2NTtcbiAgdmFyIGJ5dGVzID0gbmV3IHVpbnQ4QXJyYXkobmV3Qml0TGVuZ3RoIC8gOCk7XG4gIHZhciB3b3JkcyA9IG5ldyB1aW50MzJBcnJheShieXRlcy5idWZmZXIpO1xuICBieXRlcy5zZXQoZGF0YSwgMCk7XG4gIGJ5dGVzW2xlZ3RoXSA9IDEyODtcbiAgd29yZHNbd29yZHMubGVuZ3RoIC0gMV0gPSBjb252ZXJ0RW5kaWFuKGJpdExlbmd0aCk7XG4gIHZhciByb3VuZDtcbiAgZm9yICh2YXIgYmxvY2sgPSAwOyBibG9jayA8IG5ld0JpdExlbmd0aCAvIDMyOyBibG9jayArPSAxNikge1xuICAgIHZhciB3b3JraW5nU3RhdGUgPSBTVEFURS5zbGljZSgpO1xuICAgIGZvciAocm91bmQgPSAwOyByb3VuZCA8IDY0OyByb3VuZCsrKSB7XG4gICAgICB2YXIgTVJvdW5kO1xuICAgICAgaWYgKHJvdW5kIDwgMTYpIHtcbiAgICAgICAgTVJvdW5kID0gY29udmVydEVuZGlhbih3b3Jkc1tibG9jayArIHJvdW5kXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZ2FtbWEweCA9IE1bcm91bmQgLSAxNV07XG4gICAgICAgIHZhciBnYW1tYTF4ID0gTVtyb3VuZCAtIDJdO1xuICAgICAgICBNUm91bmQgPSBNW3JvdW5kIC0gN10gKyBNW3JvdW5kIC0gMTZdICsgKHJpZ2h0Um90YXRlKGdhbW1hMHgsIDcpIF4gcmlnaHRSb3RhdGUoZ2FtbWEweCwgMTgpIF4gZ2FtbWEweCA+Pj4gMykgKyAocmlnaHRSb3RhdGUoZ2FtbWExeCwgMTcpIF4gcmlnaHRSb3RhdGUoZ2FtbWExeCwgMTkpIF4gZ2FtbWExeCA+Pj4gMTApO1xuICAgICAgfVxuICAgICAgTVtyb3VuZF0gPSBNUm91bmQgfD0gMDtcbiAgICAgIHZhciB0MSA9IChyaWdodFJvdGF0ZSh3b3JraW5nU3RhdGVbNF0sIDYpIF4gcmlnaHRSb3RhdGUod29ya2luZ1N0YXRlWzRdLCAxMSkgXiByaWdodFJvdGF0ZSh3b3JraW5nU3RhdGVbNF0sIDI1KSkgKyAod29ya2luZ1N0YXRlWzRdICYgd29ya2luZ1N0YXRlWzVdIF4gfndvcmtpbmdTdGF0ZVs0XSAmIHdvcmtpbmdTdGF0ZVs2XSkgKyB3b3JraW5nU3RhdGVbN10gKyBNUm91bmQgKyBST1VORF9DT05TVEFOVFNbcm91bmRdO1xuICAgICAgdmFyIHQyID0gKHJpZ2h0Um90YXRlKHdvcmtpbmdTdGF0ZVswXSwgMikgXiByaWdodFJvdGF0ZSh3b3JraW5nU3RhdGVbMF0sIDEzKSBeIHJpZ2h0Um90YXRlKHdvcmtpbmdTdGF0ZVswXSwgMjIpKSArICh3b3JraW5nU3RhdGVbMF0gJiB3b3JraW5nU3RhdGVbMV0gXiB3b3JraW5nU3RhdGVbMl0gJiAod29ya2luZ1N0YXRlWzBdIF4gd29ya2luZ1N0YXRlWzFdKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+IDA7IGktLSkge1xuICAgICAgICB3b3JraW5nU3RhdGVbaV0gPSB3b3JraW5nU3RhdGVbaSAtIDFdO1xuICAgICAgfVxuICAgICAgd29ya2luZ1N0YXRlWzBdID0gdDEgKyB0MiB8IDA7XG4gICAgICB3b3JraW5nU3RhdGVbNF0gPSB3b3JraW5nU3RhdGVbNF0gKyB0MSB8IDA7XG4gICAgfVxuICAgIGZvciAocm91bmQgPSAwOyByb3VuZCA8IDg7IHJvdW5kKyspIHtcbiAgICAgIFNUQVRFW3JvdW5kXSA9IFNUQVRFW3JvdW5kXSArIHdvcmtpbmdTdGF0ZVtyb3VuZF0gfCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IHVpbnQ4QXJyYXkoXG4gICAgbmV3IHVpbnQzMkFycmF5KFxuICAgICAgU1RBVEUubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gY29udmVydEVuZGlhbih2YWwpO1xuICAgICAgfSlcbiAgICApLmJ1ZmZlclxuICApO1xufVxuZnVuY3Rpb24gaG1hYzIoa2V5LCBkYXRhKSB7XG4gIGlmIChrZXkubGVuZ3RoID4gNjQpXG4gICAga2V5ID0gc2hhMjU2KGtleSk7XG4gIGlmIChrZXkubGVuZ3RoIDwgNjQpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgdG1wLnNldChrZXksIDApO1xuICAgIGtleSA9IHRtcDtcbiAgfVxuICB2YXIgaW5uZXJLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBvdXRlcktleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgaW5uZXJLZXlbaV0gPSA1NCBeIGtleVtpXTtcbiAgICBvdXRlcktleVtpXSA9IDkyIF4ga2V5W2ldO1xuICB9XG4gIHZhciBtc2cgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIDY0KTtcbiAgbXNnLnNldChpbm5lcktleSwgMCk7XG4gIG1zZy5zZXQoZGF0YSwgNjQpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoNjQgKyAzMik7XG4gIHJlc3VsdC5zZXQob3V0ZXJLZXksIDApO1xuICByZXN1bHQuc2V0KHNoYTI1Nihtc2cpLCA2NCk7XG4gIHJldHVybiBzaGEyNTYocmVzdWx0KTtcbn1cblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC9idWZmZXJ1dGlscy50c1xudmFyIEJ1ZmZlclV0aWxzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJhc2U2NENoYXJTZXQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgICB0aGlzLmhleENoYXJTZXQgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgfVxuICAvLyBodHRwczovL2dpc3QuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pvbmxlaWdodG9uLzk1ODg0MS9yYXcvZjIwMGUzMGRmZTk1MjEyYzAxNjVjY2YxYWUwMDBjYTUxZTlkZTgwMy9naXN0ZmlsZTEuanNcbiAgdWludDhWaWV3VG9CYXNlNjQoYnl0ZXMpIHtcbiAgICBsZXQgYmFzZTY0ID0gXCJcIjtcbiAgICBjb25zdCBlbmNvZGluZ3MgPSB0aGlzLmJhc2U2NENoYXJTZXQ7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgYnl0ZVJlbWFpbmRlciA9IGJ5dGVMZW5ndGggJSAzO1xuICAgIGNvbnN0IG1haW5MZW5ndGggPSBieXRlTGVuZ3RoIC0gYnl0ZVJlbWFpbmRlcjtcbiAgICBsZXQgYSwgYiwgYywgZDtcbiAgICBsZXQgY2h1bms7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYWluTGVuZ3RoOyBpID0gaSArIDMpIHtcbiAgICAgIGNodW5rID0gYnl0ZXNbaV0gPDwgMTYgfCBieXRlc1tpICsgMV0gPDwgOCB8IGJ5dGVzW2kgKyAyXTtcbiAgICAgIGEgPSAoY2h1bmsgJiAxNjUxNTA3MikgPj4gMTg7XG4gICAgICBiID0gKGNodW5rICYgMjU4MDQ4KSA+PiAxMjtcbiAgICAgIGMgPSAoY2h1bmsgJiA0MDMyKSA+PiA2O1xuICAgICAgZCA9IGNodW5rICYgNjM7XG4gICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgZW5jb2RpbmdzW2RdO1xuICAgIH1cbiAgICBpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XG4gICAgICBjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdO1xuICAgICAgYSA9IChjaHVuayAmIDI1MikgPj4gMjtcbiAgICAgIGIgPSAoY2h1bmsgJiAzKSA8PCA0O1xuICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIFwiPT1cIjtcbiAgICB9IGVsc2UgaWYgKGJ5dGVSZW1haW5kZXIgPT0gMikge1xuICAgICAgY2h1bmsgPSBieXRlc1ttYWluTGVuZ3RoXSA8PCA4IHwgYnl0ZXNbbWFpbkxlbmd0aCArIDFdO1xuICAgICAgYSA9IChjaHVuayAmIDY0NTEyKSA+PiAxMDtcbiAgICAgIGIgPSAoY2h1bmsgJiAxMDA4KSA+PiA0O1xuICAgICAgYyA9IChjaHVuayAmIDE1KSA8PCAyO1xuICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArIFwiPVwiO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9XG4gIGJhc2U2NFRvQXJyYXlCdWZmZXIoYmFzZTY0KSB7XG4gICAgY29uc3QgYmluYXJ5X3N0cmluZyA9IGF0b2IgPT0gbnVsbCA/IHZvaWQgMCA6IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBsZW4gPSBiaW5hcnlfc3RyaW5nLmxlbmd0aDtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYXNjaWkgPSBiaW5hcnlfc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICBieXRlc1tpXSA9IGFzY2lpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b0FycmF5QnVmZmVyKGJ5dGVzKTtcbiAgfVxuICBpc0J1ZmZlcihidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcik7XG4gIH1cbiAgdG9CdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKCFBcnJheUJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29udmVydCB0byBCdWZmZXI6IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbmVjZXNzYXJ5IHR5cGVzXCIpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH1cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLnRvQXJyYXlCdWZmZXIoYnVmZmVyKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlclV0aWxzLnRvQnVmZmVyIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyIG9yIGEgdmlldyBvbnRvIG9uZVwiKTtcbiAgfVxuICB0b0FycmF5QnVmZmVyKGJ1ZmZlcikge1xuICAgIGlmICghQXJyYXlCdWZmZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdG8gQXJyYXlCdWZmZXI6IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbmVjZXNzYXJ5IHR5cGVzXCIpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXJVdGlscy50b0FycmF5QnVmZmVyIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyIG9yIGEgdmlldyBvbnRvIG9uZVwiKTtcbiAgfVxuICBiYXNlNjRFbmNvZGUoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDhWaWV3VG9CYXNlNjQodGhpcy50b0J1ZmZlcihidWZmZXIpKTtcbiAgfVxuICBiYXNlNjREZWNvZGUoc3RyKSB7XG4gICAgaWYgKEFycmF5QnVmZmVyICYmIFBsYXRmb3JtLkNvbmZpZy5hdG9iKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRUb0FycmF5QnVmZmVyKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEFycmF5QnVmZmVyIHRvIGV4aXN0IGFuZCBQbGF0Zm9ybS5Db25maWcuYXRvYiB0byBiZSBjb25maWd1cmVkXCIpO1xuICAgIH1cbiAgfVxuICBoZXhFbmNvZGUoYnVmZmVyKSB7XG4gICAgY29uc3QgdWludDhBcnJheTIgPSB0aGlzLnRvQnVmZmVyKGJ1ZmZlcik7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXkyLnJlZHVjZSgoYWNjdW0sIGJ5dGUpID0+IGFjY3VtICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbiAgfVxuICBoZXhEZWNvZGUoaGV4RW5jb2RlZEJ5dGVzKSB7XG4gICAgaWYgKGhleEVuY29kZWRCeXRlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjcmVhdGUgYSBieXRlIGFycmF5IGZyb20gYSBoZXggc3RyaW5nIG9mIG9kZCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGNvbnN0IHVpbnQ4QXJyYXkyID0gbmV3IFVpbnQ4QXJyYXkoaGV4RW5jb2RlZEJ5dGVzLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhBcnJheTIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVpbnQ4QXJyYXkyW2ldID0gcGFyc2VJbnQoaGV4RW5jb2RlZEJ5dGVzLnNsaWNlKDIgKiBpLCAyICogKGkgKyAxKSksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcih1aW50OEFycmF5Mik7XG4gIH1cbiAgdXRmOEVuY29kZShzdHJpbmcpIHtcbiAgICBpZiAoUGxhdGZvcm0uQ29uZmlnLlRleHRFbmNvZGVyKSB7XG4gICAgICBjb25zdCBlbmNvZGVkQnl0ZUFycmF5ID0gbmV3IFBsYXRmb3JtLkNvbmZpZy5UZXh0RW5jb2RlcigpLmVuY29kZShzdHJpbmcpO1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcihlbmNvZGVkQnl0ZUFycmF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgVGV4dEVuY29kZXIgdG8gYmUgY29uZmlndXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgLyogRm9yIHV0ZjggZGVjb2Rpbmcgd2UgYXBwbHkgc2xpZ2h0bHkgc3RyaWN0ZXIgaW5wdXQgdmFsaWRhdGlvbiB0aGFuIHRvXG4gICAqIGhleEVuY29kZS9iYXNlNjRFbmNvZGUvZXRjOiBpbiB0aG9zZSB3ZSBhY2NlcHQgYW55dGhpbmcgdGhhdCBCdWZmZXIuZnJvbVxuICAgKiBjYW4gdGFrZSAoaW4gcGFydGljdWxhciBhbGxvd2luZyBzdHJpbmdzLCB3aGljaCBhcmUganVzdCBpbnRlcnByZXRlZCBhc1xuICAgKiBiaW5hcnkpOyBoZXJlIHdlIGVuc3VyZSB0aGF0IHRoZSBpbnB1dCBpcyBhY3R1YWxseSBhIGJ1ZmZlciBzaW5jZSB0cnlpbmdcbiAgICogdG8gdXRmOC1kZWNvZGUgYSBzdHJpbmcgdG8gYW5vdGhlciBzdHJpbmcgaXMgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UgKi9cbiAgdXRmOERlY29kZShidWZmZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgb2YgdXRmOGRlY29kZSB0byBiZSBhbiBhcnJheWJ1ZmZlciBvciB0eXBlZCBhcnJheVwiKTtcbiAgICB9XG4gICAgaWYgKFRleHREZWNvZGVyKSB7XG4gICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFRleHREZWNvZGVyIHRvIGJlIGNvbmZpZ3VyZWRcIik7XG4gICAgfVxuICB9XG4gIGFyZUJ1ZmZlcnNFcXVhbChidWZmZXIxLCBidWZmZXIyKSB7XG4gICAgaWYgKCFidWZmZXIxIHx8ICFidWZmZXIyKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFycmF5QnVmZmVyMSA9IHRoaXMudG9BcnJheUJ1ZmZlcihidWZmZXIxKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlcjIgPSB0aGlzLnRvQXJyYXlCdWZmZXIoYnVmZmVyMik7XG4gICAgaWYgKGFycmF5QnVmZmVyMS5ieXRlTGVuZ3RoICE9IGFycmF5QnVmZmVyMi5ieXRlTGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGJ5dGVzMSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyMSk7XG4gICAgY29uc3QgYnl0ZXMyID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJ5dGVzMVtpXSAhPSBieXRlczJbaV0pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYnl0ZUxlbmd0aChidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGFycmF5QnVmZmVyVmlld1RvQnVmZmVyKGFycmF5QnVmZmVyVmlldykge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXJWaWV3KTtcbiAgfVxuICBobWFjU2hhMjU2KG1lc3NhZ2UsIGtleSkge1xuICAgIGNvbnN0IGhhc2ggPSBobWFjMih0aGlzLnRvQnVmZmVyKGtleSksIHRoaXMudG9CdWZmZXIobWVzc2FnZSkpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoaGFzaCk7XG4gIH1cbn07XG52YXIgYnVmZmVydXRpbHNfZGVmYXVsdCA9IG5ldyBCdWZmZXJVdGlscygpO1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi91dGlsL2NyeXB0by50c1xudmFyIGNyZWF0ZUNyeXB0b0NsYXNzID0gZnVuY3Rpb24oY29uZmlnLCBidWZmZXJVdGlscykge1xuICB2YXIgREVGQVVMVF9BTEdPUklUSE0gPSBcImFlc1wiO1xuICB2YXIgREVGQVVMVF9LRVlMRU5HVEggPSAyNTY7XG4gIHZhciBERUZBVUxUX01PREUgPSBcImNiY1wiO1xuICB2YXIgREVGQVVMVF9CTE9DS0xFTkdUSCA9IDE2O1xuICBmdW5jdGlvbiB2YWxpZGF0ZUNpcGhlclBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLmFsZ29yaXRobSA9PT0gXCJhZXNcIiAmJiBwYXJhbXMubW9kZSA9PT0gXCJjYmNcIikge1xuICAgICAgaWYgKHBhcmFtcy5rZXlMZW5ndGggPT09IDEyOCB8fCBwYXJhbXMua2V5TGVuZ3RoID09PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlVuc3VwcG9ydGVkIGtleSBsZW5ndGggXCIgKyBwYXJhbXMua2V5TGVuZ3RoICsgXCIgZm9yIGFlcy1jYmMgZW5jcnlwdGlvbi4gRW5jcnlwdGlvbiBrZXkgbXVzdCBiZSAxMjggb3IgMjU2IGJpdHMgKDE2IG9yIDMyIEFTQ0lJIGNoYXJhY3RlcnMpXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGlzZUJhc2U2NChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoXCJfXCIsIFwiL1wiKS5yZXBsYWNlKFwiLVwiLCBcIitcIik7XG4gIH1cbiAgZnVuY3Rpb24gaXNDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhcmFtcyBpbnN0YW5jZW9mIENpcGhlclBhcmFtcztcbiAgfVxuICBjbGFzcyBDaXBoZXJQYXJhbXMge1xuICAgIGNvbnN0cnVjdG9yKGFsZ29yaXRobSwga2V5TGVuZ3RoLCBtb2RlLCBrZXkpIHtcbiAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgdGhpcy5rZXlMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICB9XG4gIGNsYXNzIENyeXB0bzIge1xuICAgIC8qKlxuICAgICAqIE9idGFpbiBhIGNvbXBsZXRlIENpcGhlclBhcmFtcyBpbnN0YW5jZSBmcm9tIHRoZSBwcm92aWRlZCBwYXJhbXMsIGZpbGxpbmdcbiAgICAgKiBpbiBhbnkgbm90IHByb3ZpZGVkIHdpdGggZGVmYXVsdCB2YWx1ZXMsIGNhbGN1bGF0aW5nIGEga2V5TGVuZ3RoIGZyb21cbiAgICAgKiB0aGUgc3VwcGxpZWQga2V5LCBhbmQgdmFsaWRhdGluZyB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwYXJhbXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXQgYSBtaW5pbXVtIGEgYGtleWAga2V5IHdpdGggdmFsdWUgdGhlXG4gICAgICoga2V5LCBhcyBlaXRoZXIgYSBiaW5hcnkgb3IgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcuXG4gICAgICogTWF5IG9wdGlvbmFsbHkgYWxzbyBjb250YWluOiBhbGdvcml0aG0gKGRlZmF1bHRzIHRvIEFFUyksXG4gICAgICogbW9kZSAoZGVmYXVsdHMgdG8gJ2NiYycpXG4gICAgICovXG4gICAgc3RhdGljIGdldERlZmF1bHRQYXJhbXMocGFyYW1zKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgaWYgKCFwYXJhbXMua2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleSBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLmtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBrZXkgPSBidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKGJ1ZmZlclV0aWxzLmJhc2U2NERlY29kZShub3JtYWxpc2VCYXNlNjQocGFyYW1zLmtleSkpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmtleSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGtleSA9IHBhcmFtcy5rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKHBhcmFtcy5rZXkpO1xuICAgICAgfVxuICAgICAgdmFyIGFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gfHwgREVGQVVMVF9BTEdPUklUSE07XG4gICAgICB2YXIga2V5TGVuZ3RoID0ga2V5LmJ5dGVMZW5ndGggKiA4O1xuICAgICAgdmFyIG1vZGUgPSBwYXJhbXMubW9kZSB8fCBERUZBVUxUX01PREU7XG4gICAgICB2YXIgY2lwaGVyUGFyYW1zID0gbmV3IENpcGhlclBhcmFtcyhhbGdvcml0aG0sIGtleUxlbmd0aCwgbW9kZSwga2V5KTtcbiAgICAgIGlmIChwYXJhbXMua2V5TGVuZ3RoICYmIHBhcmFtcy5rZXlMZW5ndGggIT09IGNpcGhlclBhcmFtcy5rZXlMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5TGVuZ3RoIG9mIFwiICsgcGFyYW1zLmtleUxlbmd0aCArIFwiIHdhcyBzcGVjaWZpZWQsIGJ1dCB0aGUga2V5IGFjdHVhbGx5IGhhcyBsZW5ndGggXCIgKyBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YWxpZGF0ZUNpcGhlclBhcmFtcyhjaXBoZXJQYXJhbXMpO1xuICAgICAgcmV0dXJuIGNpcGhlclBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSByYW5kb20gZW5jcnlwdGlvbiBrZXkgZnJvbSB0aGUgc3VwcGxpZWQga2V5bGVuZ3RoIChvciB0aGVcbiAgICAgKiBkZWZhdWx0IGtleUxlbmd0aCBpZiBub25lIHN1cHBsaWVkKSBhcyBhbiBBcnJheUJ1ZmZlclxuICAgICAqIEBwYXJhbSBrZXlMZW5ndGggKG9wdGlvbmFsKSB0aGUgcmVxdWlyZWQga2V5TGVuZ3RoIGluIGJpdHNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVSYW5kb21LZXkoa2V5TGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmdldFJhbmRvbUFycmF5QnVmZmVyKChrZXlMZW5ndGggfHwgREVGQVVMVF9LRVlMRU5HVEgpIC8gOCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkZhaWxlZCB0byBnZW5lcmF0ZSByYW5kb20ga2V5OiBcIiArIGVyci5tZXNzYWdlLCA0MDAsIDVlNCwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWw7IGdldCBhIENoYW5uZWxDaXBoZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIGNpcGhlclBhcmFtc1xuICAgICAqIEBwYXJhbSBwYXJhbXMgZWl0aGVyIGEgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIG9yIHNvbWUgc3Vic2V0IG9mIGl0c1xuICAgICAqIGZpZWxkcyB0aGF0IGluY2x1ZGVzIGEga2V5XG4gICAgICovXG4gICAgc3RhdGljIGdldENpcGhlcihwYXJhbXMsIGxvZ2dlcikge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHZhciBjaXBoZXJQYXJhbXMgPSBpc0NpcGhlclBhcmFtcyhwYXJhbXMpID8gcGFyYW1zIDogdGhpcy5nZXREZWZhdWx0UGFyYW1zKHBhcmFtcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaXBoZXJQYXJhbXMsXG4gICAgICAgIGNpcGhlcjogbmV3IENCQ0NpcGhlcihjaXBoZXJQYXJhbXMsIChfYTIgPSBwYXJhbXMuaXYpICE9IG51bGwgPyBfYTIgOiBudWxsLCBsb2dnZXIpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBDcnlwdG8yLkNpcGhlclBhcmFtcyA9IENpcGhlclBhcmFtcztcbiAgQ3J5cHRvMjtcbiAgY2xhc3MgQ0JDQ2lwaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMsIGl2LCBsb2dnZXIpIHtcbiAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgaWYgKCFjcnlwdG8uc3VidGxlKSB7XG4gICAgICAgIGlmIChpc1NlY3VyZUNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNyeXB0byBvcGVyYXRpb25zIGFyZSBub3QgcG9zc2libGUgc2luY2UgdGhlIGJyb3dzZXJcXHUyMDE5cyBTdWJ0bGVDcnlwdG8gY2xhc3MgaXMgdW5hdmFpbGFibGUgKHJlYXNvbiB1bmtub3duKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJDcnlwdG8gb3BlcmF0aW9ucyBhcmUgaXMgbm90IHBvc3NpYmxlIHNpbmNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIGEgbm9uLXNlY3VyZSBjb250ZXh0IGFuZCBoZW5jZSB0aGUgYnJvd3NlclxcdTIwMTlzIFN1YnRsZUNyeXB0byBjbGFzcyBpcyBub3QgYXZhaWxhYmxlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtICsgXCItXCIgKyBTdHJpbmcocGFyYW1zLmtleUxlbmd0aCkgKyBcIi1cIiArIHBhcmFtcy5tb2RlO1xuICAgICAgdGhpcy53ZWJDcnlwdG9BbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtICsgXCItXCIgKyBwYXJhbXMubW9kZTtcbiAgICAgIHRoaXMua2V5ID0gYnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihwYXJhbXMua2V5KTtcbiAgICAgIHRoaXMuaXYgPSBpdiA/IGJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIoaXYpIDogbnVsbDtcbiAgICB9XG4gICAgY29uY2F0KGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIxLmJ5dGVMZW5ndGggKyBidWZmZXIyLmJ5dGVMZW5ndGgpO1xuICAgICAgY29uc3Qgb3V0cHV0VmlldyA9IG5ldyBEYXRhVmlldyhvdXRwdXQpO1xuICAgICAgY29uc3QgYnVmZmVyMVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcihidWZmZXIxKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcjFWaWV3LmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRwdXRWaWV3LnNldEludDgoaSwgYnVmZmVyMVZpZXcuZ2V0SW50OChpKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXIyVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKGJ1ZmZlcjIpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyMlZpZXcuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dFZpZXcuc2V0SW50OChidWZmZXIxVmlldy5ieXRlTGVuZ3RoICsgaSwgYnVmZmVyMlZpZXcuZ2V0SW50OChpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ0JDQ2lwaGVyLmVuY3J5cHQoKVwiLCBcIlwiKTtcbiAgICAgIGNvbnN0IGl2ID0gYXdhaXQgdGhpcy5nZXRJdigpO1xuICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgdGhpcy5rZXksIHRoaXMud2ViQ3J5cHRvQWxnb3JpdGhtLCBmYWxzZSwgW1wiZW5jcnlwdFwiXSk7XG4gICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KHsgbmFtZTogdGhpcy53ZWJDcnlwdG9BbGdvcml0aG0sIGl2IH0sIGNyeXB0b0tleSwgcGxhaW50ZXh0KTtcbiAgICAgIHJldHVybiB0aGlzLmNvbmNhdChpdiwgY2lwaGVydGV4dCk7XG4gICAgfVxuICAgIGFzeW5jIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ0JDQ2lwaGVyLmRlY3J5cHQoKVwiLCBcIlwiKTtcbiAgICAgIGNvbnN0IGNpcGhlcnRleHRBcnJheUJ1ZmZlciA9IGJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIoY2lwaGVydGV4dCk7XG4gICAgICBjb25zdCBpdiA9IGNpcGhlcnRleHRBcnJheUJ1ZmZlci5zbGljZSgwLCBERUZBVUxUX0JMT0NLTEVOR1RIKTtcbiAgICAgIGNvbnN0IGNpcGhlcnRleHRCb2R5ID0gY2lwaGVydGV4dEFycmF5QnVmZmVyLnNsaWNlKERFRkFVTFRfQkxPQ0tMRU5HVEgpO1xuICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgdGhpcy5rZXksIHRoaXMud2ViQ3J5cHRvQWxnb3JpdGhtLCBmYWxzZSwgW1wiZGVjcnlwdFwiXSk7XG4gICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogdGhpcy53ZWJDcnlwdG9BbGdvcml0aG0sIGl2IH0sIGNyeXB0b0tleSwgY2lwaGVydGV4dEJvZHkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRJdigpIHtcbiAgICAgIGlmICh0aGlzLml2KSB7XG4gICAgICAgIHZhciBpdiA9IHRoaXMuaXY7XG4gICAgICAgIHRoaXMuaXYgPSBudWxsO1xuICAgICAgICByZXR1cm4gaXY7XG4gICAgICB9XG4gICAgICBjb25zdCByYW5kb21CbG9jayA9IGF3YWl0IGNvbmZpZy5nZXRSYW5kb21BcnJheUJ1ZmZlcihERUZBVUxUX0JMT0NLTEVOR1RIKTtcbiAgICAgIHJldHVybiBidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKHJhbmRvbUJsb2NrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIENyeXB0bzI7XG59O1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9YSFJTdGF0ZXMudHNcbnZhciBYSFJTdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gKChYSFJTdGF0ZXMyKSA9PiB7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9TRU5EXCJdID0gMF0gPSBcIlJFUV9TRU5EXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWXCJdID0gMV0gPSBcIlJFUV9SRUNWXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWX1BPTExcIl0gPSAyXSA9IFwiUkVRX1JFQ1ZfUE9MTFwiO1xuICBYSFJTdGF0ZXMyW1hIUlN0YXRlczJbXCJSRVFfUkVDVl9TVFJFQU1cIl0gPSAzXSA9IFwiUkVRX1JFQ1ZfU1RSRUFNXCI7XG4gIHJldHVybiBYSFJTdGF0ZXMyO1xufSkoWEhSU3RhdGVzIHx8IHt9KTtcbnZhciBYSFJTdGF0ZXNfZGVmYXVsdCA9IFhIUlN0YXRlcztcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvaHR0cC9odHRwLnRzXG5mdW5jdGlvbiBjcmVhdGVNaXNzaW5nSW1wbGVtZW50YXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvckluZm8oXG4gICAgXCJObyBIVFRQIHJlcXVlc3QgcGx1Z2luIHByb3ZpZGVkLiBQcm92aWRlIGF0IGxlYXN0IG9uZSBvZiB0aGUgRmV0Y2hSZXF1ZXN0IG9yIFhIUlJlcXVlc3QgcGx1Z2lucy5cIixcbiAgICA0MDAsXG4gICAgNGU0XG4gICk7XG59XG52YXIgX2E7XG52YXIgSHR0cDIgPSAoX2EgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2hlY2tzSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzTGlua0hlYWRlcnMgPSBmYWxzZTtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50ICE9IG51bGwgPyBjbGllbnQgOiBudWxsO1xuICAgIGNvbnN0IGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gKGNsaWVudCA9PSBudWxsID8gdm9pZCAwIDogY2xpZW50Lm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpIHx8IGRlZmF1bHRzX2RlZmF1bHQuY29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gICAgY29uc3QgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSAoX2EyID0gY2xpZW50ID09IG51bGwgPyB2b2lkIDAgOiBjbGllbnQub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1BhcmFtcykgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgY29uc3QgY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0ID0gIShjbGllbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNsaWVudC5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsKTtcbiAgICBjb25zdCByZXF1ZXN0SW1wbGVtZW50YXRpb25zID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIEh0dHAyLmJ1bmRsZWRSZXF1ZXN0SW1wbGVtZW50YXRpb25zKSwgY2xpZW50ID09IG51bGwgPyB2b2lkIDAgOiBjbGllbnQuX2FkZGl0aW9uYWxIVFRQUmVxdWVzdEltcGxlbWVudGF0aW9ucyk7XG4gICAgY29uc3QgeGhyUmVxdWVzdEltcGxlbWVudGF0aW9uID0gcmVxdWVzdEltcGxlbWVudGF0aW9ucy5YSFJSZXF1ZXN0O1xuICAgIGNvbnN0IGZldGNoUmVxdWVzdEltcGxlbWVudGF0aW9uID0gcmVxdWVzdEltcGxlbWVudGF0aW9ucy5GZXRjaFJlcXVlc3Q7XG4gICAgY29uc3QgaGFzSW1wbGVtZW50YXRpb24gPSAhISh4aHJSZXF1ZXN0SW1wbGVtZW50YXRpb24gfHwgZmV0Y2hSZXF1ZXN0SW1wbGVtZW50YXRpb24pO1xuICAgIGlmICghaGFzSW1wbGVtZW50YXRpb24pIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdJbXBsZW1lbnRhdGlvbkVycm9yKCk7XG4gICAgfVxuICAgIGlmIChQbGF0Zm9ybS5Db25maWcueGhyU3VwcG9ydGVkICYmIHhoclJlcXVlc3RJbXBsZW1lbnRhdGlvbikge1xuICAgICAgdGhpcy5zdXBwb3J0c0F1dGhIZWFkZXJzID0gdHJ1ZTtcbiAgICAgIHRoaXMuUmVxdWVzdCA9IGFzeW5jIGZ1bmN0aW9uKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICBjb25zdCByZXEgPSB4aHJSZXF1ZXN0SW1wbGVtZW50YXRpb24uY3JlYXRlUmVxdWVzdChcbiAgICAgICAgICAgIHVyaSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1NFTkQsXG4gICAgICAgICAgICAoX2EzID0gY2xpZW50ICYmIGNsaWVudC5vcHRpb25zLnRpbWVvdXRzKSAhPSBudWxsID8gX2EzIDogbnVsbCxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbWV0aG9kXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXEub25jZShcbiAgICAgICAgICAgIFwiY29tcGxldGVcIixcbiAgICAgICAgICAgIChlcnJvciwgYm9keTIsIGhlYWRlcnMyLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkgPT4gcmVzb2x2ZSh7IGVycm9yLCBib2R5OiBib2R5MiwgaGVhZGVyczogaGVhZGVyczIsIHVucGFja2VkLCBzdGF0dXNDb2RlIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXEuZXhlYygpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBpZiAoY2xpZW50ID09IG51bGwgPyB2b2lkIDAgOiBjbGllbnQub3B0aW9ucy5kaXNhYmxlQ29ubmVjdGl2aXR5Q2hlY2spIHtcbiAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgICBcIihYSFJSZXF1ZXN0KUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKVwiLFxuICAgICAgICAgICAgXCJTZW5kaW5nOyBcIiArIGNvbm5lY3Rpdml0eUNoZWNrVXJsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0UmVzdWx0ID0gYXdhaXQgdGhpcy5kb1VyaShcbiAgICAgICAgICAgIEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LFxuICAgICAgICAgICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFjb25uZWN0aXZpdHlVcmxJc0RlZmF1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICFyZXF1ZXN0UmVzdWx0LmVycm9yICYmIGlzU3VjY2Vzc0NvZGUocmVxdWVzdFJlc3VsdC5zdGF0dXNDb2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gIXJlcXVlc3RSZXN1bHQuZXJyb3IgJiYgKChfYTMgPSByZXF1ZXN0UmVzdWx0LmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYTMucmVwbGFjZSgvXFxuLywgXCJcIikpID09IFwieWVzXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIihYSFJSZXF1ZXN0KUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKVwiLCBcIlJlc3VsdDogXCIgKyByZXN1bHQpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQbGF0Zm9ybS5Db25maWcuZmV0Y2hTdXBwb3J0ZWQgJiYgZmV0Y2hSZXF1ZXN0SW1wbGVtZW50YXRpb24pIHtcbiAgICAgIHRoaXMuc3VwcG9ydHNBdXRoSGVhZGVycyA9IHRydWU7XG4gICAgICB0aGlzLlJlcXVlc3QgPSBhc3luYyAobWV0aG9kLCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSkgPT4ge1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXF1ZXN0SW1wbGVtZW50YXRpb24obWV0aG9kLCBjbGllbnQgIT0gbnVsbCA/IGNsaWVudCA6IG51bGwsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCIoRmV0Y2gpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpXCIsXG4gICAgICAgICAgXCJTZW5kaW5nOyBcIiArIGNvbm5lY3Rpdml0eUNoZWNrVXJsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RSZXN1bHQgPSBhd2FpdCB0aGlzLmRvVXJpKEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBjb25uZWN0aXZpdHlDaGVja1VybCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICFyZXF1ZXN0UmVzdWx0LmVycm9yICYmICgoX2EzID0gcmVxdWVzdFJlc3VsdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnJlcGxhY2UoL1xcbi8sIFwiXCIpKSA9PSBcInllc1wiO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCIoRmV0Y2gpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpXCIsIFwiUmVzdWx0OiBcIiArIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLlJlcXVlc3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gaGFzSW1wbGVtZW50YXRpb24gPyBuZXcgUGFydGlhbEVycm9ySW5mbyhcIm5vIHN1cHBvcnRlZCBIVFRQIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCIsIG51bGwsIDQwMCkgOiBjcmVhdGVNaXNzaW5nSW1wbGVtZW50YXRpb25FcnJvcigpO1xuICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hMiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZ2dlcikgIT0gbnVsbCA/IF9iIDogbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcjtcbiAgfVxuICBhc3luYyBkb1VyaShtZXRob2QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLlJlcXVlc3QpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlJlcXVlc3QgaW52b2tlZCBiZWZvcmUgYXNzaWduZWQgdG9cIiwgbnVsbCwgNTAwKSB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5SZXF1ZXN0KG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHkpO1xuICB9XG4gIHNob3VsZEZhbGxiYWNrKGVycm9ySW5mbykge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBlcnJvckluZm8uc3RhdHVzQ29kZTtcbiAgICByZXR1cm4gc3RhdHVzQ29kZSA9PT0gNDA4ICYmICFlcnJvckluZm8uY29kZSB8fCBzdGF0dXNDb2RlID09PSA0MDAgJiYgIWVycm9ySW5mby5jb2RlIHx8IHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0O1xuICB9XG59LCBfYS5tZXRob2RzID0gW0h0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBIdHRwTWV0aG9kc19kZWZhdWx0LkRlbGV0ZSwgSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlB1dCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5QYXRjaF0sIF9hLm1ldGhvZHNXaXRob3V0Qm9keSA9IFtIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5EZWxldGVdLCBfYS5tZXRob2RzV2l0aEJvZHkgPSBbSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlB1dCwgSHR0cE1ldGhvZHNfZGVmYXVsdC5QYXRjaF0sIF9hKTtcbnZhciBodHRwX2RlZmF1bHQgPSBIdHRwMjtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC93ZWJzdG9yYWdlLnRzXG52YXIgdGVzdCA9IFwiYWJseWpzLXN0b3JhZ2UtdGVzdFwiO1xudmFyIGdsb2JhbE9iamVjdDMgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG52YXIgV2Vic3RvcmFnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbE9iamVjdDMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcbiAgICAgIGdsb2JhbE9iamVjdDMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcbiAgICAgIHRoaXMuc2Vzc2lvblN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5zZXNzaW9uU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmplY3QzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuICAgICAgZ2xvYmFsT2JqZWN0My5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcbiAgICAgIHRoaXMubG9jYWxTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9jYWxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIGZhbHNlKTtcbiAgfVxuICBnZXRTZXNzaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIHRydWUpO1xuICB9XG4gIHJlbW92ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW92ZShuYW1lLCBmYWxzZSk7XG4gIH1cbiAgcmVtb3ZlU2Vzc2lvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW92ZShuYW1lLCB0cnVlKTtcbiAgfVxuICBzZXQobmFtZSwgdmFsdWUsIHR0bCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQobmFtZSwgdmFsdWUsIHR0bCwgZmFsc2UpO1xuICB9XG4gIHNldFNlc3Npb24obmFtZSwgdmFsdWUsIHR0bCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQobmFtZSwgdmFsdWUsIHR0bCwgdHJ1ZSk7XG4gIH1cbiAgX3NldChuYW1lLCB2YWx1ZSwgdHRsLCBzZXNzaW9uKSB7XG4gICAgY29uc3Qgd3JhcHBlZFZhbHVlID0geyB2YWx1ZSB9O1xuICAgIGlmICh0dGwpIHtcbiAgICAgIHdyYXBwZWRWYWx1ZS5leHBpcmVzID0gRGF0ZS5ub3coKSArIHR0bDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5zZXRJdGVtKG5hbWUsIEpTT04uc3RyaW5naWZ5KHdyYXBwZWRWYWx1ZSkpO1xuICB9XG4gIF9nZXQobmFtZSwgc2Vzc2lvbikge1xuICAgIGlmIChzZXNzaW9uICYmICF0aGlzLnNlc3Npb25TdXBwb3J0ZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIFN0b3JhZ2Ugbm90IHN1cHBvcnRlZFwiKTtcbiAgICBpZiAoIXNlc3Npb24gJiYgIXRoaXMubG9jYWxTdXBwb3J0ZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2NhbCBTdG9yYWdlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgY29uc3QgcmF3SXRlbSA9IHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5nZXRJdGVtKG5hbWUpO1xuICAgIGlmICghcmF3SXRlbSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IEpTT04ucGFyc2UocmF3SXRlbSk7XG4gICAgaWYgKHdyYXBwZWRWYWx1ZS5leHBpcmVzICYmIHdyYXBwZWRWYWx1ZS5leHBpcmVzIDwgRGF0ZS5ub3coKSkge1xuICAgICAgdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWRWYWx1ZS52YWx1ZTtcbiAgfVxuICBfcmVtb3ZlKG5hbWUsIHNlc3Npb24pIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG4gIH1cbiAgc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKSB7XG4gICAgcmV0dXJuIHNlc3Npb24gPyBnbG9iYWxPYmplY3QzLnNlc3Npb25TdG9yYWdlIDogZ2xvYmFsT2JqZWN0My5sb2NhbFN0b3JhZ2U7XG4gIH1cbn07XG52YXIgd2Vic3RvcmFnZV9kZWZhdWx0ID0gbmV3IFdlYnN0b3JhZ2UoKTtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9jb25maWcudHNcbnZhciBnbG9iYWxPYmplY3Q0ID0gZ2V0R2xvYmFsT2JqZWN0KCk7XG52YXIgaXNWZXJjZWxFZGdlUnVudGltZSA9IHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIjtcbmlmICh0eXBlb2YgV2luZG93ID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNWZXJjZWxFZGdlUnVudGltZSkge1xuICBjb25zb2xlLmxvZyhcbiAgICBcIldhcm5pbmc6IHRoaXMgZGlzdHJpYnV0aW9uIG9mIEFibHkgaXMgaW50ZW5kZWQgZm9yIGJyb3dzZXJzLiBPbiBub2RlanMsIHBsZWFzZSB1c2UgdGhlICdhYmx5JyBwYWNrYWdlIG9uIG5wbVwiXG4gICk7XG59XG5mdW5jdGlvbiBhbGxvd0NvbWV0KCkge1xuICBjb25zdCBsb2MgPSBnbG9iYWxPYmplY3Q0LmxvY2F0aW9uO1xuICByZXR1cm4gIWdsb2JhbE9iamVjdDQuV2ViU29ja2V0IHx8ICFsb2MgfHwgIWxvYy5vcmlnaW4gfHwgbG9jLm9yaWdpbi5pbmRleE9mKFwiaHR0cFwiKSA+IC0xO1xufVxuZnVuY3Rpb24gaXNXZWJXb3JrZXJDb250ZXh0KCkge1xuICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxudmFyIHVzZXJBZ2VudCA9IGdsb2JhbE9iamVjdDQubmF2aWdhdG9yICYmIGdsb2JhbE9iamVjdDQubmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpO1xudmFyIGN1cnJlbnRVcmwgPSBnbG9iYWxPYmplY3Q0LmxvY2F0aW9uICYmIGdsb2JhbE9iamVjdDQubG9jYXRpb24uaHJlZjtcbnZhciBDb25maWcgPSB7XG4gIGFnZW50OiBcImJyb3dzZXJcIixcbiAgbG9nVGltZXN0YW1wczogdHJ1ZSxcbiAgdXNlckFnZW50LFxuICBjdXJyZW50VXJsLFxuICBiaW5hcnlUeXBlOiBcImFycmF5YnVmZmVyXCIsXG4gIFdlYlNvY2tldDogZ2xvYmFsT2JqZWN0NC5XZWJTb2NrZXQsXG4gIGZldGNoU3VwcG9ydGVkOiAhIWdsb2JhbE9iamVjdDQuZmV0Y2gsXG4gIHhoclN1cHBvcnRlZDogZ2xvYmFsT2JqZWN0NC5YTUxIdHRwUmVxdWVzdCAmJiBcIndpdGhDcmVkZW50aWFsc1wiIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICBhbGxvd0NvbWV0OiBhbGxvd0NvbWV0KCksXG4gIHVzZVByb3RvY29sSGVhcnRiZWF0czogdHJ1ZSxcbiAgc3VwcG9ydHNCaW5hcnk6ICEhZ2xvYmFsT2JqZWN0NC5UZXh0RGVjb2RlcixcbiAgLyogUGVyIFBhZGR5IChodHRwczovL2FibHktcmVhbC10aW1lLnNsYWNrLmNvbS9hcmNoaXZlcy9DVVJMNFUyRlAvcDE3MDU2NzQ1Mzc3NjM0NzkpIHdlYiBpbnRlbnRpb25hbGx5IHByZWZlcnMgSlNPTiB0byBNZXNzYWdlUGFjazpcbiAgICpcbiAgICogPiBicm93c2Vycycgc3VwcG9ydCBmb3IgYmluYXJ5IHR5cGVzIGluIGdlbmVyYWwgd2FzIGhpc3RvcmljYWxseSBwb29yLCBhbmQgSlNPTiB0cmFuc3BvcnQgcGVyZm9ybWFuY2UgaXMgc2lnbmlmaWNhbnRseSBiZXR0ZXIgaW4gYSBicm93c2VyIHRoYW4gbXNncGFjay4gSW4gbW9kZXJuIGJyb3dzZXJzIHRoZW4gYmluYXJ5IGlzIHN1cHBvcnRlZCBjb25zaXN0ZW50bHksIGJ1dCBJJ2Qgc3RpbGwgZXhwZWN0IHRoYXQgSlNPTiBlbmNvZGUvZGVjb2RlIHBlcmZvcm1hbmNlIGlzIGRyYW1hdGljYWxseSBiZXR0ZXIgdGhhbiBtc2dwYWNrIGluIGEgYnJvd3Nlci5cbiAgICovXG4gIHByZWZlckJpbmFyeTogZmFsc2UsXG4gIEFycmF5QnVmZmVyOiBnbG9iYWxPYmplY3Q0LkFycmF5QnVmZmVyLFxuICBhdG9iOiBnbG9iYWxPYmplY3Q0LmF0b2IsXG4gIG5leHRUaWNrOiB0eXBlb2YgZ2xvYmFsT2JqZWN0NC5zZXRJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxPYmplY3Q0LnNldEltbWVkaWF0ZS5iaW5kKGdsb2JhbE9iamVjdDQpIDogZnVuY3Rpb24oZikge1xuICAgIHNldFRpbWVvdXQoZiwgMCk7XG4gIH0sXG4gIGFkZEV2ZW50TGlzdGVuZXI6IGdsb2JhbE9iamVjdDQuYWRkRXZlbnRMaXN0ZW5lcixcbiAgaW5zcGVjdDogSlNPTi5zdHJpbmdpZnksXG4gIHN0cmluZ0J5dGVTaXplOiBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gZ2xvYmFsT2JqZWN0NC5UZXh0RGVjb2RlciAmJiBuZXcgZ2xvYmFsT2JqZWN0NC5UZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLmxlbmd0aCB8fCBzdHIubGVuZ3RoO1xuICB9LFxuICBUZXh0RW5jb2RlcjogZ2xvYmFsT2JqZWN0NC5UZXh0RW5jb2RlcixcbiAgVGV4dERlY29kZXI6IGdsb2JhbE9iamVjdDQuVGV4dERlY29kZXIsXG4gIGdldFJhbmRvbUFycmF5QnVmZmVyOiBhc3luYyBmdW5jdGlvbihieXRlTGVuZ3RoKSB7XG4gICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZ2xvYmFsT2JqZWN0NC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVBcnJheSk7XG4gICAgcmV0dXJuIGJ5dGVBcnJheS5idWZmZXI7XG4gIH0sXG4gIGlzV2Vid29ya2VyOiBpc1dlYldvcmtlckNvbnRleHQoKSxcbiAgcHVzaDoge1xuICAgIHBsYXRmb3JtOiBcImJyb3dzZXJcIiAvKiBCcm93c2VyICovLFxuICAgIGZvcm1GYWN0b3I6IFwiZGVza3RvcFwiIC8qIERlc2t0b3AgKi8sXG4gICAgc3RvcmFnZTogd2Vic3RvcmFnZV9kZWZhdWx0XG4gIH1cbn07XG52YXIgY29uZmlnX2RlZmF1bHQgPSBDb25maWc7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb21ldHRyYW5zcG9ydC50c1xuZnVuY3Rpb24gc2hvdWxkQmVFcnJvckFjdGlvbihlcnIpIHtcbiAgY29uc3QgVU5SRVNPTFZBQkxFX0VSUk9SX0NPREVTID0gWzgwMDE1LCA4MDAxNywgODAwMzBdO1xuICBpZiAoZXJyLmNvZGUpIHtcbiAgICBpZiAoYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoZXJyKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoVU5SRVNPTFZBQkxFX0VSUk9SX0NPREVTLmluY2x1ZGVzKGVyci5jb2RlKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBlcnIuY29kZSA+PSA0ZTQgJiYgZXJyLmNvZGUgPCA1ZTQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSB7XG4gIGlmIChzaG91bGRCZUVycm9yQWN0aW9uKGVycikpIHtcbiAgICByZXR1cm4gW2Zyb21WYWx1ZXMzKHsgYWN0aW9uOiBhY3Rpb25zMi5FUlJPUiwgZXJyb3I6IGVyciB9KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtmcm9tVmFsdWVzMyh7IGFjdGlvbjogYWN0aW9uczIuRElTQ09OTkVDVEVELCBlcnJvcjogZXJyIH0pXTtcbiAgfVxufVxudmFyIENvbWV0VHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyB0cmFuc3BvcnRfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBzdXBlcihcbiAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLFxuICAgICAgYXV0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIC8qIGJpbmFyeSBub3Qgc3VwcG9ydGVkIGZvciBjb21ldCBzbyBmb3JjZSBKU09OIHByb3RvY29sICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICAvKiBIaXN0b3JpY2FsIGNvbW1lbnQsIGJhY2sgZnJvbSB3aGVuIHdlIHN1cHBvcnRlZCBKU09OUDpcbiAgICAgKlxuICAgICAqID4gRm9yIGNvbWV0LCB3ZSBjb3VsZCBkbyB0aGUgYXV0aCB1cGRhdGUgYnkgYWJvcnRpbmcgdGhlIGN1cnJlbnQgcmVjdiBhbmRcbiAgICAgKiA+IHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cbiAgICAgKiA+IFByb2JsZW0gaXMgSlNPTlAgLSB5b3UgY2FuJ3QgY2FuY2VsIHRydWx5IGFib3J0IGEgcmVjdiBvbmNlIHN0YXJ0ZWQuIFNvXG4gICAgICogPiB3ZSBuZWVkIHRvIHNlbmQgYW4gQVVUSCBmb3IganNvbnAuIEluIHdoaWNoIGNhc2UgaXQncyBzaW1wbGVyIHRvIGtlZXAgYWxsXG4gICAgICogPiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcbiAgICAgKiA+IGluc3RlYWQsIGFuZCBkb24ndCBuZWVkIHRvIGFib3J0IHRoZSByZWN2XG4gICAgICpcbiAgICAgKiBOb3cgdGhhdCB3ZeKAmXZlIGRyb3BwZWQgSlNPTlAgc3VwcG9ydCwgd2UgbWF5IGJlIGFibGUgdG8gcmV2aXNpdCB0aGUgYWJvdmU7XG4gICAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzEyMTQuXG4gICAgICovXG4gICAgdGhpcy5vbkF1dGhVcGRhdGVkID0gKHRva2VuRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hdXRoUGFyYW1zID0geyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9O1xuICAgIH07XG4gICAgdGhpcy5zdHJlYW0gPSBcInN0cmVhbVwiIGluIHBhcmFtcyA/IHBhcmFtcy5zdHJlYW0gOiB0cnVlO1xuICAgIHRoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJzdGFydGluZ1wiKTtcbiAgICB0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICBjb25zdCBob3N0ID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0KG9wdGlvbnMsIHBhcmFtcy5ob3N0KTtcbiAgICBjb25zdCBwb3J0ID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRQb3J0KG9wdGlvbnMpO1xuICAgIGNvbnN0IGNvbWV0U2NoZW1lID0gb3B0aW9ucy50bHMgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIjtcbiAgICB0aGlzLmJhc2VVcmkgPSBjb21ldFNjaGVtZSArIGhvc3QgKyBcIjpcIiArIHBvcnQgKyBcIi9jb21ldC9cIjtcbiAgICBjb25zdCBjb25uZWN0VXJpID0gdGhpcy5iYXNlVXJpICsgXCJjb25uZWN0XCI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwidXJpOiBcIiArIGNvbm5lY3RVcmkpO1xuICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcygpLCAoZXJyLCBhdXRoUGFyYW1zKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXV0aFBhcmFtcyA9IGF1dGhQYXJhbXM7XG4gICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gdGhpcy5wYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgIGlmIChcInN0cmVhbVwiIGluIGNvbm5lY3RQYXJhbXMpXG4gICAgICAgIHRoaXMuc3RyZWFtID0gY29ubmVjdFBhcmFtcy5zdHJlYW07XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgIFwiY29ubmVjdFBhcmFtczpcIiArIHRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcylcbiAgICAgICk7XG4gICAgICBsZXQgcHJlY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBjb25uZWN0UmVxdWVzdCA9IHRoaXMucmVjdlJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoXG4gICAgICAgIGNvbm5lY3RVcmksXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNvbm5lY3RQYXJhbXMsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMuc3RyZWFtID8gWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNIDogWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZcbiAgICAgICk7XG4gICAgICBjb25uZWN0UmVxdWVzdC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJlY29ubmVjdGVkKSB7XG4gICAgICAgICAgcHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJwcmVjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBjb25uZWN0UmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIChlcnIyKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5yZWN2UmVxdWVzdCkge1xuICAgICAgICAgIGVycjIgPSBlcnIyIHx8IG5ldyBFcnJvckluZm8oXCJSZXF1ZXN0IGNhbmNlbGxlZFwiLCA4MDAwMywgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQgJiYgIWVycjIpIHtcbiAgICAgICAgICBwcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZW1pdChcInByZWNvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgaWYgKGVycjIuY29kZSkge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycjIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlY3YoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0LmV4ZWMoKTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0Q2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdENsb3NlKClcIik7XG4gICAgdGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KHRydWUpO1xuICB9XG4gIHJlcXVlc3REaXNjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LnJlcXVlc3REaXNjb25uZWN0KClcIik7XG4gICAgdGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KGZhbHNlKTtcbiAgfVxuICBfcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KGNsb3NpbmcpIHtcbiAgICBjb25zdCBjbG9zZU9yRGlzY29ubmVjdFVyaSA9IGNsb3NpbmcgPyB0aGlzLmNsb3NlVXJpIDogdGhpcy5kaXNjb25uZWN0VXJpO1xuICAgIGlmIChjbG9zZU9yRGlzY29ubmVjdFVyaSkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChjbG9zZU9yRGlzY29ubmVjdFVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCBudWxsLCBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfU0VORCk7XG4gICAgICByZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIkNvbWV0VHJhbnNwb3J0LnJlcXVlc3RcIiArIChjbG9zaW5nID8gXCJDbG9zZSgpXCIgOiBcIkRpc2Nvbm5lY3QoKVwiKSxcbiAgICAgICAgICAgIFwicmVxdWVzdCByZXR1cm5lZCBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlcXVlc3QuZXhlYygpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcIlwiKTtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcImFib3J0aW5nIHJlY3YgcmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5yZWN2UmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5kaXNjb25uZWN0ZWQoKSk7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJkaXNwb3NlZFwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkNvbm5lY3QobWVzc2FnZSkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uU3RyID0gKF9hMiA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY29ubmVjdGlvbktleTtcbiAgICB0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUub25Db25uZWN0LmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgY29uc3QgYmFzZUNvbm5lY3Rpb25VcmkgPSB0aGlzLmJhc2VVcmkgKyBjb25uZWN0aW9uU3RyO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbWV0VHJhbnNwb3J0Lm9uQ29ubmVjdCgpXCIsIFwiYmFzZVVyaSA9IFwiICsgYmFzZUNvbm5lY3Rpb25VcmkpO1xuICAgIHRoaXMuc2VuZFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvc2VuZFwiO1xuICAgIHRoaXMucmVjdlVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvcmVjdlwiO1xuICAgIHRoaXMuY2xvc2VVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArIFwiL2Nsb3NlXCI7XG4gICAgdGhpcy5kaXNjb25uZWN0VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9kaXNjb25uZWN0XCI7XG4gIH1cbiAgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2VuZFJlcXVlc3QpIHtcbiAgICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXMgfHwgW107XG4gICAgICB0aGlzLnBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICBwZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcbiAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcbiAgfVxuICBzZW5kQW55UGVuZGluZygpIHtcbiAgICBjb25zdCBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcztcbiAgICBpZiAoIXBlbmRpbmdJdGVtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcbiAgfVxuICBzZW5kSXRlbXMoaXRlbXMpIHtcbiAgICBjb25zdCBzZW5kUmVxdWVzdCA9IHRoaXMuc2VuZFJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoXG4gICAgICB0aGlzLnNlbmRVcmksXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5hdXRoUGFyYW1zLFxuICAgICAgdGhpcy5lbmNvZGVSZXF1ZXN0KGl0ZW1zKSxcbiAgICAgIFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EXG4gICAgKTtcbiAgICBzZW5kUmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb21ldFRyYW5zcG9ydC5zZW5kSXRlbXMoKVwiLFxuICAgICAgICAgIFwib24gY29tcGxldGU6IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgKTtcbiAgICAgIHRoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wZW5kaW5nSXRlbXMpIHtcbiAgICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2VuZFJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEFueVBlbmRpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbmRSZXF1ZXN0LmV4ZWMoKTtcbiAgfVxuICByZWN2KCkge1xuICAgIGlmICh0aGlzLnJlY3ZSZXF1ZXN0KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZWN2UmVxdWVzdCA9IHRoaXMucmVjdlJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoXG4gICAgICB0aGlzLnJlY3ZVcmksXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5hdXRoUGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuc3RyZWFtID8gWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNIDogWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1JFQ1ZfUE9MTFxuICAgICk7XG4gICAgcmVjdlJlcXVlc3Qub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICB9KTtcbiAgICByZWN2UmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIChlcnIpID0+IHtcbiAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgIHRoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJlY3YoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJlY3ZSZXF1ZXN0LmV4ZWMoKTtcbiAgfVxuICBvbkRhdGEocmVzcG9uc2VEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5kZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpO1xuICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKFxuICAgICAgICAgICAgZnJvbURlc2VyaWFsaXplZChpdGVtc1tpXSwgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSlcbiAgICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJDb21ldFRyYW5zcG9ydC5vbkRhdGEoKVwiLFxuICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBldmVudDogXCIgKyBlLnN0YWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBlbmNvZGVSZXF1ZXN0KHJlcXVlc3RJdGVtcykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0SXRlbXMpO1xuICB9XG4gIGRlY29kZVJlc3BvbnNlKHJlc3BvbnNlRGF0YSkge1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VEYXRhID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZURhdGEpO1xuICAgIHJldHVybiByZXNwb25zZURhdGE7XG4gIH1cbn07XG52YXIgY29tZXR0cmFuc3BvcnRfZGVmYXVsdCA9IENvbWV0VHJhbnNwb3J0O1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi9odHRwL3JlcXVlc3QveGhycmVxdWVzdC50c1xuZnVuY3Rpb24gaXNBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gIHJldHVybiBhbGxUb0xvd2VyQ2FzZShrZXlzQXJyYXkoaGVhZGVycykpLmluY2x1ZGVzKFwieC1hYmx5LWVycm9yY29kZVwiKTtcbn1cbmZ1bmN0aW9uIGdldEFibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpIHtcbiAgaWYgKGlzQWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5LmVycm9yICYmIEVycm9ySW5mby5mcm9tVmFsdWVzKHJlc3BvbnNlQm9keS5lcnJvcik7XG4gIH1cbn1cbnZhciBub29wMyA9IGZ1bmN0aW9uKCkge1xufTtcbnZhciBpZENvdW50ZXIgPSAwO1xudmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHt9O1xuZnVuY3Rpb24gZ2V0SGVhZGVyKHhociwgaGVhZGVyKSB7XG4gIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgeGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG59XG5mdW5jdGlvbiBpc0VuY29kaW5nQ2h1bmtlZCh4aHIpIHtcbiAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlciAmJiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwidHJhbnNmZXItZW5jb2RpbmdcIikgfHwgIXhoci5nZXRSZXNwb25zZUhlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIpKTtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlcnNBc09iamVjdCh4aHIpIHtcbiAgY29uc3QgaGVhZGVyUGFpcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkudHJpbSgpLnNwbGl0KFwiXFxyXFxuXCIpO1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVyUGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXJ0cyA9IGhlYWRlclBhaXJzW2ldLnNwbGl0KFwiOlwiKS5tYXAoKHgpID0+IHgudHJpbSgpKTtcbiAgICBoZWFkZXJzW3BhcnRzWzBdLnRvTG93ZXJDYXNlKCldID0gcGFydHNbMV07XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG52YXIgWEhSUmVxdWVzdCA9IGNsYXNzIF9YSFJSZXF1ZXN0IGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBsb2dnZXIsIG1ldGhvZCkge1xuICAgIHN1cGVyKGxvZ2dlcik7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIHBhcmFtcy5ybmQgPSBjaGVhcFJhbmRTdHIoKTtcbiAgICB0aGlzLnVyaSA9IHVyaSArIHRvUXVlcnlTdHJpbmcocGFyYW1zKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2QgPyBtZXRob2QudG9VcHBlckNhc2UoKSA6IGlzTmlsKGJvZHkpID8gXCJHRVRcIiA6IFwiUE9TVFwiO1xuICAgIHRoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcbiAgICB0aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG4gICAgdGhpcy50aW1lZE91dCA9IGZhbHNlO1xuICAgIHRoaXMucmVxdWVzdENvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5pZCA9IFN0cmluZygrK2lkQ291bnRlcik7XG4gICAgcGVuZGluZ1JlcXVlc3RzW3RoaXMuaWRdID0gdGhpcztcbiAgfVxuICBzdGF0aWMgY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBsb2dnZXIsIG1ldGhvZCkge1xuICAgIGNvbnN0IF90aW1lb3V0cyA9IHRpbWVvdXRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuVElNRU9VVFM7XG4gICAgcmV0dXJuIG5ldyBfWEhSUmVxdWVzdChcbiAgICAgIHVyaSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBjb3B5KHBhcmFtcyksXG4gICAgICBib2R5LFxuICAgICAgcmVxdWVzdE1vZGUsXG4gICAgICBfdGltZW91dHMsXG4gICAgICBsb2dnZXIsXG4gICAgICBtZXRob2RcbiAgICApO1xuICB9XG4gIGNvbXBsZXRlKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICBpZiAoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG4gICAgICBpZiAoIWVyciAmJiBib2R5KSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgYm9keSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCBlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuICBhYm9ydCgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuICBleGVjKCkge1xuICAgIGxldCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0LCB0aW1lciA9IHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudGltZWRPdXQgPSB0cnVlO1xuICAgICAgeGhyLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCksIG1ldGhvZCA9IHRoaXMubWV0aG9kLCB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCBhY2NlcHQgPSBoZWFkZXJzW1wiYWNjZXB0XCJdO1xuICAgIGxldCBib2R5ID0gdGhpcy5ib2R5O1xuICAgIGxldCByZXNwb25zZVR5cGUgPSBcInRleHRcIjtcbiAgICBpZiAoIWFjY2VwdCkge1xuICAgICAgaGVhZGVyc1tcImFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgIH0gZWxzZSBpZiAoYWNjZXB0LmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LW1zZ3BhY2tcIikgPT09IDApIHtcbiAgICAgIHJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICB9XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCAoaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgIGlmIChjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSA+IC0xICYmIHR5cGVvZiBib2R5ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICB9XG4gICAgeGhyLm9wZW4obWV0aG9kLCB0aGlzLnVyaSwgdHJ1ZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICBpZiAoXCJhdXRob3JpemF0aW9uXCIgaW4gaGVhZGVycykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaCBpbiBoZWFkZXJzKVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSk7XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGVycm9yRXZlbnQsIG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUyKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IG1lc3NhZ2UgKyBcIiAoZXZlbnQgdHlwZTogXCIgKyBlcnJvckV2ZW50LnR5cGUgKyBcIilcIjtcbiAgICAgIGlmICgoX2EyID0gdGhpcyA9PSBudWxsID8gdm9pZCAwIDogdGhpcy54aHIpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc3RhdHVzVGV4dClcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiLCBjdXJyZW50IHN0YXR1c1RleHQgaXMgXCIgKyB0aGlzLnhoci5zdGF0dXNUZXh0O1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiUmVxdWVzdC5vblwiICsgZXJyb3JFdmVudC50eXBlICsgXCIoKVwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgdGhpcy5jb21wbGV0ZShuZXcgUGFydGlhbEVycm9ySW5mbyhlcnJvck1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUyKSk7XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGVycm9yRXZlbnQpIHtcbiAgICAgIGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCBcIlhIUiBlcnJvciBvY2N1cnJlZFwiLCBudWxsLCA0MDApO1xuICAgIH07XG4gICAgeGhyLm9uYWJvcnQgPSAoZXJyb3JFdmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMudGltZWRPdXQpIHtcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsIFwiUmVxdWVzdCBhYm9ydGVkIGR1ZSB0byByZXF1ZXN0IHRpbWVvdXQgZXhwaXJpbmdcIiwgbnVsbCwgNDA4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCBcIlJlcXVlc3QgY2FuY2VsbGVkXCIsIG51bGwsIDQwMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oZXJyb3JFdmVudCkge1xuICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsIFwiUmVxdWVzdCB0aW1lZCBvdXRcIiwgbnVsbCwgNDA4KTtcbiAgICB9O1xuICAgIGxldCBzdHJlYW1pbmc7XG4gICAgbGV0IHN0YXR1c0NvZGU7XG4gICAgbGV0IHN1Y2Nlc3NSZXNwb25zZTtcbiAgICBsZXQgc3RyZWFtUG9zID0gMDtcbiAgICBsZXQgdW5wYWNrZWQgPSBmYWxzZTtcbiAgICBjb25zdCBvblJlc3BvbnNlID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHN1Y2Nlc3NSZXNwb25zZSA9IHN0YXR1c0NvZGUgPCA0MDA7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA9PSAyMDQpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBudWxsLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RyZWFtaW5nID0gdGhpcy5yZXF1ZXN0TW9kZSA9PSBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gJiYgc3VjY2Vzc1Jlc3BvbnNlICYmIGlzRW5jb2RpbmdDaHVua2VkKHhocik7XG4gICAgfTtcbiAgICBjb25zdCBvbkVuZCA9ICgpID0+IHtcbiAgICAgIGxldCBwYXJzZWRSZXNwb25zZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gZ2V0SGVhZGVyKHhociwgXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgIGNvbnN0IGpzb24gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID49IDAgOiB4aHIucmVzcG9uc2VUeXBlID09IFwidGV4dFwiO1xuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgIGNvbnN0IGpzb25SZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2VUeXBlID09PSBcImFycmF5YnVmZmVyXCIgPyBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RGVjb2RlKHhoci5yZXNwb25zZSkgOiBTdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgaWYgKGpzb25SZXNwb25zZUJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UoanNvblJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0ganNvblJlc3BvbnNlQm9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5wYWNrZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0geGhyLnJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5yZXNwb25zZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3RhdHVzQ29kZSA9IHBhcnNlZFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgc3VjY2Vzc1Jlc3BvbnNlID0gc3RhdHVzQ29kZSA8IDQwMDtcbiAgICAgICAgICBoZWFkZXJzID0gcGFyc2VkUmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IHBhcnNlZFJlc3BvbnNlLnJlc3BvbnNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRlcnMgPSBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6IFwiICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN1Y2Nlc3NSZXNwb25zZSB8fCBBcnJheS5pc0FycmF5KHBhcnNlZFJlc3BvbnNlKSkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKG51bGwsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBlcnIgPSBnZXRBYmx5RXJyb3IocGFyc2VkUmVzcG9uc2UsIGhlYWRlcnMpO1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXG4gICAgICAgICAgXCJFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogXCIgKyBzdGF0dXNDb2RlICsgXCIgYm9keSB3YXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QocGFyc2VkUmVzcG9uc2UpLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgc3RhdHVzQ29kZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wbGV0ZShlcnIsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIGNvbnN0IGJvZHlFbmQgPSByZXNwb25zZVRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBpZHgsIGNodW5rO1xuICAgICAgd2hpbGUgKHN0cmVhbVBvcyA8IGJvZHlFbmQgJiYgKGlkeCA9IHJlc3BvbnNlVGV4dC5pbmRleE9mKFwiXFxuXCIsIHN0cmVhbVBvcykpID4gLTEpIHtcbiAgICAgICAgY2h1bmsgPSByZXNwb25zZVRleHQuc2xpY2Uoc3RyZWFtUG9zLCBpZHgpO1xuICAgICAgICBzdHJlYW1Qb3MgPSBpZHggKyAxO1xuICAgICAgICBvbkNodW5rKGNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb25DaHVuayA9IChjaHVuaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2h1bmsgPSBKU09OLnBhcnNlKGNodW5rKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShuZXcgUGFydGlhbEVycm9ySW5mbyhcIk1hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiBcIiArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH07XG4gICAgY29uc3Qgb25TdHJlYW1FbmQgPSAoKSA9PiB7XG4gICAgICBvblByb2dyZXNzKCk7XG4gICAgICB0aGlzLnN0cmVhbUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgICAgaWYgKHJlYWR5U3RhdGUgPCAzKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gMCkge1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3RhdHVzQ29kZSA9IHhoci5zdGF0dXM7XG4gICAgICAgICAgb25SZXNwb25zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkeVN0YXRlID09IDMgJiYgc3RyZWFtaW5nKSB7XG4gICAgICAgICAgb25Qcm9ncmVzcygpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgIGlmIChzdHJlYW1pbmcpXG4gICAgICAgICAgICBvblN0cmVhbUVuZCgpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKGJvZHkpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3QgeGhyID0gdGhpcy54aHI7XG4gICAgaWYgKHhocikge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID0gbm9vcDM7XG4gICAgICB0aGlzLnhociA9IG51bGw7XG4gICAgICBjb25zdCB0aW1lciA9IHRoaXMudGltZXI7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVxdWVzdENvbXBsZXRlKVxuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICB9XG4gICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0c1t0aGlzLmlkXTtcbiAgfVxufTtcbnZhciB4aHJyZXF1ZXN0X2RlZmF1bHQgPSBYSFJSZXF1ZXN0O1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQveGhycG9sbGluZ3RyYW5zcG9ydC50c1xudmFyIHNob3J0TmFtZTIgPSBUcmFuc3BvcnROYW1lcy5YaHJQb2xsaW5nO1xudmFyIFhIUlBvbGxpbmdUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWUyO1xuICAgIHBhcmFtcy5zdHJlYW0gPSBmYWxzZTtcbiAgICB0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTI7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHJldHVybiAhIShQbGF0Zm9ybS5Db25maWcueGhyU3VwcG9ydGVkICYmIFBsYXRmb3JtLkNvbmZpZy5hbGxvd0NvbWV0KTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJYSFJQb2xsaW5nVHJhbnNwb3J0OyB1cmk9XCIgKyB0aGlzLmJhc2VVcmkgKyBcIjsgaXNDb25uZWN0ZWQ9XCIgKyB0aGlzLmlzQ29ubmVjdGVkO1xuICB9XG4gIGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG4gICAgcmV0dXJuIHhocnJlcXVlc3RfZGVmYXVsdC5jcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGhpcy50aW1lb3V0cywgdGhpcy5sb2dnZXIpO1xuICB9XG59O1xudmFyIHhocnBvbGxpbmd0cmFuc3BvcnRfZGVmYXVsdCA9IFhIUlBvbGxpbmdUcmFuc3BvcnQ7XG5cbi8vIHNyYy9wbGF0Zm9ybS93ZWIvbGliL3RyYW5zcG9ydC9pbmRleC50c1xudmFyIG9yZGVyID0gW1wieGhyX3BvbGxpbmdcIl07XG52YXIgZGVmYXVsdFRyYW5zcG9ydHMgPSB7XG4gIG9yZGVyLFxuICBidW5kbGVkSW1wbGVtZW50YXRpb25zOiB7XG4gICAgd2ViX3NvY2tldDogd2Vic29ja2V0dHJhbnNwb3J0X2RlZmF1bHQsXG4gICAgeGhyX3BvbGxpbmc6IHhocnBvbGxpbmd0cmFuc3BvcnRfZGVmYXVsdFxuICB9XG59O1xudmFyIHRyYW5zcG9ydF9kZWZhdWx0MiA9IGRlZmF1bHRUcmFuc3BvcnRzO1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi91dGlsL2RlZmF1bHRzLnRzXG52YXIgRGVmYXVsdHMyID0ge1xuICBjb25uZWN0aXZpdHlDaGVja1VybDogXCJodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC50eHRcIixcbiAgd3NDb25uZWN0aXZpdHlVcmw6IFwid3NzOi8vd3MtdXAuYWJseS1yZWFsdGltZS5jb21cIixcbiAgLyogT3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcbiAgICogaW50ZXJzZWN0aW9uIG9mIGJhc2VUcmFuc3BvcnRPcmRlciBhbmQgdGhlIHRyYW5zcG9ydHMgY2xpZW50T3B0aW9uIHRoYXQnc1xuICAgKiBzdXBwb3J0ZWQuICovXG4gIGRlZmF1bHRUcmFuc3BvcnRzOiBbVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZywgVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0XVxufTtcbnZhciBkZWZhdWx0c19kZWZhdWx0MiA9IERlZmF1bHRzMjtcblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvdXRpbC9tc2dwYWNrLnRzXG5mdW5jdGlvbiBpbnNwZWN0KGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gIGxldCB2aWV3O1xuICBsZXQgdHlwZTtcbiAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdHlwZSA9IFwiQXJyYXlCdWZmZXJcIjtcbiAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICB0eXBlID0gXCJEYXRhVmlld1wiO1xuICAgIHZpZXcgPSBidWZmZXI7XG4gIH1cbiAgaWYgKCF2aWV3KVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShidWZmZXIpO1xuICBjb25zdCBieXRlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA+IDIwKSB7XG4gICAgICBieXRlcy5wdXNoKFwiLi4uXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSkudG9TdHJpbmcoMTYpO1xuICAgIGlmIChieXRlXy5sZW5ndGggPT09IDEpXG4gICAgICBieXRlXyA9IFwiMFwiICsgYnl0ZV87XG4gICAgYnl0ZXMucHVzaChieXRlXyk7XG4gIH1cbiAgcmV0dXJuIFwiPFwiICsgdHlwZSArIFwiIFwiICsgYnl0ZXMuam9pbihcIiBcIikgKyBcIj5cIjtcbn1cbmZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cmluZykge1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZVBvaW50IDwgMTI4KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAxMjcgfCAwKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IDwgMjA0OCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMzEgfCAxOTIpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAwICYgNjMgfCAxMjgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPCA2NTUzNikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxMiAmIDE1IHwgMjI0KTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDYzIHwgMTI4KTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDYzIHwgMTI4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IDwgMTExNDExMikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxOCAmIDcgfCAyNDApO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxMiAmIDYzIHwgMTI4KTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDYzIHwgMTI4KTtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDYzIHwgMTI4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY29kZXBvaW50IFwiICsgY29kZVBvaW50KTtcbiAgfVxufVxuZnVuY3Rpb24gdXRmOFJlYWQodmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IHN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY29uc3QgYnl0ZV8gPSB2aWV3LmdldFVpbnQ4KGkpO1xuICAgIGlmICgoYnl0ZV8gJiAxMjgpID09PSAwKSB7XG4gICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlXyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChieXRlXyAmIDIyNCkgPT09IDE5Mikge1xuICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGJ5dGVfICYgMTUpIDw8IDYgfCB2aWV3LmdldFVpbnQ4KCsraSkgJiA2Myk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChieXRlXyAmIDI0MCkgPT09IDIyNCkge1xuICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIChieXRlXyAmIDE1KSA8PCAxMiB8ICh2aWV3LmdldFVpbnQ4KCsraSkgJiA2MykgPDwgNiB8ICh2aWV3LmdldFVpbnQ4KCsraSkgJiA2MykgPDwgMFxuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKGJ5dGVfICYgMjQ4KSA9PT0gMjQwKSB7XG4gICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgKGJ5dGVfICYgNykgPDwgMTggfCAodmlldy5nZXRVaW50OCgrK2kpICYgNjMpIDw8IDEyIHwgKHZpZXcuZ2V0VWludDgoKytpKSAmIDYzKSA8PCA2IHwgKHZpZXcuZ2V0VWludDgoKytpKSAmIDYzKSA8PCAwXG4gICAgICApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZSBcIiArIGJ5dGVfLnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn1cbmZ1bmN0aW9uIHV0ZjhCeXRlQ291bnQoc3RyaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlUG9pbnQgPCAxMjgpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCA8IDIwNDgpIHtcbiAgICAgIGNvdW50ICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCA8IDY1NTM2KSB7XG4gICAgICBjb3VudCArPSAzO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7XG4gICAgICBjb3VudCArPSA0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBjb2RlcG9pbnQgXCIgKyBjb2RlUG9pbnQpO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGVuY29kZTIodmFsdWUsIHNwYXJzZSkge1xuICBjb25zdCBzaXplID0gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpO1xuICBpZiAoc2l6ZSA9PT0gMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgX2VuY29kZSh2YWx1ZSwgdmlldywgMCwgc3BhcnNlKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbnZhciBTSF9MXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpO1xudmFyIFNIX1JfMzIgPSAxIC8gU0hfTF8zMjtcbmZ1bmN0aW9uIGdldEludDY0KHZpZXcsIG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgcmV0dXJuIHZpZXcuZ2V0SW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcbn1cbmZ1bmN0aW9uIGdldFVpbnQ2NCh2aWV3LCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHJldHVybiB2aWV3LmdldFVpbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xufVxuZnVuY3Rpb24gc2V0SW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcbiAgaWYgKHZhbCA8IDkyMjMzNzIwMzY4NTQ3NzZlMykge1xuICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcbiAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDIxNDc0ODM2NDcpO1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDIxNDc0ODM2NDcpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRVaW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcbiAgaWYgKHZhbCA8IDE4NDQ2NzQ0MDczNzA5NTUyZTMpIHtcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgdmFsICYgLTEpO1xuICB9IGVsc2Uge1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgNDI5NDk2NzI5NSk7XG4gICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgNDI5NDk2NzI5NSk7XG4gIH1cbn1cbnZhciBEZWNvZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2aWV3LCBvZmZzZXQpIHtcbiAgICB0aGlzLm1hcCA9IChsZW5ndGgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2UoKTtcbiAgICAgICAgdmFsdWVba2V5XSA9IHRoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHRoaXMuYmluID0gKGxlbmd0aCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHZhbHVlKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy52aWV3LmJ1ZmZlciwgdGhpcy5vZmZzZXQsIGxlbmd0aCksIDApO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgdGhpcy5idWYgPSB0aGlzLmJpbjtcbiAgICB0aGlzLnN0ciA9IChsZW5ndGgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdXRmOFJlYWQodGhpcy52aWV3LCB0aGlzLm9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHRoaXMuYXJyYXkgPSAobGVuZ3RoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHRoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHRoaXMuZXh0ID0gKGxlbmd0aCkgPT4ge1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpLFxuICAgICAgICBkYXRhOiB0aGlzLmJ1ZihsZW5ndGgpXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5wYXJzZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQpO1xuICAgICAgbGV0IHZhbHVlLCBsZW5ndGg7XG4gICAgICBpZiAoKHR5cGUgJiAxMjgpID09PSAwKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjQwKSA9PT0gMTI4KSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAxNTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyNDApID09PSAxNDQpIHtcbiAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDE1O1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjI0KSA9PT0gMTYwKSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAzMTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyMjQpID09PSAyMjQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDE5MjpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDE5MzpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIGNhc2UgMTk0OlxuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIDE5NTpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIDE5NjpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICBjYXNlIDE5NzpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTg6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMTk5OlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjAwOlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIwMTpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA1OlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwNjpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDc6XG4gICAgICAgICAgdmFsdWUgPSBnZXRVaW50NjQodGhpcy52aWV3LCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwODpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA5OlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjEwOlxuICAgICAgICAgIHZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjExOlxuICAgICAgICAgIHZhbHVlID0gZ2V0SW50NjQodGhpcy52aWV3LCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMjpcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjEzOlxuICAgICAgICAgIGxlbmd0aCA9IDI7XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMTQ6XG4gICAgICAgICAgbGVuZ3RoID0gNDtcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxNTpcbiAgICAgICAgICBsZW5ndGggPSA4O1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE2OlxuICAgICAgICAgIGxlbmd0aCA9IDE2O1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE3OlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE4OlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxOTpcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjE6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjI6XG4gICAgICAgICAgbGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIzOlxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIDB4XCIgKyB0eXBlLnRvU3RyaW5nKDE2KSk7XG4gICAgfTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gIH1cbn07XG5mdW5jdGlvbiBkZWNvZGUzKGJ1ZmZlcikge1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2Rlcih2aWV3KTtcbiAgY29uc3QgdmFsdWUgPSBkZWNvZGVyLnBhcnNlKCk7XG4gIGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5vZmZzZXQgKyBcIiB0cmFpbGluZyBieXRlc1wiKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgdmFsID0gdmFsdWVbZV0sIHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgIHJldHVybiAoIXNwYXJzZSB8fCB2YWwgIT09IHZvaWQgMCAmJiB2YWwgIT09IG51bGwpICYmIChcImZ1bmN0aW9uXCIgIT09IHR5cGUgfHwgISF2YWwudG9KU09OKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfZW5jb2RlKHZhbHVlLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG4gICAgaWYgKGxlbmd0aCA8IDMyKSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoIHwgMTYwKTtcbiAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gMSArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxNyk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgICB1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMiwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDIgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxOCk7XG4gICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDMsIHZhbHVlKTtcbiAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxOSk7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDUsIHZhbHVlKTtcbiAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmJ1ZmZlcjtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDE5Nik7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMik7XG4gICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMTk3KTtcbiAgICAgIHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMyk7XG4gICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAxOTgpO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyA1KTtcbiAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwMyk7XG4gICAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICBpZiAodmFsdWUgPCAxMjgpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCAyNTYpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwNCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IDY1NTM2KSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMDUpO1xuICAgICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiAzO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMjA2KTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gNTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IDE4NDQ2NzQ0MDczNzA5NTUyZTMpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwNyk7XG4gICAgICAgIHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiA5O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWcgMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAtMzIpIHtcbiAgICAgIHZpZXcuc2V0SW50OChvZmZzZXQsIHZhbHVlKTtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gLTEyOCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIwOCk7XG4gICAgICB2aWV3LnNldEludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAtMzI3NjgpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAyMDkpO1xuICAgICAgdmlldy5zZXRJbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMjEwKTtcbiAgICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSAtOTIyMzM3MjAzNjg1NDc3NmUzKSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMjExKTtcbiAgICAgIHNldEludDY0KHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiA5O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsIC0weFwiICsgKC12YWx1ZSkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAoc3BhcnNlKVxuICAgICAgcmV0dXJuIDA7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDIxMik7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCAwKTtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDIsIDApO1xuICAgIHJldHVybiAzO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIGlmIChzcGFyc2UpXG4gICAgICByZXR1cm4gMDtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMTkyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUgPyAxOTUgOiAxOTQpO1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgcmV0dXJuIF9lbmNvZGUodmFsdWUudG9KU09OKCksIHZpZXcsIG9mZnNldCwgc3BhcnNlKTtcbiAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBsZXQgbGVuZ3RoLCBzaXplID0gMDtcbiAgICBsZXQga2V5cztcbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aCB8IChpc0FycmF5ID8gMTQ0IDogMTI4KSk7XG4gICAgICBzaXplID0gMTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDIyMCA6IDIyMik7XG4gICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgc2l6ZSA9IDM7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDIyMSA6IDIyMyk7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgICAgc2l6ZSA9IDU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpemUgKz0gX2VuY29kZSh2YWx1ZVtpXSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgc2l6ZSArPSBfZW5jb2RlKGtleSwgdmlldywgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgICAgIHNpemUgKz0gX2VuY29kZSh2YWx1ZVtrZXldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAwO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcbn1cbmZ1bmN0aW9uIHNpemVvZih2YWx1ZSwgc3BhcnNlKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG4gICAgaWYgKGxlbmd0aCA8IDMyKSB7XG4gICAgICByZXR1cm4gMSArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgcmV0dXJuIDIgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgcmV0dXJuIDMgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICByZXR1cm4gNSArIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgcmV0dXJuIDk7XG4gICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgIGlmICh2YWx1ZSA8IDEyOClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAodmFsdWUgPCAyNTYpXG4gICAgICAgIHJldHVybiAyO1xuICAgICAgaWYgKHZhbHVlIDwgNjU1MzYpXG4gICAgICAgIHJldHVybiAzO1xuICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5NilcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgICBpZiAodmFsdWUgPCAxODQ0Njc0NDA3MzcwOTU1MmUzKVxuICAgICAgICByZXR1cm4gOTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gLTMyKVxuICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHZhbHVlID49IC0xMjgpXG4gICAgICByZXR1cm4gMjtcbiAgICBpZiAodmFsdWUgPj0gLTMyNzY4KVxuICAgICAgcmV0dXJuIDM7XG4gICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KVxuICAgICAgcmV0dXJuIDU7XG4gICAgaWYgKHZhbHVlID49IC05MjIzMzcyMDM2ODU0Nzc2ZTMpXG4gICAgICByZXR1cm4gOTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsIC0weFwiICsgdmFsdWUudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiAxO1xuICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgcmV0dXJuIHNwYXJzZSA/IDAgOiAxO1xuICBpZiAodmFsdWUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gc3BhcnNlID8gMCA6IDM7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgcmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcbiAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBsZXQgbGVuZ3RoLCBzaXplID0gMDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2l6ZSArPSBzaXplb2YodmFsdWVbaV0sIHNwYXJzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBzaXplICs9IHNpemVvZihrZXkpICsgc2l6ZW9mKHZhbHVlW2tleV0sIHNwYXJzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgcmV0dXJuIDEgKyBzaXplO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgIHJldHVybiAzICsgc2l6ZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgIHJldHVybiA1ICsgc2l6ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4XCIgKyBsZW5ndGgudG9TdHJpbmcoMTYpKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAwO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcbn1cbnZhciBtc2dwYWNrX2RlZmF1bHQgPSB7XG4gIGVuY29kZTogZW5jb2RlMixcbiAgZGVjb2RlOiBkZWNvZGUzLFxuICBpbnNwZWN0LFxuICB1dGY4V3JpdGUsXG4gIHV0ZjhSZWFkLFxuICB1dGY4Qnl0ZUNvdW50XG59O1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2xpYi9odHRwL3JlcXVlc3QvZmV0Y2hyZXF1ZXN0LnRzXG5mdW5jdGlvbiBpc0FibHlFcnJvcjIocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gIHJldHVybiAhIWhlYWRlcnMuZ2V0KFwieC1hYmx5LWVycm9yY29kZVwiKTtcbn1cbmZ1bmN0aW9uIGdldEFibHlFcnJvcjIocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gIGlmIChpc0FibHlFcnJvcjIocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSkge1xuICAgIHJldHVybiByZXNwb25zZUJvZHkuZXJyb3IgJiYgRXJyb3JJbmZvLmZyb21WYWx1ZXMocmVzcG9uc2VCb2R5LmVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydEhlYWRlcnMoaGVhZGVycykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlcXVlc3QobWV0aG9kLCBjbGllbnQsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5KSB7XG4gIGNvbnN0IGZldGNoSGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMgfHwge30pO1xuICBjb25zdCBfbWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBpc05pbChib2R5KSA/IFwiR0VUXCIgOiBcIlBPU1RcIjtcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgbGV0IHRpbWVvdXQ7XG4gIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICByZXNvbHZlKHsgZXJyb3I6IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiUmVxdWVzdCB0aW1lZCBvdXRcIiwgbnVsbCwgNDA4KSB9KTtcbiAgICAgIH0sXG4gICAgICBjbGllbnQgPyBjbGllbnQub3B0aW9ucy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiBkZWZhdWx0c19kZWZhdWx0LlRJTUVPVVRTLmh0dHBSZXF1ZXN0VGltZW91dFxuICAgICk7XG4gIH0pO1xuICBjb25zdCByZXF1ZXN0SW5pdCA9IHtcbiAgICBtZXRob2Q6IF9tZXRob2QsXG4gICAgaGVhZGVyczogZmV0Y2hIZWFkZXJzLFxuICAgIGJvZHksXG4gICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICB9O1xuICBpZiAoIVBsYXRmb3JtLkNvbmZpZy5pc1dlYndvcmtlcikge1xuICAgIHJlcXVlc3RJbml0LmNyZWRlbnRpYWxzID0gZmV0Y2hIZWFkZXJzLmhhcyhcImF1dGhvcml6YXRpb25cIikgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIjtcbiAgfVxuICBjb25zdCByZXN1bHRQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0R2xvYmFsT2JqZWN0KCkuZmV0Y2godXJpICsgXCI/XCIgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyB8fCB7fSksIHJlcXVlc3RJbml0KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGlmIChyZXMuc3RhdHVzID09IDIwNCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCwgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICBsZXQgYm9keTI7XG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiKSA+IC0xKSB7XG4gICAgICAgIGJvZHkyID0gYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID4gLTEpIHtcbiAgICAgICAgYm9keTIgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keTIgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5wYWNrZWQgPSAhIWNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LW1zZ3BhY2tcIikgPT09IC0xO1xuICAgICAgY29uc3QgaGVhZGVyczIgPSBjb252ZXJ0SGVhZGVycyhyZXMuaGVhZGVycyk7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGdldEFibHlFcnJvcjIoYm9keTIsIHJlcy5oZWFkZXJzKSB8fCBuZXcgUGFydGlhbEVycm9ySW5mbyhcbiAgICAgICAgICBcIkVycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIiArIHJlcy5zdGF0dXMgKyBcIiBib2R5IHdhczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChib2R5MiksXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICByZXMuc3RhdHVzXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7IGVycm9yLCBib2R5OiBib2R5MiwgaGVhZGVyczogaGVhZGVyczIsIHVucGFja2VkLCBzdGF0dXNDb2RlOiByZXMuc3RhdHVzIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCwgYm9keTogYm9keTIsIGhlYWRlcnM6IGhlYWRlcnMyLCB1bnBhY2tlZCwgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbdGltZW91dFByb21pc2UsIHJlc3VsdFByb21pc2VdKTtcbn1cblxuLy8gc3JjL3BsYXRmb3JtL3dlYi9saWIvaHR0cC9yZXF1ZXN0L2luZGV4LnRzXG52YXIgZGVmYXVsdEJ1bmRsZWRSZXF1ZXN0SW1wbGVtZW50YXRpb25zID0ge1xuICBYSFJSZXF1ZXN0OiB4aHJyZXF1ZXN0X2RlZmF1bHQsXG4gIEZldGNoUmVxdWVzdDogZmV0Y2hSZXF1ZXN0XG59O1xuXG4vLyBzcmMvcGxhdGZvcm0vd2ViL2luZGV4LnRzXG52YXIgQ3J5cHRvID0gY3JlYXRlQ3J5cHRvQ2xhc3MoY29uZmlnX2RlZmF1bHQsIGJ1ZmZlcnV0aWxzX2RlZmF1bHQpO1xuUGxhdGZvcm0uQ3J5cHRvID0gQ3J5cHRvO1xuUGxhdGZvcm0uQnVmZmVyVXRpbHMgPSBidWZmZXJ1dGlsc19kZWZhdWx0O1xuUGxhdGZvcm0uSHR0cCA9IGh0dHBfZGVmYXVsdDtcblBsYXRmb3JtLkNvbmZpZyA9IGNvbmZpZ19kZWZhdWx0O1xuUGxhdGZvcm0uVHJhbnNwb3J0cyA9IHRyYW5zcG9ydF9kZWZhdWx0MjtcblBsYXRmb3JtLldlYlN0b3JhZ2UgPSB3ZWJzdG9yYWdlX2RlZmF1bHQ7XG5mb3IgKGNvbnN0IGNsaWVudENsYXNzIG9mIFtEZWZhdWx0UmVzdCwgRGVmYXVsdFJlYWx0aW1lXSkge1xuICBjbGllbnRDbGFzcy5DcnlwdG8gPSBDcnlwdG87XG4gIGNsaWVudENsYXNzLl9Nc2dQYWNrID0gbXNncGFja19kZWZhdWx0O1xufVxuaHR0cF9kZWZhdWx0LmJ1bmRsZWRSZXF1ZXN0SW1wbGVtZW50YXRpb25zID0gZGVmYXVsdEJ1bmRsZWRSZXF1ZXN0SW1wbGVtZW50YXRpb25zO1xubG9nZ2VyX2RlZmF1bHQuaW5pdExvZ0hhbmRsZXJzKCk7XG5QbGF0Zm9ybS5EZWZhdWx0cyA9IGdldERlZmF1bHRzKGRlZmF1bHRzX2RlZmF1bHQyKTtcbmlmIChQbGF0Zm9ybS5Db25maWcuYWdlbnQpIHtcbiAgUGxhdGZvcm0uRGVmYXVsdHMuYWdlbnQgKz0gXCIgXCIgKyBQbGF0Zm9ybS5Db25maWcuYWdlbnQ7XG59XG52YXIgd2ViX2RlZmF1bHQgPSB7XG4gIEVycm9ySW5mbyxcbiAgUmVzdDogRGVmYXVsdFJlc3QsXG4gIFJlYWx0aW1lOiBEZWZhdWx0UmVhbHRpbWUsXG4gIG1zZ3BhY2s6IG1zZ3BhY2tfZGVmYXVsdFxufTtcbmlmICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiKSB7XG4gIHZhciBfX2NwID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgICBpZiAoKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIpIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmcm9tKSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IGZyb21ba2V5XSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhKGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX2NwKG1vZHVsZS5leHBvcnRzLCBleHBvcnRzKTtcbn1cbnJldHVybiBtb2R1bGUuZXhwb3J0cztcbn0pKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJseS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/build/ably.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next-auth/client/_utils.js":
/*!*************************************************!*\
  !*** ./node_modules/next-auth/client/_utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BroadcastChannel = BroadcastChannel;\nexports.apiBaseUrl = apiBaseUrl;\nexports.fetchData = fetchData;\nexports.now = now;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"(app-pages-browser)/./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction fetchData(_x, _x2, _x3) {\n  return _fetchData.apply(this, arguments);\n}\n\nfunction _fetchData() {\n  _fetchData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(path, __NEXTAUTH, logger) {\n    var _ref,\n        ctx,\n        _ref$req,\n        req,\n        url,\n        _req$headers,\n        options,\n        res,\n        data,\n        _args = arguments;\n\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 3 && _args[3] !== undefined ? _args[3] : {}, ctx = _ref.ctx, _ref$req = _ref.req, req = _ref$req === void 0 ? ctx === null || ctx === void 0 ? void 0 : ctx.req : _ref$req;\n            url = \"\".concat(apiBaseUrl(__NEXTAUTH), \"/\").concat(path);\n            _context.prev = 2;\n            options = {\n              headers: _objectSpread({\n                \"Content-Type\": \"application/json\"\n              }, req !== null && req !== void 0 && (_req$headers = req.headers) !== null && _req$headers !== void 0 && _req$headers.cookie ? {\n                cookie: req.headers.cookie\n              } : {})\n            };\n\n            if (req !== null && req !== void 0 && req.body) {\n              options.body = JSON.stringify(req.body);\n              options.method = \"POST\";\n            }\n\n            _context.next = 7;\n            return fetch(url, options);\n\n          case 7:\n            res = _context.sent;\n            _context.next = 10;\n            return res.json();\n\n          case 10:\n            data = _context.sent;\n\n            if (res.ok) {\n              _context.next = 13;\n              break;\n            }\n\n            throw data;\n\n          case 13:\n            return _context.abrupt(\"return\", Object.keys(data).length > 0 ? data : null);\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](2);\n            logger.error(\"CLIENT_FETCH_ERROR\", {\n              error: _context.t0,\n              url: url\n            });\n            return _context.abrupt(\"return\", null);\n\n          case 20:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 16]]);\n  }));\n  return _fetchData.apply(this, arguments);\n}\n\nfunction apiBaseUrl(__NEXTAUTH) {\n  if (typeof window === \"undefined\") {\n    return \"\".concat(__NEXTAUTH.baseUrlServer).concat(__NEXTAUTH.basePathServer);\n  }\n\n  return __NEXTAUTH.basePath;\n}\n\nfunction now() {\n  return Math.floor(Date.now() / 1000);\n}\n\nfunction BroadcastChannel() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"nextauth.message\";\n  return {\n    receive: function receive(onReceive) {\n      var handler = function handler(event) {\n        var _event$newValue;\n\n        if (event.key !== name) return;\n        var message = JSON.parse((_event$newValue = event.newValue) !== null && _event$newValue !== void 0 ? _event$newValue : \"{}\");\n        if ((message === null || message === void 0 ? void 0 : message.event) !== \"session\" || !(message !== null && message !== void 0 && message.data)) return;\n        onReceive(message);\n      };\n\n      window.addEventListener(\"storage\", handler);\n      return function () {\n        return window.removeEventListener(\"storage\", handler);\n      };\n    },\n    post: function post(message) {\n      if (typeof window === \"undefined\") return;\n\n      try {\n        localStorage.setItem(name, JSON.stringify(_objectSpread(_objectSpread({}, message), {}, {\n          timestamp: now()\n        })));\n      } catch (_unused) {}\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY2xpZW50L191dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyx3SUFBOEM7O0FBRW5GLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLFdBQVc7O0FBRVgsMENBQTBDLG1CQUFPLENBQUMsMEdBQTRCOztBQUU5RSw4Q0FBOEMsbUJBQU8sQ0FBQywwSEFBdUM7O0FBRTdGLGdEQUFnRCxtQkFBTyxDQUFDLDhIQUF5Qzs7QUFFakcsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsMERBQTBELG9LQUFvSyxtRkFBbUYsS0FBSzs7QUFFeGY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0lBQWtJO0FBQ2xJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUY7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NsaWVudC9fdXRpbHMuanM/NDdjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJyb2FkY2FzdENoYW5uZWwgPSBCcm9hZGNhc3RDaGFubmVsO1xuZXhwb3J0cy5hcGlCYXNlVXJsID0gYXBpQmFzZVVybDtcbmV4cG9ydHMuZmV0Y2hEYXRhID0gZmV0Y2hEYXRhO1xuZXhwb3J0cy5ub3cgPSBub3c7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZldGNoRGF0YShfeCwgX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF9mZXRjaERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2ZldGNoRGF0YSgpIHtcbiAgX2ZldGNoRGF0YSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHBhdGgsIF9fTkVYVEFVVEgsIGxvZ2dlcikge1xuICAgIHZhciBfcmVmLFxuICAgICAgICBjdHgsXG4gICAgICAgIF9yZWYkcmVxLFxuICAgICAgICByZXEsXG4gICAgICAgIHVybCxcbiAgICAgICAgX3JlcSRoZWFkZXJzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByZXMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmID0gX2FyZ3MubGVuZ3RoID4gMyAmJiBfYXJnc1szXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbM10gOiB7fSwgY3R4ID0gX3JlZi5jdHgsIF9yZWYkcmVxID0gX3JlZi5yZXEsIHJlcSA9IF9yZWYkcmVxID09PSB2b2lkIDAgPyBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucmVxIDogX3JlZiRyZXE7XG4gICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChhcGlCYXNlVXJsKF9fTkVYVEFVVEgpLCBcIi9cIikuY29uY2F0KHBhdGgpO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICB9LCByZXEgIT09IG51bGwgJiYgcmVxICE9PSB2b2lkIDAgJiYgKF9yZXEkaGVhZGVycyA9IHJlcS5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfcmVxJGhlYWRlcnMgIT09IHZvaWQgMCAmJiBfcmVxJGhlYWRlcnMuY29va2llID8ge1xuICAgICAgICAgICAgICAgIGNvb2tpZTogcmVxLmhlYWRlcnMuY29va2llXG4gICAgICAgICAgICAgIH0gOiB7fSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChyZXEgIT09IG51bGwgJiYgcmVxICE9PSB2b2lkIDAgJiYgcmVxLmJvZHkpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocmVxLmJvZHkpO1xuICAgICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGRhdGE7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwID8gZGF0YSA6IG51bGwpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNjtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkNMSUVOVF9GRVRDSF9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dC50MCxcbiAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMiwgMTZdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9mZXRjaERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gYXBpQmFzZVVybChfX05FWFRBVVRIKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KF9fTkVYVEFVVEguYmFzZVVybFNlcnZlcikuY29uY2F0KF9fTkVYVEFVVEguYmFzZVBhdGhTZXJ2ZXIpO1xuICB9XG5cbiAgcmV0dXJuIF9fTkVYVEFVVEguYmFzZVBhdGg7XG59XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiBCcm9hZGNhc3RDaGFubmVsKCkge1xuICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJuZXh0YXV0aC5tZXNzYWdlXCI7XG4gIHJldHVybiB7XG4gICAgcmVjZWl2ZTogZnVuY3Rpb24gcmVjZWl2ZShvblJlY2VpdmUpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgICB2YXIgX2V2ZW50JG5ld1ZhbHVlO1xuXG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IG5hbWUpIHJldHVybjtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKChfZXZlbnQkbmV3VmFsdWUgPSBldmVudC5uZXdWYWx1ZSkgIT09IG51bGwgJiYgX2V2ZW50JG5ld1ZhbHVlICE9PSB2b2lkIDAgPyBfZXZlbnQkbmV3VmFsdWUgOiBcInt9XCIpO1xuICAgICAgICBpZiAoKG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5ldmVudCkgIT09IFwic2Vzc2lvblwiIHx8ICEobWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgJiYgbWVzc2FnZS5kYXRhKSkgcmV0dXJuO1xuICAgICAgICBvblJlY2VpdmUobWVzc2FnZSk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgaGFuZGxlcik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHBvc3Q6IGZ1bmN0aW9uIHBvc3QobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtZXNzYWdlKSwge30sIHtcbiAgICAgICAgICB0aW1lc3RhbXA6IG5vdygpXG4gICAgICAgIH0pKSk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next-auth/client/_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next-auth/core/errors.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/core/errors.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.UnsupportedStrategy = exports.UnknownError = exports.OAuthCallbackError = exports.MissingSecret = exports.MissingAuthorize = exports.MissingAdapterMethods = exports.MissingAdapter = exports.MissingAPIRoute = exports.InvalidCallbackUrl = exports.AccountNotLinkedError = void 0;\nexports.adapterErrorHandler = adapterErrorHandler;\nexports.capitalize = capitalize;\nexports.eventsErrorHandler = eventsErrorHandler;\nexports.upperSnake = upperSnake;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"(app-pages-browser)/./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar UnknownError = function (_Error) {\n  (0, _inherits2.default)(UnknownError, _Error);\n\n  var _super = _createSuper(UnknownError);\n\n  function UnknownError(error) {\n    var _message;\n\n    var _this;\n\n    (0, _classCallCheck2.default)(this, UnknownError);\n    _this = _super.call(this, (_message = error === null || error === void 0 ? void 0 : error.message) !== null && _message !== void 0 ? _message : error);\n    _this.name = \"UnknownError\";\n    _this.code = error.code;\n\n    if (error instanceof Error) {\n      _this.stack = error.stack;\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(UnknownError, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        message: this.message,\n        stack: this.stack\n      };\n    }\n  }]);\n  return UnknownError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.UnknownError = UnknownError;\n\nvar OAuthCallbackError = function (_UnknownError) {\n  (0, _inherits2.default)(OAuthCallbackError, _UnknownError);\n\n  var _super2 = _createSuper(OAuthCallbackError);\n\n  function OAuthCallbackError() {\n    var _this2;\n\n    (0, _classCallCheck2.default)(this, OAuthCallbackError);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), \"name\", \"OAuthCallbackError\");\n    return _this2;\n  }\n\n  return (0, _createClass2.default)(OAuthCallbackError);\n}(UnknownError);\n\nexports.OAuthCallbackError = OAuthCallbackError;\n\nvar AccountNotLinkedError = function (_UnknownError2) {\n  (0, _inherits2.default)(AccountNotLinkedError, _UnknownError2);\n\n  var _super3 = _createSuper(AccountNotLinkedError);\n\n  function AccountNotLinkedError() {\n    var _this3;\n\n    (0, _classCallCheck2.default)(this, AccountNotLinkedError);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this3 = _super3.call.apply(_super3, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), \"name\", \"AccountNotLinkedError\");\n    return _this3;\n  }\n\n  return (0, _createClass2.default)(AccountNotLinkedError);\n}(UnknownError);\n\nexports.AccountNotLinkedError = AccountNotLinkedError;\n\nvar MissingAPIRoute = function (_UnknownError3) {\n  (0, _inherits2.default)(MissingAPIRoute, _UnknownError3);\n\n  var _super4 = _createSuper(MissingAPIRoute);\n\n  function MissingAPIRoute() {\n    var _this4;\n\n    (0, _classCallCheck2.default)(this, MissingAPIRoute);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this4 = _super4.call.apply(_super4, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"name\", \"MissingAPIRouteError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"code\", \"MISSING_NEXTAUTH_API_ROUTE_ERROR\");\n    return _this4;\n  }\n\n  return (0, _createClass2.default)(MissingAPIRoute);\n}(UnknownError);\n\nexports.MissingAPIRoute = MissingAPIRoute;\n\nvar MissingSecret = function (_UnknownError4) {\n  (0, _inherits2.default)(MissingSecret, _UnknownError4);\n\n  var _super5 = _createSuper(MissingSecret);\n\n  function MissingSecret() {\n    var _this5;\n\n    (0, _classCallCheck2.default)(this, MissingSecret);\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    _this5 = _super5.call.apply(_super5, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"name\", \"MissingSecretError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"code\", \"NO_SECRET\");\n    return _this5;\n  }\n\n  return (0, _createClass2.default)(MissingSecret);\n}(UnknownError);\n\nexports.MissingSecret = MissingSecret;\n\nvar MissingAuthorize = function (_UnknownError5) {\n  (0, _inherits2.default)(MissingAuthorize, _UnknownError5);\n\n  var _super6 = _createSuper(MissingAuthorize);\n\n  function MissingAuthorize() {\n    var _this6;\n\n    (0, _classCallCheck2.default)(this, MissingAuthorize);\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    _this6 = _super6.call.apply(_super6, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"name\", \"MissingAuthorizeError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"code\", \"CALLBACK_CREDENTIALS_HANDLER_ERROR\");\n    return _this6;\n  }\n\n  return (0, _createClass2.default)(MissingAuthorize);\n}(UnknownError);\n\nexports.MissingAuthorize = MissingAuthorize;\n\nvar MissingAdapter = function (_UnknownError6) {\n  (0, _inherits2.default)(MissingAdapter, _UnknownError6);\n\n  var _super7 = _createSuper(MissingAdapter);\n\n  function MissingAdapter() {\n    var _this7;\n\n    (0, _classCallCheck2.default)(this, MissingAdapter);\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    _this7 = _super7.call.apply(_super7, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"name\", \"MissingAdapterError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"code\", \"EMAIL_REQUIRES_ADAPTER_ERROR\");\n    return _this7;\n  }\n\n  return (0, _createClass2.default)(MissingAdapter);\n}(UnknownError);\n\nexports.MissingAdapter = MissingAdapter;\n\nvar MissingAdapterMethods = function (_UnknownError7) {\n  (0, _inherits2.default)(MissingAdapterMethods, _UnknownError7);\n\n  var _super8 = _createSuper(MissingAdapterMethods);\n\n  function MissingAdapterMethods() {\n    var _this8;\n\n    (0, _classCallCheck2.default)(this, MissingAdapterMethods);\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    _this8 = _super8.call.apply(_super8, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"name\", \"MissingAdapterMethodsError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"code\", \"MISSING_ADAPTER_METHODS_ERROR\");\n    return _this8;\n  }\n\n  return (0, _createClass2.default)(MissingAdapterMethods);\n}(UnknownError);\n\nexports.MissingAdapterMethods = MissingAdapterMethods;\n\nvar UnsupportedStrategy = function (_UnknownError8) {\n  (0, _inherits2.default)(UnsupportedStrategy, _UnknownError8);\n\n  var _super9 = _createSuper(UnsupportedStrategy);\n\n  function UnsupportedStrategy() {\n    var _this9;\n\n    (0, _classCallCheck2.default)(this, UnsupportedStrategy);\n\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    _this9 = _super9.call.apply(_super9, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"name\", \"UnsupportedStrategyError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"code\", \"CALLBACK_CREDENTIALS_JWT_ERROR\");\n    return _this9;\n  }\n\n  return (0, _createClass2.default)(UnsupportedStrategy);\n}(UnknownError);\n\nexports.UnsupportedStrategy = UnsupportedStrategy;\n\nvar InvalidCallbackUrl = function (_UnknownError9) {\n  (0, _inherits2.default)(InvalidCallbackUrl, _UnknownError9);\n\n  var _super10 = _createSuper(InvalidCallbackUrl);\n\n  function InvalidCallbackUrl() {\n    var _this10;\n\n    (0, _classCallCheck2.default)(this, InvalidCallbackUrl);\n\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n\n    _this10 = _super10.call.apply(_super10, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this10), \"name\", \"InvalidCallbackUrl\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this10), \"code\", \"INVALID_CALLBACK_URL_ERROR\");\n    return _this10;\n  }\n\n  return (0, _createClass2.default)(InvalidCallbackUrl);\n}(UnknownError);\n\nexports.InvalidCallbackUrl = InvalidCallbackUrl;\n\nfunction upperSnake(s) {\n  return s.replace(/([A-Z])/g, \"_$1\").toUpperCase();\n}\n\nfunction capitalize(s) {\n  return \"\".concat(s[0].toUpperCase()).concat(s.slice(1));\n}\n\nfunction eventsErrorHandler(methods, logger) {\n  return Object.keys(methods).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var method,\n          _args = arguments;\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              method = methods[name];\n              _context.next = 4;\n              return method.apply(void 0, _args);\n\n            case 4:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              logger.error(\"\".concat(upperSnake(name), \"_EVENT_ERROR\"), _context.t0);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n    return acc;\n  }, {});\n}\n\nfunction adapterErrorHandler(adapter, logger) {\n  if (!adapter) return;\n  return Object.keys(adapter).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {\n      var _len10,\n          args,\n          _key10,\n          method,\n          e,\n          _args2 = arguments;\n\n      return _regenerator.default.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n\n              for (_len10 = _args2.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n                args[_key10] = _args2[_key10];\n              }\n\n              logger.debug(\"adapter_\".concat(name), {\n                args: args\n              });\n              method = adapter[name];\n              _context2.next = 6;\n              return method.apply(void 0, args);\n\n            case 6:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](0);\n              logger.error(\"adapter_error_\".concat(name), _context2.t0);\n              e = new UnknownError(_context2.t0);\n              e.name = \"\".concat(capitalize(name), \"Error\");\n              throw e;\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 9]]);\n    }));\n    return acc;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY29yZS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsd0lBQThDOztBQUVuRiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRywwQkFBMEIsR0FBRyw2QkFBNkI7QUFDbFIsMkJBQTJCO0FBQzNCLGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUIsa0JBQWtCOztBQUVsQiwwQ0FBMEMsbUJBQU8sQ0FBQywwR0FBNEI7O0FBRTlFLGdEQUFnRCxtQkFBTyxDQUFDLDhIQUF5Qzs7QUFFakcscURBQXFELG1CQUFPLENBQUMsd0lBQThDOztBQUUzRyw4Q0FBOEMsbUJBQU8sQ0FBQywwSEFBdUM7O0FBRTdGLDhDQUE4QyxtQkFBTyxDQUFDLDBIQUF1Qzs7QUFFN0YsMkNBQTJDLG1CQUFPLENBQUMsb0hBQW9DOztBQUV2Rix3Q0FBd0MsbUJBQU8sQ0FBQyw4R0FBaUM7O0FBRWpGLHlEQUF5RCxtQkFBTyxDQUFDLGdKQUFrRDs7QUFFbkgsOENBQThDLG1CQUFPLENBQUMsMEhBQXVDOztBQUU3RiwrQ0FBK0MsbUJBQU8sQ0FBQyw0SEFBd0M7O0FBRS9GLGlDQUFpQyw2REFBNkQseUNBQXlDLDREQUE0RCxpQ0FBaUMsaUVBQWlFLDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFaFosdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3RUFBd0UsYUFBYTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRkFBaUYsaUJBQWlCO0FBQ2xHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUcsSUFBSTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY29yZS9lcnJvcnMuanM/M2Q5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBleHBvcnRzLlVua25vd25FcnJvciA9IGV4cG9ydHMuT0F1dGhDYWxsYmFja0Vycm9yID0gZXhwb3J0cy5NaXNzaW5nU2VjcmV0ID0gZXhwb3J0cy5NaXNzaW5nQXV0aG9yaXplID0gZXhwb3J0cy5NaXNzaW5nQWRhcHRlck1ldGhvZHMgPSBleHBvcnRzLk1pc3NpbmdBZGFwdGVyID0gZXhwb3J0cy5NaXNzaW5nQVBJUm91dGUgPSBleHBvcnRzLkludmFsaWRDYWxsYmFja1VybCA9IGV4cG9ydHMuQWNjb3VudE5vdExpbmtlZEVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5hZGFwdGVyRXJyb3JIYW5kbGVyID0gYWRhcHRlckVycm9ySGFuZGxlcjtcbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG5leHBvcnRzLmV2ZW50c0Vycm9ySGFuZGxlciA9IGV2ZW50c0Vycm9ySGFuZGxlcjtcbmV4cG9ydHMudXBwZXJTbmFrZSA9IHVwcGVyU25ha2U7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX3dyYXBOYXRpdmVTdXBlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgVW5rbm93bkVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShVbmtub3duRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihVbmtub3duRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFVua25vd25FcnJvcihlcnJvcikge1xuICAgIHZhciBfbWVzc2FnZTtcblxuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVua25vd25FcnJvcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAoX21lc3NhZ2UgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgIT09IG51bGwgJiYgX21lc3NhZ2UgIT09IHZvaWQgMCA/IF9tZXNzYWdlIDogZXJyb3IpO1xuICAgIF90aGlzLm5hbWUgPSBcIlVua25vd25FcnJvclwiO1xuICAgIF90aGlzLmNvZGUgPSBlcnJvci5jb2RlO1xuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIF90aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVW5rbm93bkVycm9yLCBbe1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVW5rbm93bkVycm9yO1xufSgoMCwgX3dyYXBOYXRpdmVTdXBlcjIuZGVmYXVsdCkoRXJyb3IpKTtcblxuZXhwb3J0cy5Vbmtub3duRXJyb3IgPSBVbmtub3duRXJyb3I7XG5cbnZhciBPQXV0aENhbGxiYWNrRXJyb3IgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShPQXV0aENhbGxiYWNrRXJyb3IsIF9Vbmtub3duRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKE9BdXRoQ2FsbGJhY2tFcnJvcik7XG5cbiAgZnVuY3Rpb24gT0F1dGhDYWxsYmFja0Vycm9yKCkge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBPQXV0aENhbGxiYWNrRXJyb3IpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzMiA9IF9zdXBlcjIuY2FsbC5hcHBseShfc3VwZXIyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMyKSwgXCJuYW1lXCIsIFwiT0F1dGhDYWxsYmFja0Vycm9yXCIpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoT0F1dGhDYWxsYmFja0Vycm9yKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5PQXV0aENhbGxiYWNrRXJyb3IgPSBPQXV0aENhbGxiYWNrRXJyb3I7XG5cbnZhciBBY2NvdW50Tm90TGlua2VkRXJyb3IgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoQWNjb3VudE5vdExpbmtlZEVycm9yLCBfVW5rbm93bkVycm9yMik7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoQWNjb3VudE5vdExpbmtlZEVycm9yKTtcblxuICBmdW5jdGlvbiBBY2NvdW50Tm90TGlua2VkRXJyb3IoKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEFjY291bnROb3RMaW5rZWRFcnJvcik7XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBfdGhpczMgPSBfc3VwZXIzLmNhbGwuYXBwbHkoX3N1cGVyMywgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMyksIFwibmFtZVwiLCBcIkFjY291bnROb3RMaW5rZWRFcnJvclwiKTtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEFjY291bnROb3RMaW5rZWRFcnJvcik7XG59KFVua25vd25FcnJvcik7XG5cbmV4cG9ydHMuQWNjb3VudE5vdExpbmtlZEVycm9yID0gQWNjb3VudE5vdExpbmtlZEVycm9yO1xuXG52YXIgTWlzc2luZ0FQSVJvdXRlID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3IzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdBUElSb3V0ZSwgX1Vua25vd25FcnJvcjMpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKE1pc3NpbmdBUElSb3V0ZSk7XG5cbiAgZnVuY3Rpb24gTWlzc2luZ0FQSVJvdXRlKCkge1xuICAgIHZhciBfdGhpczQ7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nQVBJUm91dGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgX3RoaXM0ID0gX3N1cGVyNC5jYWxsLmFwcGx5KF9zdXBlcjQsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczQpLCBcIm5hbWVcIiwgXCJNaXNzaW5nQVBJUm91dGVFcnJvclwiKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM0KSwgXCJjb2RlXCIsIFwiTUlTU0lOR19ORVhUQVVUSF9BUElfUk9VVEVfRVJST1JcIik7XG4gICAgcmV0dXJuIF90aGlzNDtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQVBJUm91dGUpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLk1pc3NpbmdBUElSb3V0ZSA9IE1pc3NpbmdBUElSb3V0ZTtcblxudmFyIE1pc3NpbmdTZWNyZXQgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoTWlzc2luZ1NlY3JldCwgX1Vua25vd25FcnJvcjQpO1xuXG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKE1pc3NpbmdTZWNyZXQpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdTZWNyZXQoKSB7XG4gICAgdmFyIF90aGlzNTtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE1pc3NpbmdTZWNyZXQpO1xuXG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuXG4gICAgX3RoaXM1ID0gX3N1cGVyNS5jYWxsLmFwcGx5KF9zdXBlcjUsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczUpLCBcIm5hbWVcIiwgXCJNaXNzaW5nU2VjcmV0RXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNSksIFwiY29kZVwiLCBcIk5PX1NFQ1JFVFwiKTtcbiAgICByZXR1cm4gX3RoaXM1O1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE1pc3NpbmdTZWNyZXQpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLk1pc3NpbmdTZWNyZXQgPSBNaXNzaW5nU2VjcmV0O1xuXG52YXIgTWlzc2luZ0F1dGhvcml6ZSA9IGZ1bmN0aW9uIChfVW5rbm93bkVycm9yNSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShNaXNzaW5nQXV0aG9yaXplLCBfVW5rbm93bkVycm9yNSk7XG5cbiAgdmFyIF9zdXBlcjYgPSBfY3JlYXRlU3VwZXIoTWlzc2luZ0F1dGhvcml6ZSk7XG5cbiAgZnVuY3Rpb24gTWlzc2luZ0F1dGhvcml6ZSgpIHtcbiAgICB2YXIgX3RoaXM2O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTWlzc2luZ0F1dGhvcml6ZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICB9XG5cbiAgICBfdGhpczYgPSBfc3VwZXI2LmNhbGwuYXBwbHkoX3N1cGVyNiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNiksIFwibmFtZVwiLCBcIk1pc3NpbmdBdXRob3JpemVFcnJvclwiKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM2KSwgXCJjb2RlXCIsIFwiQ0FMTEJBQ0tfQ1JFREVOVElBTFNfSEFORExFUl9FUlJPUlwiKTtcbiAgICByZXR1cm4gX3RoaXM2O1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE1pc3NpbmdBdXRob3JpemUpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLk1pc3NpbmdBdXRob3JpemUgPSBNaXNzaW5nQXV0aG9yaXplO1xuXG52YXIgTWlzc2luZ0FkYXB0ZXIgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjYpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoTWlzc2luZ0FkYXB0ZXIsIF9Vbmtub3duRXJyb3I2KTtcblxuICB2YXIgX3N1cGVyNyA9IF9jcmVhdGVTdXBlcihNaXNzaW5nQWRhcHRlcik7XG5cbiAgZnVuY3Rpb24gTWlzc2luZ0FkYXB0ZXIoKSB7XG4gICAgdmFyIF90aGlzNztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE1pc3NpbmdBZGFwdGVyKTtcblxuICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgIH1cblxuICAgIF90aGlzNyA9IF9zdXBlcjcuY2FsbC5hcHBseShfc3VwZXI3LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM3KSwgXCJuYW1lXCIsIFwiTWlzc2luZ0FkYXB0ZXJFcnJvclwiKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM3KSwgXCJjb2RlXCIsIFwiRU1BSUxfUkVRVUlSRVNfQURBUFRFUl9FUlJPUlwiKTtcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE1pc3NpbmdBZGFwdGVyKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nQWRhcHRlciA9IE1pc3NpbmdBZGFwdGVyO1xuXG52YXIgTWlzc2luZ0FkYXB0ZXJNZXRob2RzID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I3KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdBZGFwdGVyTWV0aG9kcywgX1Vua25vd25FcnJvcjcpO1xuXG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKE1pc3NpbmdBZGFwdGVyTWV0aG9kcyk7XG5cbiAgZnVuY3Rpb24gTWlzc2luZ0FkYXB0ZXJNZXRob2RzKCkge1xuICAgIHZhciBfdGhpczg7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nQWRhcHRlck1ldGhvZHMpO1xuXG4gICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgfVxuXG4gICAgX3RoaXM4ID0gX3N1cGVyOC5jYWxsLmFwcGx5KF9zdXBlcjgsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczgpLCBcIm5hbWVcIiwgXCJNaXNzaW5nQWRhcHRlck1ldGhvZHNFcnJvclwiKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM4KSwgXCJjb2RlXCIsIFwiTUlTU0lOR19BREFQVEVSX01FVEhPRFNfRVJST1JcIik7XG4gICAgcmV0dXJuIF90aGlzODtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQWRhcHRlck1ldGhvZHMpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLk1pc3NpbmdBZGFwdGVyTWV0aG9kcyA9IE1pc3NpbmdBZGFwdGVyTWV0aG9kcztcblxudmFyIFVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjgpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVW5zdXBwb3J0ZWRTdHJhdGVneSwgX1Vua25vd25FcnJvcjgpO1xuXG4gIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xuXG4gIGZ1bmN0aW9uIFVuc3VwcG9ydGVkU3RyYXRlZ3koKSB7XG4gICAgdmFyIF90aGlzOTtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xuXG4gICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgfVxuXG4gICAgX3RoaXM5ID0gX3N1cGVyOS5jYWxsLmFwcGx5KF9zdXBlcjksIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczkpLCBcIm5hbWVcIiwgXCJVbnN1cHBvcnRlZFN0cmF0ZWd5RXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzOSksIFwiY29kZVwiLCBcIkNBTExCQUNLX0NSRURFTlRJQUxTX0pXVF9FUlJPUlwiKTtcbiAgICByZXR1cm4gX3RoaXM5O1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLlVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBVbnN1cHBvcnRlZFN0cmF0ZWd5O1xuXG52YXIgSW52YWxpZENhbGxiYWNrVXJsID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I5KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludmFsaWRDYWxsYmFja1VybCwgX1Vua25vd25FcnJvcjkpO1xuXG4gIHZhciBfc3VwZXIxMCA9IF9jcmVhdGVTdXBlcihJbnZhbGlkQ2FsbGJhY2tVcmwpO1xuXG4gIGZ1bmN0aW9uIEludmFsaWRDYWxsYmFja1VybCgpIHtcbiAgICB2YXIgX3RoaXMxMDtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludmFsaWRDYWxsYmFja1VybCk7XG5cbiAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIHtcbiAgICAgIGFyZ3NbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICB9XG5cbiAgICBfdGhpczEwID0gX3N1cGVyMTAuY2FsbC5hcHBseShfc3VwZXIxMCwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMTApLCBcIm5hbWVcIiwgXCJJbnZhbGlkQ2FsbGJhY2tVcmxcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMTApLCBcImNvZGVcIiwgXCJJTlZBTElEX0NBTExCQUNLX1VSTF9FUlJPUlwiKTtcbiAgICByZXR1cm4gX3RoaXMxMDtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShJbnZhbGlkQ2FsbGJhY2tVcmwpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLkludmFsaWRDYWxsYmFja1VybCA9IEludmFsaWRDYWxsYmFja1VybDtcblxuZnVuY3Rpb24gdXBwZXJTbmFrZShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyhbQS1aXSkvZywgXCJfJDFcIikudG9VcHBlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzWzBdLnRvVXBwZXJDYXNlKCkpLmNvbmNhdChzLnNsaWNlKDEpKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzRXJyb3JIYW5kbGVyKG1ldGhvZHMsIGxvZ2dlcikge1xuICByZXR1cm4gT2JqZWN0LmtleXMobWV0aG9kcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5hbWUpIHtcbiAgICBhY2NbbmFtZV0gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHZhciBtZXRob2QsXG4gICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZHNbbmFtZV07XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHZvaWQgMCwgX2FyZ3MpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDc7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiXCIuY29uY2F0KHVwcGVyU25ha2UobmFtZSksIFwiX0VWRU5UX0VSUk9SXCIpLCBfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzAsIDddXSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gYWRhcHRlckVycm9ySGFuZGxlcihhZGFwdGVyLCBsb2dnZXIpIHtcbiAgaWYgKCFhZGFwdGVyKSByZXR1cm47XG4gIHJldHVybiBPYmplY3Qua2V5cyhhZGFwdGVyKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbmFtZSkge1xuICAgIGFjY1tuYW1lXSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHZhciBfbGVuMTAsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBfa2V5MTAsXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGUsXG4gICAgICAgICAgX2FyZ3MyID0gYXJndW1lbnRzO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcblxuICAgICAgICAgICAgICBmb3IgKF9sZW4xMCA9IF9hcmdzMi5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEwKSwgX2tleTEwID0gMDsgX2tleTEwIDwgX2xlbjEwOyBfa2V5MTArKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleTEwXSA9IF9hcmdzMltfa2V5MTBdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYWRhcHRlcl9cIi5jb25jYXQobmFtZSksIHtcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtZXRob2QgPSBhZGFwdGVyW25hbWVdO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodm9pZCAwLCBhcmdzKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA5O1xuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiYWRhcHRlcl9lcnJvcl9cIi5jb25jYXQobmFtZSksIF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIGUgPSBuZXcgVW5rbm93bkVycm9yKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIGUubmFtZSA9IFwiXCIuY29uY2F0KGNhcGl0YWxpemUobmFtZSksIFwiRXJyb3JcIik7XG4gICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMCwgOV1dKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next-auth/core/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next-auth/react/index.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/typeof.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _exportNames = {\n  SessionContext: true,\n  useSession: true,\n  getSession: true,\n  getCsrfToken: true,\n  getProviders: true,\n  signIn: true,\n  signOut: true,\n  SessionProvider: true\n};\nexports.SessionContext = void 0;\nexports.SessionProvider = SessionProvider;\nexports.getCsrfToken = getCsrfToken;\nexports.getProviders = getProviders;\nexports.getSession = getSession;\nexports.signIn = signIn;\nexports.signOut = signOut;\nexports.useSession = useSession;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"(app-pages-browser)/./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\n\nvar _logger2 = _interopRequireWildcard(__webpack_require__(/*! ../utils/logger */ \"(app-pages-browser)/./node_modules/next-auth/utils/logger.js\"));\n\nvar _parseUrl = _interopRequireDefault(__webpack_require__(/*! ../utils/parse-url */ \"(app-pages-browser)/./node_modules/next-auth/utils/parse-url.js\"));\n\nvar _utils = __webpack_require__(/*! ../client/_utils */ \"(app-pages-browser)/./node_modules/next-auth/client/_utils.js\");\n\nvar _jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n\nvar _types = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/next-auth/react/types.js\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _process$env$NEXTAUTH, _ref, _process$env$NEXTAUTH2, _process$env$NEXTAUTH3, _React$createContext;\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar __NEXTAUTH = {\n  baseUrl: (0, _parseUrl.default)((_process$env$NEXTAUTH = process.env.NEXTAUTH_URL) !== null && _process$env$NEXTAUTH !== void 0 ? _process$env$NEXTAUTH : process.env.VERCEL_URL).origin,\n  basePath: (0, _parseUrl.default)(process.env.NEXTAUTH_URL).path,\n  baseUrlServer: (0, _parseUrl.default)((_ref = (_process$env$NEXTAUTH2 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH2 !== void 0 ? _process$env$NEXTAUTH2 : process.env.NEXTAUTH_URL) !== null && _ref !== void 0 ? _ref : process.env.VERCEL_URL).origin,\n  basePathServer: (0, _parseUrl.default)((_process$env$NEXTAUTH3 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH3 !== void 0 ? _process$env$NEXTAUTH3 : process.env.NEXTAUTH_URL).path,\n  _lastSync: 0,\n  _session: undefined,\n  _getSession: function _getSession() {}\n};\nvar broadcast = (0, _utils.BroadcastChannel)();\nvar logger = (0, _logger2.proxyLogger)(_logger2.default, __NEXTAUTH.basePath);\n\nfunction useOnline() {\n  var _React$useState = React.useState(typeof navigator !== \"undefined\" ? navigator.onLine : false),\n      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),\n      isOnline = _React$useState2[0],\n      setIsOnline = _React$useState2[1];\n\n  var setOnline = function setOnline() {\n    return setIsOnline(true);\n  };\n\n  var setOffline = function setOffline() {\n    return setIsOnline(false);\n  };\n\n  React.useEffect(function () {\n    window.addEventListener(\"online\", setOnline);\n    window.addEventListener(\"offline\", setOffline);\n    return function () {\n      window.removeEventListener(\"online\", setOnline);\n      window.removeEventListener(\"offline\", setOffline);\n    };\n  }, []);\n  return isOnline;\n}\n\nvar SessionContext = (_React$createContext = React.createContext) === null || _React$createContext === void 0 ? void 0 : _React$createContext.call(React, undefined);\nexports.SessionContext = SessionContext;\n\nfunction useSession(options) {\n  if (!SessionContext) {\n    throw new Error(\"React Context is unavailable in Server Components\");\n  }\n\n  var value = React.useContext(SessionContext);\n\n  if (!value && \"development\" !== \"production\") {\n    throw new Error(\"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\");\n  }\n\n  var _ref2 = options !== null && options !== void 0 ? options : {},\n      required = _ref2.required,\n      onUnauthenticated = _ref2.onUnauthenticated;\n\n  var requiredAndNotLoading = required && value.status === \"unauthenticated\";\n  React.useEffect(function () {\n    if (requiredAndNotLoading) {\n      var url = \"/api/auth/signin?\".concat(new URLSearchParams({\n        error: \"SessionRequired\",\n        callbackUrl: window.location.href\n      }));\n      if (onUnauthenticated) onUnauthenticated();else window.location.href = url;\n    }\n  }, [requiredAndNotLoading, onUnauthenticated]);\n\n  if (requiredAndNotLoading) {\n    return {\n      data: value.data,\n      update: value.update,\n      status: \"loading\"\n    };\n  }\n\n  return value;\n}\n\nfunction getSession(_x) {\n  return _getSession2.apply(this, arguments);\n}\n\nfunction _getSession2() {\n  _getSession2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(params) {\n    var _params$broadcast;\n\n    var session;\n    return _regenerator.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return (0, _utils.fetchData)(\"session\", __NEXTAUTH, logger, params);\n\n          case 2:\n            session = _context3.sent;\n\n            if ((_params$broadcast = params === null || params === void 0 ? void 0 : params.broadcast) !== null && _params$broadcast !== void 0 ? _params$broadcast : true) {\n              broadcast.post({\n                event: \"session\",\n                data: {\n                  trigger: \"getSession\"\n                }\n              });\n            }\n\n            return _context3.abrupt(\"return\", session);\n\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getSession2.apply(this, arguments);\n}\n\nfunction getCsrfToken(_x2) {\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction _getCsrfToken() {\n  _getCsrfToken = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(params) {\n    var response;\n    return _regenerator.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return (0, _utils.fetchData)(\"csrf\", __NEXTAUTH, logger, params);\n\n          case 2:\n            response = _context4.sent;\n            return _context4.abrupt(\"return\", response === null || response === void 0 ? void 0 : response.csrfToken);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction getProviders() {\n  return _getProviders.apply(this, arguments);\n}\n\nfunction _getProviders() {\n  _getProviders = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5() {\n    return _regenerator.default.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return (0, _utils.fetchData)(\"providers\", __NEXTAUTH, logger);\n\n          case 2:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _getProviders.apply(this, arguments);\n}\n\nfunction signIn(_x3, _x4, _x5) {\n  return _signIn.apply(this, arguments);\n}\n\nfunction _signIn() {\n  _signIn = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(provider, options, authorizationParams) {\n    var _ref5, _ref5$callbackUrl, callbackUrl, _ref5$redirect, redirect, baseUrl, providers, isCredentials, isEmail, isSupportingReturn, signInUrl, _signInUrl, res, data, _data$url, url, error;\n\n    return _regenerator.default.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _ref5 = options !== null && options !== void 0 ? options : {}, _ref5$callbackUrl = _ref5.callbackUrl, callbackUrl = _ref5$callbackUrl === void 0 ? window.location.href : _ref5$callbackUrl, _ref5$redirect = _ref5.redirect, redirect = _ref5$redirect === void 0 ? true : _ref5$redirect;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context6.next = 4;\n            return getProviders();\n\n          case 4:\n            providers = _context6.sent;\n\n            if (providers) {\n              _context6.next = 8;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/error\");\n            return _context6.abrupt(\"return\");\n\n          case 8:\n            if (!(!provider || !(provider in providers))) {\n              _context6.next = 11;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/signin?\").concat(new URLSearchParams({\n              callbackUrl: callbackUrl\n            }));\n            return _context6.abrupt(\"return\");\n\n          case 11:\n            isCredentials = providers[provider].type === \"credentials\";\n            isEmail = providers[provider].type === \"email\";\n            isSupportingReturn = isCredentials || isEmail;\n            signInUrl = \"\".concat(baseUrl, \"/\").concat(isCredentials ? \"callback\" : \"signin\", \"/\").concat(provider);\n            _signInUrl = \"\".concat(signInUrl).concat(authorizationParams ? \"?\".concat(new URLSearchParams(authorizationParams)) : \"\");\n            _context6.t0 = fetch;\n            _context6.t1 = _signInUrl;\n            _context6.t2 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context6.t3 = URLSearchParams;\n            _context6.t4 = _objectSpread;\n            _context6.t5 = _objectSpread({}, options);\n            _context6.t6 = {};\n            _context6.next = 25;\n            return getCsrfToken();\n\n          case 25:\n            _context6.t7 = _context6.sent;\n            _context6.t8 = callbackUrl;\n            _context6.t9 = {\n              csrfToken: _context6.t7,\n              callbackUrl: _context6.t8,\n              json: true\n            };\n            _context6.t10 = (0, _context6.t4)(_context6.t5, _context6.t6, _context6.t9);\n            _context6.t11 = new _context6.t3(_context6.t10);\n            _context6.t12 = {\n              method: \"post\",\n              headers: _context6.t2,\n              body: _context6.t11\n            };\n            _context6.next = 33;\n            return (0, _context6.t0)(_context6.t1, _context6.t12);\n\n          case 33:\n            res = _context6.sent;\n            _context6.next = 36;\n            return res.json();\n\n          case 36:\n            data = _context6.sent;\n\n            if (!(redirect || !isSupportingReturn)) {\n              _context6.next = 42;\n              break;\n            }\n\n            url = (_data$url = data.url) !== null && _data$url !== void 0 ? _data$url : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context6.abrupt(\"return\");\n\n          case 42:\n            error = new URL(data.url).searchParams.get(\"error\");\n\n            if (!res.ok) {\n              _context6.next = 46;\n              break;\n            }\n\n            _context6.next = 46;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 46:\n            return _context6.abrupt(\"return\", {\n              error: error,\n              status: res.status,\n              ok: res.ok,\n              url: error ? null : data.url\n            });\n\n          case 47:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _signIn.apply(this, arguments);\n}\n\nfunction signOut(_x6) {\n  return _signOut.apply(this, arguments);\n}\n\nfunction _signOut() {\n  _signOut = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7(options) {\n    var _options$redirect;\n\n    var _ref6, _ref6$callbackUrl, callbackUrl, baseUrl, fetchOptions, res, data, _data$url2, url;\n\n    return _regenerator.default.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _ref6 = options !== null && options !== void 0 ? options : {}, _ref6$callbackUrl = _ref6.callbackUrl, callbackUrl = _ref6$callbackUrl === void 0 ? window.location.href : _ref6$callbackUrl;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context7.t0 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context7.t1 = URLSearchParams;\n            _context7.next = 6;\n            return getCsrfToken();\n\n          case 6:\n            _context7.t2 = _context7.sent;\n            _context7.t3 = callbackUrl;\n            _context7.t4 = {\n              csrfToken: _context7.t2,\n              callbackUrl: _context7.t3,\n              json: true\n            };\n            _context7.t5 = new _context7.t1(_context7.t4);\n            fetchOptions = {\n              method: \"post\",\n              headers: _context7.t0,\n              body: _context7.t5\n            };\n            _context7.next = 13;\n            return fetch(\"\".concat(baseUrl, \"/signout\"), fetchOptions);\n\n          case 13:\n            res = _context7.sent;\n            _context7.next = 16;\n            return res.json();\n\n          case 16:\n            data = _context7.sent;\n            broadcast.post({\n              event: \"session\",\n              data: {\n                trigger: \"signout\"\n              }\n            });\n\n            if (!((_options$redirect = options === null || options === void 0 ? void 0 : options.redirect) !== null && _options$redirect !== void 0 ? _options$redirect : true)) {\n              _context7.next = 23;\n              break;\n            }\n\n            url = (_data$url2 = data.url) !== null && _data$url2 !== void 0 ? _data$url2 : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context7.abrupt(\"return\");\n\n          case 23:\n            _context7.next = 25;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 25:\n            return _context7.abrupt(\"return\", data);\n\n          case 26:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _signOut.apply(this, arguments);\n}\n\nfunction SessionProvider(props) {\n  if (!SessionContext) {\n    throw new Error(\"React Context is unavailable in Server Components\");\n  }\n\n  var children = props.children,\n      basePath = props.basePath,\n      refetchInterval = props.refetchInterval,\n      refetchWhenOffline = props.refetchWhenOffline;\n  if (basePath) __NEXTAUTH.basePath = basePath;\n  var hasInitialSession = props.session !== undefined;\n  __NEXTAUTH._lastSync = hasInitialSession ? (0, _utils.now)() : 0;\n\n  var _React$useState3 = React.useState(function () {\n    if (hasInitialSession) __NEXTAUTH._session = props.session;\n    return props.session;\n  }),\n      _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),\n      session = _React$useState4[0],\n      setSession = _React$useState4[1];\n\n  var _React$useState5 = React.useState(!hasInitialSession),\n      _React$useState6 = (0, _slicedToArray2.default)(_React$useState5, 2),\n      loading = _React$useState6[0],\n      setLoading = _React$useState6[1];\n\n  React.useEffect(function () {\n    __NEXTAUTH._getSession = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var _ref4,\n          event,\n          storageEvent,\n          _args = arguments;\n\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _ref4 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, event = _ref4.event;\n              _context.prev = 1;\n              storageEvent = event === \"storage\";\n\n              if (!(storageEvent || __NEXTAUTH._session === undefined)) {\n                _context.next = 10;\n                break;\n              }\n\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 7;\n              return getSession({\n                broadcast: !storageEvent\n              });\n\n            case 7:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              return _context.abrupt(\"return\");\n\n            case 10:\n              if (!(!event || __NEXTAUTH._session === null || (0, _utils.now)() < __NEXTAUTH._lastSync)) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 12:\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 15;\n              return getSession();\n\n            case 15:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              _context.next = 22;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t0 = _context[\"catch\"](1);\n              logger.error(\"CLIENT_SESSION_ERROR\", _context.t0);\n\n            case 22:\n              _context.prev = 22;\n              setLoading(false);\n              return _context.finish(22);\n\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 19, 22, 25]]);\n    }));\n\n    __NEXTAUTH._getSession();\n\n    return function () {\n      __NEXTAUTH._lastSync = 0;\n      __NEXTAUTH._session = undefined;\n\n      __NEXTAUTH._getSession = function () {};\n    };\n  }, []);\n  React.useEffect(function () {\n    var unsubscribe = broadcast.receive(function () {\n      return __NEXTAUTH._getSession({\n        event: \"storage\"\n      });\n    });\n    return function () {\n      return unsubscribe();\n    };\n  }, []);\n  React.useEffect(function () {\n    var _props$refetchOnWindo = props.refetchOnWindowFocus,\n        refetchOnWindowFocus = _props$refetchOnWindo === void 0 ? true : _props$refetchOnWindo;\n\n    var visibilityHandler = function visibilityHandler() {\n      if (refetchOnWindowFocus && document.visibilityState === \"visible\") __NEXTAUTH._getSession({\n        event: \"visibilitychange\"\n      });\n    };\n\n    document.addEventListener(\"visibilitychange\", visibilityHandler, false);\n    return function () {\n      return document.removeEventListener(\"visibilitychange\", visibilityHandler, false);\n    };\n  }, [props.refetchOnWindowFocus]);\n  var isOnline = useOnline();\n  var shouldRefetch = refetchWhenOffline !== false || isOnline;\n  React.useEffect(function () {\n    if (refetchInterval && shouldRefetch) {\n      var refetchIntervalTimer = setInterval(function () {\n        if (__NEXTAUTH._session) {\n          __NEXTAUTH._getSession({\n            event: \"poll\"\n          });\n        }\n      }, refetchInterval * 1000);\n      return function () {\n        return clearInterval(refetchIntervalTimer);\n      };\n    }\n  }, [refetchInterval, shouldRefetch]);\n  var value = React.useMemo(function () {\n    return {\n      data: session,\n      status: loading ? \"loading\" : session ? \"authenticated\" : \"unauthenticated\",\n      update: function update(data) {\n        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {\n          var newSession;\n          return _regenerator.default.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(loading || !session)) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 2:\n                  setLoading(true);\n                  _context2.t0 = _utils.fetchData;\n                  _context2.t1 = __NEXTAUTH;\n                  _context2.t2 = logger;\n                  _context2.next = 8;\n                  return getCsrfToken();\n\n                case 8:\n                  _context2.t3 = _context2.sent;\n                  _context2.t4 = data;\n                  _context2.t5 = {\n                    csrfToken: _context2.t3,\n                    data: _context2.t4\n                  };\n                  _context2.t6 = {\n                    body: _context2.t5\n                  };\n                  _context2.t7 = {\n                    req: _context2.t6\n                  };\n                  _context2.next = 15;\n                  return (0, _context2.t0)(\"session\", _context2.t1, _context2.t2, _context2.t7);\n\n                case 15:\n                  newSession = _context2.sent;\n                  setLoading(false);\n\n                  if (newSession) {\n                    setSession(newSession);\n                    broadcast.post({\n                      event: \"session\",\n                      data: {\n                        trigger: \"getSession\"\n                      }\n                    });\n                  }\n\n                  return _context2.abrupt(\"return\", newSession);\n\n                case 19:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }))();\n      }\n    };\n  }, [session, loading]);\n  return (0, _jsxRuntime.jsx)(SessionContext.Provider, {\n    value: value,\n    children: children\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvcmVhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLHdJQUE4Qzs7QUFFbkYsY0FBYyxtQkFBTyxDQUFDLDBHQUErQjs7QUFFckQsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxlQUFlO0FBQ2Ysa0JBQWtCOztBQUVsQiwwQ0FBMEMsbUJBQU8sQ0FBQywwR0FBNEI7O0FBRTlFLDhDQUE4QyxtQkFBTyxDQUFDLDBIQUF1Qzs7QUFFN0YsZ0RBQWdELG1CQUFPLENBQUMsOEhBQXlDOztBQUVqRyw2Q0FBNkMsbUJBQU8sQ0FBQyx3SEFBc0M7O0FBRTNGLG9DQUFvQyxtQkFBTyxDQUFDLG1GQUFPOztBQUVuRCx1Q0FBdUMsbUJBQU8sQ0FBQyxxRkFBaUI7O0FBRWhFLHVDQUF1QyxtQkFBTyxDQUFDLDJGQUFvQjs7QUFFbkUsYUFBYSxtQkFBTyxDQUFDLHVGQUFrQjs7QUFFdkMsa0JBQWtCLG1CQUFPLENBQUMscUdBQW1COztBQUU3QyxhQUFhLG1CQUFPLENBQUMsNEVBQVM7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBLGlEQUFpRCxnREFBZ0QsdUNBQXVDLHNDQUFzQyxvRkFBb0YsNERBQTREOztBQUU5VCxxREFBcUQsNkNBQTZDLGNBQWMsOEVBQThFLFNBQVMsa0JBQWtCLG1EQUFtRCwrQkFBK0IseUJBQXlCLGlCQUFpQixzRkFBc0YsdUJBQXVCLDJFQUEyRSxxRkFBcUYsc0NBQXNDLDRDQUE0QyxPQUFPLDhCQUE4QixzQkFBc0IsYUFBYSwwQkFBMEI7O0FBRXR4QiwyQ0FBMkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsNkRBQTZELGlFQUFpRSxzQ0FBc0M7O0FBRXZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELDZEQUE2RCwwREFBMEQsb0tBQW9LLG1GQUFtRixLQUFLOztBQUV4ZjtBQUNBLDJEQUEyRCxPQUFPLDBGQUEwRixPQUFPO0FBQ25LLG1DQUFtQyxPQUFPO0FBQzFDLDBFQUEwRSxPQUFPLHFHQUFxRyxPQUFPLHdEQUF3RCxPQUFPO0FBQzVQLG1FQUFtRSxPQUFPLHFHQUFxRyxPQUFPO0FBQ3RMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLGFBQW9CO0FBQ3BDO0FBQ0E7O0FBRUEsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGlEQUFpRDtBQUNqRDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvcmVhY3QvaW5kZXguanM/YTc1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF9leHBvcnROYW1lcyA9IHtcbiAgU2Vzc2lvbkNvbnRleHQ6IHRydWUsXG4gIHVzZVNlc3Npb246IHRydWUsXG4gIGdldFNlc3Npb246IHRydWUsXG4gIGdldENzcmZUb2tlbjogdHJ1ZSxcbiAgZ2V0UHJvdmlkZXJzOiB0cnVlLFxuICBzaWduSW46IHRydWUsXG4gIHNpZ25PdXQ6IHRydWUsXG4gIFNlc3Npb25Qcm92aWRlcjogdHJ1ZVxufTtcbmV4cG9ydHMuU2Vzc2lvbkNvbnRleHQgPSB2b2lkIDA7XG5leHBvcnRzLlNlc3Npb25Qcm92aWRlciA9IFNlc3Npb25Qcm92aWRlcjtcbmV4cG9ydHMuZ2V0Q3NyZlRva2VuID0gZ2V0Q3NyZlRva2VuO1xuZXhwb3J0cy5nZXRQcm92aWRlcnMgPSBnZXRQcm92aWRlcnM7XG5leHBvcnRzLmdldFNlc3Npb24gPSBnZXRTZXNzaW9uO1xuZXhwb3J0cy5zaWduSW4gPSBzaWduSW47XG5leHBvcnRzLnNpZ25PdXQgPSBzaWduT3V0O1xuZXhwb3J0cy51c2VTZXNzaW9uID0gdXNlU2Vzc2lvbjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXlcIikpO1xuXG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vdXRpbHMvbG9nZ2VyXCIpKTtcblxudmFyIF9wYXJzZVVybCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL3BhcnNlLXVybFwiKSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vY2xpZW50L191dGlsc1wiKTtcblxudmFyIF9qc3hSdW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbk9iamVjdC5rZXlzKF90eXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3R5cGVzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX3R5cGVzW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX3Byb2Nlc3MkZW52JE5FWFRBVVRILCBfcmVmLCBfcHJvY2VzcyRlbnYkTkVYVEFVVEgyLCBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzLCBfUmVhY3QkY3JlYXRlQ29udGV4dDtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBfX05FWFRBVVRIID0ge1xuICBiYXNlVXJsOiAoMCwgX3BhcnNlVXJsLmRlZmF1bHQpKChfcHJvY2VzcyRlbnYkTkVYVEFVVEggPSBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpICE9PSBudWxsICYmIF9wcm9jZXNzJGVudiRORVhUQVVUSCAhPT0gdm9pZCAwID8gX3Byb2Nlc3MkZW52JE5FWFRBVVRIIDogcHJvY2Vzcy5lbnYuVkVSQ0VMX1VSTCkub3JpZ2luLFxuICBiYXNlUGF0aDogKDAsIF9wYXJzZVVybC5kZWZhdWx0KShwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpLnBhdGgsXG4gIGJhc2VVcmxTZXJ2ZXI6ICgwLCBfcGFyc2VVcmwuZGVmYXVsdCkoKF9yZWYgPSAoX3Byb2Nlc3MkZW52JE5FWFRBVVRIMiA9IHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTF9JTlRFUk5BTCkgIT09IG51bGwgJiYgX3Byb2Nlc3MkZW52JE5FWFRBVVRIMiAhPT0gdm9pZCAwID8gX3Byb2Nlc3MkZW52JE5FWFRBVVRIMiA6IHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpLm9yaWdpbixcbiAgYmFzZVBhdGhTZXJ2ZXI6ICgwLCBfcGFyc2VVcmwuZGVmYXVsdCkoKF9wcm9jZXNzJGVudiRORVhUQVVUSDMgPSBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkxfSU5URVJOQUwpICE9PSBudWxsICYmIF9wcm9jZXNzJGVudiRORVhUQVVUSDMgIT09IHZvaWQgMCA/IF9wcm9jZXNzJGVudiRORVhUQVVUSDMgOiBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpLnBhdGgsXG4gIF9sYXN0U3luYzogMCxcbiAgX3Nlc3Npb246IHVuZGVmaW5lZCxcbiAgX2dldFNlc3Npb246IGZ1bmN0aW9uIF9nZXRTZXNzaW9uKCkge31cbn07XG52YXIgYnJvYWRjYXN0ID0gKDAsIF91dGlscy5Ccm9hZGNhc3RDaGFubmVsKSgpO1xudmFyIGxvZ2dlciA9ICgwLCBfbG9nZ2VyMi5wcm94eUxvZ2dlcikoX2xvZ2dlcjIuZGVmYXVsdCwgX19ORVhUQVVUSC5iYXNlUGF0aCk7XG5cbmZ1bmN0aW9uIHVzZU9ubGluZSgpIHtcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3Iub25MaW5lIDogZmFsc2UpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgIGlzT25saW5lID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldElzT25saW5lID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICB2YXIgc2V0T25saW5lID0gZnVuY3Rpb24gc2V0T25saW5lKCkge1xuICAgIHJldHVybiBzZXRJc09ubGluZSh0cnVlKTtcbiAgfTtcblxuICB2YXIgc2V0T2ZmbGluZSA9IGZ1bmN0aW9uIHNldE9mZmxpbmUoKSB7XG4gICAgcmV0dXJuIHNldElzT25saW5lKGZhbHNlKTtcbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIHNldE9ubGluZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIHNldE9mZmxpbmUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBzZXRPbmxpbmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIHNldE9mZmxpbmUpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzT25saW5lO1xufVxuXG52YXIgU2Vzc2lvbkNvbnRleHQgPSAoX1JlYWN0JGNyZWF0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KSA9PT0gbnVsbCB8fCBfUmVhY3QkY3JlYXRlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX1JlYWN0JGNyZWF0ZUNvbnRleHQuY2FsbChSZWFjdCwgdW5kZWZpbmVkKTtcbmV4cG9ydHMuU2Vzc2lvbkNvbnRleHQgPSBTZXNzaW9uQ29udGV4dDtcblxuZnVuY3Rpb24gdXNlU2Vzc2lvbihvcHRpb25zKSB7XG4gIGlmICghU2Vzc2lvbkNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBDb250ZXh0IGlzIHVuYXZhaWxhYmxlIGluIFNlcnZlciBDb21wb25lbnRzXCIpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChTZXNzaW9uQ29udGV4dCk7XG5cbiAgaWYgKCF2YWx1ZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbmV4dC1hdXRoXTogYHVzZVNlc3Npb25gIG11c3QgYmUgd3JhcHBlZCBpbiBhIDxTZXNzaW9uUHJvdmlkZXIgLz5cIik7XG4gIH1cblxuICB2YXIgX3JlZjIgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSxcbiAgICAgIHJlcXVpcmVkID0gX3JlZjIucmVxdWlyZWQsXG4gICAgICBvblVuYXV0aGVudGljYXRlZCA9IF9yZWYyLm9uVW5hdXRoZW50aWNhdGVkO1xuXG4gIHZhciByZXF1aXJlZEFuZE5vdExvYWRpbmcgPSByZXF1aXJlZCAmJiB2YWx1ZS5zdGF0dXMgPT09IFwidW5hdXRoZW50aWNhdGVkXCI7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlcXVpcmVkQW5kTm90TG9hZGluZykge1xuICAgICAgdmFyIHVybCA9IFwiL2FwaS9hdXRoL3NpZ25pbj9cIi5jb25jYXQobmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGVycm9yOiBcIlNlc3Npb25SZXF1aXJlZFwiLFxuICAgICAgICBjYWxsYmFja1VybDogd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgIH0pKTtcbiAgICAgIGlmIChvblVuYXV0aGVudGljYXRlZCkgb25VbmF1dGhlbnRpY2F0ZWQoKTtlbHNlIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgIH1cbiAgfSwgW3JlcXVpcmVkQW5kTm90TG9hZGluZywgb25VbmF1dGhlbnRpY2F0ZWRdKTtcblxuICBpZiAocmVxdWlyZWRBbmROb3RMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICB1cGRhdGU6IHZhbHVlLnVwZGF0ZSxcbiAgICAgIHN0YXR1czogXCJsb2FkaW5nXCJcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRTZXNzaW9uKF94KSB7XG4gIHJldHVybiBfZ2V0U2Vzc2lvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFNlc3Npb24yKCkge1xuICBfZ2V0U2Vzc2lvbjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMocGFyYW1zKSB7XG4gICAgdmFyIF9wYXJhbXMkYnJvYWRjYXN0O1xuXG4gICAgdmFyIHNlc3Npb247XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuZmV0Y2hEYXRhKShcInNlc3Npb25cIiwgX19ORVhUQVVUSCwgbG9nZ2VyLCBwYXJhbXMpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgc2Vzc2lvbiA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICBpZiAoKF9wYXJhbXMkYnJvYWRjYXN0ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJyb2FkY2FzdCkgIT09IG51bGwgJiYgX3BhcmFtcyRicm9hZGNhc3QgIT09IHZvaWQgMCA/IF9wYXJhbXMkYnJvYWRjYXN0IDogdHJ1ZSkge1xuICAgICAgICAgICAgICBicm9hZGNhc3QucG9zdCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwic2Vzc2lvblwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IFwiZ2V0U2Vzc2lvblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgc2Vzc2lvbik7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRTZXNzaW9uMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRDc3JmVG9rZW4oX3gyKSB7XG4gIHJldHVybiBfZ2V0Q3NyZlRva2VuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRDc3JmVG9rZW4oKSB7XG4gIF9nZXRDc3JmVG9rZW4gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQocGFyYW1zKSB7XG4gICAgdmFyIHJlc3BvbnNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmZldGNoRGF0YSkoXCJjc3JmXCIsIF9fTkVYVEFVVEgsIGxvZ2dlciwgcGFyYW1zKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuY3NyZlRva2VuKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2dldENzcmZUb2tlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm92aWRlcnMoKSB7XG4gIHJldHVybiBfZ2V0UHJvdmlkZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm92aWRlcnMoKSB7XG4gIF9nZXRQcm92aWRlcnMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuZmV0Y2hEYXRhKShcInByb3ZpZGVyc1wiLCBfX05FWFRBVVRILCBsb2dnZXIpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ1LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UHJvdmlkZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNpZ25JbihfeDMsIF94NCwgX3g1KSB7XG4gIHJldHVybiBfc2lnbkluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zaWduSW4oKSB7XG4gIF9zaWduSW4gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYocHJvdmlkZXIsIG9wdGlvbnMsIGF1dGhvcml6YXRpb25QYXJhbXMpIHtcbiAgICB2YXIgX3JlZjUsIF9yZWY1JGNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCwgX3JlZjUkcmVkaXJlY3QsIHJlZGlyZWN0LCBiYXNlVXJsLCBwcm92aWRlcnMsIGlzQ3JlZGVudGlhbHMsIGlzRW1haWwsIGlzU3VwcG9ydGluZ1JldHVybiwgc2lnbkluVXJsLCBfc2lnbkluVXJsLCByZXMsIGRhdGEsIF9kYXRhJHVybCwgdXJsLCBlcnJvcjtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9yZWY1ID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIF9yZWY1JGNhbGxiYWNrVXJsID0gX3JlZjUuY2FsbGJhY2tVcmwsIGNhbGxiYWNrVXJsID0gX3JlZjUkY2FsbGJhY2tVcmwgPT09IHZvaWQgMCA/IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogX3JlZjUkY2FsbGJhY2tVcmwsIF9yZWY1JHJlZGlyZWN0ID0gX3JlZjUucmVkaXJlY3QsIHJlZGlyZWN0ID0gX3JlZjUkcmVkaXJlY3QgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmNSRyZWRpcmVjdDtcbiAgICAgICAgICAgIGJhc2VVcmwgPSAoMCwgX3V0aWxzLmFwaUJhc2VVcmwpKF9fTkVYVEFVVEgpO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGdldFByb3ZpZGVycygpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcHJvdmlkZXJzID0gX2NvbnRleHQ2LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcIlwiLmNvbmNhdChiYXNlVXJsLCBcIi9lcnJvclwiKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgaWYgKCEoIXByb3ZpZGVyIHx8ICEocHJvdmlkZXIgaW4gcHJvdmlkZXJzKSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCJcIi5jb25jYXQoYmFzZVVybCwgXCIvc2lnbmluP1wiKS5jb25jYXQobmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgIGNhbGxiYWNrVXJsOiBjYWxsYmFja1VybFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgaXNDcmVkZW50aWFscyA9IHByb3ZpZGVyc1twcm92aWRlcl0udHlwZSA9PT0gXCJjcmVkZW50aWFsc1wiO1xuICAgICAgICAgICAgaXNFbWFpbCA9IHByb3ZpZGVyc1twcm92aWRlcl0udHlwZSA9PT0gXCJlbWFpbFwiO1xuICAgICAgICAgICAgaXNTdXBwb3J0aW5nUmV0dXJuID0gaXNDcmVkZW50aWFscyB8fCBpc0VtYWlsO1xuICAgICAgICAgICAgc2lnbkluVXJsID0gXCJcIi5jb25jYXQoYmFzZVVybCwgXCIvXCIpLmNvbmNhdChpc0NyZWRlbnRpYWxzID8gXCJjYWxsYmFja1wiIDogXCJzaWduaW5cIiwgXCIvXCIpLmNvbmNhdChwcm92aWRlcik7XG4gICAgICAgICAgICBfc2lnbkluVXJsID0gXCJcIi5jb25jYXQoc2lnbkluVXJsKS5jb25jYXQoYXV0aG9yaXphdGlvblBhcmFtcyA/IFwiP1wiLmNvbmNhdChuZXcgVVJMU2VhcmNoUGFyYW1zKGF1dGhvcml6YXRpb25QYXJhbXMpKSA6IFwiXCIpO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gZmV0Y2g7XG4gICAgICAgICAgICBfY29udGV4dDYudDEgPSBfc2lnbkluVXJsO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQyID0ge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQzID0gVVJMU2VhcmNoUGFyYW1zO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQ0ID0gX29iamVjdFNwcmVhZDtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50NSA9IF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQ2ID0ge307XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI1O1xuICAgICAgICAgICAgcmV0dXJuIGdldENzcmZUb2tlbigpO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIF9jb250ZXh0Ni50NyA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQ4ID0gY2FsbGJhY2tVcmw7XG4gICAgICAgICAgICBfY29udGV4dDYudDkgPSB7XG4gICAgICAgICAgICAgIGNzcmZUb2tlbjogX2NvbnRleHQ2LnQ3LFxuICAgICAgICAgICAgICBjYWxsYmFja1VybDogX2NvbnRleHQ2LnQ4LFxuICAgICAgICAgICAgICBqc29uOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQxMCA9ICgwLCBfY29udGV4dDYudDQpKF9jb250ZXh0Ni50NSwgX2NvbnRleHQ2LnQ2LCBfY29udGV4dDYudDkpO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQxMSA9IG5ldyBfY29udGV4dDYudDMoX2NvbnRleHQ2LnQxMCk7XG4gICAgICAgICAgICBfY29udGV4dDYudDEyID0ge1xuICAgICAgICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBfY29udGV4dDYudDIsXG4gICAgICAgICAgICAgIGJvZHk6IF9jb250ZXh0Ni50MTFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDMzO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfY29udGV4dDYudDApKF9jb250ZXh0Ni50MSwgX2NvbnRleHQ2LnQxMik7XG5cbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDM2O1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG5cbiAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0Ni5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIShyZWRpcmVjdCB8fCAhaXNTdXBwb3J0aW5nUmV0dXJuKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDQyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsID0gKF9kYXRhJHVybCA9IGRhdGEudXJsKSAhPT0gbnVsbCAmJiBfZGF0YSR1cmwgIT09IHZvaWQgMCA/IF9kYXRhJHVybCA6IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICBpZiAodXJsLmluY2x1ZGVzKFwiI1wiKSkgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVVJMKGRhdGEudXJsKS5zZWFyY2hQYXJhbXMuZ2V0KFwiZXJyb3JcIik7XG5cbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDQ2O1xuICAgICAgICAgICAgcmV0dXJuIF9fTkVYVEFVVEguX2dldFNlc3Npb24oe1xuICAgICAgICAgICAgICBldmVudDogXCJzdG9yYWdlXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgIG9rOiByZXMub2ssXG4gICAgICAgICAgICAgIHVybDogZXJyb3IgPyBudWxsIDogZGF0YS51cmxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2KTtcbiAgfSkpO1xuICByZXR1cm4gX3NpZ25Jbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzaWduT3V0KF94Nikge1xuICByZXR1cm4gX3NpZ25PdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3NpZ25PdXQoKSB7XG4gIF9zaWduT3V0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkcmVkaXJlY3Q7XG5cbiAgICB2YXIgX3JlZjYsIF9yZWY2JGNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCwgYmFzZVVybCwgZmV0Y2hPcHRpb25zLCByZXMsIGRhdGEsIF9kYXRhJHVybDIsIHVybDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9yZWY2ID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIF9yZWY2JGNhbGxiYWNrVXJsID0gX3JlZjYuY2FsbGJhY2tVcmwsIGNhbGxiYWNrVXJsID0gX3JlZjYkY2FsbGJhY2tVcmwgPT09IHZvaWQgMCA/IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogX3JlZjYkY2FsbGJhY2tVcmw7XG4gICAgICAgICAgICBiYXNlVXJsID0gKDAsIF91dGlscy5hcGlCYXNlVXJsKShfX05FWFRBVVRIKTtcbiAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0Ny50MSA9IFVSTFNlYXJjaFBhcmFtcztcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiBnZXRDc3JmVG9rZW4oKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9jb250ZXh0Ny50MiA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQzID0gY2FsbGJhY2tVcmw7XG4gICAgICAgICAgICBfY29udGV4dDcudDQgPSB7XG4gICAgICAgICAgICAgIGNzcmZUb2tlbjogX2NvbnRleHQ3LnQyLFxuICAgICAgICAgICAgICBjYWxsYmFja1VybDogX2NvbnRleHQ3LnQzLFxuICAgICAgICAgICAgICBqc29uOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQ1ID0gbmV3IF9jb250ZXh0Ny50MShfY29udGV4dDcudDQpO1xuICAgICAgICAgICAgZmV0Y2hPcHRpb25zID0ge1xuICAgICAgICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBfY29udGV4dDcudDAsXG4gICAgICAgICAgICAgIGJvZHk6IF9jb250ZXh0Ny50NVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTM7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goXCJcIi5jb25jYXQoYmFzZVVybCwgXCIvc2lnbm91dFwiKSwgZmV0Y2hPcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICBicm9hZGNhc3QucG9zdCh7XG4gICAgICAgICAgICAgIGV2ZW50OiBcInNlc3Npb25cIixcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6IFwic2lnbm91dFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoISgoX29wdGlvbnMkcmVkaXJlY3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3QpICE9PSBudWxsICYmIF9vcHRpb25zJHJlZGlyZWN0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRyZWRpcmVjdCA6IHRydWUpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cmwgPSAoX2RhdGEkdXJsMiA9IGRhdGEudXJsKSAhPT0gbnVsbCAmJiBfZGF0YSR1cmwyICE9PSB2b2lkIDAgPyBfZGF0YSR1cmwyIDogY2FsbGJhY2tVcmw7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgIGlmICh1cmwuaW5jbHVkZXMoXCIjXCIpKSB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDI1O1xuICAgICAgICAgICAgcmV0dXJuIF9fTkVYVEFVVEguX2dldFNlc3Npb24oe1xuICAgICAgICAgICAgICBldmVudDogXCJzdG9yYWdlXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU3KTtcbiAgfSkpO1xuICByZXR1cm4gX3NpZ25PdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gU2Vzc2lvblByb3ZpZGVyKHByb3BzKSB7XG4gIGlmICghU2Vzc2lvbkNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBDb250ZXh0IGlzIHVuYXZhaWxhYmxlIGluIFNlcnZlciBDb21wb25lbnRzXCIpO1xuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBiYXNlUGF0aCA9IHByb3BzLmJhc2VQYXRoLFxuICAgICAgcmVmZXRjaEludGVydmFsID0gcHJvcHMucmVmZXRjaEludGVydmFsLFxuICAgICAgcmVmZXRjaFdoZW5PZmZsaW5lID0gcHJvcHMucmVmZXRjaFdoZW5PZmZsaW5lO1xuICBpZiAoYmFzZVBhdGgpIF9fTkVYVEFVVEguYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgdmFyIGhhc0luaXRpYWxTZXNzaW9uID0gcHJvcHMuc2Vzc2lvbiAhPT0gdW5kZWZpbmVkO1xuICBfX05FWFRBVVRILl9sYXN0U3luYyA9IGhhc0luaXRpYWxTZXNzaW9uID8gKDAsIF91dGlscy5ub3cpKCkgOiAwO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIGlmIChoYXNJbml0aWFsU2Vzc2lvbikgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IHByb3BzLnNlc3Npb247XG4gICAgcmV0dXJuIHByb3BzLnNlc3Npb247XG4gIH0pLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlNCA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX1JlYWN0JHVzZVN0YXRlMywgMiksXG4gICAgICBzZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlNFswXSxcbiAgICAgIHNldFNlc3Npb24gPSBfUmVhY3QkdXNlU3RhdGU0WzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGU1ID0gUmVhY3QudXNlU3RhdGUoIWhhc0luaXRpYWxTZXNzaW9uKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTYgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9SZWFjdCR1c2VTdGF0ZTUsIDIpLFxuICAgICAgbG9hZGluZyA9IF9SZWFjdCR1c2VTdGF0ZTZbMF0sXG4gICAgICBzZXRMb2FkaW5nID0gX1JlYWN0JHVzZVN0YXRlNlsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHZhciBfcmVmNCxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBzdG9yYWdlRXZlbnQsXG4gICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfcmVmNCA9IF9hcmdzLmxlbmd0aCA+IDAgJiYgX2FyZ3NbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzBdIDoge30sIGV2ZW50ID0gX3JlZjQuZXZlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICBzdG9yYWdlRXZlbnQgPSBldmVudCA9PT0gXCJzdG9yYWdlXCI7XG5cbiAgICAgICAgICAgICAgaWYgKCEoc3RvcmFnZUV2ZW50IHx8IF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFNlc3Npb24oe1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogIXN0b3JhZ2VFdmVudFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9zZXNzaW9uID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgc2V0U2Vzc2lvbihfX05FWFRBVVRILl9zZXNzaW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgaWYgKCEoIWV2ZW50IHx8IF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IG51bGwgfHwgKDAsIF91dGlscy5ub3cpKCkgPCBfX05FWFRBVVRILl9sYXN0U3luYykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBzZXRTZXNzaW9uKF9fTkVYVEFVVEguX3Nlc3Npb24pO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQ0xJRU5UX1NFU1NJT05fRVJST1JcIiwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjI7XG4gICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIyKTtcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTksIDIyLCAyNV1dKTtcbiAgICB9KSk7XG5cbiAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX19ORVhUQVVUSC5fbGFzdFN5bmMgPSAwO1xuICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBicm9hZGNhc3QucmVjZWl2ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgIGV2ZW50OiBcInN0b3JhZ2VcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Byb3BzJHJlZmV0Y2hPbldpbmRvID0gcHJvcHMucmVmZXRjaE9uV2luZG93Rm9jdXMsXG4gICAgICAgIHJlZmV0Y2hPbldpbmRvd0ZvY3VzID0gX3Byb3BzJHJlZmV0Y2hPbldpbmRvID09PSB2b2lkIDAgPyB0cnVlIDogX3Byb3BzJHJlZmV0Y2hPbldpbmRvO1xuXG4gICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICBpZiAocmVmZXRjaE9uV2luZG93Rm9jdXMgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgIGV2ZW50OiBcInZpc2liaWxpdHljaGFuZ2VcIlxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlIYW5kbGVyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB2aXNpYmlsaXR5SGFuZGxlciwgZmFsc2UpO1xuICAgIH07XG4gIH0sIFtwcm9wcy5yZWZldGNoT25XaW5kb3dGb2N1c10pO1xuICB2YXIgaXNPbmxpbmUgPSB1c2VPbmxpbmUoKTtcbiAgdmFyIHNob3VsZFJlZmV0Y2ggPSByZWZldGNoV2hlbk9mZmxpbmUgIT09IGZhbHNlIHx8IGlzT25saW5lO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWZldGNoSW50ZXJ2YWwgJiYgc2hvdWxkUmVmZXRjaCkge1xuICAgICAgdmFyIHJlZmV0Y2hJbnRlcnZhbFRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX19ORVhUQVVUSC5fc2Vzc2lvbikge1xuICAgICAgICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24oe1xuICAgICAgICAgICAgZXZlbnQ6IFwicG9sbFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJlZmV0Y2hJbnRlcnZhbCAqIDEwMDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwocmVmZXRjaEludGVydmFsVGltZXIpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtyZWZldGNoSW50ZXJ2YWwsIHNob3VsZFJlZmV0Y2hdKTtcbiAgdmFyIHZhbHVlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHNlc3Npb24sXG4gICAgICBzdGF0dXM6IGxvYWRpbmcgPyBcImxvYWRpbmdcIiA6IHNlc3Npb24gPyBcImF1dGhlbnRpY2F0ZWRcIiA6IFwidW5hdXRoZW50aWNhdGVkXCIsXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIHJldHVybiAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgdmFyIG5ld1Nlc3Npb247XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgaWYgKCEobG9hZGluZyB8fCAhc2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX3V0aWxzLmZldGNoRGF0YTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IF9fTkVYVEFVVEg7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIudDIgPSBsb2dnZXI7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q3NyZlRva2VuKCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIudDMgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50NCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIudDUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNzcmZUb2tlbjogX2NvbnRleHQyLnQzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBfY29udGV4dDIudDRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIudDYgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IF9jb250ZXh0Mi50NVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50NyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxOiBfY29udGV4dDIudDZcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfY29udGV4dDIudDApKFwic2Vzc2lvblwiLCBfY29udGV4dDIudDEsIF9jb250ZXh0Mi50MiwgX2NvbnRleHQyLnQ3KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICBuZXdTZXNzaW9uID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld1Nlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2Vzc2lvbihuZXdTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0LnBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcInNlc3Npb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcImdldFNlc3Npb25cIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIG5ld1Nlc3Npb24pO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgfSkpKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3Nlc3Npb24sIGxvYWRpbmddKTtcbiAgcmV0dXJuICgwLCBfanN4UnVudGltZS5qc3gpKFNlc3Npb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next-auth/react/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next-auth/react/types.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/types.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvcmVhY3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvcmVhY3QvdHlwZXMuanM/Y2Q4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next-auth/react/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next-auth/utils/logger.js":
/*!************************************************!*\
  !*** ./node_modules/next-auth/utils/logger.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.proxyLogger = proxyLogger;\nexports.setLogger = setLogger;\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _errors = __webpack_require__(/*! ../core/errors */ \"(app-pages-browser)/./node_modules/next-auth/core/errors.js\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction formatError(o) {\n  if (o instanceof Error && !(o instanceof _errors.UnknownError)) {\n    return {\n      message: o.message,\n      stack: o.stack,\n      name: o.name\n    };\n  }\n\n  if (hasErrorProperty(o)) {\n    var _o$message;\n\n    o.error = formatError(o.error);\n    o.message = (_o$message = o.message) !== null && _o$message !== void 0 ? _o$message : o.error.message;\n  }\n\n  return o;\n}\n\nfunction hasErrorProperty(x) {\n  return !!(x !== null && x !== void 0 && x.error);\n}\n\nvar _logger = {\n  error: function error(code, metadata) {\n    metadata = formatError(metadata);\n    console.error(\"[next-auth][error][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/errors#\".concat(code.toLowerCase()), metadata.message, metadata);\n  },\n  warn: function warn(code) {\n    console.warn(\"[next-auth][warn][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/warnings#\".concat(code.toLowerCase()));\n  },\n  debug: function debug(code, metadata) {\n    console.log(\"[next-auth][debug][\".concat(code, \"]\"), metadata);\n  }\n};\n\nfunction setLogger() {\n  var newLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var debug = arguments.length > 1 ? arguments[1] : undefined;\n  if (!debug) _logger.debug = function () {};\n  if (newLogger.error) _logger.error = newLogger.error;\n  if (newLogger.warn) _logger.warn = newLogger.warn;\n  if (newLogger.debug) _logger.debug = newLogger.debug;\n}\n\nvar _default = _logger;\nexports[\"default\"] = _default;\n\nfunction proxyLogger() {\n  var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _logger;\n  var basePath = arguments.length > 1 ? arguments[1] : undefined;\n\n  try {\n    if (typeof window === \"undefined\") {\n      return logger;\n    }\n\n    var clientLogger = {};\n\n    var _loop = function _loop(level) {\n      clientLogger[level] = function (code, metadata) {\n        _logger[level](code, metadata);\n\n        if (level === \"error\") {\n          metadata = formatError(metadata);\n        }\n\n        ;\n        metadata.client = true;\n        var url = \"\".concat(basePath, \"/_log\");\n        var body = new URLSearchParams(_objectSpread({\n          level: level,\n          code: code\n        }, metadata));\n\n        if (navigator.sendBeacon) {\n          return navigator.sendBeacon(url, body);\n        }\n\n        return fetch(url, {\n          method: \"POST\",\n          body: body,\n          keepalive: true\n        });\n      };\n    };\n\n    for (var level in logger) {\n      _loop(level);\n    }\n\n    return clientLogger;\n  } catch (_unused) {\n    return _logger;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvdXRpbHMvbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLHdJQUE4Qzs7QUFFbkYsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixtQkFBbUI7QUFDbkIsaUJBQWlCOztBQUVqQiw4Q0FBOEMsbUJBQU8sQ0FBQywwSEFBdUM7O0FBRTdGLGNBQWMsbUJBQU8sQ0FBQyxtRkFBZ0I7O0FBRXRDLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQzs7QUFFdlUsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsNkRBQTZELDBEQUEwRCxvS0FBb0ssbUZBQW1GLEtBQUs7O0FBRXhmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvdXRpbHMvbG9nZ2VyLmpzP2M0M2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cy5wcm94eUxvZ2dlciA9IHByb3h5TG9nZ2VyO1xuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfZXJyb3JzID0gcmVxdWlyZShcIi4uL2NvcmUvZXJyb3JzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBFcnJvciAmJiAhKG8gaW5zdGFuY2VvZiBfZXJyb3JzLlVua25vd25FcnJvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogby5tZXNzYWdlLFxuICAgICAgc3RhY2s6IG8uc3RhY2ssXG4gICAgICBuYW1lOiBvLm5hbWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGhhc0Vycm9yUHJvcGVydHkobykpIHtcbiAgICB2YXIgX28kbWVzc2FnZTtcblxuICAgIG8uZXJyb3IgPSBmb3JtYXRFcnJvcihvLmVycm9yKTtcbiAgICBvLm1lc3NhZ2UgPSAoX28kbWVzc2FnZSA9IG8ubWVzc2FnZSkgIT09IG51bGwgJiYgX28kbWVzc2FnZSAhPT0gdm9pZCAwID8gX28kbWVzc2FnZSA6IG8uZXJyb3IubWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBoYXNFcnJvclByb3BlcnR5KHgpIHtcbiAgcmV0dXJuICEhKHggIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwICYmIHguZXJyb3IpO1xufVxuXG52YXIgX2xvZ2dlciA9IHtcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGNvZGUsIG1ldGFkYXRhKSB7XG4gICAgbWV0YWRhdGEgPSBmb3JtYXRFcnJvcihtZXRhZGF0YSk7XG4gICAgY29uc29sZS5lcnJvcihcIltuZXh0LWF1dGhdW2Vycm9yXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBcIlxcbmh0dHBzOi8vbmV4dC1hdXRoLmpzLm9yZy9lcnJvcnMjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSksIG1ldGFkYXRhLm1lc3NhZ2UsIG1ldGFkYXRhKTtcbiAgfSxcbiAgd2FybjogZnVuY3Rpb24gd2Fybihjb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW25leHQtYXV0aF1bd2Fybl1bXCIuY29uY2F0KGNvZGUsIFwiXVwiKSwgXCJcXG5odHRwczovL25leHQtYXV0aC5qcy5vcmcvd2FybmluZ3MjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSkpO1xuICB9LFxuICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoY29kZSwgbWV0YWRhdGEpIHtcbiAgICBjb25zb2xlLmxvZyhcIltuZXh0LWF1dGhdW2RlYnVnXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBtZXRhZGF0YSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldExvZ2dlcigpIHtcbiAgdmFyIG5ld0xvZ2dlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBpZiAoIWRlYnVnKSBfbG9nZ2VyLmRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gIGlmIChuZXdMb2dnZXIuZXJyb3IpIF9sb2dnZXIuZXJyb3IgPSBuZXdMb2dnZXIuZXJyb3I7XG4gIGlmIChuZXdMb2dnZXIud2FybikgX2xvZ2dlci53YXJuID0gbmV3TG9nZ2VyLndhcm47XG4gIGlmIChuZXdMb2dnZXIuZGVidWcpIF9sb2dnZXIuZGVidWcgPSBuZXdMb2dnZXIuZGVidWc7XG59XG5cbnZhciBfZGVmYXVsdCA9IF9sb2dnZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuZnVuY3Rpb24gcHJveHlMb2dnZXIoKSB7XG4gIHZhciBsb2dnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9sb2dnZXI7XG4gIHZhciBiYXNlUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfVxuXG4gICAgdmFyIGNsaWVudExvZ2dlciA9IHt9O1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AobGV2ZWwpIHtcbiAgICAgIGNsaWVudExvZ2dlcltsZXZlbF0gPSBmdW5jdGlvbiAoY29kZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgX2xvZ2dlcltsZXZlbF0oY29kZSwgbWV0YWRhdGEpO1xuXG4gICAgICAgIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgbWV0YWRhdGEgPSBmb3JtYXRFcnJvcihtZXRhZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICA7XG4gICAgICAgIG1ldGFkYXRhLmNsaWVudCA9IHRydWU7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChiYXNlUGF0aCwgXCIvX2xvZ1wiKTtcbiAgICAgICAgdmFyIGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICBjb2RlOiBjb2RlXG4gICAgICAgIH0sIG1ldGFkYXRhKSk7XG5cbiAgICAgICAgaWYgKG5hdmlnYXRvci5zZW5kQmVhY29uKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5zZW5kQmVhY29uKHVybCwgYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgIGtlZXBhbGl2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZvciAodmFyIGxldmVsIGluIGxvZ2dlcikge1xuICAgICAgX2xvb3AobGV2ZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGllbnRMb2dnZXI7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gX2xvZ2dlcjtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next-auth/utils/logger.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next-auth/utils/parse-url.js":
/*!***************************************************!*\
  !*** ./node_modules/next-auth/utils/parse-url.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseUrl;\n\nfunction parseUrl(url) {\n  var _url2;\n\n  const defaultUrl = new URL(\"http://localhost:3000/api/auth\");\n\n  if (url && !url.startsWith(\"http\")) {\n    url = `https://${url}`;\n  }\n\n  const _url = new URL((_url2 = url) !== null && _url2 !== void 0 ? _url2 : defaultUrl);\n\n  const path = (_url.pathname === \"/\" ? defaultUrl.pathname : _url.pathname).replace(/\\/$/, \"\");\n  const base = `${_url.origin}${path}`;\n  return {\n    origin: _url.origin,\n    host: _url.host,\n    path,\n    base,\n    toString: () => base\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvdXRpbHMvcGFyc2UtdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsSUFBSTtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZLEVBQUUsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvdXRpbHMvcGFyc2UtdXJsLmpzPzFjNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVVybDtcblxuZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gIHZhciBfdXJsMjtcblxuICBjb25zdCBkZWZhdWx0VXJsID0gbmV3IFVSTChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aFwiKTtcblxuICBpZiAodXJsICYmICF1cmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICB1cmwgPSBgaHR0cHM6Ly8ke3VybH1gO1xuICB9XG5cbiAgY29uc3QgX3VybCA9IG5ldyBVUkwoKF91cmwyID0gdXJsKSAhPT0gbnVsbCAmJiBfdXJsMiAhPT0gdm9pZCAwID8gX3VybDIgOiBkZWZhdWx0VXJsKTtcblxuICBjb25zdCBwYXRoID0gKF91cmwucGF0aG5hbWUgPT09IFwiL1wiID8gZGVmYXVsdFVybC5wYXRobmFtZSA6IF91cmwucGF0aG5hbWUpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgY29uc3QgYmFzZSA9IGAke191cmwub3JpZ2lufSR7cGF0aH1gO1xuICByZXR1cm4ge1xuICAgIG9yaWdpbjogX3VybC5vcmlnaW4sXG4gICAgaG9zdDogX3VybC5ob3N0LFxuICAgIHBhdGgsXG4gICAgYmFzZSxcbiAgICB0b1N0cmluZzogKCkgPT4gYmFzZVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next-auth/utils/parse-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/NTJkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createServerReference\", ({\n    enumerable: true,\n    get: function() {\n        return createServerReference;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! next/dist/client/app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nfunction createServerReference(id) {\n    // Since we're using the Edge build of Flight client for SSR [1], here we need to\n    // also use the same Edge build to create the reference. For the client bundle,\n    // we use the default and let Webpack to resolve it to the correct version.\n    // 1: https://github.com/vercel/next.js/blob/16eb80b0b0be13f04a6407943664b5efd8f3d7d0/packages/next/src/server/app-render/use-flight-response.tsx#L24-L26\n    const { createServerReference: createServerReferenceImpl } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\n    return createServerReferenceImpl(id, _appcallserver.callServer);\n}\n\n//# sourceMappingURL=action-client-wrapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWxvYWRlci9hY3Rpb24tY2xpZW50LXdyYXBwZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUJBQXVCLG1CQUFPLENBQUMsZ0hBQWtDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRCxFQUFFLE1BQTBCLEdBQUcsQ0FBK0MsR0FBRyxtQkFBTyxDQUFDLGlJQUFpQztBQUN6TDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWxvYWRlci9hY3Rpb24tY2xpZW50LXdyYXBwZXIuanM/N2FhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgbXVzdCBiZSBidW5kbGVkIGluIHRoZSBhcHAncyBjbGllbnQgbGF5ZXIsIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseVxuLy8gaW1wb3J0ZWQgYnkgdGhlIHNlcnZlci5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlU2VydmVyUmVmZXJlbmNlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJSZWZlcmVuY2U7XG4gICAgfVxufSk7XG5jb25zdCBfYXBwY2FsbHNlcnZlciA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY2xpZW50L2FwcC1jYWxsLXNlcnZlclwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclJlZmVyZW5jZShpZCkge1xuICAgIC8vIFNpbmNlIHdlJ3JlIHVzaW5nIHRoZSBFZGdlIGJ1aWxkIG9mIEZsaWdodCBjbGllbnQgZm9yIFNTUiBbMV0sIGhlcmUgd2UgbmVlZCB0b1xuICAgIC8vIGFsc28gdXNlIHRoZSBzYW1lIEVkZ2UgYnVpbGQgdG8gY3JlYXRlIHRoZSByZWZlcmVuY2UuIEZvciB0aGUgY2xpZW50IGJ1bmRsZSxcbiAgICAvLyB3ZSB1c2UgdGhlIGRlZmF1bHQgYW5kIGxldCBXZWJwYWNrIHRvIHJlc29sdmUgaXQgdG8gdGhlIGNvcnJlY3QgdmVyc2lvbi5cbiAgICAvLyAxOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvYmxvYi8xNmViODBiMGIwYmUxM2YwNGE2NDA3OTQzNjY0YjVlZmQ4ZjNkN2QwL3BhY2thZ2VzL25leHQvc3JjL3NlcnZlci9hcHAtcmVuZGVyL3VzZS1mbGlnaHQtcmVzcG9uc2UudHN4I0wyNC1MMjZcbiAgICBjb25zdCB7IGNyZWF0ZVNlcnZlclJlZmVyZW5jZTogY3JlYXRlU2VydmVyUmVmZXJlbmNlSW1wbCB9ID0gISFwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPyByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5lZGdlXCIpIDogcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnRcIik7XG4gICAgcmV0dXJuIGNyZWF0ZVNlcnZlclJlZmVyZW5jZUltcGwoaWQsIF9hcHBjYWxsc2VydmVyLmNhbGxTZXJ2ZXIpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpb24tY2xpZW50LXdyYXBwZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz81MmM0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/flatpickr/dist/flatpickr.min.css":
/*!*******************************************************!*\
  !*** ./node_modules/flatpickr/dist/flatpickr.min.css ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"5c1169418eb5\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9mbGF0cGlja3IubWluLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZsYXRwaWNrci9kaXN0L2ZsYXRwaWNrci5taW4uY3NzPzU3ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI1YzExNjk0MThlYjVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/flatpickr/dist/flatpickr.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jsvectormap/dist/jsvectormap.css":
/*!*******************************************************!*\
  !*** ./node_modules/jsvectormap/dist/jsvectormap.css ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"2911ae477d3a\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc3ZlY3Rvcm1hcC9kaXN0L2pzdmVjdG9ybWFwLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pzdmVjdG9ybWFwL2Rpc3QvanN2ZWN0b3JtYXAuY3NzPzI0MGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIyOTExYWU0NzdkM2FcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jsvectormap/dist/jsvectormap.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/css/style.css":
/*!***************************!*\
  !*** ./src/css/style.css ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"7091481e06c7\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jc3Mvc3R5bGUuY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY3NzL3N0eWxlLmNzcz9mNDdiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNzA5MTQ4MWUwNmM3XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/css/style.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/context/UserContext.tsx":
/*!*****************************************!*\
  !*** ./src/app/context/UserContext.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UserProvider: function() { return /* binding */ UserProvider; },\n/* harmony export */   useUser: function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lib_actions_user_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/actions/user.actions */ \"(app-pages-browser)/./src/lib/actions/user.actions.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst UserContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst UserProvider = (param)=>{\n    let { children } = param;\n    var _session_user;\n    _s();\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession)();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        firstName: \"John\",\n        lastName: \"Doe\",\n        photo: \"/images/user/user-01.png\",\n        jobTitle: \"Drug Researcher\",\n        userBio: \"\"\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const fetchUser = async ()=>{\n            var _session_user;\n            if (session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email) {\n                const fetchedUser = await (0,_lib_actions_user_actions__WEBPACK_IMPORTED_MODULE_3__.getUserByEmail)(session.user.email);\n                setUser({\n                    firstName: (fetchedUser === null || fetchedUser === void 0 ? void 0 : fetchedUser.firstName) || \"John\",\n                    lastName: (fetchedUser === null || fetchedUser === void 0 ? void 0 : fetchedUser.lastName) || \"Doe\",\n                    photo: (fetchedUser === null || fetchedUser === void 0 ? void 0 : fetchedUser.photo) || \"/images/user/user-01.png\",\n                    jobTitle: (fetchedUser === null || fetchedUser === void 0 ? void 0 : fetchedUser.jobTitle) || \"Researcher\",\n                    userBio: (fetchedUser === null || fetchedUser === void 0 ? void 0 : fetchedUser.userBio) || \"\"\n                });\n            }\n        };\n        fetchUser();\n    }, [\n        session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(UserContext.Provider, {\n        value: user,\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/context/UserContext.tsx\",\n        lineNumber: 38,\n        columnNumber: 12\n    }, undefined);\n};\n_s(UserProvider, \"vTbimg//JBPp0s6oENWCRIE9jMQ=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession\n    ];\n});\n_c = UserProvider;\nconst useUser = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(UserContext);\n};\n_s1(useUser, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29udGV4dC9Vc2VyQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQU1pQjtBQUM4QjtBQUNlO0FBRTVELE1BQU1NLDRCQUFjTixvREFBYUEsQ0FBTTtBQUNoQyxNQUFNTyxlQUFlO1FBQUMsRUFBRUMsUUFBUSxFQUEyQjtRQXdCNURDOztJQXZCSixNQUFNLEVBQUVDLE1BQU1ELE9BQU8sRUFBRSxHQUFHTCwyREFBVUE7SUFDcEMsTUFBTSxDQUFDTyxNQUFNQyxRQUFRLEdBQUdWLCtDQUFRQSxDQUFDO1FBQy9CVyxXQUFXO1FBQ1hDLFVBQVU7UUFDVkMsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtJQUVBZCxnREFBU0EsQ0FBQztRQUNSLE1BQU1lLFlBQVk7Z0JBQ1pUO1lBQUosSUFBSUEsb0JBQUFBLCtCQUFBQSxnQkFBQUEsUUFBU0UsSUFBSSxjQUFiRixvQ0FBQUEsY0FBZVUsS0FBSyxFQUFFO2dCQUN4QixNQUFNQyxjQUFjLE1BQU1mLHlFQUFjQSxDQUFDSSxRQUFRRSxJQUFJLENBQUNRLEtBQUs7Z0JBQzNEUCxRQUFRO29CQUNOQyxXQUFXTyxDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFQLFNBQVMsS0FBSTtvQkFDckNDLFVBQVVNLENBQUFBLHdCQUFBQSxrQ0FBQUEsWUFBYU4sUUFBUSxLQUFJO29CQUNuQ0MsT0FBT0ssQ0FBQUEsd0JBQUFBLGtDQUFBQSxZQUFhTCxLQUFLLEtBQUk7b0JBQzdCQyxVQUFVSSxDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFKLFFBQVEsS0FBSTtvQkFDbkNDLFNBQVNHLENBQUFBLHdCQUFBQSxrQ0FBQUEsWUFBYUgsT0FBTyxLQUFJO2dCQUNuQztZQUNGO1FBQ0Y7UUFDQUM7SUFDRixHQUFHO1FBQUNULG9CQUFBQSwrQkFBQUEsZ0JBQUFBLFFBQVNFLElBQUksY0FBYkYsb0NBQUFBLGNBQWVVLEtBQUs7S0FBQztJQUV6QixxQkFBTyw4REFBQ2IsWUFBWWUsUUFBUTtRQUFDQyxPQUFPWDtrQkFBT0g7Ozs7OztBQUM3QyxFQUFFO0dBM0JXRDs7UUFDZUgsdURBQVVBOzs7S0FEekJHO0FBNkJOLE1BQU1nQixVQUFVOztJQUFNdEIsT0FBQUEsaURBQVVBLENBQUNLO0FBQVcsRUFBRTtJQUF4Q2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvY29udGV4dC9Vc2VyQ29udGV4dC50c3g/ZTJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIGNyZWF0ZUNvbnRleHQsXG4gICAgdXNlQ29udGV4dCxcbiAgICB1c2VTdGF0ZSxcbiAgICB1c2VFZmZlY3QsXG4gICAgUmVhY3ROb2RlLFxuICB9IGZyb20gXCJyZWFjdFwiO1xuICBpbXBvcnQgeyB1c2VTZXNzaW9uIH0gZnJvbSBcIm5leHQtYXV0aC9yZWFjdFwiO1xuICBpbXBvcnQgeyBnZXRVc2VyQnlFbWFpbCB9IGZyb20gXCJAL2xpYi9hY3Rpb25zL3VzZXIuYWN0aW9uc1wiO1xuICBcbiAgY29uc3QgVXNlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0PGFueT4obnVsbCk7XG4gIGV4cG9ydCBjb25zdCBVc2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xuICAgIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlKHtcbiAgICAgIGZpcnN0TmFtZTogXCJKb2huXCIsXG4gICAgICBsYXN0TmFtZTogXCJEb2VcIixcbiAgICAgIHBob3RvOiBcIi9pbWFnZXMvdXNlci91c2VyLTAxLnBuZ1wiLFxuICAgICAgam9iVGl0bGU6IFwiRHJ1ZyBSZXNlYXJjaGVyXCIsXG4gICAgICB1c2VyQmlvOiBcIlwiLFxuICAgIH0pO1xuICBcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgZmV0Y2hVc2VyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoc2Vzc2lvbj8udXNlcj8uZW1haWwpIHtcbiAgICAgICAgICBjb25zdCBmZXRjaGVkVXNlciA9IGF3YWl0IGdldFVzZXJCeUVtYWlsKHNlc3Npb24udXNlci5lbWFpbCk7XG4gICAgICAgICAgc2V0VXNlcih7XG4gICAgICAgICAgICBmaXJzdE5hbWU6IGZldGNoZWRVc2VyPy5maXJzdE5hbWUgfHwgXCJKb2huXCIsXG4gICAgICAgICAgICBsYXN0TmFtZTogZmV0Y2hlZFVzZXI/Lmxhc3ROYW1lIHx8IFwiRG9lXCIsXG4gICAgICAgICAgICBwaG90bzogZmV0Y2hlZFVzZXI/LnBob3RvIHx8IFwiL2ltYWdlcy91c2VyL3VzZXItMDEucG5nXCIsXG4gICAgICAgICAgICBqb2JUaXRsZTogZmV0Y2hlZFVzZXI/LmpvYlRpdGxlIHx8IFwiUmVzZWFyY2hlclwiLFxuICAgICAgICAgICAgdXNlckJpbzogZmV0Y2hlZFVzZXI/LnVzZXJCaW8gfHwgXCJcIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZldGNoVXNlcigpO1xuICAgIH0sIFtzZXNzaW9uPy51c2VyPy5lbWFpbF0pO1xuICBcbiAgICByZXR1cm4gPFVzZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VyfT57Y2hpbGRyZW59PC9Vc2VyQ29udGV4dC5Qcm92aWRlcj47XG4gIH07XG4gIFxuICBleHBvcnQgY29uc3QgdXNlVXNlciA9ICgpID0+IHVzZUNvbnRleHQoVXNlckNvbnRleHQpOyJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlU2Vzc2lvbiIsImdldFVzZXJCeUVtYWlsIiwiVXNlckNvbnRleHQiLCJVc2VyUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNlc3Npb24iLCJkYXRhIiwidXNlciIsInNldFVzZXIiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsInBob3RvIiwiam9iVGl0bGUiLCJ1c2VyQmlvIiwiZmV0Y2hVc2VyIiwiZW1haWwiLCJmZXRjaGVkVXNlciIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VVc2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/context/UserContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/layout.tsx":
/*!****************************!*\
  !*** ./src/app/layout.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RootLayout; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var jsvectormap_dist_jsvectormap_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsvectormap/dist/jsvectormap.css */ \"(app-pages-browser)/./node_modules/jsvectormap/dist/jsvectormap.css\");\n/* harmony import */ var flatpickr_dist_flatpickr_min_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flatpickr/dist/flatpickr.min.css */ \"(app-pages-browser)/./node_modules/flatpickr/dist/flatpickr.min.css\");\n/* harmony import */ var _css_style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/css/style.css */ \"(app-pages-browser)/./src/css/style.css\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _components_common_Loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/common/Loader */ \"(app-pages-browser)/./src/components/common/Loader/index.tsx\");\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ably */ \"(app-pages-browser)/./node_modules/ably/build/ably.js\");\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ably__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var ably_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ably/react */ \"(app-pages-browser)/./node_modules/ably/react/mjs/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _app_context_UserContext__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/app/context/UserContext */ \"(app-pages-browser)/./src/app/context/UserContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nfunction RootLayout(param) {\n    let { children } = param;\n    _s();\n    const [sidebarOpen, setSidebarOpen] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(false);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        setTimeout(()=>setLoading(false), 1000);\n    }, []);\n    const client = new ably__WEBPACK_IMPORTED_MODULE_6__.Realtime({\n        key: \"ht6EPg.n_pKHw:qJbqSjbfAv9Mjsf1DMjNp-nCSWB0S_60R5QxTJlqGSA\"\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"html\", {\n        lang: \"en\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"script\", {\n                src: \"https://unpkg.com/@rdkit/rdkit/dist/RDKit_minimal.js\"\n            }, void 0, false, {\n                fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n                lineNumber: 31,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n                suppressHydrationWarning: true,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_auth_react__WEBPACK_IMPORTED_MODULE_8__.SessionProvider, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_context_UserContext__WEBPACK_IMPORTED_MODULE_9__.UserProvider, {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ably_react__WEBPACK_IMPORTED_MODULE_7__.AblyProvider, {\n                            client: client,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ably_react__WEBPACK_IMPORTED_MODULE_7__.ChannelProvider, {\n                                channelName: \"chat-demo1\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"font-poppins dark:bg-boxdark-2 dark:text-bodydark \",\n                                    children: loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_common_Loader__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                                        fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n                                        lineNumber: 38,\n                                        columnNumber: 30\n                                    }, this) : children\n                                }, void 0, false, {\n                                    fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n                                    lineNumber: 37,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n                                lineNumber: 36,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n                            lineNumber: 35,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n                        lineNumber: 34,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n                    lineNumber: 33,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n                lineNumber: 32,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ubuntu/Documents/ProteinBind/src/app/layout.tsx\",\n        lineNumber: 29,\n        columnNumber: 5\n    }, this);\n}\n_s(RootLayout, \"W0GlrGRGi4fX92DkQbdCWtCD/TE=\");\n_c = RootLayout;\nvar _c;\n$RefreshReg$(_c, \"RootLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbGF5b3V0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQzBDO0FBQ0E7QUFDakI7QUFDMEI7QUFDSDtBQUVuQjtBQUM4QjtBQUNUO0FBQ087QUFFMUMsU0FBU1MsV0FBVyxLQUlqQztRQUppQyxFQUNqQ0MsUUFBUSxFQUdSLEdBSmlDOztJQUtqQyxNQUFNLENBQUNDLGFBQWFDLGVBQWUsR0FBR1YsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDVyxTQUFTQyxXQUFXLEdBQUdaLCtDQUFRQSxDQUFVO0lBRWhERCxnREFBU0EsQ0FBQztRQUNSYyxXQUFXLElBQU1ELFdBQVcsUUFBUTtJQUN0QyxHQUFHLEVBQUU7SUFFTCxNQUFNRSxTQUFTLElBQUlaLDBDQUFhLENBQUM7UUFDL0JjLEtBQUs7SUFDUDtJQUNBLHFCQUNFLDhEQUFDQztRQUFLQyxNQUFLOzswQkFFVCw4REFBQ0M7Z0JBQU9DLEtBQUk7Ozs7OzswQkFDWiw4REFBQ0M7Z0JBQUtDLDBCQUEwQjswQkFDOUIsNEVBQUNqQiw0REFBZUE7OEJBQ2QsNEVBQUNDLGtFQUFZQTtrQ0FDWCw0RUFBQ0gsb0RBQVlBOzRCQUFDVyxRQUFRQTtzQ0FDcEIsNEVBQUNWLHVEQUFlQTtnQ0FBQ21CLGFBQVk7MENBQzNCLDRFQUFDQztvQ0FBSUMsV0FBVTs4Q0FDWmQsd0JBQVUsOERBQUNWLGlFQUFNQTs7OzsrQ0FBTU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTMUM7R0FsQ3dCRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2xheW91dC50c3g/NTdhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBcImpzdmVjdG9ybWFwL2Rpc3QvanN2ZWN0b3JtYXAuY3NzXCI7XG5pbXBvcnQgXCJmbGF0cGlja3IvZGlzdC9mbGF0cGlja3IubWluLmNzc1wiO1xuaW1wb3J0IFwiQC9jc3Mvc3R5bGUuY3NzXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IExvYWRlciBmcm9tIFwiQC9jb21wb25lbnRzL2NvbW1vbi9Mb2FkZXJcIjtcblxuaW1wb3J0ICogYXMgQWJseSBmcm9tIFwiYWJseVwiO1xuaW1wb3J0IHsgQWJseVByb3ZpZGVyLCBDaGFubmVsUHJvdmlkZXIgfSBmcm9tIFwiYWJseS9yZWFjdFwiO1xuaW1wb3J0IHsgU2Vzc2lvblByb3ZpZGVyIH0gZnJvbSBcIm5leHQtYXV0aC9yZWFjdFwiO1xuaW1wb3J0IHsgVXNlclByb3ZpZGVyIH0gZnJvbSBcIkAvYXBwL2NvbnRleHQvVXNlckNvbnRleHRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUm9vdExheW91dCh7XG4gIGNoaWxkcmVuLFxufTogUmVhZG9ubHk8e1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufT4pIHtcbiAgY29uc3QgW3NpZGViYXJPcGVuLCBzZXRTaWRlYmFyT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBzZXRMb2FkaW5nKGZhbHNlKSwgMTAwMCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjbGllbnQgPSBuZXcgQWJseS5SZWFsdGltZSh7XG4gICAga2V5OiBcImh0NkVQZy5uX3BLSHc6cUpicVNqYmZBdjlNanNmMURNak5wLW5DU1dCMFNfNjBSNVF4VEpscUdTQVwiLFxuICB9KTtcbiAgcmV0dXJuIChcbiAgICA8aHRtbCBsYW5nPVwiZW5cIj5cbiAgICAgIHsvKiA8c2NyaXB0IHNyYz1cImh0dHBzOi8vdW5wa2cuY29tL0ByZGtpdC9yZGtpdC9kaXN0L1JES2l0X21pbmltYWwuanNcIj48L3NjcmlwdD4gKi99XG4gICAgICA8c2NyaXB0IHNyYz1cImh0dHBzOi8vdW5wa2cuY29tL0ByZGtpdC9yZGtpdC9kaXN0L1JES2l0X21pbmltYWwuanNcIj48L3NjcmlwdD5cbiAgICAgIDxib2R5IHN1cHByZXNzSHlkcmF0aW9uV2FybmluZz17dHJ1ZX0+XG4gICAgICAgIDxTZXNzaW9uUHJvdmlkZXI+XG4gICAgICAgICAgPFVzZXJQcm92aWRlcj5cbiAgICAgICAgICAgIDxBYmx5UHJvdmlkZXIgY2xpZW50PXtjbGllbnR9PlxuICAgICAgICAgICAgICA8Q2hhbm5lbFByb3ZpZGVyIGNoYW5uZWxOYW1lPVwiY2hhdC1kZW1vMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9udC1wb3BwaW5zIGRhcms6YmctYm94ZGFyay0yIGRhcms6dGV4dC1ib2R5ZGFyayBcIj5cbiAgICAgICAgICAgICAgICAgIHtsb2FkaW5nID8gPExvYWRlciAvPiA6IGNoaWxkcmVufVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L0NoYW5uZWxQcm92aWRlcj5cbiAgICAgICAgICAgIDwvQWJseVByb3ZpZGVyPlxuICAgICAgICAgIDwvVXNlclByb3ZpZGVyPlxuICAgICAgICA8L1Nlc3Npb25Qcm92aWRlcj5cbiAgICAgIDwvYm9keT5cbiAgICA8L2h0bWw+XG4gICk7XG59Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJMb2FkZXIiLCJBYmx5IiwiQWJseVByb3ZpZGVyIiwiQ2hhbm5lbFByb3ZpZGVyIiwiU2Vzc2lvblByb3ZpZGVyIiwiVXNlclByb3ZpZGVyIiwiUm9vdExheW91dCIsImNoaWxkcmVuIiwic2lkZWJhck9wZW4iLCJzZXRTaWRlYmFyT3BlbiIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwic2V0VGltZW91dCIsImNsaWVudCIsIlJlYWx0aW1lIiwia2V5IiwiaHRtbCIsImxhbmciLCJzY3JpcHQiLCJzcmMiLCJib2R5Iiwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiwiY2hhbm5lbE5hbWUiLCJkaXYiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/layout.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/common/Loader/index.tsx":
/*!************************************************!*\
  !*** ./src/components/common/Loader/index.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst Loader = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex h-screen items-center justify-center bg-white dark:bg-black\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent\"\n        }, void 0, false, {\n            fileName: \"/home/ubuntu/Documents/ProteinBind/src/components/common/Loader/index.tsx\",\n            lineNumber: 4,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/home/ubuntu/Documents/ProteinBind/src/components/common/Loader/index.tsx\",\n        lineNumber: 3,\n        columnNumber: 7\n    }, undefined);\n};\n_c = Loader;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Loader);\nvar _c;\n$RefreshReg$(_c, \"Loader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9Mb2FkZXIvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7OztBQUFBLE1BQU1BLFNBQVM7SUFDWCxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ0Q7WUFBSUMsV0FBVTs7Ozs7Ozs7Ozs7QUFHckI7S0FOSUY7QUFRSiwrREFBZUEsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9jb21tb24vTG9hZGVyL2luZGV4LnRzeD9jMDNmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IExvYWRlciA9ICgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGgtc2NyZWVuIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy13aGl0ZSBkYXJrOmJnLWJsYWNrXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC0xNiB3LTE2IGFuaW1hdGUtc3BpbiByb3VuZGVkLWZ1bGwgYm9yZGVyLTQgYm9yZGVyLXNvbGlkIGJvcmRlci1wcmltYXJ5IGJvcmRlci10LXRyYW5zcGFyZW50XCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9O1xuICBcbiAgZXhwb3J0IGRlZmF1bHQgTG9hZGVyOyJdLCJuYW1lcyI6WyJMb2FkZXIiLCJkaXYiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/common/Loader/index.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/actions/user.actions.ts":
/*!*****************************************!*\
  !*** ./src/lib/actions/user.actions.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUser: function() { return /* binding */ createUser; },
/* harmony export */   deleteUser: function() { return /* binding */ deleteUser; },
/* harmony export */   getUserByEmail: function() { return /* binding */ getUserByEmail; },
/* harmony export */   getUserById: function() { return /* binding */ getUserById; },
/* harmony export */   loginUser: function() { return /* binding */ loginUser; },
/* harmony export */   requestPasswordReset: function() { return /* binding */ requestPasswordReset; },
/* harmony export */   resetPassword: function() { return /* binding */ resetPassword; },
/* harmony export */   updateCredits: function() { return /* binding */ updateCredits; },
/* harmony export */   updateUser: function() { return /* binding */ updateUser; },
/* harmony export */   verifyEmail: function() { return /* binding */ verifyEmail; }
/* harmony export */ });
/* harmony import */ var next_dist_client_app_call_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/client/app-call-server */ "(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js");
/* harmony import */ var next_dist_client_app_call_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_app_call_server__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-client-wrapper */ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js");



function __build_action__(action, args) {
  return (0,next_dist_client_app_call_server__WEBPACK_IMPORTED_MODULE_0__.callServer)(action.$$id, args)
}

/* __next_internal_action_entry_do_not_use__ {"1895fef7a24496c41c0396c6c06321a1bb345a31":"resetPassword","4235fae0ab118ee2d9ffb0f50ed3451af47f1a99":"loginUser","423daf469954e6944cd4d8f7bed13ce2390ec0a5":"getUserByEmail","63c744e75d7a52ffb555b08e0abbb74d9d8223a9":"requestPasswordReset","9ccc436be31a00d4a409e10020b33f5cc0fb0826":"updateUser","a5b400fe54aee3aacede104bb9ccac65aa9a0466":"updateCredits","b16a1e11f9a0b220612a5620e583cbf38fd0c56b":"getUserById","cad3176dbd4c77458c16a471a3bd84c9f37fdaed":"verifyEmail","f813a29a6efe418805d57636972dc4c53f4dbe04":"deleteUser","fb9c8f749cbe6b633c943eed783406648196b7d7":"createUser"} */ var getUserByEmail = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("423daf469954e6944cd4d8f7bed13ce2390ec0a5");

var createUser = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("fb9c8f749cbe6b633c943eed783406648196b7d7");
var loginUser = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("4235fae0ab118ee2d9ffb0f50ed3451af47f1a99");
var verifyEmail = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("cad3176dbd4c77458c16a471a3bd84c9f37fdaed");
var requestPasswordReset = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("63c744e75d7a52ffb555b08e0abbb74d9d8223a9");
var resetPassword = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("1895fef7a24496c41c0396c6c06321a1bb345a31");
var getUserById = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("b16a1e11f9a0b220612a5620e583cbf38fd0c56b");
var updateUser = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("9ccc436be31a00d4a409e10020b33f5cc0fb0826");
var deleteUser = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("f813a29a6efe418805d57636972dc4c53f4dbe04");
var updateCredits = (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_1__.createServerReference)("a5b400fe54aee3aacede104bb9ccac65aa9a0466");



;
    // Wrapped in an IIFE to avoid polluting the global scope
    ;
    (function () {
        var _a, _b;
        // Legacy CSS implementations will `eval` browser code in a Node.js context
        // to extract CSS. For backwards compatibility, we need to check we're in a
        // browser context before continuing.
        if (typeof self !== 'undefined' &&
            // AMP / No-JS mode does not inject these helpers:
            '$RefreshHelpers$' in self) {
            // @ts-ignore __webpack_module__ is global
            var currentExports = module.exports;
            // @ts-ignore __webpack_module__ is global
            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;
            // This cannot happen in MainTemplate because the exports mismatch between
            // templating and execution.
            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
            // A module can be accepted automatically based on its exports, e.g. when
            // it is a Refresh Boundary.
            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
                // Save the previous exports signature on update so we can compare the boundary
                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)
                module.hot.dispose(function (data) {
                    data.prevSignature =
                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);
                });
                // Unconditionally accept an update to this module, we'll check if it's
                // still a Refresh Boundary later.
                // @ts-ignore importMeta is replaced in the loader
                module.hot.accept();
                // This field is set when the previous version of this module was a
                // Refresh Boundary, letting us know we need to check for invalidation or
                // enqueue an update.
                if (prevSignature !== null) {
                    // A boundary can become ineligible if its exports are incompatible
                    // with the previous exports.
                    //
                    // For example, if you add/remove/change exports, we'll want to
                    // re-execute the importing modules, and force those components to
                    // re-render. Similarly, if you convert a class component to a
                    // function, we want to invalidate the boundary.
                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {
                        module.hot.invalidate();
                    }
                    else {
                        self.$RefreshHelpers$.scheduleUpdate();
                    }
                }
            }
            else {
                // Since we just executed the code for the module, it's possible that the
                // new exports made it ineligible for being a boundary.
                // We only care about the case when we were _previously_ a boundary,
                // because we already accepted this update (accidental side effect).
                var isNoLongerABoundary = prevSignature !== null;
                if (isNoLongerABoundary) {
                    module.hot.invalidate();
                }
            }
        }
    })();


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz83ZjdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZGEwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanM/Y2MwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanM/YjdhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/arrayWithHoles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcz9jNDY1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzPzlkMmMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzP2VhOTAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/classCallCheck.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\nvar isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\");\nfunction _construct(t, e, r) {\n  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && setPrototypeOf(p, r.prototype), p;\n}\nmodule.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsbUJBQU8sQ0FBQyx3R0FBcUI7QUFDbEQsK0JBQStCLG1CQUFPLENBQUMsNEhBQStCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanM/NWI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanNcIik7XG5mdW5jdGlvbiBfY29uc3RydWN0KHQsIGUsIHIpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgdmFyIG8gPSBbbnVsbF07XG4gIG8ucHVzaC5hcHBseShvLCBlKTtcbiAgdmFyIHAgPSBuZXcgKHQuYmluZC5hcHBseSh0LCBvKSkoKTtcbiAgcmV0dXJuIHIgJiYgc2V0UHJvdG90eXBlT2YocCwgci5wcm90b3R5cGUpLCBwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/construct.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/toPropertyKey.js\");\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQixtQkFBTyxDQUFDLHNHQUFvQjtBQUNoRDtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzP2QwNjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKFwiLi90b1Byb3BlcnR5S2V5LmpzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/createClass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/toPropertyKey.js\");\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQixtQkFBTyxDQUFDLHNHQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanM/NTZjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoXCIuL3RvUHJvcGVydHlLZXkuanNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/defineProperty.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSx5QkFBeUIsU0FBUyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanM/ZDYzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLHdHQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzPzdmMGIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/inherits.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanM/MTk1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/isNativeFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeFunction(fn) {\n  try {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  } catch (e) {\n    return typeof fn === \"function\";\n  }\n}\nmodule.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcz9lNzhmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVGdW5jdGlvbiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/isNativeFunction.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports)();\n}\nmodule.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRyxFQUFFLHlCQUF5QixTQUFTLHlCQUF5QjtBQUNoRTtBQUNBLDRDQUE0Qyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzP2JkZDciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksa0VBQWtFO0FBQ3RGLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanM/OWMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gITAsXG4gICAgICBvID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9ICEwLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcz9iNzcyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/nonIterableRest.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return assertThisInitialized(self);\n}\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYywwSEFBaUM7QUFDL0MsNEJBQTRCLG1CQUFPLENBQUMsc0hBQTRCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz9hNmU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nfunction _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return e;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var t,\n    e = {},\n    r = Object.prototype,\n    n = r.hasOwnProperty,\n    o = Object.defineProperty || function (t, e, r) {\n      t[e] = r.value;\n    },\n    i = \"function\" == typeof Symbol ? Symbol : {},\n    a = i.iterator || \"@@iterator\",\n    c = i.asyncIterator || \"@@asyncIterator\",\n    u = i.toStringTag || \"@@toStringTag\";\n  function define(t, e, r) {\n    return Object.defineProperty(t, e, {\n      value: r,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), t[e];\n  }\n  try {\n    define({}, \"\");\n  } catch (t) {\n    define = function define(t, e, r) {\n      return t[e] = r;\n    };\n  }\n  function wrap(t, e, r, n) {\n    var i = e && e.prototype instanceof Generator ? e : Generator,\n      a = Object.create(i.prototype),\n      c = new Context(n || []);\n    return o(a, \"_invoke\", {\n      value: makeInvokeMethod(t, r, c)\n    }), a;\n  }\n  function tryCatch(t, e, r) {\n    try {\n      return {\n        type: \"normal\",\n        arg: t.call(e, r)\n      };\n    } catch (t) {\n      return {\n        type: \"throw\",\n        arg: t\n      };\n    }\n  }\n  e.wrap = wrap;\n  var h = \"suspendedStart\",\n    l = \"suspendedYield\",\n    f = \"executing\",\n    s = \"completed\",\n    y = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var p = {};\n  define(p, a, function () {\n    return this;\n  });\n  var d = Object.getPrototypeOf,\n    v = d && d(d(values([])));\n  v && v !== r && n.call(v, a) && (p = v);\n  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);\n  function defineIteratorMethods(t) {\n    [\"next\", \"throw\", \"return\"].forEach(function (e) {\n      define(t, e, function (t) {\n        return this._invoke(e, t);\n      });\n    });\n  }\n  function AsyncIterator(t, e) {\n    function invoke(r, o, i, a) {\n      var c = tryCatch(t[r], t, o);\n      if (\"throw\" !== c.type) {\n        var u = c.arg,\n          h = u.value;\n        return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) {\n          invoke(\"next\", t, i, a);\n        }, function (t) {\n          invoke(\"throw\", t, i, a);\n        }) : e.resolve(h).then(function (t) {\n          u.value = t, i(u);\n        }, function (t) {\n          return invoke(\"throw\", t, i, a);\n        });\n      }\n      a(c.arg);\n    }\n    var r;\n    o(this, \"_invoke\", {\n      value: function value(t, n) {\n        function callInvokeWithMethodAndArg() {\n          return new e(function (e, r) {\n            invoke(t, n, e, r);\n          });\n        }\n        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(e, r, n) {\n    var o = h;\n    return function (i, a) {\n      if (o === f) throw new Error(\"Generator is already running\");\n      if (o === s) {\n        if (\"throw\" === i) throw a;\n        return {\n          value: t,\n          done: !0\n        };\n      }\n      for (n.method = i, n.arg = a;;) {\n        var c = n.delegate;\n        if (c) {\n          var u = maybeInvokeDelegate(c, n);\n          if (u) {\n            if (u === y) continue;\n            return u;\n          }\n        }\n        if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n          if (o === h) throw o = s, n.arg;\n          n.dispatchException(n.arg);\n        } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n        o = f;\n        var p = tryCatch(e, r, n);\n        if (\"normal\" === p.type) {\n          if (o = n.done ? s : l, p.arg === y) continue;\n          return {\n            value: p.arg,\n            done: n.done\n          };\n        }\n        \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(e, r) {\n    var n = r.method,\n      o = e.iterator[n];\n    if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y;\n    var i = tryCatch(o, e.iterator, r.arg);\n    if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y;\n    var a = i.arg;\n    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y);\n  }\n  function pushTryEntry(t) {\n    var e = {\n      tryLoc: t[0]\n    };\n    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n  }\n  function resetTryEntry(t) {\n    var e = t.completion || {};\n    e.type = \"normal\", delete e.arg, t.completion = e;\n  }\n  function Context(t) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], t.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(e) {\n    if (e || \"\" === e) {\n      var r = e[a];\n      if (r) return r.call(e);\n      if (\"function\" == typeof e.next) return e;\n      if (!isNaN(e.length)) {\n        var o = -1,\n          i = function next() {\n            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;\n            return next.value = t, next.done = !0, next;\n          };\n        return i.next = i;\n      }\n    }\n    throw new TypeError(_typeof(e) + \" is not iterable\");\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), o(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) {\n    var e = \"function\" == typeof t && t.constructor;\n    return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name));\n  }, e.mark = function (t) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t;\n  }, e.awrap = function (t) {\n    return {\n      __await: t\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {\n    return this;\n  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {\n    void 0 === i && (i = Promise);\n    var a = new AsyncIterator(wrap(t, r, n, o), i);\n    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {\n      return t.done ? t.value : a.next();\n    });\n  }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () {\n    return this;\n  }), define(g, \"toString\", function () {\n    return \"[object Generator]\";\n  }), e.keys = function (t) {\n    var e = Object(t),\n      r = [];\n    for (var n in e) r.push(n);\n    return r.reverse(), function next() {\n      for (; r.length;) {\n        var t = r.pop();\n        if (t in e) return next.value = t, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, e.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(e) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);\n    },\n    stop: function stop() {\n      this.done = !0;\n      var t = this.tryEntries[0].completion;\n      if (\"throw\" === t.type) throw t.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(e) {\n      if (this.done) throw e;\n      var r = this;\n      function handle(n, o) {\n        return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o;\n      }\n      for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n        var i = this.tryEntries[o],\n          a = i.completion;\n        if (\"root\" === i.tryLoc) return handle(\"end\");\n        if (i.tryLoc <= this.prev) {\n          var c = n.call(i, \"catchLoc\"),\n            u = n.call(i, \"finallyLoc\");\n          if (c && u) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          } else if (c) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n          } else {\n            if (!u) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(t, e) {\n      for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n        var o = this.tryEntries[r];\n        if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n          var i = o;\n          break;\n        }\n      }\n      i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n      var a = i ? i.completion : {};\n      return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a);\n    },\n    complete: function complete(t, e) {\n      if (\"throw\" === t.type) throw t.arg;\n      return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y;\n    },\n    finish: function finish(t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;\n      }\n    },\n    \"catch\": function _catch(t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.tryLoc === t) {\n          var n = r.completion;\n          if (\"throw\" === n.type) {\n            var o = n.arg;\n            resetTryEntry(r);\n          }\n          return o;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(e, r, n) {\n      return this.delegate = {\n        iterator: values(e),\n        resultName: r,\n        nextLoc: n\n      }, \"next\" === this.method && (this.arg = t), y;\n    }\n  }, e;\n}\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yUnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLDBIQUFpQztBQUMvQztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsR0FBRyxFQUFFLHlCQUF5QixTQUFTLHlCQUF5QjtBQUNoRTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0MseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yUnVudGltZS5qcz83Y2Q4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIFwidXNlIHN0cmljdFwiOyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovXG4gIG1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIGU7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIHQsXG4gICAgZSA9IHt9LFxuICAgIHIgPSBPYmplY3QucHJvdG90eXBlLFxuICAgIG4gPSByLmhhc093blByb3BlcnR5LFxuICAgIG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRbZV0gPSByLnZhbHVlO1xuICAgIH0sXG4gICAgaSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sXG4gICAgYSA9IGkuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsXG4gICAgYyA9IGkuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLFxuICAgIHUgPSBpLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuICBmdW5jdGlvbiBkZWZpbmUodCwgZSwgcikge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgZSwge1xuICAgICAgdmFsdWU6IHIsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITBcbiAgICB9KSwgdFtlXTtcbiAgfVxuICB0cnkge1xuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKHQpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRbZV0gPSByO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gd3JhcCh0LCBlLCByLCBuKSB7XG4gICAgdmFyIGkgPSBlICYmIGUucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gZSA6IEdlbmVyYXRvcixcbiAgICAgIGEgPSBPYmplY3QuY3JlYXRlKGkucHJvdG90eXBlKSxcbiAgICAgIGMgPSBuZXcgQ29udGV4dChuIHx8IFtdKTtcbiAgICByZXR1cm4gbyhhLCBcIl9pbnZva2VcIiwge1xuICAgICAgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QodCwgciwgYylcbiAgICB9KSwgYTtcbiAgfVxuICBmdW5jdGlvbiB0cnlDYXRjaCh0LCBlLCByKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGFyZzogdC5jYWxsKGUsIHIpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiB0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBlLndyYXAgPSB3cmFwO1xuICB2YXIgaCA9IFwic3VzcGVuZGVkU3RhcnRcIixcbiAgICBsID0gXCJzdXNwZW5kZWRZaWVsZFwiLFxuICAgIGYgPSBcImV4ZWN1dGluZ1wiLFxuICAgIHMgPSBcImNvbXBsZXRlZFwiLFxuICAgIHkgPSB7fTtcbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG4gIHZhciBwID0ge307XG4gIGRlZmluZShwLCBhLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICB2YXIgZCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICB2ID0gZCAmJiBkKGQodmFsdWVzKFtdKSkpO1xuICB2ICYmIHYgIT09IHIgJiYgbi5jYWxsKHYsIGEpICYmIChwID0gdik7XG4gIHZhciBnID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocCk7XG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyh0KSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRlZmluZSh0LCBlLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKGUsIHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcih0LCBlKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKHIsIG8sIGksIGEpIHtcbiAgICAgIHZhciBjID0gdHJ5Q2F0Y2godFtyXSwgdCwgbyk7XG4gICAgICBpZiAoXCJ0aHJvd1wiICE9PSBjLnR5cGUpIHtcbiAgICAgICAgdmFyIHUgPSBjLmFyZyxcbiAgICAgICAgICBoID0gdS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGggJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKGgpICYmIG4uY2FsbChoLCBcIl9fYXdhaXRcIikgPyBlLnJlc29sdmUoaC5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB0LCBpLCBhKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCB0LCBpLCBhKTtcbiAgICAgICAgfSkgOiBlLnJlc29sdmUoaCkudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHUudmFsdWUgPSB0LCBpKHUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCB0LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhKGMuYXJnKTtcbiAgICB9XG4gICAgdmFyIHI7XG4gICAgbyh0aGlzLCBcIl9pbnZva2VcIiwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIG4pIHtcbiAgICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBlKGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICBpbnZva2UodCwgbiwgZSwgcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIgPSByID8gci50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoZSwgciwgbikge1xuICAgIHZhciBvID0gaDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGksIGEpIHtcbiAgICAgIGlmIChvID09PSBmKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgaWYgKG8gPT09IHMpIHtcbiAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gaSkgdGhyb3cgYTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgICBkb25lOiAhMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZm9yIChuLm1ldGhvZCA9IGksIG4uYXJnID0gYTs7KSB7XG4gICAgICAgIHZhciBjID0gbi5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICB2YXIgdSA9IG1heWJlSW52b2tlRGVsZWdhdGUoYywgbik7XG4gICAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICAgIGlmICh1ID09PSB5KSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJuZXh0XCIgPT09IG4ubWV0aG9kKSBuLnNlbnQgPSBuLl9zZW50ID0gbi5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBuLm1ldGhvZCkge1xuICAgICAgICAgIGlmIChvID09PSBoKSB0aHJvdyBvID0gcywgbi5hcmc7XG4gICAgICAgICAgbi5kaXNwYXRjaEV4Y2VwdGlvbihuLmFyZyk7XG4gICAgICAgIH0gZWxzZSBcInJldHVyblwiID09PSBuLm1ldGhvZCAmJiBuLmFicnVwdChcInJldHVyblwiLCBuLmFyZyk7XG4gICAgICAgIG8gPSBmO1xuICAgICAgICB2YXIgcCA9IHRyeUNhdGNoKGUsIHIsIG4pO1xuICAgICAgICBpZiAoXCJub3JtYWxcIiA9PT0gcC50eXBlKSB7XG4gICAgICAgICAgaWYgKG8gPSBuLmRvbmUgPyBzIDogbCwgcC5hcmcgPT09IHkpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcC5hcmcsXG4gICAgICAgICAgICBkb25lOiBuLmRvbmVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFwidGhyb3dcIiA9PT0gcC50eXBlICYmIChvID0gcywgbi5tZXRob2QgPSBcInRocm93XCIsIG4uYXJnID0gcC5hcmcpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShlLCByKSB7XG4gICAgdmFyIG4gPSByLm1ldGhvZCxcbiAgICAgIG8gPSBlLml0ZXJhdG9yW25dO1xuICAgIGlmIChvID09PSB0KSByZXR1cm4gci5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbiAmJiBlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChyLm1ldGhvZCA9IFwicmV0dXJuXCIsIHIuYXJnID0gdCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShlLCByKSwgXCJ0aHJvd1wiID09PSByLm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbiAmJiAoci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbiArIFwiJyBtZXRob2RcIikpLCB5O1xuICAgIHZhciBpID0gdHJ5Q2F0Y2gobywgZS5pdGVyYXRvciwgci5hcmcpO1xuICAgIGlmIChcInRocm93XCIgPT09IGkudHlwZSkgcmV0dXJuIHIubWV0aG9kID0gXCJ0aHJvd1wiLCByLmFyZyA9IGkuYXJnLCByLmRlbGVnYXRlID0gbnVsbCwgeTtcbiAgICB2YXIgYSA9IGkuYXJnO1xuICAgIHJldHVybiBhID8gYS5kb25lID8gKHJbZS5yZXN1bHROYW1lXSA9IGEudmFsdWUsIHIubmV4dCA9IGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gci5tZXRob2QgJiYgKHIubWV0aG9kID0gXCJuZXh0XCIsIHIuYXJnID0gdCksIHIuZGVsZWdhdGUgPSBudWxsLCB5KSA6IGEgOiAoci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCByLmRlbGVnYXRlID0gbnVsbCwgeSk7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KHQpIHtcbiAgICB2YXIgZSA9IHtcbiAgICAgIHRyeUxvYzogdFswXVxuICAgIH07XG4gICAgMSBpbiB0ICYmIChlLmNhdGNoTG9jID0gdFsxXSksIDIgaW4gdCAmJiAoZS5maW5hbGx5TG9jID0gdFsyXSwgZS5hZnRlckxvYyA9IHRbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KHQpIHtcbiAgICB2YXIgZSA9IHQuY29tcGxldGlvbiB8fCB7fTtcbiAgICBlLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgZS5hcmcsIHQuY29tcGxldGlvbiA9IGU7XG4gIH1cbiAgZnVuY3Rpb24gQ29udGV4dCh0KSB7XG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICB9XSwgdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApO1xuICB9XG4gIGZ1bmN0aW9uIHZhbHVlcyhlKSB7XG4gICAgaWYgKGUgfHwgXCJcIiA9PT0gZSkge1xuICAgICAgdmFyIHIgPSBlW2FdO1xuICAgICAgaWYgKHIpIHJldHVybiByLmNhbGwoZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlLm5leHQpIHJldHVybiBlO1xuICAgICAgaWYgKCFpc05hTihlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIG8gPSAtMSxcbiAgICAgICAgICBpID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIGZvciAoOyArK28gPCBlLmxlbmd0aDspIGlmIChuLmNhbGwoZSwgbykpIHJldHVybiBuZXh0LnZhbHVlID0gZVtvXSwgbmV4dC5kb25lID0gITEsIG5leHQ7XG4gICAgICAgICAgICByZXR1cm4gbmV4dC52YWx1ZSA9IHQsIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBpLm5leHQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKF90eXBlb2YoZSkgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG4gIH1cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBvKGcsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICBjb25maWd1cmFibGU6ICEwXG4gIH0pLCBvKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHUsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgJiYgdC5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gISFlICYmIChlID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSkpO1xuICB9LCBlLm1hcmsgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YodCwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKHQuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZSh0LCB1LCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGcpLCB0O1xuICB9LCBlLmF3cmFwID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19hd2FpdDogdFxuICAgIH07XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZS5hc3luYyA9IGZ1bmN0aW9uICh0LCByLCBuLCBvLCBpKSB7XG4gICAgdm9pZCAwID09PSBpICYmIChpID0gUHJvbWlzZSk7XG4gICAgdmFyIGEgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKHQsIHIsIG4sIG8pLCBpKTtcbiAgICByZXR1cm4gZS5pc0dlbmVyYXRvckZ1bmN0aW9uKHIpID8gYSA6IGEubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LmRvbmUgPyB0LnZhbHVlIDogYS5uZXh0KCk7XG4gICAgfSk7XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhnKSwgZGVmaW5lKGcsIHUsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoZywgYSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZGVmaW5lKGcsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KSwgZS5rZXlzID0gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgZSA9IE9iamVjdCh0KSxcbiAgICAgIHIgPSBbXTtcbiAgICBmb3IgKHZhciBuIGluIGUpIHIucHVzaChuKTtcbiAgICByZXR1cm4gci5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmb3IgKDsgci5sZW5ndGg7KSB7XG4gICAgICAgIHZhciB0ID0gci5wb3AoKTtcbiAgICAgICAgaWYgKHQgaW4gZSkgcmV0dXJuIG5leHQudmFsdWUgPSB0LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDtcbiAgICB9O1xuICB9LCBlLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KGUpIHtcbiAgICAgIGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhZSkgZm9yICh2YXIgciBpbiB0aGlzKSBcInRcIiA9PT0gci5jaGFyQXQoMCkgJiYgbi5jYWxsKHRoaXMsIHIpICYmICFpc05hTigrci5zbGljZSgxKSkgJiYgKHRoaXNbcl0gPSB0KTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgIHZhciB0ID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247XG4gICAgICBpZiAoXCJ0aHJvd1wiID09PSB0LnR5cGUpIHRocm93IHQuYXJnO1xuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB0aHJvdyBlO1xuICAgICAgdmFyIHIgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKG4sIG8pIHtcbiAgICAgICAgcmV0dXJuIGEudHlwZSA9IFwidGhyb3dcIiwgYS5hcmcgPSBlLCByLm5leHQgPSBuLCBvICYmIChyLm1ldGhvZCA9IFwibmV4dFwiLCByLmFyZyA9IHQpLCAhIW87XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBvID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IG8gPj0gMDsgLS1vKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy50cnlFbnRyaWVzW29dLFxuICAgICAgICAgIGEgPSBpLmNvbXBsZXRpb247XG4gICAgICAgIGlmIChcInJvb3RcIiA9PT0gaS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIGlmIChpLnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgYyA9IG4uY2FsbChpLCBcImNhdGNoTG9jXCIpLFxuICAgICAgICAgICAgdSA9IG4uY2FsbChpLCBcImZpbmFsbHlMb2NcIik7XG4gICAgICAgICAgaWYgKGMgJiYgdSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoaS5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShpLmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYykge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoaS5jYXRjaExvYywgITApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXUpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShpLmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyByID49IDA7IC0tcikge1xuICAgICAgICB2YXIgbyA9IHRoaXMudHJ5RW50cmllc1tyXTtcbiAgICAgICAgaWYgKG8udHJ5TG9jIDw9IHRoaXMucHJldiAmJiBuLmNhbGwobywgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IG8uZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBpID0gbztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSAmJiAoXCJicmVha1wiID09PSB0IHx8IFwiY29udGludWVcIiA9PT0gdCkgJiYgaS50cnlMb2MgPD0gZSAmJiBlIDw9IGkuZmluYWxseUxvYyAmJiAoaSA9IG51bGwpO1xuICAgICAgdmFyIGEgPSBpID8gaS5jb21wbGV0aW9uIDoge307XG4gICAgICByZXR1cm4gYS50eXBlID0gdCwgYS5hcmcgPSBlLCBpID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGkuZmluYWxseUxvYywgeSkgOiB0aGlzLmNvbXBsZXRlKGEpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHQsIGUpIHtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7XG4gICAgICByZXR1cm4gXCJicmVha1wiID09PSB0LnR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0LnR5cGUgPyB0aGlzLm5leHQgPSB0LmFyZyA6IFwicmV0dXJuXCIgPT09IHQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gdC50eXBlICYmIGUgJiYgKHRoaXMubmV4dCA9IGUpLCB5O1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2godCkge1xuICAgICAgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkge1xuICAgICAgICB2YXIgciA9IHRoaXMudHJ5RW50cmllc1tlXTtcbiAgICAgICAgaWYgKHIuZmluYWxseUxvYyA9PT0gdCkgcmV0dXJuIHRoaXMuY29tcGxldGUoci5jb21wbGV0aW9uLCByLmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShyKSwgeTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgZSA+PSAwOyAtLWUpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07XG4gICAgICAgIGlmIChyLnRyeUxvYyA9PT0gdCkge1xuICAgICAgICAgIHZhciBuID0gci5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IG4udHlwZSkge1xuICAgICAgICAgICAgdmFyIG8gPSBuLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkocik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGUpLFxuICAgICAgICByZXN1bHROYW1lOiByLFxuICAgICAgICBuZXh0TG9jOiBuXG4gICAgICB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdCksIHk7XG4gICAgfVxuICB9LCBlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLHlCQUF5QixTQUFTLHlCQUF5QjtBQUNoRTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcz8wMzViIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/setPrototypeOf.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsd0dBQXFCO0FBQ2xELDJCQUEyQixtQkFBTyxDQUFDLG9IQUEyQjtBQUM5RCxpQ0FBaUMsbUJBQU8sQ0FBQyxnSUFBaUM7QUFDMUUsc0JBQXNCLG1CQUFPLENBQUMsMEdBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcz81MDNlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzLmpzXCIpO1xudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXQuanNcIik7XG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIik7XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/slicedToArray.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsMEhBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1ByaW1pdGl2ZS5qcz85MGUyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJpbWl0aXZlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/toPrimitive.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nvar toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : String(i);\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYywwSEFBaUM7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsa0dBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzP2ZmOTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZShcIi4vdG9QcmltaXRpdmUuanNcIik7XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBTdHJpbmcoaSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJvcGVydHlLZXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/toPropertyKey.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHLEVBQUUseUJBQXlCLFNBQVMseUJBQXlCO0FBQ2hFO0FBQ0EsMEJBQTBCLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/M2JmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpLCBfdHlwZW9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/typeof.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFBLHVCQUF1QixtQkFBTyxDQUFDLDRHQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcz82ZDg1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\nvar setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\nvar isNativeFunction = __webpack_require__(/*! ./isNativeFunction.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/isNativeFunction.js\");\nvar construct = __webpack_require__(/*! ./construct.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/construct.js\");\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _wrapNativeSuper(Class);\n}\nmodule.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsbUJBQU8sQ0FBQyx3R0FBcUI7QUFDbEQscUJBQXFCLG1CQUFPLENBQUMsd0dBQXFCO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLDRHQUF1QjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxFQUFFLHlCQUF5QixTQUFTLHlCQUF5QjtBQUNoRTtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanM/YjRmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xudmFyIGlzTmF0aXZlRnVuY3Rpb24gPSByZXF1aXJlKFwiLi9pc05hdGl2ZUZ1bmN0aW9uLmpzXCIpO1xudmFyIGNvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdC5qc1wiKTtcbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIGdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// TODO(Babel 8): Remove this file.\n\nvar runtime = __webpack_require__(/*! ../helpers/regeneratorRuntime */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\")();\nmodule.exports = runtime;\n\n// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsc0hBQStCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/NzJmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPKEJhYmVsIDgpOiBSZW1vdmUgdGhpcyBmaWxlLlxuXG52YXIgcnVudGltZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3JlZ2VuZXJhdG9yUnVudGltZVwiKSgpO1xubW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL3BhY2thZ2VzL3J1bnRpbWUvcnVudGltZS5qcyNMNzM2PVxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBlbHNlIHtcbiAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/regenerator/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/AblyContext.js":
/*!****************************************************!*\
  !*** ./node_modules/ably/react/mjs/AblyContext.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AblyContext: function() { return /* binding */ AblyContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// We need to make sure we never create more than one Ably React context.\n// This might happen when exporting a context directly from a module -\n// there's a risk of creating multiple instances of the same context\n// if there are misconfigurations in module bundler or package manager on the consumer side of Ably Context.\n// This can lead to problems like having an Ably Channel instance added\n// in one context, and then attempting to retrieve it from another different context.\n// This is why a single Ably context is created and stored in the global state.\nconst contextKey = Symbol.for('__ABLY_CONTEXT__');\nconst globalObjectForContext = typeof globalThis !== 'undefined' ? globalThis : {};\nfunction getContext() {\n    let context = globalObjectForContext[contextKey];\n    if (!context) {\n        context = globalObjectForContext[contextKey] = react__WEBPACK_IMPORTED_MODULE_0__.createContext({});\n    }\n    return context;\n}\nconst AblyContext = getContext();\n//# sourceMappingURL=AblyContext.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9BYmx5Q29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0RBQW1CLEdBQUc7QUFDN0U7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvQWJseUNvbnRleHQuanM/NDNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgbmV2ZXIgY3JlYXRlIG1vcmUgdGhhbiBvbmUgQWJseSBSZWFjdCBjb250ZXh0LlxuLy8gVGhpcyBtaWdodCBoYXBwZW4gd2hlbiBleHBvcnRpbmcgYSBjb250ZXh0IGRpcmVjdGx5IGZyb20gYSBtb2R1bGUgLVxuLy8gdGhlcmUncyBhIHJpc2sgb2YgY3JlYXRpbmcgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIGNvbnRleHRcbi8vIGlmIHRoZXJlIGFyZSBtaXNjb25maWd1cmF0aW9ucyBpbiBtb2R1bGUgYnVuZGxlciBvciBwYWNrYWdlIG1hbmFnZXIgb24gdGhlIGNvbnN1bWVyIHNpZGUgb2YgQWJseSBDb250ZXh0LlxuLy8gVGhpcyBjYW4gbGVhZCB0byBwcm9ibGVtcyBsaWtlIGhhdmluZyBhbiBBYmx5IENoYW5uZWwgaW5zdGFuY2UgYWRkZWRcbi8vIGluIG9uZSBjb250ZXh0LCBhbmQgdGhlbiBhdHRlbXB0aW5nIHRvIHJldHJpZXZlIGl0IGZyb20gYW5vdGhlciBkaWZmZXJlbnQgY29udGV4dC5cbi8vIFRoaXMgaXMgd2h5IGEgc2luZ2xlIEFibHkgY29udGV4dCBpcyBjcmVhdGVkIGFuZCBzdG9yZWQgaW4gdGhlIGdsb2JhbCBzdGF0ZS5cbmNvbnN0IGNvbnRleHRLZXkgPSBTeW1ib2wuZm9yKCdfX0FCTFlfQ09OVEVYVF9fJyk7XG5jb25zdCBnbG9iYWxPYmplY3RGb3JDb250ZXh0ID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHt9O1xuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICBsZXQgY29udGV4dCA9IGdsb2JhbE9iamVjdEZvckNvbnRleHRbY29udGV4dEtleV07XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBnbG9iYWxPYmplY3RGb3JDb250ZXh0W2NvbnRleHRLZXldID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuZXhwb3J0IGNvbnN0IEFibHlDb250ZXh0ID0gZ2V0Q29udGV4dCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJseUNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/AblyContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/AblyProvider.js":
/*!*****************************************************!*\
  !*** ./node_modules/ably/react/mjs/AblyProvider.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AblyProvider: function() { return /* binding */ AblyProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AblyContext.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/AblyContext.js\");\n\n\n\nconst AblyProvider = ({ client, children, ablyId = 'default' }) => {\n    if (!client) {\n        throw new Error('AblyProvider: the `client` prop is required');\n    }\n    const context = react__WEBPACK_IMPORTED_MODULE_1__.useContext(_AblyContext_js__WEBPACK_IMPORTED_MODULE_2__.AblyContext);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        return Object.assign(Object.assign({}, context), { [ablyId]: { client, _channelNameToChannelContext: {} } });\n    }, [context, client, ablyId]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_AblyContext_js__WEBPACK_IMPORTED_MODULE_2__.AblyContext.Provider, Object.assign({ value: value }, { children: children }));\n};\n//# sourceMappingURL=AblyProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9BYmx5UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRDtBQUNUO0FBQ1E7QUFDeEMsd0JBQXdCLHNDQUFzQztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQWdCLENBQUMsd0RBQVc7QUFDaEQsa0JBQWtCLDhDQUFPO0FBQ3pCLDZDQUE2QyxjQUFjLFlBQVksNENBQTRDO0FBQ25ILEtBQUs7QUFDTCxXQUFXLHNEQUFJLENBQUMsd0RBQVcsMkJBQTJCLGNBQWMsSUFBSSxvQkFBb0I7QUFDNUY7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvQWJseVByb3ZpZGVyLmpzPzYzYjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQWJseUNvbnRleHQgfSBmcm9tICcuL0FibHlDb250ZXh0LmpzJztcbmV4cG9ydCBjb25zdCBBYmx5UHJvdmlkZXIgPSAoeyBjbGllbnQsIGNoaWxkcmVuLCBhYmx5SWQgPSAnZGVmYXVsdCcgfSkgPT4ge1xuICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWJseVByb3ZpZGVyOiB0aGUgYGNsaWVudGAgcHJvcCBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChBYmx5Q29udGV4dCk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCksIHsgW2FibHlJZF06IHsgY2xpZW50LCBfY2hhbm5lbE5hbWVUb0NoYW5uZWxDb250ZXh0OiB7fSB9IH0pO1xuICAgIH0sIFtjb250ZXh0LCBjbGllbnQsIGFibHlJZF0pO1xuICAgIHJldHVybiBfanN4KEFibHlDb250ZXh0LlByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgdmFsdWU6IHZhbHVlIH0sIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmx5UHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/AblyProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/AblyReactHooks.js":
/*!*******************************************************!*\
  !*** ./node_modules/ably/react/mjs/AblyReactHooks.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   channelOptionsWithAgent: function() { return /* binding */ channelOptionsWithAgent; },\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\nconst version = '2.3.1';\nfunction channelOptionsWithAgent(options) {\n    return Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), { agent: `react-hooks/${version}` }) });\n}\n//# sourceMappingURL=AblyReactHooks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9BYmx5UmVhY3RIb29rcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ0E7QUFDUCx5Q0FBeUMsY0FBYyxzQ0FBc0MsdUVBQXVFLHNCQUFzQixRQUFRLEdBQUcsR0FBRztBQUN4TTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9BYmx5UmVhY3RIb29rcy5qcz80MDBjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuMy4xJztcbmV4cG9ydCBmdW5jdGlvbiBjaGFubmVsT3B0aW9uc1dpdGhBZ2VudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcGFyYW1zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpLCB7IGFnZW50OiBgcmVhY3QtaG9va3MvJHt2ZXJzaW9ufWAgfSkgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmx5UmVhY3RIb29rcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/AblyReactHooks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/ChannelProvider.js":
/*!********************************************************!*\
  !*** ./node_modules/ably/react/mjs/ChannelProvider.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelProvider: function() { return /* binding */ ChannelProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AblyContext.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/AblyContext.js\");\n/* harmony import */ var _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AblyReactHooks.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/AblyReactHooks.js\");\n\n\n\n\nconst ChannelProvider = ({ ablyId = 'default', channelName, options, deriveOptions, children, }) => {\n    const context = react__WEBPACK_IMPORTED_MODULE_1__.useContext(_AblyContext_js__WEBPACK_IMPORTED_MODULE_2__.AblyContext);\n    const { client, _channelNameToChannelContext } = context[ablyId];\n    if (_channelNameToChannelContext[channelName]) {\n        throw new Error('You can not use more than one `ChannelProvider` with the same channel name');\n    }\n    const derived = Boolean(deriveOptions);\n    const channel = derived ? client.channels.getDerived(channelName, deriveOptions) : client.channels.get(channelName);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        return Object.assign(Object.assign({}, context), { [ablyId]: {\n                client,\n                _channelNameToChannelContext: Object.assign(Object.assign({}, _channelNameToChannelContext), { [channelName]: {\n                        channel,\n                        derived,\n                    } }),\n            } });\n    }, [derived, client, channel, channelName, _channelNameToChannelContext, ablyId, context]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(() => {\n        channel.setOptions((0,_AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_3__.channelOptionsWithAgent)(options));\n    }, [channel, options]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_AblyContext_js__WEBPACK_IMPORTED_MODULE_2__.AblyContext.Provider, Object.assign({ value: value }, { children: children }));\n};\n//# sourceMappingURL=ChannelProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9DaGFubmVsUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDUTtBQUNUO0FBQ2U7QUFDdkQsMkJBQTJCLG9FQUFvRTtBQUN0RyxvQkFBb0IsNkNBQWdCLENBQUMsd0RBQVc7QUFDaEQsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBTztBQUN6Qiw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBLDRFQUE0RSxtQ0FBbUM7QUFDL0c7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2YsS0FBSztBQUNMLElBQUksc0RBQWU7QUFDbkIsMkJBQTJCLDJFQUF1QjtBQUNsRCxLQUFLO0FBQ0wsV0FBVyxzREFBSSxDQUFDLHdEQUFXLDJCQUEyQixjQUFjLElBQUksb0JBQW9CO0FBQzVGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL0NoYW5uZWxQcm92aWRlci5qcz9jNDI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQWJseUNvbnRleHQgfSBmcm9tICcuL0FibHlDb250ZXh0LmpzJztcbmltcG9ydCB7IGNoYW5uZWxPcHRpb25zV2l0aEFnZW50IH0gZnJvbSAnLi9BYmx5UmVhY3RIb29rcy5qcyc7XG5leHBvcnQgY29uc3QgQ2hhbm5lbFByb3ZpZGVyID0gKHsgYWJseUlkID0gJ2RlZmF1bHQnLCBjaGFubmVsTmFtZSwgb3B0aW9ucywgZGVyaXZlT3B0aW9ucywgY2hpbGRyZW4sIH0pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChBYmx5Q29udGV4dCk7XG4gICAgY29uc3QgeyBjbGllbnQsIF9jaGFubmVsTmFtZVRvQ2hhbm5lbENvbnRleHQgfSA9IGNvbnRleHRbYWJseUlkXTtcbiAgICBpZiAoX2NoYW5uZWxOYW1lVG9DaGFubmVsQ29udGV4dFtjaGFubmVsTmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG5vdCB1c2UgbW9yZSB0aGFuIG9uZSBgQ2hhbm5lbFByb3ZpZGVyYCB3aXRoIHRoZSBzYW1lIGNoYW5uZWwgbmFtZScpO1xuICAgIH1cbiAgICBjb25zdCBkZXJpdmVkID0gQm9vbGVhbihkZXJpdmVPcHRpb25zKTtcbiAgICBjb25zdCBjaGFubmVsID0gZGVyaXZlZCA/IGNsaWVudC5jaGFubmVscy5nZXREZXJpdmVkKGNoYW5uZWxOYW1lLCBkZXJpdmVPcHRpb25zKSA6IGNsaWVudC5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IFthYmx5SWRdOiB7XG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgICAgIF9jaGFubmVsTmFtZVRvQ2hhbm5lbENvbnRleHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX2NoYW5uZWxOYW1lVG9DaGFubmVsQ29udGV4dCksIHsgW2NoYW5uZWxOYW1lXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcml2ZWQsXG4gICAgICAgICAgICAgICAgICAgIH0gfSksXG4gICAgICAgICAgICB9IH0pO1xuICAgIH0sIFtkZXJpdmVkLCBjbGllbnQsIGNoYW5uZWwsIGNoYW5uZWxOYW1lLCBfY2hhbm5lbE5hbWVUb0NoYW5uZWxDb250ZXh0LCBhYmx5SWQsIGNvbnRleHRdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnNXaXRoQWdlbnQob3B0aW9ucykpO1xuICAgIH0sIFtjaGFubmVsLCBvcHRpb25zXSk7XG4gICAgcmV0dXJuIF9qc3goQWJseUNvbnRleHQuUHJvdmlkZXIsIE9iamVjdC5hc3NpZ24oeyB2YWx1ZTogdmFsdWUgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW5uZWxQcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/ChannelProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useAbly.js":
/*!******************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useAbly.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAbly: function() { return /* binding */ useAbly; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AblyContext.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/AblyContext.js\");\n\n\nfunction useAbly(ablyId = 'default') {\n    const client = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_AblyContext_js__WEBPACK_IMPORTED_MODULE_1__.AblyContext)[ablyId].client;\n    if (!client) {\n        throw new Error('Could not find ably client in context. ' + 'Make sure your ably hooks are called inside an <AblyProvider>');\n    }\n    return client;\n}\n//# sourceMappingURL=useAbly.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VBYmx5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQUNzQjtBQUN6QztBQUNQLG1CQUFtQiw2Q0FBZ0IsQ0FBQyx3REFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL2hvb2tzL3VzZUFibHkuanM/MDM2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQWJseUNvbnRleHQgfSBmcm9tICcuLi9BYmx5Q29udGV4dC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gdXNlQWJseShhYmx5SWQgPSAnZGVmYXVsdCcpIHtcbiAgICBjb25zdCBjbGllbnQgPSBSZWFjdC51c2VDb250ZXh0KEFibHlDb250ZXh0KVthYmx5SWRdLmNsaWVudDtcbiAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGFibHkgY2xpZW50IGluIGNvbnRleHQuICcgKyAnTWFrZSBzdXJlIHlvdXIgYWJseSBob29rcyBhcmUgY2FsbGVkIGluc2lkZSBhbiA8QWJseVByb3ZpZGVyPicpO1xuICAgIH1cbiAgICByZXR1cm4gY2xpZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQWJseS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useAbly.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannel.js":
/*!*********************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useChannel.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChannel: function() { return /* binding */ useChannel; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _useAbly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useAbly.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useAbly.js\");\n/* harmony import */ var _useStateErrors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useStateErrors.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useStateErrors.js\");\n/* harmony import */ var _useChannelInstance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useChannelInstance.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\");\n\n\n\n\nfunction useChannel(channelNameOrNameAndOptions, eventOrCallback, callback) {\n    const channelHookOptions = typeof channelNameOrNameAndOptions === 'object'\n        ? channelNameOrNameAndOptions\n        : { channelName: channelNameOrNameAndOptions };\n    const ably = (0,_useAbly_js__WEBPACK_IMPORTED_MODULE_1__.useAbly)(channelHookOptions.ablyId);\n    const { channelName, skip } = channelHookOptions;\n    const { channel, derived } = (0,_useChannelInstance_js__WEBPACK_IMPORTED_MODULE_3__.useChannelInstance)(channelHookOptions.ablyId, channelName);\n    const publish = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (!derived)\n            return channel.publish.bind(channel);\n        const regularChannel = ably.channels.get(channelName);\n        // For derived channels we use transient publish (it won't attach to the channel)\n        return regularChannel.publish.bind(regularChannel);\n    }, [ably.channels, derived, channel, channelName]);\n    const channelEvent = typeof eventOrCallback === 'string' ? eventOrCallback : null;\n    const ablyMessageCallback = typeof eventOrCallback === 'string' ? callback : eventOrCallback;\n    const ablyMessageCallbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(ablyMessageCallback);\n    const { connectionError, channelError } = (0,_useStateErrors_js__WEBPACK_IMPORTED_MODULE_2__.useStateErrors)(channelHookOptions);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        ablyMessageCallbackRef.current = ablyMessageCallback;\n    }, [ablyMessageCallback]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const listener = ablyMessageCallbackRef.current\n            ? (message) => {\n                ablyMessageCallbackRef.current && ablyMessageCallbackRef.current(message);\n            }\n            : null;\n        const subscribeArgs = listener\n            ? channelEvent === null\n                ? [listener]\n                : [channelEvent, listener]\n            : null;\n        if (!skip && subscribeArgs) {\n            handleChannelMount(channel, ...subscribeArgs);\n        }\n        return () => {\n            !skip && subscribeArgs && handleChannelUnmount(channel, ...subscribeArgs);\n        };\n    }, [channelEvent, channel, skip]);\n    return { channel, publish, ably, connectionError, channelError };\n}\nasync function handleChannelMount(channel, ...subscribeArgs) {\n    await channel.subscribe(...subscribeArgs);\n}\nasync function handleChannelUnmount(channel, ...subscribeArgs) {\n    await channel.unsubscribe(...subscribeArgs);\n}\n//# sourceMappingURL=useChannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VDaGFubmVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1EO0FBQ1o7QUFDYztBQUNRO0FBQ3REO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWixpQkFBaUIsb0RBQU87QUFDeEIsWUFBWSxvQkFBb0I7QUFDaEMsWUFBWSxtQkFBbUIsRUFBRSwwRUFBa0I7QUFDbkQsb0JBQW9CLDhDQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyw2Q0FBTTtBQUN6QyxZQUFZLGdDQUFnQyxFQUFFLGtFQUFjO0FBQzVELElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL2hvb2tzL3VzZUNoYW5uZWwuanM/MzY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUFibHkgfSBmcm9tICcuL3VzZUFibHkuanMnO1xuaW1wb3J0IHsgdXNlU3RhdGVFcnJvcnMgfSBmcm9tICcuL3VzZVN0YXRlRXJyb3JzLmpzJztcbmltcG9ydCB7IHVzZUNoYW5uZWxJbnN0YW5jZSB9IGZyb20gJy4vdXNlQ2hhbm5lbEluc3RhbmNlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGFubmVsKGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucywgZXZlbnRPckNhbGxiYWNrLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGNoYW5uZWxIb29rT3B0aW9ucyA9IHR5cGVvZiBjaGFubmVsTmFtZU9yTmFtZUFuZE9wdGlvbnMgPT09ICdvYmplY3QnXG4gICAgICAgID8gY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zXG4gICAgICAgIDogeyBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zIH07XG4gICAgY29uc3QgYWJseSA9IHVzZUFibHkoY2hhbm5lbEhvb2tPcHRpb25zLmFibHlJZCk7XG4gICAgY29uc3QgeyBjaGFubmVsTmFtZSwgc2tpcCB9ID0gY2hhbm5lbEhvb2tPcHRpb25zO1xuICAgIGNvbnN0IHsgY2hhbm5lbCwgZGVyaXZlZCB9ID0gdXNlQ2hhbm5lbEluc3RhbmNlKGNoYW5uZWxIb29rT3B0aW9ucy5hYmx5SWQsIGNoYW5uZWxOYW1lKTtcbiAgICBjb25zdCBwdWJsaXNoID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghZGVyaXZlZClcbiAgICAgICAgICAgIHJldHVybiBjaGFubmVsLnB1Ymxpc2guYmluZChjaGFubmVsKTtcbiAgICAgICAgY29uc3QgcmVndWxhckNoYW5uZWwgPSBhYmx5LmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSk7XG4gICAgICAgIC8vIEZvciBkZXJpdmVkIGNoYW5uZWxzIHdlIHVzZSB0cmFuc2llbnQgcHVibGlzaCAoaXQgd29uJ3QgYXR0YWNoIHRvIHRoZSBjaGFubmVsKVxuICAgICAgICByZXR1cm4gcmVndWxhckNoYW5uZWwucHVibGlzaC5iaW5kKHJlZ3VsYXJDaGFubmVsKTtcbiAgICB9LCBbYWJseS5jaGFubmVscywgZGVyaXZlZCwgY2hhbm5lbCwgY2hhbm5lbE5hbWVdKTtcbiAgICBjb25zdCBjaGFubmVsRXZlbnQgPSB0eXBlb2YgZXZlbnRPckNhbGxiYWNrID09PSAnc3RyaW5nJyA/IGV2ZW50T3JDYWxsYmFjayA6IG51bGw7XG4gICAgY29uc3QgYWJseU1lc3NhZ2VDYWxsYmFjayA9IHR5cGVvZiBldmVudE9yQ2FsbGJhY2sgPT09ICdzdHJpbmcnID8gY2FsbGJhY2sgOiBldmVudE9yQ2FsbGJhY2s7XG4gICAgY29uc3QgYWJseU1lc3NhZ2VDYWxsYmFja1JlZiA9IHVzZVJlZihhYmx5TWVzc2FnZUNhbGxiYWNrKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25FcnJvciwgY2hhbm5lbEVycm9yIH0gPSB1c2VTdGF0ZUVycm9ycyhjaGFubmVsSG9va09wdGlvbnMpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGFibHlNZXNzYWdlQ2FsbGJhY2tSZWYuY3VycmVudCA9IGFibHlNZXNzYWdlQ2FsbGJhY2s7XG4gICAgfSwgW2FibHlNZXNzYWdlQ2FsbGJhY2tdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGFibHlNZXNzYWdlQ2FsbGJhY2tSZWYuY3VycmVudFxuICAgICAgICAgICAgPyAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFibHlNZXNzYWdlQ2FsbGJhY2tSZWYuY3VycmVudCAmJiBhYmx5TWVzc2FnZUNhbGxiYWNrUmVmLmN1cnJlbnQobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZUFyZ3MgPSBsaXN0ZW5lclxuICAgICAgICAgICAgPyBjaGFubmVsRXZlbnQgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFtsaXN0ZW5lcl1cbiAgICAgICAgICAgICAgICA6IFtjaGFubmVsRXZlbnQsIGxpc3RlbmVyXVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIXNraXAgJiYgc3Vic2NyaWJlQXJncykge1xuICAgICAgICAgICAgaGFuZGxlQ2hhbm5lbE1vdW50KGNoYW5uZWwsIC4uLnN1YnNjcmliZUFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAhc2tpcCAmJiBzdWJzY3JpYmVBcmdzICYmIGhhbmRsZUNoYW5uZWxVbm1vdW50KGNoYW5uZWwsIC4uLnN1YnNjcmliZUFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0sIFtjaGFubmVsRXZlbnQsIGNoYW5uZWwsIHNraXBdKTtcbiAgICByZXR1cm4geyBjaGFubmVsLCBwdWJsaXNoLCBhYmx5LCBjb25uZWN0aW9uRXJyb3IsIGNoYW5uZWxFcnJvciB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ2hhbm5lbE1vdW50KGNoYW5uZWwsIC4uLnN1YnNjcmliZUFyZ3MpIHtcbiAgICBhd2FpdCBjaGFubmVsLnN1YnNjcmliZSguLi5zdWJzY3JpYmVBcmdzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNoYW5uZWxVbm1vdW50KGNoYW5uZWwsIC4uLnN1YnNjcmliZUFyZ3MpIHtcbiAgICBhd2FpdCBjaGFubmVsLnVuc3Vic2NyaWJlKC4uLnN1YnNjcmliZUFyZ3MpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQ2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useChannelInstance.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChannelInstance: function() { return /* binding */ useChannelInstance; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AblyContext.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/AblyContext.js\");\n\n\nfunction useChannelInstance(ablyId = 'default', channelName) {\n    const channelContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_AblyContext_js__WEBPACK_IMPORTED_MODULE_1__.AblyContext)[ablyId]._channelNameToChannelContext[channelName];\n    if (!channelContext) {\n        throw new Error(`Could not find a parent ChannelProvider in the component tree for channelName=\"${channelName}\". Make sure your channel based hooks (usePresence, useChannel, useChannelStateListener) are called inside a <ChannelProvider> component`);\n    }\n    return channelContext;\n}\n//# sourceMappingURL=useChannelInstance.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VDaGFubmVsSW5zdGFuY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBCO0FBQ3NCO0FBQ3pDO0FBQ1AsMkJBQTJCLDZDQUFnQixDQUFDLHdEQUFXO0FBQ3ZEO0FBQ0EsMEdBQTBHLFlBQVk7QUFDdEg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL2hvb2tzL3VzZUNoYW5uZWxJbnN0YW5jZS5qcz8zMmEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBBYmx5Q29udGV4dCB9IGZyb20gJy4uL0FibHlDb250ZXh0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGFubmVsSW5zdGFuY2UoYWJseUlkID0gJ2RlZmF1bHQnLCBjaGFubmVsTmFtZSkge1xuICAgIGNvbnN0IGNoYW5uZWxDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChBYmx5Q29udGV4dClbYWJseUlkXS5fY2hhbm5lbE5hbWVUb0NoYW5uZWxDb250ZXh0W2NoYW5uZWxOYW1lXTtcbiAgICBpZiAoIWNoYW5uZWxDb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBwYXJlbnQgQ2hhbm5lbFByb3ZpZGVyIGluIHRoZSBjb21wb25lbnQgdHJlZSBmb3IgY2hhbm5lbE5hbWU9XCIke2NoYW5uZWxOYW1lfVwiLiBNYWtlIHN1cmUgeW91ciBjaGFubmVsIGJhc2VkIGhvb2tzICh1c2VQcmVzZW5jZSwgdXNlQ2hhbm5lbCwgdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIpIGFyZSBjYWxsZWQgaW5zaWRlIGEgPENoYW5uZWxQcm92aWRlcj4gY29tcG9uZW50YCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsQ29udGV4dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUNoYW5uZWxJbnN0YW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useChannelStateListener.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChannelStateListener: function() { return /* binding */ useChannelStateListener; }\n/* harmony export */ });\n/* harmony import */ var _useEventListener_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useEventListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useEventListener.js\");\n/* harmony import */ var _useChannelInstance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useChannelInstance.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\");\n\n\nfunction useChannelStateListener(channelNameOrNameAndAblyId, stateOrListener, listener) {\n    const channelHookOptions = typeof channelNameOrNameAndAblyId === 'object'\n        ? channelNameOrNameAndAblyId\n        : { channelName: channelNameOrNameAndAblyId };\n    const { ablyId, channelName } = channelHookOptions;\n    const { channel } = (0,_useChannelInstance_js__WEBPACK_IMPORTED_MODULE_1__.useChannelInstance)(ablyId, channelName);\n    const _listener = typeof listener === 'function' ? listener : stateOrListener;\n    const state = typeof stateOrListener !== 'function' ? stateOrListener : undefined;\n    (0,_useEventListener_js__WEBPACK_IMPORTED_MODULE_0__.useEventListener)(channel, _listener, state);\n}\n//# sourceMappingURL=useChannelStateListener.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VDaGFubmVsU3RhdGVMaXN0ZW5lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUFDSTtBQUN0RDtBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWSxzQkFBc0I7QUFDbEMsWUFBWSxVQUFVLEVBQUUsMEVBQWtCO0FBQzFDO0FBQ0E7QUFDQSxJQUFJLHNFQUFnQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VDaGFubmVsU3RhdGVMaXN0ZW5lci5qcz9jNDUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUV2ZW50TGlzdGVuZXIgfSBmcm9tICcuL3VzZUV2ZW50TGlzdGVuZXIuanMnO1xuaW1wb3J0IHsgdXNlQ2hhbm5lbEluc3RhbmNlIH0gZnJvbSAnLi91c2VDaGFubmVsSW5zdGFuY2UuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYW5uZWxTdGF0ZUxpc3RlbmVyKGNoYW5uZWxOYW1lT3JOYW1lQW5kQWJseUlkLCBzdGF0ZU9yTGlzdGVuZXIsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgY2hhbm5lbEhvb2tPcHRpb25zID0gdHlwZW9mIGNoYW5uZWxOYW1lT3JOYW1lQW5kQWJseUlkID09PSAnb2JqZWN0J1xuICAgICAgICA/IGNoYW5uZWxOYW1lT3JOYW1lQW5kQWJseUlkXG4gICAgICAgIDogeyBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWVPck5hbWVBbmRBYmx5SWQgfTtcbiAgICBjb25zdCB7IGFibHlJZCwgY2hhbm5lbE5hbWUgfSA9IGNoYW5uZWxIb29rT3B0aW9ucztcbiAgICBjb25zdCB7IGNoYW5uZWwgfSA9IHVzZUNoYW5uZWxJbnN0YW5jZShhYmx5SWQsIGNoYW5uZWxOYW1lKTtcbiAgICBjb25zdCBfbGlzdGVuZXIgPSB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgPyBsaXN0ZW5lciA6IHN0YXRlT3JMaXN0ZW5lcjtcbiAgICBjb25zdCBzdGF0ZSA9IHR5cGVvZiBzdGF0ZU9yTGlzdGVuZXIgIT09ICdmdW5jdGlvbicgPyBzdGF0ZU9yTGlzdGVuZXIgOiB1bmRlZmluZWQ7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihjaGFubmVsLCBfbGlzdGVuZXIsIHN0YXRlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUNoYW5uZWxTdGF0ZUxpc3RlbmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useConnectionStateListener: function() { return /* binding */ useConnectionStateListener; }\n/* harmony export */ });\n/* harmony import */ var _useAbly_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useAbly.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useAbly.js\");\n/* harmony import */ var _useEventListener_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useEventListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useEventListener.js\");\n\n\nfunction useConnectionStateListener(stateOrListener, listenerOrAblyId, ablyId = 'default') {\n    const _ablyId = typeof listenerOrAblyId === 'string' ? listenerOrAblyId : ablyId;\n    const ably = (0,_useAbly_js__WEBPACK_IMPORTED_MODULE_0__.useAbly)(_ablyId);\n    const listener = typeof listenerOrAblyId === 'function' ? listenerOrAblyId : stateOrListener;\n    const state = typeof stateOrListener !== 'function' ? stateOrListener : undefined;\n    (0,_useEventListener_js__WEBPACK_IMPORTED_MODULE_1__.useEventListener)(ably.connection, listener, state);\n}\n//# sourceMappingURL=useConnectionStateListener.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VDb25uZWN0aW9uU3RhdGVMaXN0ZW5lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUM7QUFDa0I7QUFDbEQ7QUFDUDtBQUNBLGlCQUFpQixvREFBTztBQUN4QjtBQUNBO0FBQ0EsSUFBSSxzRUFBZ0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIuanM/Y2U4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VBYmx5IH0gZnJvbSAnLi91c2VBYmx5LmpzJztcbmltcG9ydCB7IHVzZUV2ZW50TGlzdGVuZXIgfSBmcm9tICcuL3VzZUV2ZW50TGlzdGVuZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyKHN0YXRlT3JMaXN0ZW5lciwgbGlzdGVuZXJPckFibHlJZCwgYWJseUlkID0gJ2RlZmF1bHQnKSB7XG4gICAgY29uc3QgX2FibHlJZCA9IHR5cGVvZiBsaXN0ZW5lck9yQWJseUlkID09PSAnc3RyaW5nJyA/IGxpc3RlbmVyT3JBYmx5SWQgOiBhYmx5SWQ7XG4gICAgY29uc3QgYWJseSA9IHVzZUFibHkoX2FibHlJZCk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSB0eXBlb2YgbGlzdGVuZXJPckFibHlJZCA9PT0gJ2Z1bmN0aW9uJyA/IGxpc3RlbmVyT3JBYmx5SWQgOiBzdGF0ZU9yTGlzdGVuZXI7XG4gICAgY29uc3Qgc3RhdGUgPSB0eXBlb2Ygc3RhdGVPckxpc3RlbmVyICE9PSAnZnVuY3Rpb24nID8gc3RhdGVPckxpc3RlbmVyIDogdW5kZWZpbmVkO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoYWJseS5jb25uZWN0aW9uLCBsaXN0ZW5lciwgc3RhdGUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useEventListener.js":
/*!***************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useEventListener.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEventListener: function() { return /* binding */ useEventListener; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction useEventListener(emitter, listener, event) {\n    const savedListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(listener);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        savedListener.current = listener;\n    }, [listener]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (event) {\n            emitter.on(event, savedListener.current);\n        }\n        else {\n            emitter.on(listener);\n        }\n        return () => {\n            if (event) {\n                emitter.off(event, listener);\n            }\n            else {\n                emitter.off(listener);\n            }\n        };\n    }, [emitter, event, listener]);\n}\n//# sourceMappingURL=useEventListener.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VFdmVudExpc3RlbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBQ25DO0FBQ1AsMEJBQTBCLDZDQUFNO0FBQ2hDLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VFdmVudExpc3RlbmVyLmpzPzlhN2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihlbWl0dGVyLCBsaXN0ZW5lciwgZXZlbnQpIHtcbiAgICBjb25zdCBzYXZlZExpc3RlbmVyID0gdXNlUmVmKGxpc3RlbmVyKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzYXZlZExpc3RlbmVyLmN1cnJlbnQgPSBsaXN0ZW5lcjtcbiAgICB9LCBbbGlzdGVuZXJdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub24oZXZlbnQsIHNhdmVkTGlzdGVuZXIuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIub2ZmKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbZW1pdHRlciwgZXZlbnQsIGxpc3RlbmVyXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VFdmVudExpc3RlbmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useEventListener.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/usePresence.js":
/*!**********************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/usePresence.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePresence: function() { return /* binding */ usePresence; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _useAbly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useAbly.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useAbly.js\");\n/* harmony import */ var _useChannelInstance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useChannelInstance.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\");\n/* harmony import */ var _useStateErrors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useStateErrors.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useStateErrors.js\");\n/* harmony import */ var _useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useConnectionStateListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js\");\n/* harmony import */ var _useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./useChannelStateListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js\");\n\n\n\n\n\n\nconst INACTIVE_CONNECTION_STATES = ['suspended', 'closing', 'closed', 'failed'];\nconst INACTIVE_CHANNEL_STATES = ['failed', 'suspended', 'detaching'];\nfunction usePresence(channelNameOrNameAndOptions, messageOrPresenceObject) {\n    const params = typeof channelNameOrNameAndOptions === 'object'\n        ? channelNameOrNameAndOptions\n        : { channelName: channelNameOrNameAndOptions };\n    const skip = params.skip;\n    const ably = (0,_useAbly_js__WEBPACK_IMPORTED_MODULE_1__.useAbly)(params.ablyId);\n    const { channel } = (0,_useChannelInstance_js__WEBPACK_IMPORTED_MODULE_2__.useChannelInstance)(params.ablyId, params.channelName);\n    const { connectionError, channelError } = (0,_useStateErrors_js__WEBPACK_IMPORTED_MODULE_3__.useStateErrors)(params);\n    // we can't simply add messageOrPresenceObject to dependency list in our useCallback/useEffect hooks,\n    // since it will most likely cause an infinite loop of updates in cases when user calls this hook\n    // with an object literal instead of a state or memoized object.\n    // to prevent this from happening we store messageOrPresenceObject in a ref, and use that instead.\n    // note that it still prevents us from automatically re-entering presence with new messageOrPresenceObject if it changes.\n    // one of the options to fix this, is to use deep equals to check if the object has actually changed. see https://github.com/ably/ably-js/issues/1688.\n    const messageOrPresenceObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messageOrPresenceObject);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        messageOrPresenceObjectRef.current = messageOrPresenceObject;\n    }, [messageOrPresenceObject]);\n    // we need to listen for the current connection state in order to react to it.\n    // for example, we should enter presence when first connected, re-enter when reconnected,\n    // and be able to prevent entering presence when the connection is in an inactive state.\n    // all of that can be achieved by using the useConnectionStateListener hook.\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(ably.connection.state);\n    (0,_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_4__.useConnectionStateListener)((stateChange) => {\n        setConnectionState(stateChange.current);\n    }, params.ablyId);\n    // similar to connection states, we should only attempt to enter presence when in certain\n    // channel states.\n    const [channelState, setChannelState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(channel.state);\n    (0,_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_5__.useChannelStateListener)(params, (stateChange) => {\n        setChannelState(stateChange.current);\n    });\n    const shouldNotEnterPresence = INACTIVE_CONNECTION_STATES.includes(connectionState) || INACTIVE_CHANNEL_STATES.includes(channelState) || skip;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (shouldNotEnterPresence) {\n            return;\n        }\n        const onMount = async () => {\n            await channel.presence.enter(messageOrPresenceObjectRef.current);\n        };\n        onMount();\n        return () => {\n            // here we use the ably.connection.state property, which upon this cleanup function call\n            // will have the current connection state for that connection, thanks to us accessing the Ably instance here by reference.\n            // if the connection is in one of the inactive states or the channel is not attached, a presence.leave call will produce an exception.\n            // so we only leave presence in other cases.\n            if (channel.state === 'attached' && !INACTIVE_CONNECTION_STATES.includes(ably.connection.state)) {\n                channel.presence.leave();\n            }\n        };\n    }, [shouldNotEnterPresence, channel, ably]);\n    const updateStatus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (messageOrPresenceObject) => {\n        await channel.presence.update(messageOrPresenceObject);\n    }, [channel]);\n    return { updateStatus, connectionError, channelError };\n}\n//# sourceMappingURL=usePresence.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VQcmVzZW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWlFO0FBQzFCO0FBQ3NCO0FBQ1I7QUFDd0I7QUFDTjtBQUN2RTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsaUJBQWlCLG9EQUFPO0FBQ3hCLFlBQVksVUFBVSxFQUFFLDBFQUFrQjtBQUMxQyxZQUFZLGdDQUFnQyxFQUFFLGtFQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2Q0FBTTtBQUM3QyxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsK0NBQVE7QUFDMUQsSUFBSSwwRkFBMEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QywrQ0FBUTtBQUNwRCxJQUFJLG9GQUF1QjtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsa0RBQVc7QUFDcEM7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL2hvb2tzL3VzZVByZXNlbmNlLmpzPzEwMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUFibHkgfSBmcm9tICcuL3VzZUFibHkuanMnO1xuaW1wb3J0IHsgdXNlQ2hhbm5lbEluc3RhbmNlIH0gZnJvbSAnLi91c2VDaGFubmVsSW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgdXNlU3RhdGVFcnJvcnMgfSBmcm9tICcuL3VzZVN0YXRlRXJyb3JzLmpzJztcbmltcG9ydCB7IHVzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyIH0gZnJvbSAnLi91c2VDb25uZWN0aW9uU3RhdGVMaXN0ZW5lci5qcyc7XG5pbXBvcnQgeyB1c2VDaGFubmVsU3RhdGVMaXN0ZW5lciB9IGZyb20gJy4vdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIuanMnO1xuY29uc3QgSU5BQ1RJVkVfQ09OTkVDVElPTl9TVEFURVMgPSBbJ3N1c3BlbmRlZCcsICdjbG9zaW5nJywgJ2Nsb3NlZCcsICdmYWlsZWQnXTtcbmNvbnN0IElOQUNUSVZFX0NIQU5ORUxfU1RBVEVTID0gWydmYWlsZWQnLCAnc3VzcGVuZGVkJywgJ2RldGFjaGluZyddO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVByZXNlbmNlKGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucywgbWVzc2FnZU9yUHJlc2VuY2VPYmplY3QpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0eXBlb2YgY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zID09PSAnb2JqZWN0J1xuICAgICAgICA/IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9uc1xuICAgICAgICA6IHsgY2hhbm5lbE5hbWU6IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucyB9O1xuICAgIGNvbnN0IHNraXAgPSBwYXJhbXMuc2tpcDtcbiAgICBjb25zdCBhYmx5ID0gdXNlQWJseShwYXJhbXMuYWJseUlkKTtcbiAgICBjb25zdCB7IGNoYW5uZWwgfSA9IHVzZUNoYW5uZWxJbnN0YW5jZShwYXJhbXMuYWJseUlkLCBwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkVycm9yLCBjaGFubmVsRXJyb3IgfSA9IHVzZVN0YXRlRXJyb3JzKHBhcmFtcyk7XG4gICAgLy8gd2UgY2FuJ3Qgc2ltcGx5IGFkZCBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCB0byBkZXBlbmRlbmN5IGxpc3QgaW4gb3VyIHVzZUNhbGxiYWNrL3VzZUVmZmVjdCBob29rcyxcbiAgICAvLyBzaW5jZSBpdCB3aWxsIG1vc3QgbGlrZWx5IGNhdXNlIGFuIGluZmluaXRlIGxvb3Agb2YgdXBkYXRlcyBpbiBjYXNlcyB3aGVuIHVzZXIgY2FsbHMgdGhpcyBob29rXG4gICAgLy8gd2l0aCBhbiBvYmplY3QgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgc3RhdGUgb3IgbWVtb2l6ZWQgb2JqZWN0LlxuICAgIC8vIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZyB3ZSBzdG9yZSBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCBpbiBhIHJlZiwgYW5kIHVzZSB0aGF0IGluc3RlYWQuXG4gICAgLy8gbm90ZSB0aGF0IGl0IHN0aWxsIHByZXZlbnRzIHVzIGZyb20gYXV0b21hdGljYWxseSByZS1lbnRlcmluZyBwcmVzZW5jZSB3aXRoIG5ldyBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCBpZiBpdCBjaGFuZ2VzLlxuICAgIC8vIG9uZSBvZiB0aGUgb3B0aW9ucyB0byBmaXggdGhpcywgaXMgdG8gdXNlIGRlZXAgZXF1YWxzIHRvIGNoZWNrIGlmIHRoZSBvYmplY3QgaGFzIGFjdHVhbGx5IGNoYW5nZWQuIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8xNjg4LlxuICAgIGNvbnN0IG1lc3NhZ2VPclByZXNlbmNlT2JqZWN0UmVmID0gdXNlUmVmKG1lc3NhZ2VPclByZXNlbmNlT2JqZWN0KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdFJlZi5jdXJyZW50ID0gbWVzc2FnZU9yUHJlc2VuY2VPYmplY3Q7XG4gICAgfSwgW21lc3NhZ2VPclByZXNlbmNlT2JqZWN0XSk7XG4gICAgLy8gd2UgbmVlZCB0byBsaXN0ZW4gZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgaW4gb3JkZXIgdG8gcmVhY3QgdG8gaXQuXG4gICAgLy8gZm9yIGV4YW1wbGUsIHdlIHNob3VsZCBlbnRlciBwcmVzZW5jZSB3aGVuIGZpcnN0IGNvbm5lY3RlZCwgcmUtZW50ZXIgd2hlbiByZWNvbm5lY3RlZCxcbiAgICAvLyBhbmQgYmUgYWJsZSB0byBwcmV2ZW50IGVudGVyaW5nIHByZXNlbmNlIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgaW4gYW4gaW5hY3RpdmUgc3RhdGUuXG4gICAgLy8gYWxsIG9mIHRoYXQgY2FuIGJlIGFjaGlldmVkIGJ5IHVzaW5nIHRoZSB1c2VDb25uZWN0aW9uU3RhdGVMaXN0ZW5lciBob29rLlxuICAgIGNvbnN0IFtjb25uZWN0aW9uU3RhdGUsIHNldENvbm5lY3Rpb25TdGF0ZV0gPSB1c2VTdGF0ZShhYmx5LmNvbm5lY3Rpb24uc3RhdGUpO1xuICAgIHVzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyKChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoc3RhdGVDaGFuZ2UuY3VycmVudCk7XG4gICAgfSwgcGFyYW1zLmFibHlJZCk7XG4gICAgLy8gc2ltaWxhciB0byBjb25uZWN0aW9uIHN0YXRlcywgd2Ugc2hvdWxkIG9ubHkgYXR0ZW1wdCB0byBlbnRlciBwcmVzZW5jZSB3aGVuIGluIGNlcnRhaW5cbiAgICAvLyBjaGFubmVsIHN0YXRlcy5cbiAgICBjb25zdCBbY2hhbm5lbFN0YXRlLCBzZXRDaGFubmVsU3RhdGVdID0gdXNlU3RhdGUoY2hhbm5lbC5zdGF0ZSk7XG4gICAgdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIocGFyYW1zLCAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgICAgc2V0Q2hhbm5lbFN0YXRlKHN0YXRlQ2hhbmdlLmN1cnJlbnQpO1xuICAgIH0pO1xuICAgIGNvbnN0IHNob3VsZE5vdEVudGVyUHJlc2VuY2UgPSBJTkFDVElWRV9DT05ORUNUSU9OX1NUQVRFUy5pbmNsdWRlcyhjb25uZWN0aW9uU3RhdGUpIHx8IElOQUNUSVZFX0NIQU5ORUxfU1RBVEVTLmluY2x1ZGVzKGNoYW5uZWxTdGF0ZSkgfHwgc2tpcDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkTm90RW50ZXJQcmVzZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uTW91bnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBjaGFubmVsLnByZXNlbmNlLmVudGVyKG1lc3NhZ2VPclByZXNlbmNlT2JqZWN0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBvbk1vdW50KCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBoZXJlIHdlIHVzZSB0aGUgYWJseS5jb25uZWN0aW9uLnN0YXRlIHByb3BlcnR5LCB3aGljaCB1cG9uIHRoaXMgY2xlYW51cCBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAvLyB3aWxsIGhhdmUgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSBmb3IgdGhhdCBjb25uZWN0aW9uLCB0aGFua3MgdG8gdXMgYWNjZXNzaW5nIHRoZSBBYmx5IGluc3RhbmNlIGhlcmUgYnkgcmVmZXJlbmNlLlxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3Rpb24gaXMgaW4gb25lIG9mIHRoZSBpbmFjdGl2ZSBzdGF0ZXMgb3IgdGhlIGNoYW5uZWwgaXMgbm90IGF0dGFjaGVkLCBhIHByZXNlbmNlLmxlYXZlIGNhbGwgd2lsbCBwcm9kdWNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIC8vIHNvIHdlIG9ubHkgbGVhdmUgcHJlc2VuY2UgaW4gb3RoZXIgY2FzZXMuXG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJyAmJiAhSU5BQ1RJVkVfQ09OTkVDVElPTl9TVEFURVMuaW5jbHVkZXMoYWJseS5jb25uZWN0aW9uLnN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwucHJlc2VuY2UubGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbc2hvdWxkTm90RW50ZXJQcmVzZW5jZSwgY2hhbm5lbCwgYWJseV0pO1xuICAgIGNvbnN0IHVwZGF0ZVN0YXR1cyA9IHVzZUNhbGxiYWNrKGFzeW5jIChtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCkgPT4ge1xuICAgICAgICBhd2FpdCBjaGFubmVsLnByZXNlbmNlLnVwZGF0ZShtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCk7XG4gICAgfSwgW2NoYW5uZWxdKTtcbiAgICByZXR1cm4geyB1cGRhdGVTdGF0dXMsIGNvbm5lY3Rpb25FcnJvciwgY2hhbm5lbEVycm9yIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VQcmVzZW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/usePresence.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/usePresenceListener.js":
/*!******************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/usePresenceListener.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePresenceListener: function() { return /* binding */ usePresenceListener; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _useChannelInstance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useChannelInstance.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\");\n/* harmony import */ var _useStateErrors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useStateErrors.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useStateErrors.js\");\n\n\n\nfunction usePresenceListener(channelNameOrNameAndOptions, onPresenceMessageReceived) {\n    const params = typeof channelNameOrNameAndOptions === 'object'\n        ? channelNameOrNameAndOptions\n        : { channelName: channelNameOrNameAndOptions };\n    const skip = params.skip;\n    const { channel } = (0,_useChannelInstance_js__WEBPACK_IMPORTED_MODULE_1__.useChannelInstance)(params.ablyId, params.channelName);\n    const { connectionError, channelError } = (0,_useStateErrors_js__WEBPACK_IMPORTED_MODULE_2__.useStateErrors)(params);\n    const [presenceData, updatePresenceData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const onPresenceMessageReceivedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onPresenceMessageReceived);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        onPresenceMessageReceivedRef.current = onPresenceMessageReceived;\n    }, [onPresenceMessageReceived]);\n    const updatePresence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message) => {\n        var _a;\n        const snapshot = await channel.presence.get();\n        updatePresenceData(snapshot);\n        (_a = onPresenceMessageReceivedRef.current) === null || _a === void 0 ? void 0 : _a.call(onPresenceMessageReceivedRef, message);\n    }, [channel.presence]);\n    const onMount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n        channel.presence.subscribe(['enter', 'leave', 'update'], updatePresence);\n        const snapshot = await channel.presence.get();\n        updatePresenceData(snapshot);\n    }, [channel.presence, updatePresence]);\n    const onUnmount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n        channel.presence.unsubscribe(['enter', 'leave', 'update'], updatePresence);\n    }, [channel.presence, updatePresence]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (skip)\n            return;\n        onMount();\n        return () => {\n            onUnmount();\n        };\n    }, [skip, onMount, onUnmount]);\n    return { presenceData, connectionError, channelError };\n}\n//# sourceMappingURL=usePresenceListener.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VQcmVzZW5jZUxpc3RlbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUU7QUFDSjtBQUNSO0FBQzlDO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVksVUFBVSxFQUFFLDBFQUFrQjtBQUMxQyxZQUFZLGdDQUFnQyxFQUFFLGtFQUFjO0FBQzVELCtDQUErQywrQ0FBUTtBQUN2RCx5Q0FBeUMsNkNBQU07QUFDL0MsSUFBSSxnREFBUztBQUNiO0FBQ0EsS0FBSztBQUNMLDJCQUEyQixrREFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0Isa0RBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixrREFBVztBQUNqQztBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VQcmVzZW5jZUxpc3RlbmVyLmpzPzc4MWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNoYW5uZWxJbnN0YW5jZSB9IGZyb20gJy4vdXNlQ2hhbm5lbEluc3RhbmNlLmpzJztcbmltcG9ydCB7IHVzZVN0YXRlRXJyb3JzIH0gZnJvbSAnLi91c2VTdGF0ZUVycm9ycy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc2VuY2VMaXN0ZW5lcihjaGFubmVsTmFtZU9yTmFtZUFuZE9wdGlvbnMsIG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0eXBlb2YgY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zID09PSAnb2JqZWN0J1xuICAgICAgICA/IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9uc1xuICAgICAgICA6IHsgY2hhbm5lbE5hbWU6IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucyB9O1xuICAgIGNvbnN0IHNraXAgPSBwYXJhbXMuc2tpcDtcbiAgICBjb25zdCB7IGNoYW5uZWwgfSA9IHVzZUNoYW5uZWxJbnN0YW5jZShwYXJhbXMuYWJseUlkLCBwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkVycm9yLCBjaGFubmVsRXJyb3IgfSA9IHVzZVN0YXRlRXJyb3JzKHBhcmFtcyk7XG4gICAgY29uc3QgW3ByZXNlbmNlRGF0YSwgdXBkYXRlUHJlc2VuY2VEYXRhXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBvblByZXNlbmNlTWVzc2FnZVJlY2VpdmVkUmVmID0gdXNlUmVmKG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWRSZWYuY3VycmVudCA9IG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWQ7XG4gICAgfSwgW29uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWRdKTtcbiAgICBjb25zdCB1cGRhdGVQcmVzZW5jZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBjaGFubmVsLnByZXNlbmNlLmdldCgpO1xuICAgICAgICB1cGRhdGVQcmVzZW5jZURhdGEoc25hcHNob3QpO1xuICAgICAgICAoX2EgPSBvblByZXNlbmNlTWVzc2FnZVJlY2VpdmVkUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWRSZWYsIG1lc3NhZ2UpO1xuICAgIH0sIFtjaGFubmVsLnByZXNlbmNlXSk7XG4gICAgY29uc3Qgb25Nb3VudCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgY2hhbm5lbC5wcmVzZW5jZS5zdWJzY3JpYmUoWydlbnRlcicsICdsZWF2ZScsICd1cGRhdGUnXSwgdXBkYXRlUHJlc2VuY2UpO1xuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGNoYW5uZWwucHJlc2VuY2UuZ2V0KCk7XG4gICAgICAgIHVwZGF0ZVByZXNlbmNlRGF0YShzbmFwc2hvdCk7XG4gICAgfSwgW2NoYW5uZWwucHJlc2VuY2UsIHVwZGF0ZVByZXNlbmNlXSk7XG4gICAgY29uc3Qgb25Vbm1vdW50ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBjaGFubmVsLnByZXNlbmNlLnVuc3Vic2NyaWJlKFsnZW50ZXInLCAnbGVhdmUnLCAndXBkYXRlJ10sIHVwZGF0ZVByZXNlbmNlKTtcbiAgICB9LCBbY2hhbm5lbC5wcmVzZW5jZSwgdXBkYXRlUHJlc2VuY2VdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2tpcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb25Nb3VudCgpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgb25Vbm1vdW50KCk7XG4gICAgICAgIH07XG4gICAgfSwgW3NraXAsIG9uTW91bnQsIG9uVW5tb3VudF0pO1xuICAgIHJldHVybiB7IHByZXNlbmNlRGF0YSwgY29ubmVjdGlvbkVycm9yLCBjaGFubmVsRXJyb3IgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZVByZXNlbmNlTGlzdGVuZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/usePresenceListener.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useStateErrors.js":
/*!*************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useStateErrors.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStateErrors: function() { return /* binding */ useStateErrors; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useConnectionStateListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js\");\n/* harmony import */ var _useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useChannelStateListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js\");\n\n\n\nfunction useStateErrors(params) {\n    const [connectionError, setConnectionError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [channelError, setChannelError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_1__.useConnectionStateListener)(['suspended', 'failed', 'disconnected'], (stateChange) => {\n        var _a;\n        if (stateChange.reason) {\n            (_a = params.onConnectionError) === null || _a === void 0 ? void 0 : _a.call(params, stateChange.reason);\n            setConnectionError(stateChange.reason);\n        }\n    }, params.ablyId);\n    (0,_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_1__.useConnectionStateListener)(['connected', 'closed'], () => {\n        setConnectionError(null);\n    }, params.ablyId);\n    (0,_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_2__.useChannelStateListener)(params, ['suspended', 'failed', 'detached'], (stateChange) => {\n        var _a;\n        if (stateChange.reason) {\n            (_a = params.onChannelError) === null || _a === void 0 ? void 0 : _a.call(params, stateChange.reason);\n            setChannelError(stateChange.reason);\n        }\n    });\n    (0,_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_2__.useChannelStateListener)(params, ['attached'], () => {\n        setChannelError(null);\n    });\n    return { connectionError, channelError };\n}\n//# sourceMappingURL=useStateErrors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VTdGF0ZUVycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlDO0FBQzRDO0FBQ047QUFDaEU7QUFDUCxrREFBa0QsK0NBQVE7QUFDMUQsNENBQTRDLCtDQUFRO0FBQ3BELElBQUksMEZBQTBCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSwwRkFBMEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0wsSUFBSSxvRkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLG9GQUF1QjtBQUMzQjtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlU3RhdGVFcnJvcnMuanM/MmY2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyIH0gZnJvbSAnLi91c2VDb25uZWN0aW9uU3RhdGVMaXN0ZW5lci5qcyc7XG5pbXBvcnQgeyB1c2VDaGFubmVsU3RhdGVMaXN0ZW5lciB9IGZyb20gJy4vdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlRXJyb3JzKHBhcmFtcykge1xuICAgIGNvbnN0IFtjb25uZWN0aW9uRXJyb3IsIHNldENvbm5lY3Rpb25FcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY2hhbm5lbEVycm9yLCBzZXRDaGFubmVsRXJyb3JdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIoWydzdXNwZW5kZWQnLCAnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc3RhdGVDaGFuZ2UucmVhc29uKSB7XG4gICAgICAgICAgICAoX2EgPSBwYXJhbXMub25Db25uZWN0aW9uRXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHBhcmFtcywgc3RhdGVDaGFuZ2UucmVhc29uKTtcbiAgICAgICAgICAgIHNldENvbm5lY3Rpb25FcnJvcihzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICB9XG4gICAgfSwgcGFyYW1zLmFibHlJZCk7XG4gICAgdXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIoWydjb25uZWN0ZWQnLCAnY2xvc2VkJ10sICgpID0+IHtcbiAgICAgICAgc2V0Q29ubmVjdGlvbkVycm9yKG51bGwpO1xuICAgIH0sIHBhcmFtcy5hYmx5SWQpO1xuICAgIHVzZUNoYW5uZWxTdGF0ZUxpc3RlbmVyKHBhcmFtcywgWydzdXNwZW5kZWQnLCAnZmFpbGVkJywgJ2RldGFjaGVkJ10sIChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZS5yZWFzb24pIHtcbiAgICAgICAgICAgIChfYSA9IHBhcmFtcy5vbkNoYW5uZWxFcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocGFyYW1zLCBzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgc2V0Q2hhbm5lbEVycm9yKHN0YXRlQ2hhbmdlLnJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VDaGFubmVsU3RhdGVMaXN0ZW5lcihwYXJhbXMsIFsnYXR0YWNoZWQnXSwgKCkgPT4ge1xuICAgICAgICBzZXRDaGFubmVsRXJyb3IobnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgY29ubmVjdGlvbkVycm9yLCBjaGFubmVsRXJyb3IgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZVN0YXRlRXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useStateErrors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ably/react/mjs/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ably/react/mjs/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AblyContext: function() { return /* reexport safe */ _AblyContext_js__WEBPACK_IMPORTED_MODULE_9__.AblyContext; },\n/* harmony export */   AblyProvider: function() { return /* reexport safe */ _AblyProvider_js__WEBPACK_IMPORTED_MODULE_5__.AblyProvider; },\n/* harmony export */   ChannelProvider: function() { return /* reexport safe */ _ChannelProvider_js__WEBPACK_IMPORTED_MODULE_8__.ChannelProvider; },\n/* harmony export */   channelOptionsWithAgent: function() { return /* reexport safe */ _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__.channelOptionsWithAgent; },\n/* harmony export */   useAbly: function() { return /* reexport safe */ _hooks_useAbly_js__WEBPACK_IMPORTED_MODULE_4__.useAbly; },\n/* harmony export */   useChannel: function() { return /* reexport safe */ _hooks_useChannel_js__WEBPACK_IMPORTED_MODULE_1__.useChannel; },\n/* harmony export */   useChannelStateListener: function() { return /* reexport safe */ _hooks_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_6__.useChannelStateListener; },\n/* harmony export */   useConnectionStateListener: function() { return /* reexport safe */ _hooks_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_7__.useConnectionStateListener; },\n/* harmony export */   usePresence: function() { return /* reexport safe */ _hooks_usePresence_js__WEBPACK_IMPORTED_MODULE_2__.usePresence; },\n/* harmony export */   usePresenceListener: function() { return /* reexport safe */ _hooks_usePresenceListener_js__WEBPACK_IMPORTED_MODULE_3__.usePresenceListener; },\n/* harmony export */   version: function() { return /* reexport safe */ _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__.version; }\n/* harmony export */ });\n/* harmony import */ var _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AblyReactHooks.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/AblyReactHooks.js\");\n/* harmony import */ var _hooks_useChannel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hooks/useChannel.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannel.js\");\n/* harmony import */ var _hooks_usePresence_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks/usePresence.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/usePresence.js\");\n/* harmony import */ var _hooks_usePresenceListener_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hooks/usePresenceListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/usePresenceListener.js\");\n/* harmony import */ var _hooks_useAbly_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks/useAbly.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useAbly.js\");\n/* harmony import */ var _AblyProvider_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AblyProvider.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/AblyProvider.js\");\n/* harmony import */ var _hooks_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hooks/useChannelStateListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js\");\n/* harmony import */ var _hooks_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hooks/useConnectionStateListener.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js\");\n/* harmony import */ var _ChannelProvider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ChannelProvider.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/ChannelProvider.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AblyContext.js */ \"(app-pages-browser)/./node_modules/ably/react/mjs/AblyContext.js\");\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNDO0FBQ1E7QUFDWjtBQUNEO0FBQ2lCO0FBQ0c7QUFDQztBQUN0QjtBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaW5kZXguanM/OTBjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL0FibHlSZWFjdEhvb2tzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaG9va3MvdXNlQ2hhbm5lbC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hvb2tzL3VzZVByZXNlbmNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaG9va3MvdXNlUHJlc2VuY2VMaXN0ZW5lci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hvb2tzL3VzZUFibHkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9BYmx5UHJvdmlkZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ob29rcy91c2VDaGFubmVsU3RhdGVMaXN0ZW5lci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hvb2tzL3VzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyLmpzJztcbmV4cG9ydCB7IENoYW5uZWxQcm92aWRlciB9IGZyb20gJy4vQ2hhbm5lbFByb3ZpZGVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vQWJseUNvbnRleHQuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ably/react/mjs/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fubuntu%2FDocuments%2FProteinBind%2Fsrc%2Fapp%2Flayout.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);