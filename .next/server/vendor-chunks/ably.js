/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ably";
exports.ids = ["vendor-chunks/ably"];
exports.modules = {

/***/ "(ssr)/./node_modules/ably/build/ably-node.js":
/*!**********************************************!*\
  !*** ./node_modules/ably/build/ably-node.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n\nAbly JavaScript Library v2.3.1\nhttps://github.com/ably/ably-js\n\nReleased under the Apache Licence v2.0*/(function (g, f) {\n    if (true) {\n      module.exports = f(__webpack_require__(/*! ws */ \"(ssr)/./node_modules/ably/node_modules/ws/index.js\"), __webpack_require__(/*! got */ \"(ssr)/./node_modules/got/dist/source/index.js\"));\n    } else {}\n  }(this, (__da, __db) => {\nvar exports = {};\nvar module = { exports };\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/bops/from.js\nvar require_from = __commonJS({\n  \"node_modules/bops/from.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var version2 = ((process || {}).version || \"v0.0.0\").slice(1).split(\".\")[0];\n    module2.exports = Number(version2) < 6 ? function from(source, encoding) {\n      return new Buffer2(source, encoding);\n    } : function from(source, encoding) {\n      return Buffer2.from(source, encoding);\n    };\n  }\n});\n\n// node_modules/bops/to.js\nvar require_to = __commonJS({\n  \"node_modules/bops/to.js\"(exports2, module2) {\n    module2.exports = function(source, encoding) {\n      return source.toString(encoding);\n    };\n  }\n});\n\n// node_modules/bops/is.js\nvar require_is = __commonJS({\n  \"node_modules/bops/is.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    module2.exports = function(buffer) {\n      return Buffer2.isBuffer(buffer);\n    };\n  }\n});\n\n// node_modules/bops/subarray.js\nvar require_subarray = __commonJS({\n  \"node_modules/bops/subarray.js\"(exports2, module2) {\n    module2.exports = function(source, from, to) {\n      return arguments.length === 2 ? source.slice(from) : source.slice(from, to);\n    };\n  }\n});\n\n// node_modules/bops/join.js\nvar require_join = __commonJS({\n  \"node_modules/bops/join.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    module2.exports = function(targets, hint) {\n      return hint !== void 0 ? Buffer2.concat(targets, hint) : Buffer2.concat(targets);\n    };\n  }\n});\n\n// node_modules/bops/copy.js\nvar require_copy = __commonJS({\n  \"node_modules/bops/copy.js\"(exports2, module2) {\n    module2.exports = copy2;\n    function copy2(source, target, target_start, source_start, source_end) {\n      return source.copy(target, target_start, source_start, source_end);\n    }\n  }\n});\n\n// node_modules/bops/create.js\nvar require_create = __commonJS({\n  \"node_modules/bops/create.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var version2 = ((process || {}).version || \"v0.0.0\").slice(1).split(\".\")[0];\n    module2.exports = Number(version2) < 6 ? function create(size) {\n      return new Buffer2(size);\n    } : function create(size) {\n      return Buffer2.alloc(size);\n    };\n  }\n});\n\n// node_modules/bops/read.js\nvar require_read = __commonJS({\n  \"node_modules/bops/read.js\"(exports2, module2) {\n    var proto = {};\n    var rex = /read.+/;\n    var buildFn;\n    buildFn = function(key2) {\n      var code = \"return buf.\" + key2 + \"(\" + [\"a\", \"b\", \"c\"].join(\",\") + \")\";\n      return new Function([\"buf\", \"a\", \"b\", \"c\"], code);\n    };\n    module2.exports = proto;\n    for (key in Buffer.prototype) {\n      if (rex.test(key)) {\n        proto[key] = buildFn(key);\n      }\n    }\n    var key;\n  }\n});\n\n// node_modules/bops/write.js\nvar require_write = __commonJS({\n  \"node_modules/bops/write.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var proto = {};\n    var rex = /write.+/;\n    var buildFn;\n    buildFn = function(key2) {\n      var code = \"return buf.\" + key2 + \"(\" + [\"a\", \"b\", \"c\"].join(\",\") + \")\";\n      return new Function([\"buf\", \"a\", \"b\", \"c\"], code);\n    };\n    module2.exports = proto;\n    for (key in Buffer2.prototype) {\n      if (rex.test(key)) {\n        proto[key] = buildFn(key);\n      }\n    }\n    var key;\n  }\n});\n\n// node_modules/bops/index.js\nvar require_bops = __commonJS({\n  \"node_modules/bops/index.js\"(exports2, module2) {\n    var proto = {};\n    module2.exports = proto;\n    proto.from = require_from();\n    proto.to = require_to();\n    proto.is = require_is();\n    proto.subarray = require_subarray();\n    proto.join = require_join();\n    proto.copy = require_copy();\n    proto.create = require_create();\n    mix(require_read(), proto);\n    mix(require_write(), proto);\n    function mix(from, into) {\n      for (var key in from) {\n        into[key] = from[key];\n      }\n    }\n  }\n});\n\n// node_modules/@ably/msgpack-js/msgpack.js\nvar require_msgpack = __commonJS({\n  \"node_modules/@ably/msgpack-js/msgpack.js\"(exports2) {\n    \"use strict\";\n    var bops = require_bops();\n    exports2.encode = function(value, sparse) {\n      var size = sizeof(value, sparse);\n      if (size == 0)\n        return void 0;\n      var buffer = bops.create(size);\n      encode2(value, buffer, 0, sparse);\n      return buffer;\n    };\n    exports2.decode = decode3;\n    var SH_L_32 = (1 << 16) * (1 << 16);\n    var SH_R_32 = 1 / SH_L_32;\n    function readInt64BE(buf, offset) {\n      offset = offset || 0;\n      return buf.readInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n    }\n    function readUInt64BE(buf, offset) {\n      offset = offset || 0;\n      return buf.readUInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n    }\n    function writeInt64BE(buf, val, offset) {\n      if (val < 9223372036854776e3) {\n        buf.writeInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n      } else {\n        buf.writeUInt32BE(2147483647, offset);\n        buf.writeUInt32BE(4294967295, offset + 4);\n      }\n    }\n    function writeUInt64BE(buf, val, offset) {\n      if (val < 18446744073709552e3) {\n        buf.writeUInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n      } else {\n        buf.writeUInt32BE(4294967295, offset);\n        buf.writeUInt32BE(4294967295, offset + 4);\n      }\n    }\n    function Decoder(buffer, offset) {\n      this.offset = offset || 0;\n      this.buffer = buffer;\n      this.bufferLength = buffer.length;\n    }\n    Decoder.prototype.map = function(length) {\n      if (length * 2 > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a map of length ${length})`);\n      }\n      var value = {};\n      for (var i = 0; i < length; i++) {\n        var key = this.parse();\n        value[key] = this.parse();\n      }\n      return value;\n    };\n    Decoder.prototype.bin = Decoder.prototype.buf = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a binary of length ${length})`);\n      }\n      var value = bops.subarray(this.buffer, this.offset, this.offset + length);\n      this.offset += length;\n      return value;\n    };\n    Decoder.prototype.str = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a string of length ${length})`);\n      }\n      var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));\n      this.offset += length;\n      return value;\n    };\n    Decoder.prototype.array = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced an array of length ${length})`);\n      }\n      var value = new Array(length);\n      for (var i = 0; i < length; i++) {\n        value[i] = this.parse();\n      }\n      return value;\n    };\n    Decoder.prototype.parse = function() {\n      var type = this.buffer[this.offset];\n      var value, length, extType;\n      if (type === void 0) {\n        throw new Error(\"malformed messagepack (referenced offset is outside buffer)\");\n      }\n      if ((type & 128) === 0) {\n        this.offset++;\n        return type;\n      }\n      if ((type & 240) === 128) {\n        length = type & 15;\n        this.offset++;\n        return this.map(length);\n      }\n      if ((type & 240) === 144) {\n        length = type & 15;\n        this.offset++;\n        return this.array(length);\n      }\n      if ((type & 224) === 160) {\n        length = type & 31;\n        this.offset++;\n        return this.str(length);\n      }\n      if ((type & 224) === 224) {\n        value = bops.readInt8(this.buffer, this.offset);\n        this.offset++;\n        return value;\n      }\n      switch (type) {\n        case 192:\n          this.offset++;\n          return null;\n        case 194:\n          this.offset++;\n          return false;\n        case 195:\n          this.offset++;\n          return true;\n        case 196:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return this.bin(length);\n        case 197:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.bin(length);\n        case 198:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.bin(length);\n        case 199:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 2);\n          this.offset += 3;\n          return [extType, this.bin(length)];\n        case 200:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 3);\n          this.offset += 4;\n          return [extType, this.bin(length)];\n        case 201:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 5);\n          this.offset += 6;\n          return [extType, this.bin(length)];\n        case 202:\n          value = bops.readFloatBE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 203:\n          value = bops.readDoubleBE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 204:\n          value = this.buffer[this.offset + 1];\n          this.offset += 2;\n          return value;\n        case 205:\n          value = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 206:\n          value = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 207:\n          value = readUInt64BE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 208:\n          value = bops.readInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 209:\n          value = bops.readInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 210:\n          value = bops.readInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 211:\n          value = readInt64BE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 212:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          value = bops.readUInt8(this.buffer, this.offset + 2);\n          this.offset += 3;\n          return extType === 0 && value === 0 ? void 0 : [extType, value];\n        case 213:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(2)];\n        case 214:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(4)];\n        case 215:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(8)];\n        case 216:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(16)];\n        case 217:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return this.str(length);\n        case 218:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.str(length);\n        case 219:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.str(length);\n        case 220:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.array(length);\n        case 221:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.array(length);\n        case 222:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.map(length);\n        case 223:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.map(length);\n      }\n      throw new Error(\"Unknown type 0x\" + type.toString(16));\n    };\n    function decode3(buffer) {\n      var decoder = new Decoder(buffer);\n      var value = decoder.parse();\n      if (decoder.offset !== buffer.length)\n        throw new Error(buffer.length - decoder.offset + \" trailing bytes\");\n      return value;\n    }\n    function encodeableKeys(value, sparse) {\n      return Object.keys(value).filter(function(e) {\n        var val = value[e], type = typeof val;\n        return (!sparse || val !== void 0 && val !== null) && (\"function\" !== type || !!val.toJSON);\n      });\n    }\n    function encode2(value, buffer, offset, sparse, isMapElement) {\n      var type = typeof value;\n      var length, size;\n      if (type === \"string\") {\n        value = bops.from(value);\n        length = value.length;\n        if (length < 32) {\n          buffer[offset] = length | 160;\n          bops.copy(value, buffer, offset + 1);\n          return 1 + length;\n        }\n        if (length < 256) {\n          buffer[offset] = 217;\n          bops.writeUInt8(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 2);\n          return 2 + length;\n        }\n        if (length < 65536) {\n          buffer[offset] = 218;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 3);\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          buffer[offset] = 219;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 5);\n          return 5 + length;\n        }\n      }\n      if (bops.is(value)) {\n        length = value.length;\n        if (length < 256) {\n          buffer[offset] = 196;\n          bops.writeUInt8(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 2);\n          return 2 + length;\n        }\n        if (length < 65536) {\n          buffer[offset] = 197;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 3);\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          buffer[offset] = 198;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 5);\n          return 5 + length;\n        }\n      }\n      if (type === \"number\") {\n        if (Math.floor(value) !== value) {\n          buffer[offset] = 203;\n          bops.writeDoubleBE(buffer, value, offset + 1);\n          return 9;\n        }\n        if (value >= 0) {\n          if (value < 128) {\n            buffer[offset] = value;\n            return 1;\n          }\n          if (value < 256) {\n            buffer[offset] = 204;\n            buffer[offset + 1] = value;\n            return 2;\n          }\n          if (value < 65536) {\n            buffer[offset] = 205;\n            bops.writeUInt16BE(buffer, value, offset + 1);\n            return 3;\n          }\n          if (value < 4294967296) {\n            buffer[offset] = 206;\n            bops.writeUInt32BE(buffer, value, offset + 1);\n            return 5;\n          }\n          if (value < 18446744073709552e3) {\n            buffer[offset] = 207;\n            writeUInt64BE(buffer, value, offset + 1);\n            return 9;\n          }\n          throw new Error(\"Number too big 0x\" + value.toString(16));\n        }\n        if (value >= -32) {\n          bops.writeInt8(buffer, value, offset);\n          return 1;\n        }\n        if (value >= -128) {\n          buffer[offset] = 208;\n          bops.writeInt8(buffer, value, offset + 1);\n          return 2;\n        }\n        if (value >= -32768) {\n          buffer[offset] = 209;\n          bops.writeInt16BE(buffer, value, offset + 1);\n          return 3;\n        }\n        if (value >= -2147483648) {\n          buffer[offset] = 210;\n          bops.writeInt32BE(buffer, value, offset + 1);\n          return 5;\n        }\n        if (value >= -9223372036854776e3) {\n          buffer[offset] = 211;\n          writeInt64BE(buffer, value, offset + 1);\n          return 9;\n        }\n        throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n      }\n      if (type === \"undefined\") {\n        if (sparse && isMapElement)\n          return 0;\n        buffer[offset] = 212;\n        buffer[offset + 1] = 0;\n        buffer[offset + 2] = 0;\n        return 3;\n      }\n      if (value === null) {\n        if (sparse && isMapElement)\n          return 0;\n        buffer[offset] = 192;\n        return 1;\n      }\n      if (type === \"boolean\") {\n        buffer[offset] = value ? 195 : 194;\n        return 1;\n      }\n      if (\"function\" === typeof value.toJSON)\n        return encode2(value.toJSON(), buffer, offset, sparse);\n      if (type === \"object\") {\n        size = 0;\n        var isArray = Array.isArray(value);\n        if (isArray) {\n          length = value.length;\n        } else {\n          var keys = encodeableKeys(value, sparse);\n          length = keys.length;\n        }\n        if (length < 16) {\n          buffer[offset] = length | (isArray ? 144 : 128);\n          size = 1;\n        } else if (length < 65536) {\n          buffer[offset] = isArray ? 220 : 222;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          size = 3;\n        } else if (length < 4294967296) {\n          buffer[offset] = isArray ? 221 : 223;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          size = 5;\n        }\n        if (isArray) {\n          for (var i = 0; i < length; i++) {\n            size += encode2(value[i], buffer, offset + size, sparse);\n          }\n        } else {\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            size += encode2(key, buffer, offset + size);\n            size += encode2(value[key], buffer, offset + size, sparse, true);\n          }\n        }\n        return size;\n      }\n      if (type === \"function\")\n        return void 0;\n      throw new Error(\"Unknown type \" + type);\n    }\n    function sizeof(value, sparse, isMapElement) {\n      var type = typeof value;\n      var length, size;\n      if (type === \"string\") {\n        length = bops.from(value).length;\n        if (length < 32) {\n          return 1 + length;\n        }\n        if (length < 256) {\n          return 2 + length;\n        }\n        if (length < 65536) {\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          return 5 + length;\n        }\n      }\n      if (bops.is(value)) {\n        length = value.length;\n        if (length < 256) {\n          return 2 + length;\n        }\n        if (length < 65536) {\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          return 5 + length;\n        }\n      }\n      if (type === \"number\") {\n        if (Math.floor(value) !== value)\n          return 9;\n        if (value >= 0) {\n          if (value < 128)\n            return 1;\n          if (value < 256)\n            return 2;\n          if (value < 65536)\n            return 3;\n          if (value < 4294967296)\n            return 5;\n          if (value < 18446744073709552e3)\n            return 9;\n          throw new Error(\"Number too big 0x\" + value.toString(16));\n        }\n        if (value >= -32)\n          return 1;\n        if (value >= -128)\n          return 2;\n        if (value >= -32768)\n          return 3;\n        if (value >= -2147483648)\n          return 5;\n        if (value >= -9223372036854776e3)\n          return 9;\n        throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n      }\n      if (type === \"boolean\")\n        return 1;\n      if (value === null)\n        return sparse && isMapElement ? 0 : 1;\n      if (value === void 0)\n        return sparse && isMapElement ? 0 : 3;\n      if (\"function\" === typeof value.toJSON)\n        return sizeof(value.toJSON(), sparse);\n      if (type === \"object\") {\n        size = 0;\n        if (Array.isArray(value)) {\n          length = value.length;\n          for (var i = 0; i < length; i++) {\n            size += sizeof(value[i], sparse);\n          }\n        } else {\n          var keys = encodeableKeys(value, sparse);\n          length = keys.length;\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            size += sizeof(key) + sizeof(value[key], sparse, true);\n          }\n        }\n        if (length < 16) {\n          return 1 + size;\n        }\n        if (length < 65536) {\n          return 3 + size;\n        }\n        if (length < 4294967296) {\n          return 5 + size;\n        }\n        throw new Error(\"Array or object too long 0x\" + length.toString(16));\n      }\n      if (type === \"function\")\n        return 0;\n      throw new Error(\"Unknown type \" + type);\n    }\n  }\n});\n\n// src/common/platform.ts\nvar Platform = class {\n};\n\n// src/common/lib/util/logger.ts\nvar globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\nfunction pad(timeSegment, three) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, \"0\");\n}\nfunction getHandler(logger) {\n  return Platform.Config.logTimestamps ? function(msg) {\n    const time = /* @__PURE__ */ new Date();\n    logger(\n      pad(time.getHours()) + \":\" + pad(time.getMinutes()) + \":\" + pad(time.getSeconds()) + \".\" + pad(time.getMilliseconds(), 1) + \" \" + msg\n    );\n  } : function(msg) {\n    logger(msg);\n  };\n}\nvar getDefaultLoggers = () => {\n  var _a2;\n  let consoleLogger;\n  let errorLogger;\n  if (typeof ((_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) === \"function\") {\n    consoleLogger = function(...args) {\n      console.log.apply(console, args);\n    };\n    errorLogger = console.warn ? function(...args) {\n      console.warn.apply(console, args);\n    } : consoleLogger;\n  } else {\n    consoleLogger = errorLogger = function() {\n    };\n  }\n  return [consoleLogger, errorLogger].map(getHandler);\n};\nvar _Logger = class _Logger {\n  constructor() {\n    this.deprecated = (description, msg) => {\n      this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n    };\n    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n      the object being serialised if the log level will not output the message */\n    this.shouldLog = (level) => {\n      return level <= this.logLevel;\n    };\n    this.setLog = (level, handler) => {\n      if (level !== void 0)\n        this.logLevel = level;\n      if (handler !== void 0)\n        this.logHandler = this.logErrorHandler = handler;\n    };\n    this.logLevel = _Logger.defaultLogLevel;\n    this.logHandler = _Logger.defaultLogHandler;\n    this.logErrorHandler = _Logger.defaultLogErrorHandler;\n  }\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.defaultLogHandler = logHandler;\n    this.defaultLogErrorHandler = logErrorHandler;\n    this.defaultLogger = new _Logger();\n  }\n  /**\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n   */\n  static logActionNoStrip(logger, level, action, message) {\n    logger.logAction(level, action, message);\n  }\n  logAction(level, action, message) {\n    if (this.shouldLog(level)) {\n      (level === 1 /* Error */ ? this.logErrorHandler : this.logHandler)(\"Ably: \" + action + \": \" + message, level);\n    }\n  }\n  renamedClientOption(oldName, newName) {\n    this.deprecationWarning(\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  renamedMethod(className, oldName, newName) {\n    this.deprecationWarning(\n      `\\`${className}\\`\\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  deprecationWarning(message) {\n    if (this.shouldLog(1 /* Error */)) {\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, 1 /* Error */);\n    }\n  }\n};\n_Logger.defaultLogLevel = 1 /* Error */;\n// public constants\n_Logger.LOG_NONE = 0 /* None */;\n_Logger.LOG_ERROR = 1 /* Error */;\n_Logger.LOG_MAJOR = 2 /* Major */;\n_Logger.LOG_MINOR = 3 /* Minor */;\n_Logger.LOG_MICRO = 4 /* Micro */;\n/* public static functions */\n/**\n * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n *\n * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you canâ€™t dynamically specify the log level.\n */\n_Logger.logAction = (logger, level, action, message) => {\n  _Logger.logActionNoStrip(logger, level, action, message);\n};\nvar Logger = _Logger;\nvar logger_default = Logger;\n\n// src/common/lib/util/utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Format: () => Format,\n  allSame: () => allSame,\n  allToLowerCase: () => allToLowerCase,\n  allToUpperCase: () => allToUpperCase,\n  arrChooseN: () => arrChooseN,\n  arrDeleteValue: () => arrDeleteValue,\n  arrEquals: () => arrEquals,\n  arrIntersect: () => arrIntersect,\n  arrIntersectOb: () => arrIntersectOb,\n  arrPopRandomElement: () => arrPopRandomElement,\n  arrSubtract: () => arrSubtract,\n  arrWithoutValue: () => arrWithoutValue,\n  cheapRandStr: () => cheapRandStr,\n  containsValue: () => containsValue,\n  copy: () => copy,\n  createMissingPluginError: () => createMissingPluginError,\n  dataSizeBytes: () => dataSizeBytes,\n  decodeBody: () => decodeBody,\n  encodeBody: () => encodeBody,\n  ensureArray: () => ensureArray,\n  forInOwnNonNullProperties: () => forInOwnNonNullProperties,\n  getBackoffCoefficient: () => getBackoffCoefficient,\n  getGlobalObject: () => getGlobalObject,\n  getJitterCoefficient: () => getJitterCoefficient,\n  getRetryTime: () => getRetryTime,\n  inherits: () => inherits,\n  inspectBody: () => inspectBody,\n  inspectError: () => inspectError,\n  intersect: () => intersect,\n  isEmpty: () => isEmpty,\n  isErrorInfoOrPartialErrorInfo: () => isErrorInfoOrPartialErrorInfo,\n  isNil: () => isNil,\n  isObject: () => isObject,\n  keysArray: () => keysArray,\n  matchDerivedChannel: () => matchDerivedChannel,\n  mixin: () => mixin,\n  parseQueryString: () => parseQueryString,\n  prototypicalClone: () => prototypicalClone,\n  randomString: () => randomString,\n  shallowClone: () => shallowClone,\n  shallowEquals: () => shallowEquals,\n  throwMissingPluginError: () => throwMissingPluginError,\n  toBase64: () => toBase64,\n  toQueryString: () => toQueryString,\n  valuesArray: () => valuesArray,\n  whenPromiseSettles: () => whenPromiseSettles,\n  withTimeoutAsync: () => withTimeoutAsync\n});\n\n// src/common/lib/types/errorinfo.ts\nfunction toString(err) {\n  let result = \"[\" + err.constructor.name;\n  if (err.message)\n    result += \": \" + err.message;\n  if (err.statusCode)\n    result += \"; statusCode=\" + err.statusCode;\n  if (err.code)\n    result += \"; code=\" + err.code;\n  if (err.cause)\n    result += \"; cause=\" + inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf(\"help.ably.io\") > -1))\n    result += \"; see \" + err.href + \" \";\n  result += \"]\";\n  return result;\n}\nvar ErrorInfo = class _ErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || typeof code !== \"number\" || typeof statusCode !== \"number\") {\n      throw new Error(\"ErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\nvar PartialErrorInfo = class _PartialErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || !isNil(code) && typeof code !== \"number\" || !isNil(statusCode) && typeof statusCode !== \"number\") {\n      throw new Error(\"PartialErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _PartialErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\n\n// src/common/lib/util/utils.ts\nfunction randomPosn(arrOrStr) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\nfunction mixin(target, ...args) {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\nfunction copy(src) {\n  return mixin({}, src);\n}\nfunction ensureArray(obj) {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\nfunction isObject(ob) {\n  return Object.prototype.toString.call(ob) == \"[object Object]\";\n}\nfunction isEmpty(ob) {\n  for (const prop in ob)\n    return false;\n  return true;\n}\nfunction isNil(arg) {\n  return arg == null;\n}\nfunction shallowClone(ob) {\n  const result = new Object();\n  for (const prop in ob)\n    result[prop] = ob[prop];\n  return result;\n}\nfunction prototypicalClone(ob, ownProperties) {\n  class F {\n  }\n  F.prototype = ob;\n  const result = new F();\n  if (ownProperties)\n    mixin(result, ownProperties);\n  return result;\n}\nvar inherits = function(ctor, superCtor) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\nfunction containsValue(ob, val) {\n  for (const i in ob) {\n    if (ob[i] == val)\n      return true;\n  }\n  return false;\n}\nfunction intersect(arr, ob) {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\nfunction arrIntersect(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrIntersectOb(arr, ob) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrSubtract(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const element = arr1[i];\n    if (arr2.indexOf(element) == -1)\n      result.push(element);\n  }\n  return result;\n}\nfunction arrDeleteValue(arr, val) {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res)\n    arr.splice(idx, 1);\n  return res;\n}\nfunction arrWithoutValue(arr, val) {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\nfunction keysArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(prop);\n  }\n  return result;\n}\nfunction valuesArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\nfunction forInOwnNonNullProperties(ob, fn) {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\nfunction allSame(arr, prop) {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function(item) {\n    return item[prop] === first;\n  });\n}\nvar Format = /* @__PURE__ */ ((Format2) => {\n  Format2[\"msgpack\"] = \"msgpack\";\n  Format2[\"json\"] = \"json\";\n  return Format2;\n})(Format || {});\nfunction arrPopRandomElement(arr) {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\nfunction toQueryString(params) {\n  const parts = [];\n  if (params) {\n    for (const key in params)\n      parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n  return parts.length ? \"?\" + parts.join(\"&\") : \"\";\n}\nfunction parseQueryString(query) {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result = {};\n  while (match = search.exec(query))\n    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n  return result;\n}\nfunction isErrorInfoOrPartialErrorInfo(err) {\n  return typeof err == \"object\" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\nfunction inspectError(err) {\n  var _a2, _b;\n  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === \"ErrorInfo\" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === \"PartialErrorInfo\")\n    return err.toString();\n  return Platform.Config.inspect(err);\n}\nfunction inspectBody(body) {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return body.toString();\n  } else if (typeof body === \"string\") {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\nfunction dataSizeBytes(data) {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === \"string\") {\n    return Platform.Config.stringByteSize(data);\n  }\n  throw new Error(\"Expected input of Utils.dataSizeBytes to be a buffer or string, but was: \" + typeof data);\n}\nfunction cheapRandStr() {\n  return String(Math.random()).substr(2);\n}\nvar randomString = async (numBytes) => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\nfunction arrChooseN(arr, n) {\n  const numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\nfunction whenPromiseSettles(promise, callback) {\n  promise.then((result) => {\n    callback == null ? void 0 : callback(null, result);\n  }).catch((err) => {\n    callback == null ? void 0 : callback(err);\n  });\n}\nfunction decodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.decode(body);\n  }\n  return JSON.parse(String(body));\n}\nfunction encodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.encode(body, true);\n  }\n  return JSON.stringify(body);\n}\nfunction allToLowerCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toLowerCase();\n  });\n}\nfunction allToUpperCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toUpperCase();\n  });\n}\nfunction getBackoffCoefficient(count) {\n  return Math.min((count + 2) / 3, 2);\n}\nfunction getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\nfunction getRetryTime(initialTimeout, retryAttempt) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\nfunction getGlobalObject() {\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return self;\n}\nfunction shallowEquals(source, target) {\n  return Object.keys(source).every((key) => source[key] === target[key]) && Object.keys(target).every((key) => target[key] === source[key]);\n}\nfunction matchDerivedChannel(name) {\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/;\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo(\"regex match failed\", 400, 40010);\n  }\n  if (match[2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  return {\n    qualifierParam: match[3] || \"\",\n    channelName: match[4]\n  };\n}\nfunction toBase64(str) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\nfunction arrEquals(a, b) {\n  return a.length === b.length && a.every(function(val, i) {\n    return val === b[i];\n  });\n}\nfunction createMissingPluginError(pluginName) {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\nfunction throwMissingPluginError(pluginName) {\n  throw createMissingPluginError(pluginName);\n}\nasync function withTimeoutAsync(promise, timeout = 5e3, err = \"Timeout expired\") {\n  const e = new ErrorInfo(err, 5e4, 500);\n  return Promise.race([promise, new Promise((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\n}\n\n// package.json\nvar version = \"2.3.1\";\n\n// src/common/lib/util/defaults.ts\nvar agent = \"ably-js/\" + version;\nvar Defaults = {\n  ENVIRONMENT: \"\",\n  REST_HOST: \"rest.ably.io\",\n  REALTIME_HOST: \"realtime.ably.io\",\n  FALLBACK_HOSTS: [\n    \"A.ably-realtime.com\",\n    \"B.ably-realtime.com\",\n    \"C.ably-realtime.com\",\n    \"D.ably-realtime.com\",\n    \"E.ably-realtime.com\"\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15e3,\n    suspendedRetryTimeout: 3e4,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 1e4,\n    httpMaxRetryDuration: 15e3,\n    channelRetryTimeout: 15e3,\n    fallbackRetryTimeout: 6e5,\n    /* For internal / test use only: */\n    connectionStateTtl: 12e4,\n    realtimeRequestTimeout: 1e4,\n    recvTimeout: 9e4,\n    webSocketConnectTimeout: 1e4,\n    webSocketSlowTimeout: 4e3\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n  version,\n  protocolVersion: 3,\n  agent,\n  getHost,\n  getPort,\n  getHttpScheme,\n  environmentFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders\n};\nfunction getHost(options, host, ws) {\n  if (ws)\n    host = host == options.restHost && options.realtimeHost || host || options.realtimeHost;\n  else\n    host = host || options.restHost;\n  return host;\n}\nfunction getPort(options, tls) {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\nfunction getHttpScheme(options) {\n  return options.tls ? \"https://\" : \"http://\";\n}\nfunction environmentFallbackHosts(environment) {\n  return [\n    environment + \"-a-fallback.ably-realtime.com\",\n    environment + \"-b-fallback.ably-realtime.com\",\n    environment + \"-c-fallback.ably-realtime.com\",\n    environment + \"-d-fallback.ably-realtime.com\",\n    environment + \"-e-fallback.ably-realtime.com\"\n  ];\n}\nfunction getFallbackHosts(options) {\n  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== \"undefined\" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\nfunction getHosts(options, ws) {\n  const hosts = [options.restHost].concat(getFallbackHosts(options));\n  return ws ? hosts.map((host) => getHost(options, host, true)) : hosts;\n}\nfunction checkHost(host) {\n  if (typeof host !== \"string\") {\n    throw new ErrorInfo(\"host must be a string; was a \" + typeof host, 4e4, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo(\"host must not be zero-length\", 4e4, 400);\n  }\n}\nfunction getRealtimeHost(options, production, environment, logger) {\n  if (options.realtimeHost)\n    return options.realtimeHost;\n  if (options.restHost) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MINOR,\n      \"Defaults.normaliseOptions\",\n      'restHost is set to \"' + options.restHost + '\" but realtimeHost is not set, so setting realtimeHost to \"' + options.restHost + '\" too. If this is not what you want, please set realtimeHost explicitly.'\n    );\n    return options.restHost;\n  }\n  return production ? Defaults.REALTIME_HOST : environment + \"-\" + Defaults.REALTIME_HOST;\n}\nfunction getTimeouts(options) {\n  const timeouts = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n  }\n  return timeouts;\n}\nfunction getAgentString(options) {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent2 in options.agents) {\n      agentStr += \" \" + agent2 + \"/\" + options.agents[agent2];\n    }\n  }\n  return agentStr;\n}\nfunction objectifyOptions(options, allowKeyOrToken, sourceForErrorMessage, logger, modularPluginsToInclude) {\n  if (options === void 0) {\n    const msg = allowKeyOrToken ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token` : `${sourceForErrorMessage} must be initialized with a client options object`;\n    logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n    throw new Error(msg);\n  }\n  let optionsObj;\n  if (typeof options === \"string\") {\n    if (options.indexOf(\":\") == -1) {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\\u2019s \\`token\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { token: options };\n    } else {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\\u2019s \\`key\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { key: options };\n    }\n  } else {\n    optionsObj = options;\n  }\n  if (modularPluginsToInclude) {\n    optionsObj = __spreadProps(__spreadValues({}, optionsObj), { plugins: __spreadValues(__spreadValues({}, modularPluginsToInclude), optionsObj.plugins) });\n  }\n  return optionsObj;\n}\nfunction normaliseOptions(options, MsgPack, logger) {\n  const loggerToUse = logger != null ? logger : logger_default.defaultLogger;\n  if (typeof options.recover === \"function\" && options.closeOnUnload === true) {\n    logger_default.logAction(\n      loggerToUse,\n      logger_default.LOG_ERROR,\n      \"Defaults.normaliseOptions\",\n      \"closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter\"\n    );\n    options.recover = void 0;\n  }\n  if (!(\"closeOnUnload\" in options)) {\n    options.closeOnUnload = !options.recover;\n  }\n  if (!(\"queueMessages\" in options))\n    options.queueMessages = true;\n  const environment = options.environment && String(options.environment).toLowerCase() || Defaults.ENVIRONMENT;\n  const production = !environment || environment === \"production\";\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\n  }\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + \"-\" + Defaults.REST_HOST);\n  const realtimeHost = getRealtimeHost(options, production, environment, loggerToUse);\n  (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!(\"tls\" in options))\n    options.tls = true;\n  const timeouts = getTimeouts(options);\n  if (MsgPack) {\n    if (\"useBinaryProtocol\" in options) {\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n    } else {\n      options.useBinaryProtocol = Platform.Config.preferBinary;\n    }\n  } else {\n    options.useBinaryProtocol = false;\n  }\n  const headers = {};\n  if (options.clientId) {\n    headers[\"X-Ably-ClientId\"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n  if (!(\"idempotentRestPublishing\" in options)) {\n    options.idempotentRestPublishing = true;\n  }\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split(\"?\");\n    connectivityCheckParams = qs ? parseQueryString(qs) : {};\n    if (uri.indexOf(\"://\") === -1) {\n      uri = \"https://\" + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n  return __spreadProps(__spreadValues({}, options), {\n    realtimeHost,\n    restHost,\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    headers\n  });\n}\nfunction normaliseChannelOptions(Crypto2, logger, options) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(channelOptions.cipher, logger);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if (\"cipher\" in channelOptions) {\n    channelOptions.cipher = void 0;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\nvar contentTypes = {\n  json: \"application/json\",\n  xml: \"application/xml\",\n  html: \"text/html\",\n  msgpack: \"application/x-msgpack\",\n  text: \"text/plain\"\n};\nvar defaultHeadersOptions = {\n  format: \"json\" /* json */,\n  protocolVersion: Defaults.protocolVersion\n};\nfunction defaultGetHeaders(options, {\n  format = defaultHeadersOptions.format,\n  protocolVersion = defaultHeadersOptions.protocolVersion\n} = {}) {\n  const accept = contentTypes[format];\n  return {\n    accept,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nfunction defaultPostHeaders(options, {\n  format = defaultHeadersOptions.format,\n  protocolVersion = defaultHeadersOptions.protocolVersion\n} = {}) {\n  let contentType;\n  const accept = contentType = contentTypes[format];\n  return {\n    accept,\n    \"content-type\": contentType,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nvar defaults_default = Defaults;\nfunction getDefaults(platformDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n\n// src/common/lib/util/multicaster.ts\nvar Multicaster = class _Multicaster {\n  // Private constructor; use static Multicaster.create instead\n  constructor(logger, members) {\n    this.logger = logger;\n    this.members = members || [];\n  }\n  call(err, result) {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(err, result);\n        } catch (e) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Multicaster multiple callback handler\",\n            \"Unexpected exception: \" + e + \"; stack = \" + e.stack\n          );\n        }\n      }\n    }\n  }\n  push(...args) {\n    this.members.push(...args);\n  }\n  createPromise() {\n    return new Promise((resolve, reject) => {\n      this.push((err, result) => {\n        err ? reject(err) : resolve(result);\n      });\n    });\n  }\n  resolveAll(result) {\n    this.call(null, result);\n  }\n  rejectAll(err) {\n    this.call(err);\n  }\n  static create(logger, members) {\n    const instance = new _Multicaster(logger, members);\n    return Object.assign((err, result) => instance.call(err, result), {\n      push: (fn) => instance.push(fn),\n      createPromise: () => instance.createPromise(),\n      resolveAll: (result) => instance.resolveAll(result),\n      rejectAll: (err) => instance.rejectAll(err)\n    });\n  }\n};\nvar multicaster_default = Multicaster;\n\n// src/common/constants/HttpMethods.ts\nvar HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {\n  HttpMethods2[\"Get\"] = \"get\";\n  HttpMethods2[\"Delete\"] = \"delete\";\n  HttpMethods2[\"Post\"] = \"post\";\n  HttpMethods2[\"Put\"] = \"put\";\n  HttpMethods2[\"Patch\"] = \"patch\";\n  return HttpMethods2;\n})(HttpMethods || {});\nvar HttpMethods_default = HttpMethods;\n\n// src/common/constants/HttpStatusCodes.ts\nvar HttpStatusCodes = /* @__PURE__ */ ((HttpStatusCodes2) => {\n  HttpStatusCodes2[HttpStatusCodes2[\"Success\"] = 200] = \"Success\";\n  HttpStatusCodes2[HttpStatusCodes2[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCodes2[HttpStatusCodes2[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCodes2[HttpStatusCodes2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCodes2[HttpStatusCodes2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  return HttpStatusCodes2;\n})(HttpStatusCodes || {});\nfunction isSuccessCode(statusCode) {\n  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;\n}\nvar HttpStatusCodes_default = HttpStatusCodes;\n\n// src/common/lib/client/auth.ts\nvar MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return (\"000000\" + Math.floor(Math.random() * 1e16)).slice(-16);\n}\nfunction isRealtime(client) {\n  return !!client.connection;\n}\nfunction normaliseAuthcallbackError(err) {\n  if (!isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\nvar hmac = (text, key) => {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n  return bufferUtils.base64Encode(digest);\n};\nfunction c14n(capability) {\n  if (!capability)\n    return \"\";\n  if (typeof capability == \"string\")\n    capability = JSON.parse(capability);\n  const c14nCapability = /* @__PURE__ */ Object.create(null);\n  const keys = keysArray(capability, true);\n  if (!keys)\n    return \"\";\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = capability[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\nfunction logAndValidateTokenAuthMethod(authOptions, logger) {\n  if (authOptions.authCallback) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authCallback\");\n  } else if (authOptions.authUrl) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authUrl\");\n  } else if (authOptions.key) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with client-side signing\");\n  } else if (authOptions.tokenDetails) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with supplied token only\");\n  } else {\n    const msg = \"authOptions must include valid authentication parameters\";\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n    throw new Error(msg);\n  }\n}\nfunction basicAuthForced(options) {\n  return \"useTokenAuth\" in options && !options.useTokenAuth;\n}\nfunction useTokenAuth(options) {\n  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);\n}\nfunction noWayToRenew(options) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\nvar trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\nvar Auth = class {\n  constructor(client, options) {\n    // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n    this.authOptions = {};\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n    if (useTokenAuth(options)) {\n      if (noWayToRenew(options)) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"Auth()\",\n          \"Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams, options);\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    } else {\n      if (!options.key) {\n        const msg = \"No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth()\", \"anonymous, using basic auth\");\n      this._saveBasicOptions(options);\n    }\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async authorize(tokenParams, authOptions) {\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo(\"Unable to update auth options with incompatible key\", 40102, 401);\n    }\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams != null ? tokenParams : null, authOptions != null ? authOptions : null);\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          this.client.connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err, tokenDetails2) => err ? reject(err) : resolve(tokenDetails2)\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {\n        this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n      }\n      throw err;\n    }\n  }\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(tokenParams, authOptions) {\n    this.tokenDetails = null;\n    this._saveTokenOptions(tokenParams, authOptions);\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n  async requestToken(tokenParams, authOptions) {\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || copy(this.tokenParams);\n    let tokenRequestCallback, client = this.client;\n    if (resolvedAuthOptions.authCallback) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authCallback\");\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authUrl\");\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = mixin(\n          { accept: \"application/json, text/plain\" },\n          resolvedAuthOptions.authHeaders\n        );\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === \"post\";\n        let providedQsParams;\n        const queryIdx = resolvedAuthOptions.authUrl.indexOf(\"?\");\n        if (queryIdx > -1) {\n          providedQsParams = parseQueryString(resolvedAuthOptions.authUrl.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl.slice(0, queryIdx);\n          if (!usePost) {\n            resolvedAuthOptions.authParams = mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams\n            );\n          }\n        }\n        const authParams = mixin({}, resolvedAuthOptions.authParams || {}, params);\n        const authUrlRequestCallback = (result) => {\n          var _a2, _b;\n          let body = (_a2 = result.body) != null ? _a2 : null;\n          let contentType = null;\n          if (result.error) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received Error: \" + inspectError(result.error)\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = (_b = result.headers[\"content-type\"]) != null ? _b : null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              contentType = contentTypeHeaderOrHeaders.join(\", \");\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received; content-type: \" + contentType + \"; body: \" + inspectBody(body)\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body))\n            body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo(\"authUrl response is missing a content-type header\", 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf(\"application/json\") > -1, text = contentType.indexOf(\"text/plain\") > -1 || contentType.indexOf(\"application/jwt\") > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                \"authUrl responded with unacceptable content-type \" + contentType + \", should be either text/plain, application/jwt or application/json\",\n                40170,\n                401\n              ),\n              null\n            );\n            return;\n          }\n          if (json) {\n            if (body.length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo(\"authUrl response exceeded max permitted length\", 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  \"Unexpected error processing authURL response; err = \" + e.message,\n                  40170,\n                  401\n                ),\n                null\n              );\n              return;\n            }\n          }\n          cb(null, body, contentType);\n        };\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Auth.requestToken().tokenRequestCallback\",\n          \"Requesting token from \" + resolvedAuthOptions.authUrl + \"; Params: \" + JSON.stringify(authParams) + \"; method: \" + (usePost ? \"POST\" : \"GET\")\n        );\n        if (usePost) {\n          const headers = authHeaders || {};\n          headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n          const body = toQueryString(authParams).slice(1);\n          whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods_default.Post,\n              resolvedAuthOptions.authUrl,\n              headers,\n              body,\n              providedQsParams\n            ),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        } else {\n          whenPromiseSettles(\n            this.client.http.doUri(HttpMethods_default.Get, resolvedAuthOptions.authUrl, authHeaders || {}, null, authParams),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth.requestToken()\",\n        \"using token auth with client-side signing\"\n      );\n      tokenRequestCallback = (params, cb) => {\n        whenPromiseSettles(\n          this.createTokenRequest(params, resolvedAuthOptions),\n          (err, result) => cb(err, result != null ? result : null)\n        );\n      };\n    } else {\n      const msg = \"Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)\";\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Auth()\",\n        \"library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n    if (\"capability\" in resolvedTokenParams)\n      resolvedTokenParams.capability = c14n(\n        resolvedTokenParams.capability\n      );\n    const tokenRequest = (signedTokenParams, tokenCb) => {\n      const keyName = signedTokenParams.keyName, path = \"/keys/\" + keyName + \"/requestToken\", tokenUri = function(host) {\n        return client.baseUri(host) + path;\n      };\n      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options);\n      if (resolvedAuthOptions.requestHeaders)\n        mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Auth.requestToken().requestToken\",\n        \"Sending POST to \" + path + \"; Token params: \" + JSON.stringify(signedTokenParams)\n      );\n      whenPromiseSettles(\n        this.client.http.do(HttpMethods_default.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err, result) => err ? tokenCb(err) : tokenCb(result.error, result.body, result.unpacked)\n      );\n    };\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(() => {\n        tokenRequestCallbackTimeoutExpired = true;\n        const msg = \"Token request callback timed out after \" + timeoutLength / 1e3 + \" seconds\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n        reject(new ErrorInfo(msg, 40170, 401));\n      }, timeoutLength);\n      tokenRequestCallback(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\n        if (tokenRequestCallbackTimeoutExpired)\n          return;\n        clearTimeout(tokenRequestCallbackTimeout);\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Auth.requestToken()\",\n            \"token request signing call returned error; err = \" + inspectError(err)\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        if (typeof tokenRequestOrDetails === \"string\") {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo(\"Token string is empty\", 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                \"Token string exceeded max permitted length (was \" + tokenRequestOrDetails.length + \" bytes)\",\n                40170,\n                401\n              )\n            );\n          } else if (tokenRequestOrDetails === \"undefined\" || tokenRequestOrDetails === \"null\") {\n            reject(new ErrorInfo(\"Token string was literal null/undefined\", 40170, 401));\n          } else if (tokenRequestOrDetails[0] === \"{\" && !(contentType && contentType.indexOf(\"application/jwt\") > -1)) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401\n              )\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails });\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== \"object\" || tokenRequestOrDetails === null) {\n          const msg = \"Expected token request callback to call back with a token string or token request/details object, but got a \" + typeof tokenRequestOrDetails;\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              \"Token request/details object exceeded max permitted stringified size (was \" + objectSize + \" bytes)\",\n              40170,\n              401\n            )\n          );\n          return;\n        }\n        if (\"issued\" in tokenRequestOrDetails) {\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!(\"keyName\" in tokenRequestOrDetails)) {\n          const msg = \"Expected token request callback to call back with a token string, token request object, or token details object\";\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        tokenRequest(tokenRequestOrDetails, (err2, tokenResponse, unpacked) => {\n          if (err2) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Auth.requestToken()\",\n              \"token request API call returned error; err = \" + inspectError(err2)\n            );\n            reject(normaliseAuthcallbackError(err2));\n            return;\n          }\n          if (!unpacked)\n            tokenResponse = JSON.parse(tokenResponse);\n          logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"token received\");\n          resolve(tokenResponse);\n        });\n      });\n    });\n  }\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams, authOptions) {\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || copy(this.tokenParams);\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo(\"No key specified\", 40101, 403);\n    }\n    const keyParts = key.split(\":\"), keyName = keyParts[0], keySecret = keyParts[1];\n    if (!keySecret) {\n      throw new ErrorInfo(\"Invalid key specified\", 40101, 403);\n    }\n    if (tokenParams.clientId === \"\") {\n      throw new ErrorInfo(\"clientId can\\u2019t be an empty string\", 40012, 400);\n    }\n    if (\"capability\" in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || \"\", ttl = tokenParams.ttl || \"\", capability = tokenParams.capability || \"\";\n    if (!request.timestamp) {\n      request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\n    }\n    const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;\n    const signText = request.keyName + \"\\n\" + ttl + \"\\n\" + capability + \"\\n\" + clientId + \"\\n\" + timestamp + \"\\n\" + nonce + \"\\n\";\n    request.mac = request.mac || hmac(signText, keySecret);\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getTokenRequest()\", \"generated signed request\");\n    return request;\n  }\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams() {\n    if (this.method == \"basic\")\n      return { key: this.key };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders() {\n    if (this.method == \"basic\") {\n      return { authorization: \"Basic \" + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { authorization: \"Bearer \" + toBase64(tokenDetails.token) };\n    }\n  }\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime) {\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\n      return this.client.time();\n    } else {\n      return this.getTimestampUsingOffset();\n    }\n  }\n  getTimestampUsingOffset() {\n    return Date.now() + (this.client.serverTimeOffset || 0);\n  }\n  isTimeOffsetSet() {\n    return this.client.serverTimeOffset !== null;\n  }\n  _saveBasicOptions(authOptions) {\n    this.method = \"basic\";\n    this.key = authOptions.key;\n    this.basicKey = toBase64(authOptions.key);\n    this.authOptions = authOptions || {};\n    if (\"clientId\" in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n  _saveTokenOptions(tokenParams, authOptions) {\n    this.method = \"token\";\n    if (tokenParams) {\n      this.tokenParams = tokenParams;\n    }\n    if (authOptions) {\n      if (authOptions.token) {\n        authOptions.tokenDetails = typeof authOptions.token === \"string\" ? { token: authOptions.token } : authOptions.token;\n      }\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n      if (\"clientId\" in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n      this.authOptions = authOptions;\n    }\n  }\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede) {\n    const token = this.tokenDetails;\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        throw new ErrorInfo(\n          \"Mismatch between clientId in token (\" + token.clientId + \") and current clientId (\" + this.clientId + \")\",\n          40102,\n          403\n        );\n      }\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Auth.getToken()\",\n          \"using cached token; expires = \" + token.expires\n        );\n        return token;\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"deleting expired token\");\n      this.tokenDetails = null;\n    }\n    const promise = (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create(this.logger))).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();\n    let tokenResponse, caughtError = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err;\n    }\n    if (this.currentTokenRequestId > tokenRequestId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth._ensureValidAuthCredentials()\",\n        \"Discarding token request response; overtaken by newer one\"\n      );\n      return promise;\n    }\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster == null ? void 0 : multicaster.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster == null ? void 0 : multicaster.resolveAll(this.tokenDetails = tokenResponse);\n    return promise;\n  }\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId) {\n    if (!(typeof clientId === \"string\" || clientId === null)) {\n      throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n    } else if (clientId === \"*\") {\n      throw new ErrorInfo(\n        'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err)\n        throw err;\n    }\n  }\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      const msg = \"Unexpected clientId mismatch: client has \" + this.clientId + \", requested \" + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth._uncheckedSetClientId()\", msg);\n      return err;\n    } else {\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n  _tokenClientIdMismatch(tokenClientId) {\n    return !!(this.clientId && this.clientId !== \"*\" && tokenClientId && tokenClientId !== \"*\" && this.clientId !== tokenClientId);\n  }\n  static isTokenErr(error) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n  revokeTokens(specifiers, options) {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n};\nvar auth_default = Auth;\n\n// src/common/types/http.ts\nfunction paramString(params) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + \"=\" + params[needle]);\n    }\n  }\n  return paramPairs.join(\"&\");\n}\nfunction appendingParams(uri, params) {\n  return uri + (params ? \"?\" : \"\") + paramString(params);\n}\nfunction logResult(result, method, uri, params, logger) {\n  if (result.error) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(uri, params) + \"; Error: \" + inspectError(result.error)\n    );\n  } else {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received; \" + appendingParams(uri, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body\" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + result.body)\n    );\n  }\n}\nfunction logRequest(method, uri, body, params, logger) {\n  if (logger.shouldLog(logger_default.LOG_MICRO)) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Sending; \" + appendingParams(uri, params) + \"; Body\" + (Platform.BufferUtils.isBuffer(body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(body) : \": \" + body)\n    );\n  }\n}\nvar Http = class {\n  constructor(client) {\n    this.client = client;\n    this.platformHttp = new Platform.Http(client);\n    this.checkConnectivity = this.platformHttp.checkConnectivity ? () => this.platformHttp.checkConnectivity() : void 0;\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  get supportsAuthHeaders() {\n    return this.platformHttp.supportsAuthHeaders;\n  }\n  get supportsLinkHeaders() {\n    return this.platformHttp.supportsLinkHeaders;\n  }\n  _getHosts(client) {\n    const connection = client.connection, connectionHost = connection && connection.connectionManager.host;\n    if (connectionHost) {\n      return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));\n    }\n    return defaults_default.getHosts(client.options);\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async do(method, path, headers, body, params) {\n    try {\n      const client = this.client;\n      if (!client) {\n        return { error: new ErrorInfo(\"http.do called without client\", 5e4, 500) };\n      }\n      const uriFromHost = typeof path === \"function\" ? path : function(host) {\n        return client.baseUri(host) + path;\n      };\n      const currentFallback = client._currentFallback;\n      if (currentFallback) {\n        if (currentFallback.validUntil > Date.now()) {\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error)) {\n            client._currentFallback = null;\n            return this.do(method, path, headers, body, params);\n          }\n          return result;\n        } else {\n          client._currentFallback = null;\n        }\n      }\n      const hosts = this._getHosts(client);\n      if (hosts.length === 1) {\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n      }\n      let tryAHostStartedAt = null;\n      const tryAHost = async (candidateHosts, persistOnSuccess) => {\n        const host = candidateHosts.shift();\n        tryAHostStartedAt = tryAHostStartedAt != null ? tryAHostStartedAt : /* @__PURE__ */ new Date();\n        const result = await this.doUri(method, uriFromHost(host), headers, body, params);\n        if (result.error && this.platformHttp.shouldFallback(result.error) && candidateHosts.length) {\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\n            return {\n              error: new ErrorInfo(\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\n                50003,\n                500\n              )\n            };\n          }\n          return tryAHost(candidateHosts, true);\n        }\n        if (persistOnSuccess) {\n          client._currentFallback = {\n            host,\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout\n          };\n        }\n        return result;\n      };\n      return tryAHost(hosts);\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async doUri(method, uri, headers, body, params) {\n    try {\n      logRequest(method, uri, body, params, this.logger);\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n      if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n        logResult(result, method, uri, params, this.logger);\n      }\n      return result;\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n};\n\n// src/common/lib/client/baseclient.ts\nvar BaseClient = class {\n  constructor(options) {\n    /**\n     * These exports are for use by UMD plugins; reason being so that constructors and static methods can be accessed by these plugins without needing to import the classes directly and result in the class existing in both the plugin and the core library.\n     */\n    this.Platform = Platform;\n    this.ErrorInfo = ErrorInfo;\n    this.Logger = logger_default;\n    this.Defaults = defaults_default;\n    this.Utils = utils_exports;\n    var _a2, _b, _c, _d, _e, _f, _g, _h;\n    this._additionalHTTPRequestImplementations = (_a2 = options.plugins) != null ? _a2 : null;\n    this.logger = new logger_default();\n    this.logger.setLog(options.logLevel, options.logHandler);\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"BaseClient()\",\n      \"initialized with clientOptions \" + Platform.Config.inspect(options)\n    );\n    this._MsgPack = (_c = (_b = options.plugins) == null ? void 0 : _b.MsgPack) != null ? _c : null;\n    const normalOptions = this.options = defaults_default.normaliseOptions(options, this._MsgPack, this.logger);\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = \"invalid key parameter\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"BaseClient()\", msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n    if (\"clientId\" in normalOptions) {\n      if (!(typeof normalOptions.clientId === \"string\" || normalOptions.clientId === null))\n        throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n      else if (normalOptions.clientId === \"*\")\n        throw new ErrorInfo(\n          'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400\n        );\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"BaseClient()\", \"started; version = \" + defaults_default.version);\n    this._currentFallback = null;\n    this.serverTimeOffset = null;\n    this.http = new Http(this);\n    this.auth = new auth_default(this, normalOptions);\n    this._rest = ((_d = options.plugins) == null ? void 0 : _d.Rest) ? new options.plugins.Rest(this) : null;\n    this._Crypto = (_f = (_e = options.plugins) == null ? void 0 : _e.Crypto) != null ? _f : null;\n    this.__FilteredSubscriptions = (_h = (_g = options.plugins) == null ? void 0 : _g.MessageInteractions) != null ? _h : null;\n  }\n  get rest() {\n    if (!this._rest) {\n      throwMissingPluginError(\"Rest\");\n    }\n    return this._rest;\n  }\n  get _FilteredSubscriptions() {\n    if (!this.__FilteredSubscriptions) {\n      throwMissingPluginError(\"MessageInteractions\");\n    }\n    return this.__FilteredSubscriptions;\n  }\n  get channels() {\n    return this.rest.channels;\n  }\n  get push() {\n    return this.rest.push;\n  }\n  get device() {\n    var _a2;\n    if (!((_a2 = this.options.plugins) == null ? void 0 : _a2.Push) || !this.push.LocalDevice) {\n      throwMissingPluginError(\"Push\");\n    }\n    if (!this._device) {\n      this._device = this.push.LocalDevice.load(this);\n    }\n    return this._device;\n  }\n  baseUri(host) {\n    return defaults_default.getHttpScheme(this.options) + host + \":\" + defaults_default.getPort(this.options, false);\n  }\n  async stats(params) {\n    return this.rest.stats(params);\n  }\n  async time(params) {\n    return this.rest.time(params);\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    return this.rest.request(method, path, version2, params, body, customHeaders);\n  }\n  batchPublish(specOrSpecs) {\n    return this.rest.batchPublish(specOrSpecs);\n  }\n  batchPresence(channels) {\n    return this.rest.batchPresence(channels);\n  }\n  setLog(logOptions) {\n    this.logger.setLog(logOptions.level, logOptions.handler);\n  }\n};\nBaseClient.Platform = Platform;\nvar baseclient_default = BaseClient;\n\n// src/common/lib/types/devicedetails.ts\nvar DeviceDetails = class _DeviceDetails {\n  toJSON() {\n    var _a2, _b, _c;\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,\n        state: (_b = this.push) == null ? void 0 : _b.state,\n        error: (_c = this.push) == null ? void 0 : _c.error\n      }\n    };\n  }\n  toString() {\n    var _a2, _b, _c, _d;\n    let result = \"[DeviceDetails\";\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.platform)\n      result += \"; platform=\" + this.platform;\n    if (this.formFactor)\n      result += \"; formFactor=\" + this.formFactor;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.metadata)\n      result += \"; metadata=\" + this.metadata;\n    if (this.deviceIdentityToken)\n      result += \"; deviceIdentityToken=\" + JSON.stringify(this.deviceIdentityToken);\n    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)\n      result += \"; push.recipient=\" + JSON.stringify(this.push.recipient);\n    if ((_b = this.push) == null ? void 0 : _b.state)\n      result += \"; push.state=\" + this.push.state;\n    if ((_c = this.push) == null ? void 0 : _c.error)\n      result += \"; push.error=\" + JSON.stringify(this.push.error);\n    if ((_d = this.push) == null ? void 0 : _d.metadata)\n      result += \"; push.metadata=\" + this.push.metadata;\n    result += \"]\";\n    return result;\n  }\n  static toRequestBody(body, MsgPack, format) {\n    return encodeBody(body, MsgPack, format);\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _DeviceDetails.fromValuesArray(body);\n    } else {\n      return _DeviceDetails.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    values.error = values.error && ErrorInfo.fromValues(values.error);\n    return Object.assign(new _DeviceDetails(), values);\n  }\n  static fromLocalDevice(device) {\n    return Object.assign(new _DeviceDetails(), device);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n};\nvar devicedetails_default = DeviceDetails;\n\n// src/common/lib/client/resource.ts\nasync function withAuthDetails(client, headers, params, opCallback) {\n  if (client.http.supportsAuthHeaders) {\n    const authHeaders = await client.auth.getAuthHeaders();\n    return opCallback(mixin(authHeaders, headers), params);\n  } else {\n    const authParams = await client.auth.getAuthParams();\n    return opCallback(headers, mixin(authParams, params));\n  }\n}\nfunction unenvelope(result, MsgPack, format) {\n  if (result.err && !result.body) {\n    return { err: result.err };\n  }\n  if (result.statusCode === HttpStatusCodes_default.NoContent) {\n    return __spreadProps(__spreadValues({}, result), { body: [], unpacked: true });\n  }\n  let body = result.body;\n  if (!result.unpacked) {\n    try {\n      body = decodeBody(body, MsgPack, format);\n    } catch (e) {\n      if (isErrorInfoOrPartialErrorInfo(e)) {\n        return { err: e };\n      } else {\n        return { err: new PartialErrorInfo(inspectError(e), null) };\n      }\n    }\n  }\n  if (!body) {\n    return { err: new PartialErrorInfo(\"unenvelope(): Response body is missing\", null) };\n  }\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;\n  if (wrappedStatusCode === void 0) {\n    return __spreadProps(__spreadValues({}, result), { body, unpacked: true });\n  }\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n    let wrappedErr = response && response.error || result.err;\n    if (!wrappedErr) {\n      wrappedErr = new Error(\"Error in unenveloping \" + body);\n      wrappedErr.statusCode = wrappedStatusCode;\n    }\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n  }\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n}\nfunction logResult2(result, method, path, params, logger) {\n  if (result.err) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(path, params) + \"; Error: \" + inspectError(result.err)\n    );\n  } else {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received; \" + appendingParams(path, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body: \" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + Platform.Config.inspect(result.body))\n    );\n  }\n}\nvar Resource = class _Resource {\n  static async get(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, throwError != null ? throwError : false);\n  }\n  static async delete(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, throwError);\n  }\n  static async post(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, throwError);\n  }\n  static async patch(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, throwError);\n  }\n  static async put(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, throwError);\n  }\n  static async do(method, client, path, body, headers, params, envelope, throwError) {\n    if (envelope) {\n      (params = params || {})[\"envelope\"] = envelope;\n    }\n    const logger = client.logger;\n    async function doRequest(headers2, params2) {\n      var _a2;\n      if (logger.shouldLog(logger_default.LOG_MICRO)) {\n        let decodedBody = body;\n        if (((_a2 = headers2[\"content-type\"]) == null ? void 0 : _a2.indexOf(\"msgpack\")) > 0) {\n          try {\n            if (!client._MsgPack) {\n              throwMissingPluginError(\"MsgPack\");\n            }\n            decodedBody = client._MsgPack.decode(body);\n          } catch (decodeErr) {\n            logger_default.logAction(\n              logger,\n              logger_default.LOG_MICRO,\n              \"Resource.\" + method + \"()\",\n              \"Sending MsgPack Decoding Error: \" + inspectError(decodeErr)\n            );\n          }\n        }\n        logger_default.logAction(\n          logger,\n          logger_default.LOG_MICRO,\n          \"Resource.\" + method + \"()\",\n          \"Sending; \" + appendingParams(path, params2) + \"; Body: \" + decodedBody\n        );\n      }\n      const httpResult = await client.http.do(method, path, headers2, body, params2);\n      if (httpResult.error && auth_default.isTokenErr(httpResult.error)) {\n        await client.auth.authorize(null, null);\n        return withAuthDetails(client, headers2, params2, doRequest);\n      }\n      return {\n        err: httpResult.error,\n        body: httpResult.body,\n        headers: httpResult.headers,\n        unpacked: httpResult.unpacked,\n        statusCode: httpResult.statusCode\n      };\n    }\n    let result = await withAuthDetails(client, headers, params, doRequest);\n    if (envelope) {\n      result = unenvelope(result, client._MsgPack, envelope);\n    }\n    if (logger.shouldLog(logger_default.LOG_MICRO)) {\n      logResult2(result, method, path, params, logger);\n    }\n    if (throwError) {\n      if (result.err) {\n        throw result.err;\n      } else {\n        const response = __spreadValues({}, result);\n        delete response.err;\n        return response;\n      }\n    }\n    return result;\n  }\n};\nvar resource_default = Resource;\n\n// src/common/lib/client/paginatedresource.ts\nfunction getRelParams(linkUrl) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);\n}\nfunction parseRelLinks(linkHeader) {\n  if (typeof linkHeader == \"string\")\n    linkHeader = linkHeader.split(\",\");\n  const relParams = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params)\n        relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\nfunction returnErrOnly(err, body, useHPR) {\n  return !(useHPR && (body || typeof err.code === \"number\"));\n}\nvar PaginatedResource = class {\n  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope != null ? envelope : null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async get(params) {\n    const result = await resource_default.get(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async delete(params) {\n    const result = await resource_default.delete(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async post(params, body) {\n    const result = await resource_default.post(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async put(params, body) {\n    const result = await resource_default.put(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async patch(params, body) {\n    const result = await resource_default.patch(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async handlePage(result) {\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"PaginatedResource.handlePage()\",\n        \"Unexpected error getting resource: err = \" + inspectError(result.err)\n      );\n      throw result.err;\n    }\n    let items, linkHeader, relParams;\n    try {\n      items = result.statusCode == HttpStatusCodes_default.NoContent ? [] : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n    } catch (e) {\n      throw result.err || e;\n    }\n    if (result.headers && (linkHeader = result.headers[\"Link\"] || result.headers[\"link\"])) {\n      relParams = parseRelLinks(linkHeader);\n    }\n    if (this.useHttpPaginatedResponse) {\n      return new HttpPaginatedResponse(\n        this,\n        items,\n        result.headers || {},\n        result.statusCode,\n        relParams,\n        result.err\n      );\n    } else {\n      return new PaginatedResult(this, items, relParams);\n    }\n  }\n};\nvar PaginatedResult = class {\n  constructor(resource, items, relParams) {\n    this.resource = resource;\n    this.items = items;\n    const self2 = this;\n    if (relParams) {\n      if (\"first\" in relParams) {\n        this.first = async function() {\n          return self2.get(relParams.first);\n        };\n      }\n      if (\"current\" in relParams) {\n        this.current = async function() {\n          return self2.get(relParams.current);\n        };\n      }\n      this.next = async function() {\n        if (\"next\" in relParams) {\n          return self2.get(relParams.next);\n        } else {\n          return null;\n        }\n      };\n      this.hasNext = function() {\n        return \"next\" in relParams;\n      };\n      this.isLast = () => {\n        var _a2;\n        return !((_a2 = this.hasNext) == null ? void 0 : _a2.call(this));\n      };\n    }\n  }\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  async get(params) {\n    const res = this.resource;\n    const result = await resource_default.get(res.client, res.path, res.headers, params, res.envelope, false);\n    return res.handlePage(result);\n  }\n};\nvar HttpPaginatedResponse = class extends PaginatedResult {\n  constructor(resource, items, headers, statusCode, relParams, err) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage\n    };\n  }\n};\nvar paginatedresource_default = PaginatedResource;\n\n// src/common/lib/types/pushchannelsubscription.ts\nvar _PushChannelSubscription = class _PushChannelSubscription {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId\n    };\n  }\n  toString() {\n    let result = \"[PushChannelSubscription\";\n    if (this.channel)\n      result += \"; channel=\" + this.channel;\n    if (this.deviceId)\n      result += \"; deviceId=\" + this.deviceId;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    result += \"]\";\n    return result;\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return _PushChannelSubscription.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    return Object.assign(new _PushChannelSubscription(), values);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n};\n_PushChannelSubscription.toRequestBody = encodeBody;\nvar PushChannelSubscription = _PushChannelSubscription;\nvar pushchannelsubscription_default = PushChannelSubscription;\n\n// src/common/lib/client/push.ts\nvar Push = class {\n  constructor(client) {\n    var _a2;\n    this.client = client;\n    this.admin = new Admin(client);\n    if (Platform.Config.push && ((_a2 = client.options.plugins) == null ? void 0 : _a2.Push)) {\n      this.stateMachine = new client.options.plugins.Push.ActivationStateMachine(client);\n      this.LocalDevice = client.options.plugins.Push.localDeviceFactory(devicedetails_default);\n    }\n  }\n  async activate(registerCallback, updateFailedCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.activatedCallback) {\n        reject(new ErrorInfo(\"Activation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.activatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.updateFailedCallback = updateFailedCallback;\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledActivate(this.stateMachine, registerCallback)\n      );\n    });\n  }\n  async deactivate(deregisterCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.deactivatedCallback) {\n        reject(new ErrorInfo(\"Deactivation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.deactivatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledDeactivate(this.stateMachine, deregisterCallback)\n      );\n    });\n  }\n};\nvar Admin = class {\n  constructor(client) {\n    this.client = client;\n    this.deviceRegistrations = new DeviceRegistrations(client);\n    this.channelSubscriptions = new ChannelSubscriptions(client);\n  }\n  async publish(recipient, payload) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    const body = mixin({ recipient }, payload);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    await resource_default.post(client, \"/push/publish\", requestBody, headers, params, null, true);\n  }\n};\nvar DeviceRegistrations = class {\n  constructor(client) {\n    this.client = client;\n  }\n  async save(device) {\n    const client = this.client;\n    const body = devicedetails_default.fromValues(device);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.put(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async get(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    const response = await resource_default.get(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/deviceRegistrations\", headers, envelope, async function(body, headers2, unpacked) {\n      return devicedetails_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async remove(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/deviceRegistrations\", headers, params, null, true);\n  }\n};\nvar ChannelSubscriptions = class _ChannelSubscriptions {\n  constructor(client) {\n    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n    this.remove = _ChannelSubscriptions.prototype.removeWhere;\n    this.client = client;\n  }\n  async save(subscription) {\n    const client = this.client;\n    const body = pushchannelsubscription_default.fromValues(subscription);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.post(\n      client,\n      \"/push/channelSubscriptions\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return pushchannelsubscription_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/channelSubscriptions\", headers, envelope, async function(body, headers2, unpacked) {\n      return pushchannelsubscription_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/channelSubscriptions\", headers, params, null, true);\n  }\n  async listChannels(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    return new paginatedresource_default(client, \"/push/channels\", headers, envelope, async function(body, headers2, unpacked) {\n      const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params);\n  }\n};\nvar push_default = Push;\n\n// src/common/lib/types/message.ts\nfunction normaliseContext(context) {\n  if (!context || !context.channelOptions) {\n    return {\n      channelOptions: context,\n      plugins: {},\n      baseEncodedPreviousPayload: void 0\n    };\n  }\n  return context;\n}\nfunction normalizeCipherOptions(Crypto2, logger, options) {\n  if (options && options.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(options.cipher, logger);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher\n    };\n  }\n  return options != null ? options : {};\n}\nfunction getMessageSize(msg) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += dataSizeBytes(msg.data);\n  }\n  return size;\n}\nasync function fromEncoded(logger, Crypto2, encoded, inputOptions) {\n  const msg = fromValues(encoded);\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  try {\n    await decode(msg, options);\n  } catch (e) {\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Message.fromEncoded()\", e.toString());\n  }\n  return msg;\n}\nasync function fromEncodedArray(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function encrypt(msg, options) {\n  let data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;\n  encoding = encoding ? encoding + \"/\" : \"\";\n  if (!Platform.BufferUtils.isBuffer(data)) {\n    data = Platform.BufferUtils.utf8Encode(String(data));\n    encoding = encoding + \"utf-8/\";\n  }\n  const ciphertext = await cipher.encrypt(data);\n  msg.data = ciphertext;\n  msg.encoding = encoding + \"cipher+\" + cipher.algorithm;\n  return msg;\n}\nasync function encode(msg, options) {\n  const data = msg.data;\n  const nativeDataType = typeof data == \"string\" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;\n  if (!nativeDataType) {\n    if (isObject(data) || Array.isArray(data)) {\n      msg.data = JSON.stringify(data);\n      msg.encoding = msg.encoding ? msg.encoding + \"/json\" : \"json\";\n    } else {\n      throw new ErrorInfo(\"Data type is unsupported\", 40013, 400);\n    }\n  }\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\nasync function encodeArray(messages, options) {\n  return Promise.all(messages.map((message) => encode(message, options)));\n}\nvar serialize = encodeBody;\nasync function decode(message, inputContext) {\n  const context = normaliseContext(inputContext);\n  let lastPayload = message.data;\n  const encoding = message.encoding;\n  if (encoding) {\n    const xforms = encoding.split(\"/\");\n    let lastProcessedEncodingIndex, encodingsToProcess = xforms.length, data = message.data;\n    let xform = \"\";\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match)\n          break;\n        xform = match[1];\n        switch (xform) {\n          case \"base64\":\n            data = Platform.BufferUtils.base64Decode(String(data));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = data;\n            }\n            continue;\n          case \"utf-8\":\n            data = Platform.BufferUtils.utf8Decode(data);\n            continue;\n          case \"json\":\n            data = JSON.parse(data);\n            continue;\n          case \"cipher\":\n            if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {\n              const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error(\"Unable to decrypt message with given cipher; incompatible cipher params\");\n              }\n              data = await cipher.decrypt(data);\n              continue;\n            } else {\n              throw new Error(\"Unable to decrypt message; not an encrypted channel\");\n            }\n          case \"vcdiff\":\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo(\"Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)\", 40019, 400);\n            }\n            if (typeof Uint8Array === \"undefined\") {\n              throw new ErrorInfo(\n                \"Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)\",\n                40020,\n                400\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === \"string\") {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);\n              data = Platform.BufferUtils.toBuffer(data);\n              data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\n              lastPayload = data;\n            } catch (e) {\n              throw new ErrorInfo(\"Vcdiff delta decode failed with \" + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error(\"Unknown encoding\");\n        }\n      }\n    } catch (e) {\n      const err = e;\n      throw new ErrorInfo(\n        \"Error processing the \" + xform + \" encoding, decoder returned \\u2018\" + err.message + \"\\u2019\",\n        err.code || 40013,\n        400\n      );\n    } finally {\n      message.encoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join(\"/\");\n      message.data = data;\n    }\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n}\nasync function fromResponseBody(body, options, logger, MsgPack, format) {\n  if (format) {\n    body = decodeBody(body, MsgPack, format);\n  }\n  for (let i = 0; i < body.length; i++) {\n    const msg = body[i] = fromValues(body[i]);\n    try {\n      await decode(msg, options);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"Message.fromResponseBody()\", e.toString());\n    }\n  }\n  return body;\n}\nfunction fromValues(values) {\n  return Object.assign(new Message(), values);\n}\nfunction fromValuesArray(values) {\n  const count = values.length, result = new Array(count);\n  for (let i = 0; i < count; i++)\n    result[i] = fromValues(values[i]);\n  return result;\n}\nfunction getMessagesSize(messages) {\n  let msg, total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\nvar Message = class {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    let encoding = this.encoding;\n    let data = this.data;\n    if (data && Platform.BufferUtils.isBuffer(data)) {\n      if (arguments.length > 0) {\n        encoding = encoding ? encoding + \"/base64\" : \"base64\";\n        data = Platform.BufferUtils.base64Encode(data);\n      } else {\n        data = Platform.BufferUtils.toBuffer(data);\n      }\n    }\n    return {\n      name: this.name,\n      id: this.id,\n      clientId: this.clientId,\n      connectionId: this.connectionId,\n      connectionKey: this.connectionKey,\n      extras: this.extras,\n      encoding,\n      data\n    };\n  }\n  toString() {\n    let result = \"[Message\";\n    if (this.name)\n      result += \"; name=\" + this.name;\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.timestamp)\n      result += \"; timestamp=\" + this.timestamp;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.connectionId)\n      result += \"; connectionId=\" + this.connectionId;\n    if (this.encoding)\n      result += \"; encoding=\" + this.encoding;\n    if (this.extras)\n      result += \"; extras =\" + JSON.stringify(this.extras);\n    if (this.data) {\n      if (typeof this.data == \"string\")\n        result += \"; data=\" + this.data;\n      else if (Platform.BufferUtils.isBuffer(this.data))\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(this.data);\n      else\n        result += \"; data (json)=\" + JSON.stringify(this.data);\n    }\n    if (this.extras)\n      result += \"; extras=\" + JSON.stringify(this.extras);\n    result += \"]\";\n    return result;\n  }\n};\nvar message_default = Message;\n\n// src/common/lib/types/presencemessage.ts\nvar actions = [\"absent\", \"present\", \"enter\", \"leave\", \"update\"];\nfunction toActionValue(actionString) {\n  return actions.indexOf(actionString);\n}\nasync function fromEncoded2(logger, encoded, options) {\n  const msg = fromValues2(encoded, true);\n  try {\n    await decode2(msg, options != null ? options : {});\n  } catch (e) {\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"PresenceMessage.fromEncoded()\", e.toString());\n  }\n  return msg;\n}\nasync function fromEncodedArray2(logger, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded2(logger, encoded, options);\n    })\n  );\n}\nfunction fromValues2(values, stringifyAction) {\n  if (stringifyAction) {\n    values.action = actions[values.action];\n  }\n  return Object.assign(new PresenceMessage(), values);\n}\nvar decode2 = decode;\nasync function fromResponseBody2(body, options, logger, MsgPack, format) {\n  const messages = [];\n  if (format) {\n    body = decodeBody(body, MsgPack, format);\n  }\n  for (let i = 0; i < body.length; i++) {\n    const msg = messages[i] = fromValues2(body[i], true);\n    try {\n      await decode2(msg, options);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"PresenceMessage.fromResponseBody()\", e.toString());\n    }\n  }\n  return messages;\n}\nfunction fromValuesArray2(values) {\n  const count = values.length, result = new Array(count);\n  for (let i = 0; i < count; i++)\n    result[i] = fromValues2(values[i]);\n  return result;\n}\nfunction fromData(data) {\n  if (data instanceof PresenceMessage) {\n    return data;\n  }\n  return fromValues2({\n    data\n  });\n}\nvar PresenceMessage = class {\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized() {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n  /* RTP2b2 */\n  parseId() {\n    if (!this.id)\n      throw new Error(\"parseId(): Presence message does not contain an id\");\n    const parts = this.id.split(\":\");\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10)\n    };\n  }\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    let data = this.data;\n    let encoding = this.encoding;\n    if (data && Platform.BufferUtils.isBuffer(data)) {\n      if (arguments.length > 0) {\n        encoding = encoding ? encoding + \"/base64\" : \"base64\";\n        data = Platform.BufferUtils.base64Encode(data);\n      } else {\n        data = Platform.BufferUtils.toBuffer(data);\n      }\n    }\n    return {\n      id: this.id,\n      clientId: this.clientId,\n      /* Convert presence action back to an int for sending to Ably */\n      action: toActionValue(this.action),\n      data,\n      encoding,\n      extras: this.extras\n    };\n  }\n  toString() {\n    let result = \"[PresenceMessage\";\n    result += \"; action=\" + this.action;\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.timestamp)\n      result += \"; timestamp=\" + this.timestamp;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.connectionId)\n      result += \"; connectionId=\" + this.connectionId;\n    if (this.encoding)\n      result += \"; encoding=\" + this.encoding;\n    if (this.data) {\n      if (typeof this.data == \"string\")\n        result += \"; data=\" + this.data;\n      else if (Platform.BufferUtils.isBuffer(this.data))\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(this.data);\n      else\n        result += \"; data (json)=\" + JSON.stringify(this.data);\n    }\n    if (this.extras) {\n      result += \"; extras=\" + JSON.stringify(this.extras);\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar presencemessage_default = PresenceMessage;\n\n// src/common/lib/client/restpresence.ts\nvar RestPresence = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  get logger() {\n    return this.channel.logger;\n  }\n  async get(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.get()\", \"channel = \" + this.channel.name);\n    const client = this.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    const options = this.channel.channelOptions;\n    return new paginatedresource_default(\n      client,\n      this.channel.client.rest.presenceMixin.basePath(this),\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        return await fromResponseBody2(\n          body,\n          options,\n          this.logger,\n          client._MsgPack,\n          unpacked ? void 0 : format\n        );\n      }\n    ).get(params);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.history()\", \"channel = \" + this.channel.name);\n    return this.channel.client.rest.presenceMixin.history(this, params);\n  }\n};\nvar restpresence_default = RestPresence;\n\n// src/common/lib/client/restchannel.ts\nvar MSG_ID_ENTROPY_BYTES = 9;\nfunction allEmptyIds(messages) {\n  return messages.every(function(message) {\n    return !message.id;\n  });\n}\nvar RestChannel = class {\n  constructor(client, name, channelOptions) {\n    var _a2, _b;\n    logger_default.logAction(client.logger, logger_default.LOG_MINOR, \"RestChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.client = client;\n    this.presence = new restpresence_default(this);\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, channelOptions);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  setOptions(options) {\n    var _a2;\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.history()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.history(this, params);\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null) {\n      messages = [fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    if (!params) {\n      params = {};\n    }\n    const client = this.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options, { format });\n    mixin(headers, options.headers);\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = await randomString(MSG_ID_ENTROPY_BYTES);\n      messages.forEach(function(message, index) {\n        message.id = msgIdBase + \":\" + index.toString();\n      });\n    }\n    await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(messages), maxMessageSize = options.maxMessageSize;\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        \"Maximum size of messages that can be published at once exceeded ( was \" + size + \" bytes; limit is \" + maxMessageSize + \" bytes)\",\n        40009,\n        400\n      );\n    }\n    await this._publish(serialize(messages, client._MsgPack, format), headers, params);\n  }\n  async _publish(requestBody, headers, params) {\n    await resource_default.post(\n      this.client,\n      this.client.rest.channelMixin.basePath(this) + \"/messages\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n};\nvar restchannel_default = RestChannel;\n\n// src/common/lib/types/stats.ts\nvar Stats = class _Stats {\n  constructor(values) {\n    this.entries = values && values.entries || void 0;\n    this.schema = values && values.schema || void 0;\n    this.appId = values && values.appId || void 0;\n    this.inProgress = values && values.inProgress || void 0;\n    this.unit = values && values.unit || void 0;\n    this.intervalId = values && values.intervalId || void 0;\n  }\n  static fromValues(values) {\n    return new _Stats(values);\n  }\n};\nvar stats_default = Stats;\n\n// src/common/lib/client/restchannelmixin.ts\nvar RestChannelMixin = class {\n  static basePath(channel) {\n    return \"/channels/\" + encodeURIComponent(channel.name);\n  }\n  static history(channel, params) {\n    const client = channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    const options = channel.channelOptions;\n    return new paginatedresource_default(client, this.basePath(channel) + \"/messages\", headers, envelope, async function(body, headers2, unpacked) {\n      return await fromResponseBody(\n        body,\n        options,\n        channel.logger,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  static async status(channel) {\n    const format = channel.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(channel.client.options, { format });\n    const response = await resource_default.get(\n      channel.client,\n      this.basePath(channel),\n      headers,\n      {},\n      format,\n      true\n    );\n    return response.body;\n  }\n};\n\n// src/common/lib/client/restpresencemixin.ts\nvar RestPresenceMixin = class {\n  static basePath(presence) {\n    return RestChannelMixin.basePath(presence.channel) + \"/presence\";\n  }\n  static async history(presence, params) {\n    const client = presence.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    const options = presence.channel.channelOptions;\n    return new paginatedresource_default(client, this.basePath(presence) + \"/history\", headers, envelope, async function(body, headers2, unpacked) {\n      return await fromResponseBody2(\n        body,\n        options,\n        presence.logger,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n};\n\n// src/common/lib/client/rest.ts\nvar Rest = class {\n  constructor(client) {\n    this.channelMixin = RestChannelMixin;\n    this.presenceMixin = RestPresenceMixin;\n    // exposed for plugins but shouldn't be bundled with minimal realtime\n    this.Resource = resource_default;\n    this.DeviceDetails = devicedetails_default;\n    this.client = client;\n    this.channels = new Channels(this.client);\n    this.push = new push_default(this.client);\n  }\n  async stats(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options), format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    mixin(headers, this.client.options.headers);\n    return new paginatedresource_default(this.client, \"/stats\", headers, envelope, function(body, headers2, unpacked) {\n      const statsValues = unpacked ? body : JSON.parse(body);\n      for (let i = 0; i < statsValues.length; i++)\n        statsValues[i] = stats_default.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params);\n  }\n  async time(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const timeUri = (host) => {\n      return this.client.baseUri(host) + \"/time\";\n    };\n    let { error, body, unpacked } = await this.client.http.do(\n      HttpMethods_default.Get,\n      timeUri,\n      headers,\n      null,\n      params\n    );\n    if (error) {\n      throw error;\n    }\n    if (!unpacked)\n      body = JSON.parse(body);\n    const time = body[0];\n    if (!time) {\n      throw new ErrorInfo(\"Internal error (unexpected result type from GET /time)\", 5e4, 500);\n    }\n    this.client.serverTimeOffset = time - Date.now();\n    return time;\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    var _a2;\n    const [encoder, decoder, format] = (() => {\n      if (this.client.options.useBinaryProtocol) {\n        if (!this.client._MsgPack) {\n          throwMissingPluginError(\"MsgPack\");\n        }\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, \"msgpack\" /* msgpack */];\n      } else {\n        return [JSON.stringify, JSON.parse, \"json\" /* json */];\n      }\n    })();\n    const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    params = params || {};\n    const _method = method.toLowerCase();\n    const headers = _method == \"get\" ? defaults_default.defaultGetHeaders(this.client.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.client.options, { format, protocolVersion: version2 });\n    if (typeof body !== \"string\") {\n      body = (_a2 = encoder(body)) != null ? _a2 : null;\n    }\n    mixin(headers, this.client.options.headers);\n    if (customHeaders) {\n      mixin(headers, customHeaders);\n    }\n    const paginatedResource = new paginatedresource_default(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function(resbody, headers2, unpacked) {\n        return ensureArray(unpacked ? resbody : decoder(resbody));\n      },\n      /* useHttpPaginatedResponse: */\n      true\n    );\n    if (!Platform.Http.methods.includes(_method)) {\n      throw new ErrorInfo(\"Unsupported method \" + _method, 40500, 405);\n    }\n    if (Platform.Http.methodsWithBody.includes(_method)) {\n      return paginatedResource[_method](params, body);\n    } else {\n      return paginatedResource[_method](params);\n    }\n  }\n  async batchPublish(specOrSpecs) {\n    let requestBodyDTO;\n    let singleSpecMode;\n    if (Array.isArray(specOrSpecs)) {\n      requestBodyDTO = specOrSpecs;\n      singleSpecMode = false;\n    } else {\n      requestBodyDTO = [specOrSpecs];\n      singleSpecMode = true;\n    }\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(this.client, \"/messages\", requestBody, headers, {}, null, true);\n    const batchResults = response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    if (singleSpecMode) {\n      return batchResults[0];\n    } else {\n      return batchResults;\n    }\n  }\n  async batchPresence(channels) {\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const channelsParam = channels.join(\",\");\n    const response = await resource_default.get(this.client, \"/presence\", headers, { channels: channelsParam }, null, true);\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n  async revokeTokens(specifiers, options) {\n    if (useTokenAuth(this.client.options)) {\n      throw new ErrorInfo(\"Cannot revoke tokens when using token auth\", 40162, 401);\n    }\n    const keyName = this.client.options.keyName;\n    let resolvedOptions = options != null ? options : {};\n    const requestBodyDTO = __spreadValues({\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`)\n    }, resolvedOptions);\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(\n      this.client,\n      `/keys/${keyName}/revokeTokens`,\n      requestBody,\n      headers,\n      {},\n      null,\n      true\n    );\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n};\nvar Channels = class {\n  constructor(client) {\n    this.client = client;\n    this.all = /* @__PURE__ */ Object.create(null);\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    delete this.all[String(name)];\n  }\n};\n\n// src/common/lib/client/baserest.ts\nvar BaseRest = class extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    super(defaults_default.objectifyOptions(options, false, \"BaseRest\", logger_default.defaultLogger, { Rest }));\n  }\n};\n\n// src/common/lib/client/modularplugins.ts\nvar allCommonModularPlugins = { Rest };\n\n// src/common/lib/types/defaultmessage.ts\nvar DefaultMessage = class extends message_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  // Used by tests\n  static fromValues(values) {\n    return Object.assign(new message_default(), values);\n  }\n  // Used by tests\n  static async encode(msg, options) {\n    return encode(msg, options);\n  }\n  // Used by tests\n  static async decode(message, inputContext) {\n    return decode(message, inputContext);\n  }\n};\n\n// src/common/lib/types/defaultpresencemessage.ts\nvar DefaultPresenceMessage = class extends presencemessage_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded2(logger_default.defaultLogger, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray2(logger_default.defaultLogger, encodedArray, options);\n  }\n  static fromValues(values, stringifyAction) {\n    return fromValues2(values, stringifyAction);\n  }\n};\n\n// src/common/lib/client/defaultrest.ts\nvar _DefaultRest = class _DefaultRest extends BaseRest {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2, _b;\n    const MsgPack = _DefaultRest._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRest._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Rest\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRest.Crypto) != null ? _a2 : void 0,\n        MsgPack: (_b = _DefaultRest._MsgPack) != null ? _b : void 0\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRest._Crypto = null;\n_DefaultRest.Message = DefaultMessage;\n_DefaultRest.PresenceMessage = DefaultPresenceMessage;\n_DefaultRest._MsgPack = null;\n// Used by tests\n_DefaultRest._Http = Http;\nvar DefaultRest = _DefaultRest;\n\n// src/common/lib/util/eventemitter.ts\nfunction callListener(logger, eventThis, listener, args) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_ERROR,\n      \"EventEmitter.emit()\",\n      \"Unexpected listener exception: \" + e + \"; stack = \" + (e && e.stack)\n    );\n  }\n}\nfunction removeListener(targetListeners, listener, eventFilter) {\n  let listeners;\n  let index;\n  let eventName;\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter];\n    }\n    if (Array.isArray(listeners)) {\n      while ((index = listeners.indexOf(listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (isObject(listeners)) {\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\nvar EventEmitter = class {\n  constructor(logger) {\n    this.logger = logger;\n    this.any = [];\n    this.events = /* @__PURE__ */ Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = /* @__PURE__ */ Object.create(null);\n  }\n  on(...args) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === \"function\") {\n        this.any.push(listener);\n      } else {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== \"function\") {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n      if (isNil(event)) {\n        this.any.push(listener);\n      } else if (Array.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== \"string\") {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n  off(...args) {\n    if (args.length == 0 || isNil(args[0]) && isNil(args[1])) {\n      this.any = [];\n      this.events = /* @__PURE__ */ Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = /* @__PURE__ */ Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener = null;\n    let event = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === \"function\") {\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n    } else {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n    if (listener && isNil(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n    if (Array.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n    if (typeof event !== \"string\") {\n      throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event])\n        Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event, ...args) {\n    const eventThis = { event };\n    const listeners = [];\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n    listeners.forEach((listener) => {\n      callListener(this.logger, eventThis, listener, args);\n    });\n  }\n  once(...args) {\n    const argCount = args.length;\n    if (argCount === 0 || argCount === 1 && typeof args[0] !== \"function\") {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event, resolve);\n      });\n    }\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === \"function\") {\n      this.anyOnce.push(firstArg);\n    } else if (isNil(firstArg)) {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Array.isArray(firstArg)) {\n      const self2 = this;\n      const listenerWrapper = function() {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        firstArg.forEach(function(eventName) {\n          self2.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      firstArg.forEach(function(eventName) {\n        self2.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== \"string\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n  /**\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   */\n  async whenState(targetState, currentState) {\n    if (typeof targetState !== \"string\" || typeof currentState !== \"string\") {\n      throw new Error(\"whenState requires a valid state String argument\");\n    }\n    if (targetState === currentState) {\n      return null;\n    } else {\n      return this.once(targetState);\n    }\n  }\n};\nvar eventemitter_default = EventEmitter;\n\n// src/common/lib/types/protocolmessage.ts\nvar actions2 = {\n  HEARTBEAT: 0,\n  ACK: 1,\n  NACK: 2,\n  CONNECT: 3,\n  CONNECTED: 4,\n  DISCONNECT: 5,\n  DISCONNECTED: 6,\n  CLOSE: 7,\n  CLOSED: 8,\n  ERROR: 9,\n  ATTACH: 10,\n  ATTACHED: 11,\n  DETACH: 12,\n  DETACHED: 13,\n  PRESENCE: 14,\n  MESSAGE: 15,\n  SYNC: 16,\n  AUTH: 17,\n  ACTIVATE: 18\n};\nvar ActionName = [];\nObject.keys(actions2).forEach(function(name) {\n  ActionName[actions2[name]] = name;\n});\nvar flags = {\n  /* Channel attach state flags */\n  HAS_PRESENCE: 1 << 0,\n  HAS_BACKLOG: 1 << 1,\n  RESUMED: 1 << 2,\n  TRANSIENT: 1 << 4,\n  ATTACH_RESUME: 1 << 5,\n  /* Channel mode flags */\n  PRESENCE: 1 << 16,\n  PUBLISH: 1 << 17,\n  SUBSCRIBE: 1 << 18,\n  PRESENCE_SUBSCRIBE: 1 << 19\n};\nvar flagNames = Object.keys(flags);\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\nfunction toStringArray(array) {\n  const result = [];\n  if (array) {\n    for (let i = 0; i < array.length; i++) {\n      result.push(array[i].toString());\n    }\n  }\n  return \"[ \" + result.join(\", \") + \" ]\";\n}\nvar channelModes = [\"PRESENCE\", \"PUBLISH\", \"SUBSCRIBE\", \"PRESENCE_SUBSCRIBE\"];\nvar serialize2 = encodeBody;\nfunction deserialize(serialized, MsgPack, presenceMessagePlugin, format) {\n  const deserialized = decodeBody(serialized, MsgPack, format);\n  return fromDeserialized(deserialized, presenceMessagePlugin);\n}\nfunction fromDeserialized(deserialized, presenceMessagePlugin) {\n  const error = deserialized.error;\n  if (error)\n    deserialized.error = ErrorInfo.fromValues(error);\n  const messages = deserialized.messages;\n  if (messages)\n    for (let i = 0; i < messages.length; i++)\n      messages[i] = fromValues(messages[i]);\n  const presence = presenceMessagePlugin ? deserialized.presence : void 0;\n  if (presenceMessagePlugin) {\n    if (presence && presenceMessagePlugin)\n      for (let i = 0; i < presence.length; i++)\n        presence[i] = presenceMessagePlugin.presenceMessageFromValues(presence[i], true);\n  }\n  return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), { presence }));\n}\nfunction fromDeserializedIncludingDependencies(deserialized) {\n  return fromDeserialized(deserialized, { presenceMessageFromValues: fromValues2, presenceMessagesFromValuesArray: fromValuesArray2 });\n}\nfunction fromValues3(values) {\n  return Object.assign(new ProtocolMessage(), values);\n}\nfunction stringify(msg, presenceMessagePlugin) {\n  let result = \"[ProtocolMessage\";\n  if (msg.action !== void 0)\n    result += \"; action=\" + ActionName[msg.action] || 0;\n  const simpleAttributes = [\"id\", \"channel\", \"channelSerial\", \"connectionId\", \"count\", \"msgSerial\", \"timestamp\"];\n  let attribute;\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n    attribute = simpleAttributes[attribIndex];\n    if (msg[attribute] !== void 0)\n      result += \"; \" + attribute + \"=\" + msg[attribute];\n  }\n  if (msg.messages)\n    result += \"; messages=\" + toStringArray(fromValuesArray(msg.messages));\n  if (msg.presence && presenceMessagePlugin)\n    result += \"; presence=\" + toStringArray(presenceMessagePlugin.presenceMessagesFromValuesArray(msg.presence));\n  if (msg.error)\n    result += \"; error=\" + ErrorInfo.fromValues(msg.error).toString();\n  if (msg.auth && msg.auth.accessToken)\n    result += \"; token=\" + msg.auth.accessToken;\n  if (msg.flags)\n    result += \"; flags=\" + flagNames.filter(msg.hasFlag).join(\",\");\n  if (msg.params) {\n    let stringifiedParams = \"\";\n    forInOwnNonNullProperties(msg.params, function(prop) {\n      if (stringifiedParams.length > 0) {\n        stringifiedParams += \"; \";\n      }\n      stringifiedParams += prop + \"=\" + msg.params[prop];\n    });\n    if (stringifiedParams.length > 0) {\n      result += \"; params=[\" + stringifiedParams + \"]\";\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar ProtocolMessage = class {\n  constructor() {\n    this.hasFlag = (flag) => {\n      return (this.flags & flags[flag]) > 0;\n    };\n  }\n  setFlag(flag) {\n    return this.flags = this.flags | flags[flag];\n  }\n  getMode() {\n    return this.flags && this.flags & flags.MODE_ALL;\n  }\n  encodeModesToFlags(modes) {\n    modes.forEach((mode) => this.setFlag(mode));\n  }\n  decodeModesFromFlags() {\n    const modes = [];\n    channelModes.forEach((mode) => {\n      if (this.hasFlag(mode)) {\n        modes.push(mode);\n      }\n    });\n    return modes.length > 0 ? modes : void 0;\n  }\n};\nvar protocolmessage_default = ProtocolMessage;\n\n// src/common/lib/transport/messagequeue.ts\nvar MessageQueue = class extends eventemitter_default {\n  constructor(logger) {\n    super(logger);\n    this.messages = [];\n  }\n  count() {\n    return this.messages.length;\n  }\n  push(message) {\n    this.messages.push(message);\n  }\n  shift() {\n    return this.messages.shift();\n  }\n  last() {\n    return this.messages[this.messages.length - 1];\n  }\n  copyAll() {\n    return this.messages.slice();\n  }\n  append(messages) {\n    this.messages.push.apply(this.messages, messages);\n  }\n  prepend(messages) {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n  completeMessages(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.completeMessages()\",\n      \"serial = \" + serial + \"; count = \" + count\n    );\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error(\"MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue\");\n    }\n    const first = messages[0];\n    if (first) {\n      const startSerial = first.message.msgSerial;\n      const endSerial = serial + count;\n      if (endSerial > startSerial) {\n        const completeMessages = messages.splice(0, endSerial - startSerial);\n        for (const message of completeMessages) {\n          message.callback(err);\n        }\n      }\n      if (messages.length == 0)\n        this.emit(\"idle\");\n    }\n  }\n  completeAllMessages(err) {\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n  }\n  resetSendAttempted() {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n  clear() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.clear()\",\n      \"clearing \" + this.messages.length + \" messages\"\n    );\n    this.messages = [];\n    this.emit(\"idle\");\n  }\n};\nvar messagequeue_default = MessageQueue;\n\n// src/common/lib/transport/protocol.ts\nvar PendingMessage = class {\n  constructor(message, callback) {\n    this.message = message;\n    this.callback = callback;\n    this.merged = false;\n    const action = message.action;\n    this.sendAttempted = false;\n    this.ackRequired = action == actions2.MESSAGE || action == actions2.PRESENCE;\n  }\n};\nvar Protocol = class extends eventemitter_default {\n  constructor(transport) {\n    super(transport.logger);\n    this.transport = transport;\n    this.messageQueue = new messagequeue_default(this.logger);\n    transport.on(\"ack\", (serial, count) => {\n      this.onAck(serial, count);\n    });\n    transport.on(\"nack\", (serial, count, err) => {\n      this.onNack(serial, count, err);\n    });\n  }\n  onAck(serial, count) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"Protocol.onAck()\", \"serial = \" + serial + \"; count = \" + count);\n    this.messageQueue.completeMessages(serial, count);\n  }\n  onNack(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_ERROR,\n      \"Protocol.onNack()\",\n      \"serial = \" + serial + \"; count = \" + count + \"; err = \" + inspectError(err)\n    );\n    if (!err) {\n      err = new ErrorInfo(\"Unable to send message; channel not responding\", 50001, 500);\n    }\n    this.messageQueue.completeMessages(serial, count, err);\n  }\n  onceIdle(listener) {\n    const messageQueue = this.messageQueue;\n    if (messageQueue.count() === 0) {\n      listener();\n      return;\n    }\n    messageQueue.once(\"idle\", listener);\n  }\n  send(pendingMessage) {\n    if (pendingMessage.ackRequired) {\n      this.messageQueue.push(pendingMessage);\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Protocol.send()\",\n        \"sending msg; \" + stringify(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence)\n      );\n    }\n    pendingMessage.sendAttempted = true;\n    this.transport.send(pendingMessage.message);\n  }\n  getTransport() {\n    return this.transport;\n  }\n  getPendingMessages() {\n    return this.messageQueue.copyAll();\n  }\n  clearPendingMessages() {\n    return this.messageQueue.clear();\n  }\n  finish() {\n    const transport = this.transport;\n    this.onceIdle(function() {\n      transport.disconnect();\n    });\n  }\n};\nvar protocol_default = Protocol;\n\n// src/common/lib/client/connectionstatechange.ts\nvar ConnectionStateChange = class {\n  constructor(previous, current, retryIn, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn)\n      this.retryIn = retryIn;\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar connectionstatechange_default = ConnectionStateChange;\n\n// src/common/lib/transport/connectionerrors.ts\nvar ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 8e4,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001\n};\nvar ConnectionErrors = {\n  disconnected: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.DISCONNECTED,\n    message: \"Connection to server temporarily unavailable\"\n  }),\n  suspended: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.SUSPENDED,\n    message: \"Connection to server unavailable\"\n  }),\n  failed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.FAILED,\n    message: \"Connection failed or disconnected by server\"\n  }),\n  closing: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSING,\n    message: \"Connection closing\"\n  }),\n  closed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSED,\n    message: \"Connection closed\"\n  }),\n  unknownConnectionErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal connection error\"\n  }),\n  unknownChannelErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal channel error\"\n  })\n};\nfunction isRetriable(err) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\nvar connectionerrors_default = ConnectionErrors;\n\n// src/common/lib/transport/transport.ts\nvar closeMessage = fromValues3({ action: actions2.CLOSE });\nvar disconnectMessage = fromValues3({ action: actions2.DISCONNECT });\nvar Transport = class extends eventemitter_default {\n  constructor(connectionManager, auth, params, forceJsonProtocol) {\n    super(connectionManager.logger);\n    if (forceJsonProtocol) {\n      params.format = void 0;\n      params.heartbeats = true;\n    }\n    this.connectionManager = connectionManager;\n    this.auth = auth;\n    this.params = params;\n    this.timeouts = params.options.timeouts;\n    this.format = params.format;\n    this.isConnected = false;\n    this.isFinished = false;\n    this.isDisposed = false;\n    this.maxIdleInterval = null;\n    this.idleTimer = null;\n    this.lastActivity = null;\n  }\n  connect() {\n  }\n  close() {\n    if (this.isConnected) {\n      this.requestClose();\n    }\n    this.finish(\"closed\", connectionerrors_default.closed());\n  }\n  disconnect(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"disconnected\", err || connectionerrors_default.disconnected());\n  }\n  fail(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"failed\", err || connectionerrors_default.failed());\n  }\n  finish(event, err) {\n    var _a2;\n    if (this.isFinished) {\n      return;\n    }\n    this.isFinished = true;\n    this.isConnected = false;\n    this.maxIdleInterval = null;\n    clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);\n    this.idleTimer = null;\n    this.emit(event, err);\n    this.dispose();\n  }\n  onProtocolMessage(message) {\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Transport.onProtocolMessage()\",\n        \"received on \" + this.shortName + \": \" + stringify(message, this.connectionManager.realtime._RealtimePresence) + \"; connectionId = \" + this.connectionManager.connectionId\n      );\n    }\n    this.onActivity();\n    switch (message.action) {\n      case actions2.HEARTBEAT:\n        logger_default.logActionNoStrip(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Transport.onProtocolMessage()\",\n          this.shortName + \" heartbeat; connectionId = \" + this.connectionManager.connectionId\n        );\n        this.emit(\"heartbeat\", message.id);\n        break;\n      case actions2.CONNECTED:\n        this.onConnect(message);\n        this.emit(\"connected\", message.error, message.connectionId, message.connectionDetails, message);\n        break;\n      case actions2.CLOSED:\n        this.onClose(message);\n        break;\n      case actions2.DISCONNECTED:\n        this.onDisconnect(message);\n        break;\n      case actions2.ACK:\n        this.emit(\"ack\", message.msgSerial, message.count);\n        break;\n      case actions2.NACK:\n        this.emit(\"nack\", message.msgSerial, message.count, message.error);\n        break;\n      case actions2.SYNC:\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      case actions2.ACTIVATE:\n        break;\n      case actions2.AUTH:\n        whenPromiseSettles(this.auth.authorize(), (err) => {\n          if (err) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Transport.onProtocolMessage()\",\n              \"Ably requested re-authentication, but unable to obtain a new token: \" + inspectError(err)\n            );\n          }\n        });\n        break;\n      case actions2.ERROR:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Transport.onProtocolMessage()\",\n          \"received error action; connectionId = \" + this.connectionManager.connectionId + \"; err = \" + Platform.Config.inspect(message.error) + (message.channel ? \", channel: \" + message.channel : \"\")\n        );\n        if (message.channel === void 0) {\n          this.onFatalError(message);\n          break;\n        }\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      default:\n        this.connectionManager.onChannelMessage(message, this);\n    }\n  }\n  onConnect(message) {\n    this.isConnected = true;\n    if (!message.connectionDetails) {\n      throw new Error(\"Transport.onConnect(): Connect message recieved without connectionDetails\");\n    }\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n    if (maxPromisedIdle) {\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n      this.onActivity();\n    }\n  }\n  onDisconnect(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onDisconnect()\", \"err = \" + inspectError(err));\n    this.finish(\"disconnected\", err);\n  }\n  onFatalError(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onFatalError()\", \"err = \" + inspectError(err));\n    this.finish(\"failed\", err);\n  }\n  onClose(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onClose()\", \"err = \" + inspectError(err));\n    this.finish(\"closed\", err);\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestClose()\", \"\");\n    this.send(closeMessage);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestDisconnect()\", \"\");\n    this.send(disconnectMessage);\n  }\n  ping(id) {\n    const msg = { action: actions2.HEARTBEAT };\n    if (id)\n      msg.id = id;\n    this.send(fromValues3(msg));\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.dispose()\", \"\");\n    this.isDisposed = true;\n    this.off();\n  }\n  onActivity() {\n    if (!this.maxIdleInterval) {\n      return;\n    }\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\n    this.setIdleTimer(this.maxIdleInterval + 100);\n  }\n  setIdleTimer(timeout) {\n    if (!this.idleTimer) {\n      this.idleTimer = setTimeout(() => {\n        this.onIdleTimerExpire();\n      }, timeout);\n    }\n  }\n  onIdleTimerExpire() {\n    if (!this.lastActivity || !this.maxIdleInterval) {\n      throw new Error(\"Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set\");\n    }\n    this.idleTimer = null;\n    const sinceLast = Date.now() - this.lastActivity;\n    const timeRemaining = this.maxIdleInterval - sinceLast;\n    if (timeRemaining <= 0) {\n      const msg = \"No activity seen from realtime in \" + sinceLast + \"ms; assuming connection has dropped\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Transport.onIdleTimerExpire()\", msg);\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\n    } else {\n      this.setIdleTimer(timeRemaining + 100);\n    }\n  }\n  static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {\n    const transport = new transportCtor(connectionManager, auth, transportParams);\n    let transportAttemptTimer;\n    const errorCb = function(err) {\n      clearTimeout(transportAttemptTimer);\n      callback({ event: this.event, error: err });\n    };\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n    transportAttemptTimer = setTimeout(() => {\n      transport.off([\"preconnect\", \"disconnected\", \"failed\"]);\n      transport.dispose();\n      errorCb.call(\n        { event: \"disconnected\" },\n        new ErrorInfo(\"Timeout waiting for transport to indicate itself viable\", 5e4, 500)\n      );\n    }, realtimeRequestTimeout);\n    transport.on([\"failed\", \"disconnected\"], errorCb);\n    transport.on(\"preconnect\", function() {\n      logger_default.logAction(\n        connectionManager.logger,\n        logger_default.LOG_MINOR,\n        \"Transport.tryConnect()\",\n        \"viable transport \" + transport\n      );\n      clearTimeout(transportAttemptTimer);\n      transport.off([\"failed\", \"disconnected\"], errorCb);\n      callback(null, transport);\n    });\n    transport.connect();\n    return transport;\n  }\n  static isAvailable() {\n    throw new ErrorInfo(\"isAvailable not implemented for transport\", 5e4, 500);\n  }\n};\nvar transport_default = Transport;\n\n// src/common/constants/TransportName.ts\nvar TransportNames;\n((TransportNames2) => {\n  TransportNames2.WebSocket = \"web_socket\";\n  TransportNames2.Comet = \"comet\";\n  TransportNames2.XhrPolling = \"xhr_polling\";\n})(TransportNames || (TransportNames = {}));\n\n// src/common/lib/transport/connectionmanager.ts\nvar globalObject2 = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\nvar haveWebStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);\n};\nvar haveSessionStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);\n};\nvar noop = function() {\n};\nvar transportPreferenceName = \"ably-transport-preference\";\nfunction bundleWith(dest, src, maxSize) {\n  let action;\n  if (dest.channel !== src.channel) {\n    return false;\n  }\n  if ((action = dest.action) !== actions2.PRESENCE && action !== actions2.MESSAGE) {\n    return false;\n  }\n  if (action !== src.action) {\n    return false;\n  }\n  const kind = action === actions2.PRESENCE ? \"presence\" : \"messages\", proposed = dest[kind].concat(src[kind]), size = getMessagesSize(proposed);\n  if (size > maxSize) {\n    return false;\n  }\n  if (!allSame(proposed, \"clientId\")) {\n    return false;\n  }\n  if (!proposed.every(function(msg) {\n    return !msg.id;\n  })) {\n    return false;\n  }\n  dest[kind] = proposed;\n  return true;\n}\nfunction decodeRecoveryKey(recoveryKey) {\n  try {\n    return JSON.parse(recoveryKey);\n  } catch (e) {\n    return null;\n  }\n}\nvar TransportParams = class {\n  constructor(options, host, mode, connectionKey) {\n    this.options = options;\n    this.host = host;\n    this.mode = mode;\n    this.connectionKey = connectionKey;\n    this.format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n  }\n  getConnectParams(authParams) {\n    const params = authParams ? copy(authParams) : {};\n    const options = this.options;\n    switch (this.mode) {\n      case \"resume\":\n        params.resume = this.connectionKey;\n        break;\n      case \"recover\": {\n        const recoveryContext = decodeRecoveryKey(options.recover);\n        if (recoveryContext) {\n          params.recover = recoveryContext.connectionKey;\n        }\n        break;\n      }\n      default:\n    }\n    if (options.clientId !== void 0) {\n      params.clientId = options.clientId;\n    }\n    if (options.echoMessages === false) {\n      params.echo = \"false\";\n    }\n    if (this.format !== void 0) {\n      params.format = this.format;\n    }\n    if (this.stream !== void 0) {\n      params.stream = this.stream;\n    }\n    if (this.heartbeats !== void 0) {\n      params.heartbeats = this.heartbeats;\n    }\n    params.v = defaults_default.protocolVersion;\n    params.agent = getAgentString(this.options);\n    if (options.transportParams !== void 0) {\n      mixin(params, options.transportParams);\n    }\n    return params;\n  }\n  toString() {\n    let result = \"[mode=\" + this.mode;\n    if (this.host) {\n      result += \",host=\" + this.host;\n    }\n    if (this.connectionKey) {\n      result += \",connectionKey=\" + this.connectionKey;\n    }\n    if (this.format) {\n      result += \",format=\" + this.format;\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar ConnectionManager = class _ConnectionManager extends eventemitter_default {\n  constructor(realtime, options) {\n    super(realtime.logger);\n    this.supportedTransports = {};\n    this.disconnectedRetryCount = 0;\n    this.pendingChannelMessagesState = { isProcessing: false, queue: [] };\n    this.realtime = realtime;\n    this.initTransports();\n    this.options = options;\n    const timeouts = options.timeouts;\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n    this.states = {\n      initialized: {\n        state: \"initialized\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        failState: \"disconnected\"\n      },\n      connecting: {\n        state: \"connecting\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: connectingTimeout,\n        failState: \"disconnected\"\n      },\n      connected: {\n        state: \"connected\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: true,\n        failState: \"disconnected\"\n      },\n      disconnected: {\n        state: \"disconnected\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: timeouts.disconnectedRetryTimeout,\n        failState: \"disconnected\"\n      },\n      suspended: {\n        state: \"suspended\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.suspendedRetryTimeout,\n        failState: \"suspended\"\n      },\n      closing: {\n        state: \"closing\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.realtimeRequestTimeout,\n        failState: \"closed\"\n      },\n      closed: { state: \"closed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"closed\" },\n      failed: { state: \"failed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"failed\" }\n    };\n    this.state = this.states.initialized;\n    this.errorReason = null;\n    this.queuedMessages = new messagequeue_default(this.logger);\n    this.msgSerial = 0;\n    this.connectionDetails = void 0;\n    this.connectionId = void 0;\n    this.connectionKey = void 0;\n    this.connectionStateTtl = timeouts.connectionStateTtl;\n    this.maxIdleInterval = null;\n    this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);\n    this.transportPreference = null;\n    if (this.transports.includes(TransportNames.WebSocket)) {\n      this.webSocketTransportAvailable = true;\n    }\n    if (this.transports.includes(TransportNames.XhrPolling)) {\n      this.baseTransport = TransportNames.XhrPolling;\n    } else if (this.transports.includes(TransportNames.Comet)) {\n      this.baseTransport = TransportNames.Comet;\n    }\n    this.httpHosts = defaults_default.getHosts(options);\n    this.wsHosts = defaults_default.getHosts(options, true);\n    this.activeProtocol = null;\n    this.host = null;\n    this.lastAutoReconnectAttempt = null;\n    this.lastActivity = null;\n    this.forceFallbackHost = false;\n    this.connectCounter = 0;\n    this.wsCheckResult = null;\n    this.webSocketSlowTimer = null;\n    this.webSocketGiveUpTimer = null;\n    this.abandonedWebSocket = false;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.ConnectionManager()\", \"started\");\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"requested transports = [\" + (options.transports || defaults_default.defaultTransports) + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"available transports = [\" + this.transports + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"http hosts = [\" + this.httpHosts + \"]\"\n    );\n    if (!this.transports.length) {\n      const msg = \"no requested transports available\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"realtime.ConnectionManager()\", msg);\n      throw new Error(msg);\n    }\n    const addEventListener = Platform.Config.addEventListener;\n    if (addEventListener) {\n      if (haveSessionStorage() && typeof options.recover === \"function\") {\n        addEventListener(\"beforeunload\", this.persistConnection.bind(this));\n      }\n      if (options.closeOnUnload === true) {\n        addEventListener(\"beforeunload\", () => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"Realtime.ConnectionManager()\",\n            \"beforeunload event has triggered the connection to close as closeOnUnload is true\"\n          );\n          this.requestState({ state: \"closing\" });\n        });\n      }\n      addEventListener(\"online\", () => {\n        var _a2;\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018online\\u2019 event\",\n            \"reattempting connection\"\n          );\n          this.requestState({ state: \"connecting\" });\n        } else if (this.state == this.states.connecting) {\n          (_a2 = this.pendingTransport) == null ? void 0 : _a2.off();\n          this.disconnectAllTransports();\n          this.startConnect();\n        }\n      });\n      addEventListener(\"offline\", () => {\n        if (this.state == this.states.connected) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018offline\\u2019 event\",\n            \"disconnecting active transport\"\n          );\n          this.disconnectAllTransports();\n        }\n      });\n    }\n  }\n  /*********************\n   * transport management\n   *********************/\n  // Used by tests\n  static supportedTransports(additionalImplementations) {\n    const storage = { supportedTransports: {} };\n    this.initTransports(additionalImplementations, storage);\n    return storage.supportedTransports;\n  }\n  static initTransports(additionalImplementations, storage) {\n    const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\n      const transport = implementations[transportName];\n      if (transport && transport.isAvailable()) {\n        storage.supportedTransports[transportName] = transport;\n      }\n    });\n  }\n  initTransports() {\n    _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n  }\n  createTransportParams(host, mode) {\n    return new TransportParams(this.options, host, mode, this.connectionKey);\n  }\n  getTransportParams(callback) {\n    const decideMode = (modeCb) => {\n      if (this.connectionKey) {\n        modeCb(\"resume\");\n        return;\n      }\n      if (typeof this.options.recover === \"string\") {\n        modeCb(\"recover\");\n        return;\n      }\n      const recoverFn = this.options.recover, lastSessionData = this.getSessionRecoverData(), sessionRecoveryName = this.sessionRecoveryName();\n      if (lastSessionData && typeof recoverFn === \"function\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Calling clientOptions-provided recover function with last session data (recovery scope: \" + sessionRecoveryName + \")\"\n        );\n        recoverFn(lastSessionData, (shouldRecover) => {\n          if (shouldRecover) {\n            this.options.recover = lastSessionData.recoveryKey;\n            modeCb(\"recover\");\n          } else {\n            modeCb(\"clean\");\n          }\n        });\n        return;\n      }\n      modeCb(\"clean\");\n    };\n    decideMode((mode) => {\n      const transportParams = this.createTransportParams(null, mode);\n      if (mode === \"recover\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport recovery mode = recover; recoveryKey = \" + this.options.recover\n        );\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\n        if (recoveryContext) {\n          this.msgSerial = recoveryContext.msgSerial;\n        }\n      } else {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport params = \" + transportParams.toString()\n        );\n      }\n      callback(transportParams);\n    });\n  }\n  /**\n   * Attempt to connect using a given transport\n   * @param transportParams\n   * @param candidate, the transport to try\n   * @param callback\n   */\n  tryATransport(transportParams, candidate, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"trying \" + candidate);\n    this.proposedTransport = transport_default.tryConnect(\n      this.supportedTransports[candidate],\n      this,\n      this.realtime.auth,\n      transportParams,\n      (wrappedErr, transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager.tryATransport()\",\n              \"connection \" + state.state + \" while we were attempting the transport; closing \" + transport\n            );\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n        if (wrappedErr) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.tryATransport()\",\n            \"transport \" + candidate + \" \" + wrappedErr.event + \", err: \" + wrappedErr.error.toString()\n          );\n          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {\n            this.errorReason = wrappedErr.error;\n            whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err) => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === \"failed\") {\n            this.notifyState({ state: \"failed\", error: wrappedErr.error });\n            callback(true);\n          } else if (wrappedErr.event === \"disconnected\") {\n            if (!isRetriable(wrappedErr.error)) {\n              this.notifyState({ state: this.states.connecting.failState, error: wrappedErr.error });\n              callback(true);\n            } else {\n              callback(false);\n            }\n          }\n          return;\n        }\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.tryATransport()\",\n          \"viable transport \" + candidate + \"; setting pending\"\n        );\n        this.setTransportPending(transport, transportParams);\n        callback(null, transport);\n      }\n    );\n  }\n  /**\n   * Called when a transport is indicated to be viable, and the ConnectionManager\n   * expects to activate this transport as soon as it is connected.\n   * @param transport\n   * @param transportParams\n   */\n  setTransportPending(transport, transportParams) {\n    const mode = transportParams.mode;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.setTransportPending()\",\n      \"transport = \" + transport + \"; mode = \" + mode\n    );\n    this.pendingTransport = transport;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    transport.once(\"connected\", (error, connectionId, connectionDetails) => {\n      this.activateTransport(error, transport, connectionId, connectionDetails);\n      if (mode === \"recover\" && this.options.recover) {\n        delete this.options.recover;\n        this.unpersistConnection();\n      }\n    });\n    const self2 = this;\n    transport.on([\"disconnected\", \"closed\", \"failed\"], function(error) {\n      self2.deactivateTransport(transport, this.event, error);\n    });\n    this.emit(\"transport.pending\", transport);\n  }\n  /**\n   * Called when a transport is connected, and the connectionmanager decides that\n   * it will now be the active transport. Returns whether or not it activated\n   * the transport (if the connection is closing/closed it will choose not to).\n   * @param transport the transport instance\n   * @param connectionId the id of the new active connection\n   * @param connectionDetails the details of the new active connection\n   */\n  activateTransport(error, transport, connectionId, connectionDetails) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"transport = \" + transport\n    );\n    if (error) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"error = \" + error);\n    }\n    if (connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionId =  \" + connectionId\n      );\n    }\n    if (connectionDetails) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionDetails =  \" + JSON.stringify(connectionDetails)\n      );\n    }\n    this.persistTransportPreference(transport);\n    const existingState = this.state, connectedState = this.states.connected.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"current state = \" + existingState.state\n    );\n    if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Disconnecting transport and abandoning\"\n      );\n      transport.disconnect();\n      return false;\n    }\n    delete this.pendingTransport;\n    if (!transport.isConnected) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Declining to activate transport \" + transport + \" since it appears to no longer be connected\"\n      );\n      return false;\n    }\n    const existingActiveProtocol = this.activeProtocol;\n    this.activeProtocol = new protocol_default(transport);\n    this.host = transport.params.host;\n    const connectionKey = connectionDetails.connectionKey;\n    if (connectionKey && this.connectionKey != connectionKey) {\n      this.setConnection(connectionId, connectionDetails, !!error);\n    }\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\n    Platform.Config.nextTick(() => {\n      transport.on(\n        \"connected\",\n        (connectedErr, _connectionId, connectionDetails2) => {\n          this.onConnectionDetailsUpdate(connectionDetails2, transport);\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));\n        }\n      );\n    });\n    if (existingState.state === this.states.connected.state) {\n      if (error) {\n        this.errorReason = this.realtime.connection.errorReason = error;\n        this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, error));\n      }\n    } else {\n      this.notifyState({ state: \"connected\", error });\n      this.errorReason = this.realtime.connection.errorReason = error || null;\n    }\n    this.emit(\"transport.active\", transport);\n    if (existingActiveProtocol) {\n      if (existingActiveProtocol.messageQueue.count() > 0) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.activateTransport()\",\n          \"Previous active protocol (for transport \" + existingActiveProtocol.transport.shortName + \", new one is \" + transport.shortName + \") finishing with \" + existingActiveProtocol.messageQueue.count() + \" messages still pending\"\n        );\n      }\n      if (existingActiveProtocol.transport === transport) {\n        const msg = \"Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = \" + transport.shortName + \"; stack = \" + new Error().stack;\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", msg);\n      } else {\n        existingActiveProtocol.finish();\n      }\n    }\n    return true;\n  }\n  /**\n   * Called when a transport is no longer the active transport. This can occur\n   * in any transport connection state.\n   * @param transport\n   */\n  deactivateTransport(transport, state, error) {\n    const currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = transport === this.pendingTransport, noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"transport = \" + transport\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"state = \" + state + (wasActive ? \"; was active\" : wasPending ? \"; was pending\" : \"\") + (noTransportsScheduledForActivation ? \"\" : \"; another transport is scheduled for activation\")\n    );\n    if (error && error.message)\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"reason =  \" + error.message\n      );\n    if (wasActive) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"Getting, clearing, and requeuing \" + this.activeProtocol.messageQueue.count() + \" pending messages\"\n      );\n      this.queuePendingMessages(currentProtocol.getPendingMessages());\n      currentProtocol.clearPendingMessages();\n      this.activeProtocol = this.host = null;\n    }\n    this.emit(\"transport.inactive\", transport);\n    if (wasActive && noTransportsScheduledForActivation || wasActive && state === \"failed\" || state === \"closed\" || currentProtocol === null && wasPending) {\n      if (state === \"disconnected\" && error && error.statusCode > 500 && this.httpHosts.length > 1) {\n        this.unpersistTransportPreference();\n        this.forceFallbackHost = true;\n        this.notifyState({ state, error, retryImmediately: true });\n        return;\n      }\n      const newConnectionState = state === \"failed\" && auth_default.isTokenErr(error) ? \"disconnected\" : state;\n      this.notifyState({ state: newConnectionState, error });\n      return;\n    }\n  }\n  /* Helper that returns true if there are no transports which are pending,\n   * have been connected, and are just waiting for onceNoPending to fire before\n   * being activated */\n  noTransportsScheduledForActivation() {\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\n  }\n  setConnection(connectionId, connectionDetails, hasConnectionError) {\n    const prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;\n    if (connIdChanged || recoverFailure) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"Resetting msgSerial\");\n      this.msgSerial = 0;\n      this.queuedMessages.resetSendAttempted();\n    }\n    if (this.connectionId !== connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.setConnection()\",\n        \"New connectionId; reattaching any attached channels\"\n      );\n    }\n    this.realtime.connection.id = this.connectionId = connectionId;\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n  }\n  clearConnection() {\n    this.realtime.connection.id = this.connectionId = void 0;\n    this.realtime.connection.key = this.connectionKey = void 0;\n    this.msgSerial = 0;\n    this.unpersistConnection();\n  }\n  createRecoveryKey() {\n    if (!this.connectionKey) {\n      return null;\n    }\n    return JSON.stringify({\n      connectionKey: this.connectionKey,\n      msgSerial: this.msgSerial,\n      channelSerials: this.realtime.channels.channelSerials()\n    });\n  }\n  checkConnectionStateFreshness() {\n    if (!this.lastActivity || !this.connectionId) {\n      return;\n    }\n    const sinceLast = Date.now() - this.lastActivity;\n    if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.checkConnectionStateFreshness()\",\n        \"Last known activity from realtime was \" + sinceLast + \"ms ago; discarding connection state\"\n      );\n      this.clearConnection();\n      this.states.connecting.failState = \"suspended\";\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  persistConnection() {\n    if (haveSessionStorage()) {\n      const recoveryKey = this.createRecoveryKey();\n      if (recoveryKey) {\n        this.setSessionRecoverData({\n          recoveryKey,\n          disconnectedAt: Date.now(),\n          location: globalObject2.location,\n          clientId: this.realtime.auth.clientId\n        });\n      }\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  unpersistConnection() {\n    this.clearSessionRecoverData();\n  }\n  /*********************\n   * state management\n   *********************/\n  getError() {\n    if (this.errorReason) {\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\n      newError.cause = this.errorReason;\n      return newError;\n    }\n    return this.getStateError();\n  }\n  getStateError() {\n    var _a2, _b;\n    return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);\n  }\n  activeState() {\n    return this.state.queueEvents || this.state.sendEvents;\n  }\n  enactStateChange(stateChange) {\n    const action = \"Connection state\";\n    const message = stateChange.current + (stateChange.reason ? \"; reason: \" + stateChange.reason : \"\");\n    if (stateChange.current === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.enactStateChange\",\n      \"setting new state: \" + stateChange.current + \"; reason = \" + (stateChange.reason && stateChange.reason.message)\n    );\n    const newState = this.state = this.states[stateChange.current];\n    if (stateChange.reason) {\n      this.errorReason = stateChange.reason;\n      this.realtime.connection.errorReason = stateChange.reason;\n    }\n    if (newState.terminal || newState.state === \"suspended\") {\n      this.clearConnection();\n    }\n    this.emit(\"connectionstate\", stateChange);\n  }\n  /****************************************\n   * ConnectionManager connection lifecycle\n   ****************************************/\n  startTransitionTimer(transitionState) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.startTransitionTimer()\",\n      \"transitionState: \" + transitionState.state\n    );\n    if (this.transitionTimer) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startTransitionTimer()\",\n        \"clearing already-running timer\"\n      );\n      clearTimeout(this.transitionTimer);\n    }\n    this.transitionTimer = setTimeout(() => {\n      if (this.transitionTimer) {\n        this.transitionTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager \" + transitionState.state + \" timer expired\",\n          \"requesting new state: \" + transitionState.failState\n        );\n        this.notifyState({ state: transitionState.failState });\n      }\n    }, transitionState.retryDelay);\n  }\n  cancelTransitionTimer() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.cancelTransitionTimer()\", \"\");\n    if (this.transitionTimer) {\n      clearTimeout(this.transitionTimer);\n      this.transitionTimer = null;\n    }\n  }\n  startSuspendTimer() {\n    if (this.suspendTimer)\n      return;\n    this.suspendTimer = setTimeout(() => {\n      if (this.suspendTimer) {\n        this.suspendTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager suspend timer expired\",\n          \"requesting new state: suspended\"\n        );\n        this.states.connecting.failState = \"suspended\";\n        this.notifyState({ state: \"suspended\" });\n      }\n    }, this.connectionStateTtl);\n  }\n  checkSuspendTimer(state) {\n    if (state !== \"disconnected\" && state !== \"suspended\" && state !== \"connecting\")\n      this.cancelSuspendTimer();\n  }\n  cancelSuspendTimer() {\n    this.states.connecting.failState = \"disconnected\";\n    if (this.suspendTimer) {\n      clearTimeout(this.suspendTimer);\n      this.suspendTimer = null;\n    }\n  }\n  startRetryTimer(interval) {\n    this.retryTimer = setTimeout(() => {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager retry timer expired\", \"retrying\");\n      this.retryTimer = null;\n      this.requestState({ state: \"connecting\" });\n    }, interval);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  startWebSocketSlowTimer() {\n    this.webSocketSlowTimer = setTimeout(() => {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager WebSocket slow timer\",\n        \"checking connectivity\"\n      );\n      if (this.wsCheckResult === null) {\n        this.checkWsConnectivity().then(() => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager WebSocket slow timer\",\n            \"ws connectivity check succeeded\"\n          );\n          this.wsCheckResult = true;\n        }).catch(() => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket slow timer\",\n            \"ws connectivity check failed\"\n          );\n          this.wsCheckResult = false;\n        });\n      }\n      if (this.realtime.http.checkConnectivity) {\n        whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (err || !connectivity) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MAJOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check failed\"\n            );\n            this.cancelWebSocketGiveUpTimer();\n            this.notifyState({\n              state: \"disconnected\",\n              error: new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404)\n            });\n          } else {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check succeeded\"\n            );\n          }\n        });\n      }\n    }, this.options.timeouts.webSocketSlowTimeout);\n  }\n  cancelWebSocketSlowTimer() {\n    if (this.webSocketSlowTimer) {\n      clearTimeout(this.webSocketSlowTimer);\n      this.webSocketSlowTimer = null;\n    }\n  }\n  startWebSocketGiveUpTimer(transportParams) {\n    this.webSocketGiveUpTimer = setTimeout(() => {\n      var _a2, _b;\n      if (!this.wsCheckResult) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket give up timer\",\n          \"websocket connection took more than 10s; \" + (this.baseTransport ? \"trying base transport\" : \"\")\n        );\n        if (this.baseTransport) {\n          this.abandonedWebSocket = true;\n          (_a2 = this.proposedTransport) == null ? void 0 : _a2.dispose();\n          (_b = this.pendingTransport) == null ? void 0 : _b.dispose();\n          this.connectBase(transportParams, ++this.connectCounter);\n        } else {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket give up timer\",\n            \"websocket connectivity appears to be unavailable but no other transports to try\"\n          );\n        }\n      }\n    }, this.options.timeouts.webSocketConnectTimeout);\n  }\n  cancelWebSocketGiveUpTimer() {\n    if (this.webSocketGiveUpTimer) {\n      clearTimeout(this.webSocketGiveUpTimer);\n      this.webSocketGiveUpTimer = null;\n    }\n  }\n  notifyState(indicated) {\n    var _a2, _b;\n    const state = indicated.state;\n    const retryImmediately = state === \"disconnected\" && (this.state === this.states.connected || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.notifyState()\",\n      \"new state: \" + state + (retryImmediately ? \"; will retry connection immediately\" : \"\")\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.checkSuspendTimer(indicated.state);\n    if (state === \"suspended\" || state === \"connected\") {\n      this.disconnectedRetryCount = 0;\n    }\n    if (this.state.terminal)\n      return;\n    const newState = this.states[indicated.state];\n    let retryDelay = newState.retryDelay;\n    if (newState.state === \"disconnected\") {\n      this.disconnectedRetryCount++;\n      retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n    }\n    const change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      retryDelay,\n      indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    if (retryImmediately) {\n      const autoReconnect = () => {\n        if (this.state === this.states.disconnected) {\n          this.lastAutoReconnectAttempt = Date.now();\n          this.requestState({ state: \"connecting\" });\n        }\n      };\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n      if (sinceLast && sinceLast < 1e3) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.notifyState()\",\n          \"Last reconnect attempt was only \" + sinceLast + \"ms ago, waiting another \" + (1e3 - sinceLast) + \"ms before trying again\"\n        );\n        setTimeout(autoReconnect, 1e3 - sinceLast);\n      } else {\n        Platform.Config.nextTick(autoReconnect);\n      }\n    } else if (state === \"disconnected\" || state === \"suspended\") {\n      this.startRetryTimer(retryDelay);\n    }\n    if (state === \"disconnected\" && !retryImmediately || state === \"suspended\" || newState.terminal) {\n      Platform.Config.nextTick(() => {\n        this.disconnectAllTransports();\n      });\n    }\n    if (state == \"connected\" && !this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.notifyState()\",\n        \"Broken invariant: attempted to go into connected state, but there is no active protocol\"\n      );\n    }\n    this.enactStateChange(change);\n    if (this.state.sendEvents) {\n      this.sendQueuedMessages();\n    } else if (!this.state.queueEvents) {\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n      this.failQueuedMessages(change.reason);\n    }\n  }\n  requestState(request) {\n    var _a2, _b;\n    const state = request.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.requestState()\",\n      \"requested state: \" + state + \"; current state: \" + this.state.state\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.checkSuspendTimer(state);\n    if (state == \"connecting\" && this.state.state == \"connected\")\n      return;\n    if (state == \"closing\" && this.state.state == \"closed\")\n      return;\n    const newState = this.states[state], change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      null,\n      request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    this.enactStateChange(change);\n    if (state == \"connecting\") {\n      Platform.Config.nextTick(() => {\n        this.startConnect();\n      });\n    }\n    if (state == \"closing\") {\n      this.closeImpl();\n    }\n  }\n  startConnect() {\n    if (this.state !== this.states.connecting) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startConnect()\",\n        \"Must be in connecting state to connect, but was \" + this.state.state\n      );\n      return;\n    }\n    const auth = this.realtime.auth;\n    const connectCount = ++this.connectCounter;\n    const connect = () => {\n      this.checkConnectionStateFreshness();\n      this.getTransportParams((transportParams) => {\n        if (transportParams.mode === \"recover\" && transportParams.options.recover) {\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n          if (recoveryContext) {\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n          }\n        }\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        this.connectImpl(transportParams, connectCount);\n      });\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"starting connection\");\n    this.startSuspendTimer();\n    this.startTransitionTimer(this.states.connecting);\n    if (auth.method === \"basic\") {\n      connect();\n    } else {\n      const authCb = (err) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (err) {\n          this.actOnErrorFromAuthorize(err);\n        } else {\n          connect();\n        }\n      };\n      if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {\n        whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n      } else {\n        whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n      }\n    }\n  }\n  /*\n   * there are, at most, two transports available with which a connection may\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n   * comet in nodejs). web_socket is always preferred, and the base transport is\n   * only used in case web_socket connectivity appears to be unavailable.\n   *\n   * connectImpl begins the transport selection process by checking which transports\n   * are available, and if there is a cached preference. It then defers to the\n   * transport-specific connect methods: connectWs and connectBase.\n   *\n   * It is also responsible for invalidating the cache in the case that a base\n   * transport preference is stored but web socket connectivity is now available.\n   *\n   * handling of the case where we need to failover from web_socket to the base\n   * transport is implemented in the connectWs method.\n   */\n  connectImpl(transportParams, connectCount) {\n    const state = this.state.state;\n    if (state !== this.states.connecting.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.connectImpl()\",\n        \"Must be in connecting state to connect, but was \" + state\n      );\n      return;\n    }\n    const transportPreference = this.getTransportPreference();\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n      this.checkWsConnectivity().then(() => {\n        this.wsCheckResult = true;\n        this.abandonedWebSocket = false;\n        this.unpersistTransportPreference();\n        if (this.state === this.states.connecting) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.connectImpl():\",\n            \"web socket connectivity available, cancelling connection attempt with \" + this.baseTransport\n          );\n          this.disconnectAllTransports();\n          this.connectWs(transportParams, ++this.connectCounter);\n        }\n      }).catch(noop);\n    }\n    if (transportPreference && transportPreference === this.baseTransport || this.baseTransport && !this.webSocketTransportAvailable) {\n      this.connectBase(transportParams, connectCount);\n    } else {\n      this.connectWs(transportParams, connectCount);\n    }\n  }\n  /*\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n   *   connectivity check fails, we give up the connection sequence entirely and\n   *   transition to disconnected. if the websocket connectivity check fails then\n   *   we assume no ws connectivity and failover to base transport. in the case that\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n   *   and, if unsuccessful, ultimately transition to disconnected.\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n   *   connectivity check is still pending then we assume that there is an issue\n   *   with the transport and fallback to base transport.\n   */\n  connectWs(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectWs()\");\n    this.startWebSocketSlowTimer();\n    this.startWebSocketGiveUpTimer(transportParams);\n    this.tryTransportWithFallbacks(\"web_socket\", transportParams, true, connectCount, () => {\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\n    });\n  }\n  connectBase(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectBase()\");\n    if (this.baseTransport) {\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n    } else {\n      this.notifyState({\n        state: \"disconnected\",\n        error: new ErrorInfo(\"No transports left to try\", 8e4, 404)\n      });\n    }\n  }\n  tryTransportWithFallbacks(transportName, transportParams, ws, connectCount, shouldContinue) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.tryTransportWithFallbacks()\",\n      transportName\n    );\n    const giveUp = (err) => {\n      this.notifyState({ state: this.states.connecting.failState, error: err });\n    };\n    const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\n    const hostAttemptCb = (fatal, transport) => {\n      if (connectCount !== this.connectCounter) {\n        return;\n      }\n      if (!shouldContinue()) {\n        if (transport) {\n          transport.dispose();\n        }\n        return;\n      }\n      if (!transport && !fatal) {\n        tryFallbackHosts();\n      }\n    };\n    const host = candidateHosts.shift();\n    if (!host) {\n      giveUp(new ErrorInfo(\"Unable to connect (no available host)\", 80003, 404));\n      return;\n    }\n    transportParams.host = host;\n    const tryFallbackHosts = () => {\n      if (!candidateHosts.length) {\n        giveUp(new ErrorInfo(\"Unable to connect (and no more fallback hosts to try)\", 80003, 404));\n        return;\n      }\n      if (!this.realtime.http.checkConnectivity) {\n        giveUp(new PartialErrorInfo(\"Internal error: Http.checkConnectivity not set\", null, 500));\n        return;\n      }\n      whenPromiseSettles(\n        this.realtime.http.checkConnectivity(),\n        (err, connectivity) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            giveUp(new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404));\n            return;\n          }\n          transportParams.host = arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        }\n      );\n    };\n    if (this.forceFallbackHost && candidateHosts.length) {\n      this.forceFallbackHost = false;\n      tryFallbackHosts();\n      return;\n    }\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\n  }\n  closeImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.closeImpl()\", \"closing connection\");\n    this.cancelSuspendTimer();\n    this.startTransitionTimer(this.states.closing);\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.close();\n    }\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().close();\n    }\n    this.notifyState({ state: \"closed\" });\n  }\n  onAuthUpdated(tokenDetails, callback) {\n    var _a2;\n    switch (this.state.state) {\n      case \"connected\": {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Sending AUTH message on active transport\"\n        );\n        const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n        if (activeTransport && activeTransport.onAuthUpdated) {\n          activeTransport.onAuthUpdated(tokenDetails);\n        }\n        const authMsg = fromValues3({\n          action: actions2.AUTH,\n          auth: {\n            accessToken: tokenDetails.token\n          }\n        });\n        this.send(authMsg);\n        const successListener = () => {\n          this.off(failureListener);\n          callback(null, tokenDetails);\n        };\n        const failureListener = (stateChange) => {\n          if (stateChange.current === \"failed\") {\n            this.off(successListener);\n            this.off(failureListener);\n            callback(stateChange.reason || this.getStateError());\n          }\n        };\n        this.once(\"connectiondetails\", successListener);\n        this.on(\"connectionstate\", failureListener);\n        break;\n      }\n      case \"connecting\":\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Aborting current connection attempts in order to start again with the new auth details\"\n        );\n        this.disconnectAllTransports();\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Connection state is \" + this.state.state + \"; waiting until either connected or failed\"\n        );\n        const listener = (stateChange) => {\n          switch (stateChange.current) {\n            case \"connected\":\n              this.off(listener);\n              callback(null, tokenDetails);\n              break;\n            case \"failed\":\n            case \"closed\":\n            case \"suspended\":\n              this.off(listener);\n              callback(stateChange.reason || this.getStateError());\n              break;\n            default:\n              break;\n          }\n        };\n        this.on(\"connectionstate\", listener);\n        if (this.state.state === \"connecting\") {\n          this.startConnect();\n        } else {\n          this.requestState({ state: \"connecting\" });\n        }\n      }\n    }\n  }\n  disconnectAllTransports() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.disconnectAllTransports()\",\n      \"Disconnecting all transports\"\n    );\n    this.connectCounter++;\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.proposedTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting proposed transport: \" + this.pendingTransport\n      );\n      this.proposedTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().disconnect();\n    }\n  }\n  /******************\n   * event queueing\n   ******************/\n  send(msg, queueEvent, callback) {\n    callback = callback || noop;\n    const state = this.state;\n    if (state.sendEvents) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"sending event\");\n      this.sendImpl(new PendingMessage(msg, callback));\n      return;\n    }\n    const shouldQueue = queueEvent && state.queueEvents;\n    if (!shouldQueue) {\n      const err = \"rejecting event, queueEvent was \" + queueEvent + \", state was \" + state.state;\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", err);\n      callback(this.errorReason || new ErrorInfo(err, 9e4, 400));\n      return;\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.send()\",\n        \"queueing msg; \" + stringify(msg, this.realtime._RealtimePresence)\n      );\n    }\n    this.queue(msg, callback);\n  }\n  sendImpl(pendingMessage) {\n    const msg = pendingMessage.message;\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n      msg.msgSerial = this.msgSerial++;\n    }\n    try {\n      this.activeProtocol.send(pendingMessage);\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.sendImpl()\",\n        \"Unexpected exception in transport.send(): \" + e.stack\n      );\n    }\n  }\n  queue(msg, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.queue()\", \"queueing event\");\n    const lastQueued = this.queuedMessages.last();\n    const maxSize = this.options.maxMessageSize;\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\n      if (!lastQueued.merged) {\n        lastQueued.callback = multicaster_default.create(this.logger, [lastQueued.callback]);\n        lastQueued.merged = true;\n      }\n      lastQueued.callback.push(callback);\n    } else {\n      this.queuedMessages.push(new PendingMessage(msg, callback));\n    }\n  }\n  sendQueuedMessages() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.sendQueuedMessages()\",\n      \"sending \" + this.queuedMessages.count() + \" queued messages\"\n    );\n    let pendingMessage;\n    while (pendingMessage = this.queuedMessages.shift())\n      this.sendImpl(pendingMessage);\n  }\n  queuePendingMessages(pendingMessages) {\n    if (pendingMessages && pendingMessages.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.queuePendingMessages()\",\n        \"queueing \" + pendingMessages.length + \" pending messages\"\n      );\n      this.queuedMessages.prepend(pendingMessages);\n    }\n  }\n  failQueuedMessages(err) {\n    const numQueued = this.queuedMessages.count();\n    if (numQueued > 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.failQueuedMessages()\",\n        \"failing \" + numQueued + \" queued messages, err = \" + inspectError(err)\n      );\n      this.queuedMessages.completeAllMessages(err);\n    }\n  }\n  onChannelMessage(message, transport) {\n    this.pendingChannelMessagesState.queue.push({ message, transport });\n    if (!this.pendingChannelMessagesState.isProcessing) {\n      this.processNextPendingChannelMessage();\n    }\n  }\n  processNextPendingChannelMessage() {\n    if (this.pendingChannelMessagesState.queue.length > 0) {\n      this.pendingChannelMessagesState.isProcessing = true;\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();\n      this.processChannelMessage(pendingChannelMessage.message).catch((err) => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.processNextPendingChannelMessage() received error \",\n          err\n        );\n      }).finally(() => {\n        this.pendingChannelMessagesState.isProcessing = false;\n        this.processNextPendingChannelMessage();\n      });\n    }\n  }\n  async processChannelMessage(message) {\n    await this.realtime.channels.processChannelMessage(message);\n  }\n  async ping() {\n    var _a2;\n    if (this.state.state !== \"connected\") {\n      throw new ErrorInfo(\"Unable to ping service; not connected\", 4e4, 400);\n    }\n    const transport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n    if (!transport) {\n      throw this.getStateError();\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.ping()\", \"transport = \" + transport);\n    const pingStart = Date.now();\n    const id = cheapRandStr();\n    return withTimeoutAsync(\n      new Promise((resolve) => {\n        const onHeartbeat = (responseId) => {\n          if (responseId === id) {\n            transport.off(\"heartbeat\", onHeartbeat);\n            resolve(Date.now() - pingStart);\n          }\n        };\n        transport.on(\"heartbeat\", onHeartbeat);\n        transport.ping(id);\n      }),\n      this.options.timeouts.realtimeRequestTimeout,\n      \"Timeout waiting for heartbeat response\"\n    );\n  }\n  abort(error) {\n    this.activeProtocol.getTransport().fail(error);\n  }\n  getTransportPreference() {\n    var _a2, _b;\n    return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));\n  }\n  persistTransportPreference(transport) {\n    var _a2, _b;\n    this.transportPreference = transport.shortName;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);\n    }\n  }\n  unpersistTransportPreference() {\n    var _a2, _b;\n    this.transportPreference = null;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);\n    }\n  }\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n   * server returns 403. */\n  actOnErrorFromAuthorize(err) {\n    if (err.code === 40171) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.code === 40102) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {\n      const msg = \"Client configured authentication provider returned 403; failing the connection\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.actOnErrorFromAuthorize()\", msg);\n      this.notifyState({ state: \"failed\", error: new ErrorInfo(msg, 80019, 403, err) });\n    } else {\n      const msg = \"Client configured authentication provider request failed\";\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.actOnErrorFromAuthorize\", msg);\n      this.notifyState({ state: this.state.failState, error: new ErrorInfo(msg, 80019, 401, err) });\n    }\n  }\n  onConnectionDetailsUpdate(connectionDetails, transport) {\n    if (!connectionDetails) {\n      return;\n    }\n    this.connectionDetails = connectionDetails;\n    if (connectionDetails.maxMessageSize) {\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\n    }\n    const clientId = connectionDetails.clientId;\n    if (clientId) {\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\n      if (err) {\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.onConnectionDetailsUpdate()\", err.message);\n        transport.fail(err);\n        return;\n      }\n    }\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\n    if (connectionStateTtl) {\n      this.connectionStateTtl = connectionStateTtl;\n    }\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\n    this.emit(\"connectiondetails\", connectionDetails);\n  }\n  checkWsConnectivity() {\n    const ws = new Platform.Config.WebSocket(defaults_default.wsConnectivityUrl);\n    return new Promise((resolve, reject) => {\n      let finished = false;\n      ws.onopen = () => {\n        if (!finished) {\n          finished = true;\n          resolve();\n          ws.close();\n        }\n      };\n      ws.onclose = ws.onerror = () => {\n        if (!finished) {\n          finished = true;\n          reject();\n        }\n      };\n    });\n  }\n  sessionRecoveryName() {\n    return this.options.recoveryKeyStorageName || \"ably-connection-recovery\";\n  }\n  getSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n  setSessionRecoverData(value) {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName(), value));\n  }\n  clearSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n};\nvar connectionmanager_default = ConnectionManager;\n\n// src/common/lib/client/connection.ts\nvar Connection = class extends eventemitter_default {\n  constructor(ably, options) {\n    super(ably.logger);\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    this.ably = ably;\n    this.connectionManager = new connectionmanager_default(ably, options);\n    this.state = this.connectionManager.state.state;\n    this.key = void 0;\n    this.id = void 0;\n    this.errorReason = null;\n    this.connectionManager.on(\"connectionstate\", (stateChange) => {\n      const state = this.state = stateChange.current;\n      Platform.Config.nextTick(() => {\n        this.emit(state, stateChange);\n      });\n    });\n    this.connectionManager.on(\"update\", (stateChange) => {\n      Platform.Config.nextTick(() => {\n        this.emit(\"update\", stateChange);\n      });\n    });\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.connect()\", \"\");\n    this.connectionManager.requestState({ state: \"connecting\" });\n  }\n  async ping() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.ping()\", \"\");\n    return this.connectionManager.ping();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.close()\", \"connectionKey = \" + this.key);\n    this.connectionManager.requestState({ state: \"closing\" });\n  }\n  get recoveryKey() {\n    this.logger.deprecationWarning(\n      \"The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.\"\n    );\n    return this.createRecoveryKey();\n  }\n  createRecoveryKey() {\n    return this.connectionManager.createRecoveryKey();\n  }\n};\nvar connection_default = Connection;\n\n// src/common/lib/client/channelstatechange.ts\nvar ChannelStateChange = class {\n  constructor(previous, current, resumed, hasBacklog, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (current === \"attached\") {\n      this.resumed = resumed;\n      this.hasBacklog = hasBacklog;\n    }\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar channelstatechange_default = ChannelStateChange;\n\n// src/common/lib/client/realtimechannel.ts\nvar noop2 = function() {\n};\nfunction validateChannelOptions(options) {\n  if (options && \"params\" in options && !isObject(options.params)) {\n    return new ErrorInfo(\"options.params must be an object\", 4e4, 400);\n  }\n  if (options && \"modes\" in options) {\n    if (!Array.isArray(options.modes)) {\n      return new ErrorInfo(\"options.modes must be an array\", 4e4, 400);\n    }\n    for (let i = 0; i < options.modes.length; i++) {\n      const currentMode = options.modes[i];\n      if (!currentMode || typeof currentMode !== \"string\" || !channelModes.includes(String.prototype.toUpperCase.call(currentMode))) {\n        return new ErrorInfo(\"Invalid channel mode: \" + currentMode, 4e4, 400);\n      }\n    }\n  }\n}\nvar RealtimeChannel = class _RealtimeChannel extends eventemitter_default {\n  constructor(client, name, options) {\n    var _a2, _b;\n    super(client.logger);\n    this.retryCount = 0;\n    this.history = async function(params) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.history()\", \"channel = \" + this.name);\n      const restMixin = this.client.rest.channelMixin;\n      if (params && params.untilAttach) {\n        if (this.state !== \"attached\") {\n          throw new ErrorInfo(\"option untilAttach requires the channel to be attached\", 4e4, 400);\n        }\n        if (!this.properties.attachSerial) {\n          throw new ErrorInfo(\n            \"untilAttach was specified and channel is attached, but attachSerial is not defined\",\n            4e4,\n            400\n          );\n        }\n        delete params.untilAttach;\n        params.from_serial = this.properties.attachSerial;\n      }\n      return restMixin.history(this, params);\n    };\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, options);\n    this.client = client;\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n    this.connectionManager = client.connection.connectionManager;\n    this.state = \"initialized\";\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.syncChannelSerial = void 0;\n    this.properties = {\n      attachSerial: void 0,\n      channelSerial: void 0\n    };\n    this.setOptions(options);\n    this.errorReason = null;\n    this._requestedFlags = null;\n    this._mode = null;\n    this._attachResume = false;\n    this._decodingContext = {\n      channelOptions: this.channelOptions,\n      plugins: client.options.plugins || {},\n      baseEncodedPreviousPayload: void 0\n    };\n    this._lastPayload = {\n      messageId: null,\n      protocolMessageChannelSerial: null,\n      decodeFailureRecoveryInProgress: null\n    };\n    this._allChannelChanges = new eventemitter_default(this.logger);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n  }\n  get presence() {\n    if (!this._presence) {\n      throwMissingPluginError(\"RealtimePresence\");\n    }\n    return this._presence;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  invalidStateError() {\n    return new ErrorInfo(\n      \"Channel operation failed as channel state is \" + this.state,\n      90001,\n      400,\n      this.errorReason || void 0\n    );\n  }\n  static processListenerArgs(args) {\n    args = Array.prototype.slice.call(args);\n    if (typeof args[0] === \"function\") {\n      args.unshift(null);\n    }\n    return args;\n  }\n  async setOptions(options) {\n    var _a2;\n    const previousChannelOptions = this.channelOptions;\n    const err = validateChannelOptions(options);\n    if (err) {\n      throw err;\n    }\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n    if (this._decodingContext)\n      this._decodingContext.channelOptions = this.channelOptions;\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n      this.attachImpl();\n      return new Promise((resolve, reject) => {\n        this._allChannelChanges.once(\n          [\"attached\", \"update\", \"detached\", \"failed\"],\n          function(stateChange) {\n            switch (this.event) {\n              case \"update\":\n              case \"attached\":\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          }\n        );\n      });\n    }\n  }\n  _shouldReattachToSetOptions(options, prevOptions) {\n    if (!(this.state === \"attached\" || this.state === \"attaching\")) {\n      return false;\n    }\n    if (options == null ? void 0 : options.params) {\n      const requestedParams = omitAgent(options.params);\n      const existingParams = omitAgent(prevOptions.params);\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n        return true;\n      }\n      if (!shallowEquals(existingParams, requestedParams)) {\n        return true;\n      }\n    }\n    if (options == null ? void 0 : options.modes) {\n      if (!prevOptions.modes || !arrEquals(options.modes, prevOptions.modes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async publish(...args) {\n    let messages = args[0];\n    let argCount = args.length;\n    if (!this.connectionManager.activeState()) {\n      throw this.connectionManager.getError();\n    }\n    if (argCount == 1) {\n      if (isObject(messages))\n        messages = [fromValues(messages)];\n      else if (Array.isArray(messages))\n        messages = fromValuesArray(messages);\n      else\n        throw new ErrorInfo(\n          \"The single-argument form of publish() expects a message object or an array of message objects\",\n          40013,\n          400\n        );\n    } else {\n      messages = [fromValues({ name: args[0], data: args[1] })];\n    }\n    const maxMessageSize = this.client.options.maxMessageSize;\n    await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(messages);\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        \"Maximum size of messages that can be published at once exceeded ( was \" + size + \" bytes; limit is \" + maxMessageSize + \" bytes)\",\n        40009,\n        400\n      );\n    }\n    return new Promise((resolve, reject) => {\n      this._publish(messages, (err) => err ? reject(err) : resolve());\n    });\n  }\n  _publish(messages, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.publish()\", \"message count = \" + messages.length);\n    const state = this.state;\n    switch (state) {\n      case \"failed\":\n      case \"suspended\":\n        callback(ErrorInfo.fromValues(this.invalidStateError()));\n        break;\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"RealtimeChannel.publish()\",\n          \"sending message; channel state is \" + state\n        );\n        const msg = new protocolmessage_default();\n        msg.action = actions2.MESSAGE;\n        msg.channel = this.name;\n        msg.messages = messages;\n        this.sendMessage(msg, callback);\n        break;\n      }\n    }\n  }\n  onEvent(messages) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.onEvent()\", \"received message\");\n    const subscriptions = this.subscriptions;\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      subscriptions.emit(message.name, message);\n    }\n  }\n  async attach() {\n    if (this.state === \"attached\") {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      this._attach(false, null, (err, result) => err ? reject(err) : resolve(result));\n    });\n  }\n  _attach(forceReattach, attachReason, callback) {\n    if (!callback) {\n      callback = (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"RealtimeChannel._attach()\",\n            \"Channel attach failed: \" + err.toString()\n          );\n        }\n      };\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      callback(connectionManager.getError());\n      return;\n    }\n    if (this.state !== \"attaching\" || forceReattach) {\n      this.requestState(\"attaching\", attachReason);\n    }\n    this.once(function(stateChange) {\n      switch (this.event) {\n        case \"attached\":\n          callback == null ? void 0 : callback(null, stateChange);\n          break;\n        case \"detached\":\n        case \"suspended\":\n        case \"failed\":\n          callback == null ? void 0 : callback(\n            stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to attach; reason unknown; state = \" + this.event, 9e4, 500)\n          );\n          break;\n        case \"detaching\":\n          callback == null ? void 0 : callback(new ErrorInfo(\"Attach request superseded by a subsequent detach request\", 9e4, 409));\n          break;\n      }\n    });\n  }\n  attachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.attachImpl()\", \"sending ATTACH message\");\n    const attachMsg = fromValues3({\n      action: actions2.ATTACH,\n      channel: this.name,\n      params: this.channelOptions.params,\n      // RTL4c1: Includes the channel serial to resume from a previous message\n      // or attachment.\n      channelSerial: this.properties.channelSerial\n    });\n    if (this._requestedFlags) {\n      attachMsg.encodeModesToFlags(this._requestedFlags);\n    } else if (this.channelOptions.modes) {\n      attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));\n    }\n    if (this._attachResume) {\n      attachMsg.setFlag(\"ATTACH_RESUME\");\n    }\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n    }\n    this.sendMessage(attachMsg, noop2);\n  }\n  async detach() {\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    switch (this.state) {\n      case \"suspended\":\n        this.notifyState(\"detached\");\n        return;\n      case \"detached\":\n        return;\n      case \"failed\":\n        throw new ErrorInfo(\"Unable to detach; channel state = failed\", 90001, 400);\n      default:\n        this.requestState(\"detaching\");\n      case \"detaching\":\n        return new Promise((resolve, reject) => {\n          this.once(function(stateChange) {\n            switch (this.event) {\n              case \"detached\":\n                resolve();\n                break;\n              case \"attached\":\n              case \"suspended\":\n              case \"failed\":\n                reject(\n                  stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to detach; reason unknown; state = \" + this.event, 9e4, 500)\n                );\n                break;\n              case \"attaching\":\n                reject(new ErrorInfo(\"Detach request superseded by a subsequent attach request\", 9e4, 409));\n                break;\n            }\n          });\n        });\n    }\n  }\n  detachImpl(callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.detach()\", \"sending DETACH message\");\n    const msg = fromValues3({ action: actions2.DETACH, channel: this.name });\n    this.sendMessage(msg, callback || noop2);\n  }\n  async subscribe(...args) {\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (this.state === \"failed\") {\n      throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n    if (event && typeof event === \"object\" && !Array.isArray(event)) {\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n    } else {\n      this.subscriptions.on(event, listener);\n    }\n    return this.attach();\n  }\n  unsubscribe(...args) {\n    var _a2;\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (typeof event === \"object\" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {\n      this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach((l) => this.subscriptions.off(l));\n      return;\n    }\n    this.subscriptions.off(event, listener);\n  }\n  sync() {\n    switch (this.state) {\n      case \"initialized\":\n      case \"detaching\":\n      case \"detached\":\n        throw new PartialErrorInfo(\"Unable to sync to channel; not attached\", 4e4);\n      default:\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    const syncMessage = fromValues3({ action: actions2.SYNC, channel: this.name });\n    if (this.syncChannelSerial) {\n      syncMessage.channelSerial = this.syncChannelSerial;\n    }\n    connectionManager.send(syncMessage);\n  }\n  sendMessage(msg, callback) {\n    this.connectionManager.send(msg, this.client.options.queueMessages, callback);\n  }\n  sendPresence(presence, callback) {\n    const msg = fromValues3({\n      action: actions2.PRESENCE,\n      channel: this.name,\n      presence: Array.isArray(presence) ? this.client._RealtimePresence.presenceMessagesFromValuesArray(presence) : [this.client._RealtimePresence.presenceMessageFromValues(presence)]\n    });\n    this.sendMessage(msg, callback);\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n  async processMessage(message) {\n    if (message.action === actions2.ATTACHED || message.action === actions2.MESSAGE || message.action === actions2.PRESENCE) {\n      this.setChannelSerial(message.channelSerial);\n    }\n    let syncChannelSerial, isSync = false;\n    switch (message.action) {\n      case actions2.ATTACHED: {\n        this.properties.attachSerial = message.channelSerial;\n        this._mode = message.getMode();\n        this.params = message.params || {};\n        const modesFromFlags = message.decodeModesFromFlags();\n        this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;\n        const resumed = message.hasFlag(\"RESUMED\");\n        const hasPresence = message.hasFlag(\"HAS_PRESENCE\");\n        const hasBacklog = message.hasFlag(\"HAS_BACKLOG\");\n        if (this.state === \"attached\") {\n          if (!resumed) {\n            if (this._presence) {\n              this._presence.onAttached(hasPresence);\n            }\n          }\n          const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);\n          this._allChannelChanges.emit(\"update\", change);\n          if (!resumed || this.channelOptions.updateOnAttached) {\n            this.emit(\"update\", change);\n          }\n        } else if (this.state === \"detaching\") {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"attached\", message.error, resumed, hasPresence, hasBacklog);\n        }\n        break;\n      }\n      case actions2.DETACHED: {\n        const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo(\"Channel detached\", 90001, 404);\n        if (this.state === \"detaching\") {\n          this.notifyState(\"detached\", detachErr);\n        } else if (this.state === \"attaching\") {\n          this.notifyState(\"suspended\", detachErr);\n        } else if (this.state === \"attached\" || this.state === \"suspended\") {\n          this.requestState(\"attaching\", detachErr);\n        }\n        break;\n      }\n      case actions2.SYNC:\n        isSync = true;\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n        if (!message.presence)\n          break;\n      case actions2.PRESENCE: {\n        const presence = message.presence;\n        if (!presence) {\n          break;\n        }\n        const { id, connectionId, timestamp } = message;\n        const options = this.channelOptions;\n        let presenceMsg;\n        for (let i = 0; i < presence.length; i++) {\n          try {\n            presenceMsg = presence[i];\n            await decode2(presenceMsg, options);\n            if (!presenceMsg.connectionId)\n              presenceMsg.connectionId = connectionId;\n            if (!presenceMsg.timestamp)\n              presenceMsg.timestamp = timestamp;\n            if (!presenceMsg.id)\n              presenceMsg.id = id + \":\" + i;\n          } catch (e) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"RealtimeChannel.processMessage()\",\n              e.toString()\n            );\n          }\n        }\n        if (this._presence) {\n          this._presence.setPresence(presence, isSync, syncChannelSerial);\n        }\n        break;\n      }\n      case actions2.MESSAGE: {\n        if (this.state !== \"attached\") {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"RealtimeChannel.processMessage()\",\n            'Message \"' + message.id + '\" skipped as this channel \"' + this.name + '\" state is not \"attached\" (state is \"' + this.state + '\").'\n          );\n          return;\n        }\n        const messages = message.messages, firstMessage = messages[0], lastMessage = messages[messages.length - 1], id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;\n        if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n          const msg = 'Delta message decode failure - previous message not available for message \"' + message.id + '\" on this channel \"' + this.name + '\".';\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", msg);\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n          break;\n        }\n        for (let i = 0; i < messages.length; i++) {\n          const msg = messages[i];\n          try {\n            await decode(msg, this._decodingContext);\n          } catch (e) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"RealtimeChannel.processMessage()\",\n              e.toString()\n            );\n            switch (e.code) {\n              case 40018:\n                this._startDecodeFailureRecovery(e);\n                return;\n              case 40019:\n              case 40021:\n                this.notifyState(\"failed\", e);\n                return;\n            }\n          }\n          if (!msg.connectionId)\n            msg.connectionId = connectionId;\n          if (!msg.timestamp)\n            msg.timestamp = timestamp;\n          if (!msg.id)\n            msg.id = id + \":\" + i;\n        }\n        this._lastPayload.messageId = lastMessage.id;\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n        this.onEvent(messages);\n        break;\n      }\n      case actions2.ERROR: {\n        const err = message.error;\n        if (err && err.code == 80016) {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"failed\", ErrorInfo.fromValues(err));\n        }\n        break;\n      }\n      default:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"RealtimeChannel.processMessage()\",\n          \"Fatal protocol error: unrecognised action (\" + message.action + \")\"\n        );\n        this.connectionManager.abort(connectionerrors_default.unknownChannelErr());\n    }\n  }\n  _startDecodeFailureRecovery(reason) {\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MAJOR,\n        \"RealtimeChannel.processMessage()\",\n        \"Starting decode failure recovery process.\"\n      );\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\n      this._attach(true, reason, () => {\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\n      });\n    }\n  }\n  onAttached() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.onAttached\",\n      \"activating channel; name = \" + this.name\n    );\n  }\n  notifyState(state, reason, resumed, hasPresence, hasBacklog) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.notifyState\",\n      \"name = \" + this.name + \", current state = \" + this.state + \", notifying state \" + state\n    );\n    this.clearStateTimer();\n    if ([\"detached\", \"suspended\", \"failed\"].includes(state)) {\n      this.properties.channelSerial = null;\n    }\n    if (state === this.state) {\n      return;\n    }\n    if (this._presence) {\n      this._presence.actOnChannelState(state, hasPresence, reason);\n    }\n    if (state === \"suspended\" && this.connectionManager.state.sendEvents) {\n      this.startRetryTimer();\n    } else {\n      this.cancelRetryTimer();\n    }\n    if (reason) {\n      this.errorReason = reason;\n    }\n    const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);\n    const action = 'Channel state for channel \"' + this.name + '\"';\n    const message = state + (reason ? \"; reason: \" + reason : \"\");\n    if (state === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    if (state !== \"attaching\" && state !== \"suspended\") {\n      this.retryCount = 0;\n    }\n    if (state === \"attached\") {\n      this.onAttached();\n    }\n    if (state === \"attached\") {\n      this._attachResume = true;\n    } else if (state === \"detaching\" || state === \"failed\") {\n      this._attachResume = false;\n    }\n    this.state = state;\n    this._allChannelChanges.emit(state, change);\n    this.emit(state, change);\n  }\n  requestState(state, reason) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.requestState\",\n      \"name = \" + this.name + \", state = \" + state\n    );\n    this.notifyState(state, reason);\n    this.checkPendingState();\n  }\n  checkPendingState() {\n    const cmState = this.connectionManager.state;\n    if (!cmState.sendEvents) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.checkPendingState\",\n        \"sendEvents is false; state is \" + this.connectionManager.state.state\n      );\n      return;\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.checkPendingState\",\n      \"name = \" + this.name + \", state = \" + this.state\n    );\n    switch (this.state) {\n      case \"attaching\":\n        this.startStateTimerIfNotRunning();\n        this.attachImpl();\n        break;\n      case \"detaching\":\n        this.startStateTimerIfNotRunning();\n        this.detachImpl();\n        break;\n      case \"attached\":\n        this.sync();\n        break;\n      default:\n        break;\n    }\n  }\n  timeoutPendingState() {\n    switch (this.state) {\n      case \"attaching\": {\n        const err = new ErrorInfo(\"Channel attach timed out\", 90007, 408);\n        this.notifyState(\"suspended\", err);\n        break;\n      }\n      case \"detaching\": {\n        const err = new ErrorInfo(\"Channel detach timed out\", 90007, 408);\n        this.notifyState(\"attached\", err);\n        break;\n      }\n      default:\n        this.checkPendingState();\n        break;\n    }\n  }\n  startStateTimerIfNotRunning() {\n    if (!this.stateTimer) {\n      this.stateTimer = setTimeout(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel.startStateTimerIfNotRunning\", \"timer expired\");\n        this.stateTimer = null;\n        this.timeoutPendingState();\n      }, this.client.options.timeouts.realtimeRequestTimeout);\n    }\n  }\n  clearStateTimer() {\n    const stateTimer = this.stateTimer;\n    if (stateTimer) {\n      clearTimeout(stateTimer);\n      this.stateTimer = null;\n    }\n  }\n  startRetryTimer() {\n    if (this.retryTimer)\n      return;\n    this.retryCount++;\n    const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n    this.retryTimer = setTimeout(() => {\n      if (this.state === \"suspended\" && this.connectionManager.state.sendEvents) {\n        this.retryTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"RealtimeChannel retry timer expired\",\n          \"attempting a new attach\"\n        );\n        this.requestState(\"attaching\");\n      }\n    }, retryDelay);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n  getReleaseErr() {\n    const s = this.state;\n    if (s === \"initialized\" || s === \"detached\" || s === \"failed\") {\n      return null;\n    }\n    return new ErrorInfo(\n      \"Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was \" + s,\n      90001,\n      400\n    );\n  }\n  setChannelSerial(channelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.setChannelSerial()\",\n      \"Updating channel serial; serial = \" + channelSerial + \"; previous = \" + this.properties.channelSerial\n    );\n    if (channelSerial) {\n      this.properties.channelSerial = channelSerial;\n    }\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n};\nfunction omitAgent(channelParams) {\n  const _a2 = channelParams || {}, { agent: _ } = _a2, paramsWithoutAgent = __objRest(_a2, [\"agent\"]);\n  return paramsWithoutAgent;\n}\nvar realtimechannel_default = RealtimeChannel;\n\n// src/common/lib/client/baserealtime.ts\nvar _BaseRealtime = class _BaseRealtime extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    var _a2, _b;\n    super(defaults_default.objectifyOptions(options, false, \"BaseRealtime\", logger_default.defaultLogger));\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime()\", \"\");\n    if (typeof EdgeRuntime === \"string\") {\n      throw new ErrorInfo(\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime. If you are running Vercel Edge functions, please replace your \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API instead of the Realtime API. If you are server-rendering your application in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\" to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\n        4e4,\n        400\n      );\n    }\n    this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n    this._RealtimePresence = (_b = (_a2 = this.options.plugins) == null ? void 0 : _a2.RealtimePresence) != null ? _b : null;\n    this.connection = new connection_default(this, this.options);\n    this._channels = new Channels2(this);\n    if (this.options.autoConnect !== false)\n      this.connect();\n  }\n  static transportImplementationsFromPlugins(plugins) {\n    const transports = {};\n    if (plugins == null ? void 0 : plugins.WebSocketTransport) {\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n    }\n    if (plugins == null ? void 0 : plugins.XHRPolling) {\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n    }\n    return transports;\n  }\n  get channels() {\n    return this._channels;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.connect()\", \"\");\n    this.connection.connect();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.close()\", \"\");\n    this.connection.close();\n  }\n};\n// internal API to make EventEmitter usable in other SDKs\n_BaseRealtime.EventEmitter = eventemitter_default;\nvar BaseRealtime = _BaseRealtime;\nvar Channels2 = class extends eventemitter_default {\n  constructor(realtime) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.all = /* @__PURE__ */ Object.create(null);\n    realtime.connection.connectionManager.on(\"transport.active\", () => {\n      this.onTransportActive();\n    });\n  }\n  channelSerials() {\n    let serials = {};\n    for (const name of keysArray(this.all, true)) {\n      const channel = this.all[name];\n      if (channel.properties.channelSerial) {\n        serials[name] = channel.properties.channelSerial;\n      }\n    }\n    return serials;\n  }\n  // recoverChannels gets the given channels and sets their channel serials.\n  recoverChannels(channelSerials) {\n    for (const name of keysArray(channelSerials, true)) {\n      const channel = this.get(name);\n      channel.properties.channelSerial = channelSerials[name];\n    }\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n  async processChannelMessage(msg) {\n    const channelName = msg.channel;\n    if (channelName === void 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event unspecified channel, action = \" + msg.action\n      );\n      return;\n    }\n    const channel = this.all[channelName];\n    if (!channel) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event for non-existent channel: \" + channelName\n      );\n      return;\n    }\n    await channel.processMessage(msg);\n  }\n  /* called when a transport becomes connected; reattempt attach/detach\n   * for channels that are attaching or detaching. */\n  onTransportActive() {\n    for (const channelName in this.all) {\n      const channel = this.all[channelName];\n      if (channel.state === \"attaching\" || channel.state === \"detaching\") {\n        channel.checkPendingState();\n      } else if (channel.state === \"suspended\") {\n        channel._attach(false, null);\n      } else if (channel.state === \"attached\") {\n        channel.requestState(\"attaching\");\n      }\n    }\n  }\n  /* Connection interruptions (ie when the connection will no longer queue\n   * events) imply connection state changes for any channel which is either\n   * attached, pending, or will attempt to become attached in the future */\n  propogateConnectionInterruption(connectionState, reason) {\n    const connectionStateToChannelState = {\n      closing: \"detached\",\n      closed: \"detached\",\n      failed: \"failed\",\n      suspended: \"suspended\"\n    };\n    const fromChannelStates = [\"attaching\", \"attached\", \"detaching\", \"suspended\"];\n    const toChannelState = connectionStateToChannelState[connectionState];\n    for (const channelId in this.all) {\n      const channel = this.all[channelId];\n      if (fromChannelStates.includes(channel.state)) {\n        channel.notifyState(toChannelState, reason);\n      }\n    }\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);\n    } else if (channelOptions) {\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n        throw new ErrorInfo(\n          \"Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.\",\n          4e4,\n          400\n        );\n      }\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  getDerived(name, deriveOptions, channelOptions) {\n    if (deriveOptions.filter) {\n      const filter = toBase64(deriveOptions.filter);\n      const match = matchDerivedChannel(name);\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n    }\n    return this.get(name, channelOptions);\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    name = String(name);\n    const channel = this.all[name];\n    if (!channel) {\n      return;\n    }\n    const releaseErr = channel.getReleaseErr();\n    if (releaseErr) {\n      throw releaseErr;\n    }\n    delete this.all[name];\n  }\n};\nvar baserealtime_default = BaseRealtime;\n\n// src/common/lib/client/realtimepresence.ts\nfunction getClientId(realtimePresence) {\n  return realtimePresence.channel.client.auth.clientId;\n}\nfunction isAnonymousOrWildcard(realtimePresence) {\n  const realtime = realtimePresence.channel.client;\n  const clientId = realtime.auth.clientId;\n  return (!clientId || clientId === \"*\") && realtime.connection.state === \"connected\";\n}\nfunction waitAttached(channel, callback, action) {\n  switch (channel.state) {\n    case \"attached\":\n    case \"suspended\":\n      action();\n      break;\n    case \"initialized\":\n    case \"detached\":\n    case \"detaching\":\n    case \"attaching\":\n      whenPromiseSettles(channel.attach(), function(err) {\n        if (err)\n          callback(err);\n        else\n          action();\n      });\n      break;\n    default:\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\n  }\n}\nfunction newerThan(item, existing) {\n  if (item.isSynthesized() || existing.isSynthesized()) {\n    return item.timestamp >= existing.timestamp;\n  }\n  const itemOrderings = item.parseId(), existingOrderings = existing.parseId();\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n    return itemOrderings.index > existingOrderings.index;\n  } else {\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\n  }\n}\nvar RealtimePresence = class extends eventemitter_default {\n  constructor(channel) {\n    super(channel.logger);\n    this.channel = channel;\n    this.syncComplete = false;\n    this.members = new PresenceMap(this, (item) => item.clientId + \":\" + item.connectionId);\n    this._myMembers = new PresenceMap(this, (item) => item.clientId);\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.pendingPresence = [];\n  }\n  async enter(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to enter a presence channel\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"enter\");\n  }\n  async update(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to update presence data\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"update\");\n  }\n  async enterClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"enter\");\n  }\n  async updateClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"update\");\n  }\n  async _enterOrUpdateClient(id, clientId, data, action) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.\" + action + \"Client()\",\n      \"channel = \" + channel.name + \", id = \" + id + \", client = \" + (clientId || \"(implicit) \" + getClientId(this))\n    );\n    const presence = fromData(data);\n    presence.action = action;\n    if (id) {\n      presence.id = id;\n    }\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    await encode(presence, channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return new Promise((resolve, reject) => {\n          channel.sendPresence(presence, (err) => err ? reject(err) : resolve());\n        });\n      case \"initialized\":\n      case \"detached\":\n        channel.attach();\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      default: {\n        const err = new PartialErrorInfo(\n          \"Unable to \" + action + \" presence channel while in \" + channel.state + \" state\",\n          90001\n        );\n        err.code = 90001;\n        throw err;\n      }\n    }\n  }\n  async leave(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must have been specified to enter or leave a presence channel\", 40012, 400);\n    }\n    return this.leaveClient(void 0, data);\n  }\n  async leaveClient(clientId, data) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.leaveClient()\",\n      \"leaving; channel = \" + this.channel.name + \", client = \" + clientId\n    );\n    const presence = fromData(data);\n    presence.action = \"leave\";\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    return new Promise((resolve, reject) => {\n      switch (channel.state) {\n        case \"attached\":\n          channel.sendPresence(presence, (err) => err ? reject(err) : resolve());\n          break;\n        case \"attaching\":\n          this.pendingPresence.push({\n            presence,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n          break;\n        case \"initialized\":\n        case \"failed\": {\n          const err = new PartialErrorInfo(\"Unable to leave presence channel (incompatible state)\", 90001);\n          reject(err);\n          break;\n        }\n        default:\n          reject(channel.invalidStateError());\n      }\n    });\n  }\n  async get(params) {\n    const waitForSync = !params || (\"waitForSync\" in params ? params.waitForSync : true);\n    return new Promise((resolve, reject) => {\n      function returnMembers(members) {\n        resolve(params ? members.list(params) : members.values());\n      }\n      if (this.channel.state === \"suspended\") {\n        if (waitForSync) {\n          reject(\n            ErrorInfo.fromValues({\n              statusCode: 400,\n              code: 91005,\n              message: \"Presence state is out of sync due to channel being in the SUSPENDED state\"\n            })\n          );\n        } else {\n          returnMembers(this.members);\n        }\n        return;\n      }\n      waitAttached(\n        this.channel,\n        (err) => reject(err),\n        () => {\n          const members = this.members;\n          if (waitForSync) {\n            members.waitSync(function() {\n              returnMembers(members);\n            });\n          } else {\n            returnMembers(members);\n          }\n        }\n      );\n    });\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimePresence.history()\", \"channel = \" + this.name);\n    const restMixin = this.channel.client.rest.presenceMixin;\n    if (params && params.untilAttach) {\n      if (this.channel.state === \"attached\") {\n        delete params.untilAttach;\n        params.from_serial = this.channel.properties.attachSerial;\n      } else {\n        throw new ErrorInfo(\n          \"option untilAttach requires the channel to be attached, was: \" + this.channel.state,\n          4e4,\n          400\n        );\n      }\n    }\n    return restMixin.history(this, params);\n  }\n  setPresence(presenceSet, isSync, syncChannelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.setPresence()\",\n      \"received presence for \" + presenceSet.length + \" participants; syncChannelSerial = \" + syncChannelSerial\n    );\n    let syncCursor, match;\n    const members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;\n    if (isSync) {\n      this.members.startSync();\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n        syncCursor = match[1];\n      }\n    }\n    for (let i = 0; i < presenceSet.length; i++) {\n      const presence = fromValues2(presenceSet[i]);\n      switch (presence.action) {\n        case \"leave\":\n          if (members.remove(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\n            myMembers.remove(presence);\n          }\n          break;\n        case \"enter\":\n        case \"present\":\n        case \"update\":\n          if (members.put(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId) {\n            myMembers.put(presence);\n          }\n          break;\n      }\n    }\n    if (isSync && !syncCursor) {\n      members.endSync();\n      this.channel.syncChannelSerial = null;\n    }\n    for (let i = 0; i < broadcastMessages.length; i++) {\n      const presence = broadcastMessages[i];\n      this.subscriptions.emit(presence.action, presence);\n    }\n  }\n  onAttached(hasPresence) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimePresence.onAttached()\",\n      \"channel = \" + this.channel.name + \", hasPresence = \" + hasPresence\n    );\n    if (hasPresence) {\n      this.members.startSync();\n    } else {\n      this._synthesizeLeaves(this.members.values());\n      this.members.clear();\n    }\n    this._ensureMyMembersPresent();\n    const pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;\n    if (pendingPresCount) {\n      this.pendingPresence = [];\n      const presenceArray = [];\n      const multicaster = multicaster_default.create(this.logger);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence.onAttached\",\n        \"sending \" + pendingPresCount + \" queued presence messages\"\n      );\n      for (let i = 0; i < pendingPresCount; i++) {\n        const event = pendingPresence[i];\n        presenceArray.push(event.presence);\n        multicaster.push(event.callback);\n      }\n      this.channel.sendPresence(presenceArray, multicaster);\n    }\n  }\n  actOnChannelState(state, hasPresence, err) {\n    switch (state) {\n      case \"attached\":\n        this.onAttached(hasPresence);\n        break;\n      case \"detached\":\n      case \"failed\":\n        this._clearMyMembers();\n        this.members.clear();\n      case \"suspended\":\n        this.failPendingPresence(err);\n        break;\n    }\n  }\n  failPendingPresence(err) {\n    if (this.pendingPresence.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.failPendingPresence\",\n        \"channel; name = \" + this.channel.name + \", err = \" + inspectError(err)\n      );\n      for (let i = 0; i < this.pendingPresence.length; i++)\n        try {\n          this.pendingPresence[i].callback(err);\n        } catch (e) {\n        }\n      this.pendingPresence = [];\n    }\n  }\n  _clearMyMembers() {\n    this._myMembers.clear();\n  }\n  _ensureMyMembersPresent() {\n    const myMembers = this._myMembers, reenterCb = (err) => {\n      if (err) {\n        const msg = \"Presence auto-re-enter failed: \" + err.toString();\n        const wrappedErr = new ErrorInfo(msg, 91004, 400);\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimePresence._ensureMyMembersPresent()\", msg);\n        const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);\n        this.channel.emit(\"update\", change);\n      }\n    };\n    for (const memberKey in myMembers.map) {\n      const entry = myMembers.map[memberKey];\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence._ensureMyMembersPresent()\",\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set'\n      );\n      whenPromiseSettles(this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, \"enter\"), reenterCb);\n    }\n  }\n  _synthesizeLeaves(items) {\n    const subscriptions = this.subscriptions;\n    items.forEach(function(item) {\n      const presence = fromValues2({\n        action: \"leave\",\n        connectionId: item.connectionId,\n        clientId: item.clientId,\n        data: item.data,\n        encoding: item.encoding,\n        timestamp: Date.now()\n      });\n      subscriptions.emit(\"leave\", presence);\n    });\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    await channel.attach();\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n};\nvar PresenceMap = class extends eventemitter_default {\n  constructor(presence, memberKey) {\n    super(presence.logger);\n    this.presence = presence;\n    this.map = /* @__PURE__ */ Object.create(null);\n    this.syncInProgress = false;\n    this.residualMembers = null;\n    this.memberKey = memberKey;\n  }\n  get(key) {\n    return this.map[key];\n  }\n  getClient(clientId) {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.clientId == clientId && item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  list(params) {\n    const map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action === \"absent\")\n        continue;\n      if (clientId && clientId != item.clientId)\n        continue;\n      if (connectionId && connectionId != item.connectionId)\n        continue;\n      result.push(item);\n    }\n    return result;\n  }\n  put(item) {\n    if (item.action === \"enter\" || item.action === \"update\") {\n      item = fromValues2(item);\n      item.action = \"present\";\n    }\n    const map = this.map, key = this.memberKey(item);\n    if (this.residualMembers)\n      delete this.residualMembers[key];\n    const existingItem = map[key];\n    if (existingItem && !newerThan(item, existingItem)) {\n      return false;\n    }\n    map[key] = item;\n    return true;\n  }\n  values() {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  remove(item) {\n    const map = this.map, key = this.memberKey(item);\n    const existingItem = map[key];\n    if (existingItem && !newerThan(item, existingItem)) {\n      return false;\n    }\n    if (this.syncInProgress) {\n      item = fromValues2(item);\n      item.action = \"absent\";\n      map[key] = item;\n    } else {\n      delete map[key];\n    }\n    return true;\n  }\n  startSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.startSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!this.syncInProgress) {\n      this.residualMembers = copy(map);\n      this.setInProgress(true);\n    }\n  }\n  endSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.endSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (syncInProgress) {\n      for (const memberKey in map) {\n        const entry = map[memberKey];\n        if (entry.action === \"absent\") {\n          delete map[memberKey];\n        }\n      }\n      this.presence._synthesizeLeaves(valuesArray(this.residualMembers));\n      for (const memberKey in this.residualMembers) {\n        delete map[memberKey];\n      }\n      this.residualMembers = null;\n      this.setInProgress(false);\n    }\n    this.emit(\"sync\");\n  }\n  waitSync(callback) {\n    const syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.waitSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!syncInProgress) {\n      callback();\n      return;\n    }\n    this.once(\"sync\", callback);\n  }\n  clear() {\n    this.map = {};\n    this.setInProgress(false);\n    this.residualMembers = null;\n  }\n  setInProgress(inProgress) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"PresenceMap.setInProgress()\", \"inProgress = \" + inProgress);\n    this.syncInProgress = inProgress;\n    this.presence.syncComplete = !inProgress;\n  }\n};\nvar realtimepresence_default = RealtimePresence;\n\n// src/common/lib/transport/websockettransport.ts\nvar shortName = TransportNames.WebSocket;\nfunction isNodeWebSocket(ws) {\n  return !!ws.on;\n}\nvar WebSocketTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName;\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\n    this.wsHost = params.host;\n  }\n  static isAvailable() {\n    return !!Platform.Config.WebSocket;\n  }\n  createWebSocket(uri, connectParams) {\n    this.uri = uri + toQueryString(connectParams);\n    return new Platform.Config.WebSocket(this.uri);\n  }\n  toString() {\n    return \"WebSocketTransport; uri=\" + this.uri;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const self2 = this, params = this.params, options = params.options;\n    const wsScheme = options.tls ? \"wss://\" : \"ws://\";\n    const wsUri = wsScheme + this.wsHost + \":\" + defaults_default.getPort(options) + \"/\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"uri: \" + wsUri);\n    whenPromiseSettles(\n      this.auth.getAuthParams(),\n      function(err, authParams) {\n        if (self2.isDisposed) {\n          return;\n        }\n        let paramStr = \"\";\n        for (const param in authParams)\n          paramStr += \" \" + param + \": \" + authParams[param] + \";\";\n        logger_default.logAction(\n          self2.logger,\n          logger_default.LOG_MINOR,\n          \"WebSocketTransport.connect()\",\n          \"authParams:\" + paramStr + \" err: \" + err\n        );\n        if (err) {\n          self2.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams);\n        try {\n          const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function() {\n            self2.onWsOpen();\n          };\n          wsConnection.onclose = function(ev) {\n            self2.onWsClose(ev);\n          };\n          wsConnection.onmessage = function(ev) {\n            self2.onWsData(ev.data);\n          };\n          wsConnection.onerror = function(ev) {\n            self2.onWsError(ev);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            wsConnection.on(\"ping\", function() {\n              self2.onActivity();\n            });\n          }\n        } catch (e) {\n          logger_default.logAction(\n            self2.logger,\n            logger_default.LOG_ERROR,\n            \"WebSocketTransport.connect()\",\n            \"Unexpected exception creating websocket: err = \" + (e.stack || e.message)\n          );\n          self2.disconnect(e);\n        }\n      }\n    );\n  }\n  send(message) {\n    const wsConnection = this.wsConnection;\n    if (!wsConnection) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", \"No socket connection\");\n      return;\n    }\n    try {\n      wsConnection.send(\n        serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format)\n      );\n    } catch (e) {\n      const msg = \"Exception from ws connection when trying to send: \" + inspectError(e);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", msg);\n      this.finish(\"disconnected\", new ErrorInfo(msg, 5e4, 500));\n    }\n  }\n  onWsData(data) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"WebSocketTransport.onWsData()\",\n      \"data received; length = \" + data.length + \"; type = \" + typeof data\n    );\n    try {\n      this.onProtocolMessage(\n        deserialize(\n          data,\n          this.connectionManager.realtime._MsgPack,\n          this.connectionManager.realtime._RealtimePresence,\n          this.format\n        )\n      );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"WebSocketTransport.onWsData()\",\n        \"Unexpected exception handing channel message: \" + e.stack\n      );\n    }\n  }\n  onWsOpen() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsOpen()\", \"opened WebSocket\");\n    this.emit(\"preconnect\");\n  }\n  onWsClose(ev) {\n    let wasClean, code;\n    if (typeof ev == \"object\") {\n      code = ev.code;\n      wasClean = ev.wasClean || code === 1e3;\n    } else {\n      code = ev;\n      wasClean = code == 1e3;\n    }\n    delete this.wsConnection;\n    if (wasClean) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", \"Cleanly closed WebSocket\");\n      const err = new ErrorInfo(\"Websocket closed\", 80003, 400);\n      this.finish(\"disconnected\", err);\n    } else {\n      const msg = \"Unclean disconnection of WebSocket ; code = \" + code, err = new ErrorInfo(msg, 80003, 400);\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", msg);\n      this.finish(\"disconnected\", err);\n    }\n    this.emit(\"disposed\");\n  }\n  onWsError(err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"WebSocketTransport.onError()\",\n      \"Error from WebSocket: \" + err.message\n    );\n    Platform.Config.nextTick(() => {\n      this.disconnect(Error(err.message));\n    });\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.dispose()\", \"\");\n    this.isDisposed = true;\n    const wsConnection = this.wsConnection;\n    if (wsConnection) {\n      wsConnection.onmessage = function() {\n      };\n      delete this.wsConnection;\n      Platform.Config.nextTick(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"WebSocketTransport.dispose()\", \"closing websocket\");\n        if (!wsConnection) {\n          throw new Error(\"WebSocketTransport.dispose(): wsConnection is not defined\");\n        }\n        wsConnection.close();\n      });\n    }\n  }\n};\nvar websockettransport_default = WebSocketTransport;\n\n// src/common/lib/client/filteredsubscriptions.ts\nvar FilteredSubscriptions = class {\n  static subscribeFilter(channel, filter, listener) {\n    const filteredListener = (m) => {\n      var _a2, _b, _c, _d, _e, _f;\n      const mapping = {\n        name: m.name,\n        refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,\n        refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,\n        isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),\n        clientId: m.clientId\n      };\n      if (Object.entries(filter).find(\n        ([key, value]) => value !== void 0 ? mapping[key] !== value : false\n      )) {\n        return;\n      }\n      listener(m);\n    };\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\n    channel.subscriptions.on(filteredListener);\n  }\n  // Adds a new filtered subscription\n  static addFilteredSubscription(channel, filter, realListener, filteredListener) {\n    var _a2;\n    if (!channel.filteredSubscriptions) {\n      channel.filteredSubscriptions = /* @__PURE__ */ new Map();\n    }\n    if (channel.filteredSubscriptions.has(realListener)) {\n      const realListenerMap = channel.filteredSubscriptions.get(realListener);\n      realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);\n    } else {\n      channel.filteredSubscriptions.set(\n        realListener,\n        /* @__PURE__ */ new Map([[filter, [filteredListener]]])\n      );\n    }\n  }\n  static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {\n    if (!channel.filteredSubscriptions) {\n      return [];\n    }\n    if (!realListener && filter) {\n      return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {\n        var _a2;\n        let listenerMaps = filterMaps.get(filter);\n        filterMaps.delete(filter);\n        if (filterMaps.size === 0) {\n          (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);\n        }\n        return listenerMaps;\n      }).reduce(\n        (prev, cur) => cur ? prev.concat(...cur) : prev,\n        []\n      );\n    }\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n      return [];\n    }\n    const realListenerMap = channel.filteredSubscriptions.get(realListener);\n    if (!filter) {\n      const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n      channel.filteredSubscriptions.delete(realListener);\n      return listeners2;\n    }\n    let listeners = realListenerMap.get(filter);\n    realListenerMap.delete(filter);\n    return listeners || [];\n  }\n};\n\n// src/common/lib/client/defaultrealtime.ts\nvar _DefaultRealtime = class _DefaultRealtime extends baserealtime_default {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2;\n    const MsgPack = _DefaultRealtime._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRealtime._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Realtime\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRealtime.Crypto) != null ? _a2 : void 0,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence: realtimepresence_default,\n          presenceMessageFromValues: fromValues2,\n          presenceMessagesFromValuesArray: fromValuesArray2\n        },\n        WebSocketTransport: websockettransport_default,\n        MessageInteractions: FilteredSubscriptions\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRealtime.Utils = utils_exports;\n_DefaultRealtime.ConnectionManager = connectionmanager_default;\n_DefaultRealtime.ProtocolMessage = protocolmessage_default;\n_DefaultRealtime._Crypto = null;\n_DefaultRealtime.Message = DefaultMessage;\n_DefaultRealtime.PresenceMessage = DefaultPresenceMessage;\n_DefaultRealtime._MsgPack = null;\n// Used by tests\n_DefaultRealtime._Http = Http;\nvar DefaultRealtime = _DefaultRealtime;\n\n// src/platform/nodejs/lib/util/bufferutils.ts\nvar import_crypto = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar BufferUtils = class {\n  constructor() {\n    this.base64CharSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    this.hexCharSet = \"0123456789abcdef\";\n  }\n  base64Decode(string) {\n    return Buffer.from(string, \"base64\");\n  }\n  base64Encode(buffer) {\n    return this.toBuffer(buffer).toString(\"base64\");\n  }\n  areBuffersEqual(buffer1, buffer2) {\n    if (!buffer1 || !buffer2)\n      return false;\n    return this.toBuffer(buffer1).compare(this.toBuffer(buffer2)) == 0;\n  }\n  byteLength(buffer) {\n    return buffer.byteLength;\n  }\n  hexDecode(string) {\n    return Buffer.from(string, \"hex\");\n  }\n  hexEncode(buffer) {\n    return this.toBuffer(buffer).toString(\"hex\");\n  }\n  /* In node, BufferUtils methods that return binary objects return a Buffer\n   * for historical reasons; the browser equivalents return ArrayBuffers */\n  isBuffer(buffer) {\n    return Buffer.isBuffer(buffer) || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n  toArrayBuffer(buffer) {\n    const nodeBuffer = this.toBuffer(buffer);\n    return nodeBuffer.buffer.slice(nodeBuffer.byteOffset, nodeBuffer.byteOffset + nodeBuffer.byteLength);\n  }\n  toBuffer(buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return Buffer.from(buffer);\n    }\n    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  }\n  arrayBufferViewToBuffer(arrayBufferView) {\n    return this.toBuffer(arrayBufferView);\n  }\n  utf8Decode(buffer) {\n    if (!this.isBuffer(buffer)) {\n      throw new Error(\"Expected input of utf8Decode to be a buffer, arraybuffer, or view\");\n    }\n    return this.toBuffer(buffer).toString(\"utf8\");\n  }\n  utf8Encode(string) {\n    return Buffer.from(string, \"utf8\");\n  }\n  hmacSha256(message, key) {\n    const messageBuffer = this.toBuffer(message);\n    const keyBuffer = this.toBuffer(key);\n    const hmac2 = import_crypto.default.createHmac(\"SHA256\", keyBuffer);\n    hmac2.update(messageBuffer);\n    return hmac2.digest();\n  }\n};\nvar bufferutils_default = new BufferUtils();\n\n// src/platform/nodejs/lib/util/crypto.ts\nvar import_crypto2 = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_util = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar createCryptoClass = function(bufferUtils) {\n  var DEFAULT_ALGORITHM = \"aes\";\n  var DEFAULT_KEYLENGTH = 256;\n  var DEFAULT_MODE = \"cbc\";\n  var DEFAULT_BLOCKLENGTH = 16;\n  async function generateRandom(bytes) {\n    return import_util.default.promisify(import_crypto2.default.randomBytes)(bytes);\n  }\n  function getPaddedLength(plaintextLength) {\n    return plaintextLength + DEFAULT_BLOCKLENGTH & -DEFAULT_BLOCKLENGTH;\n  }\n  function validateCipherParams(params) {\n    if (params.algorithm === \"aes\" && params.mode === \"cbc\") {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        \"Unsupported key length \" + params.keyLength + \" for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)\"\n      );\n    }\n  }\n  function normaliseBase64(string) {\n    return string.replace(\"_\", \"/\").replace(\"-\", \"+\");\n  }\n  function filledBuffer(length, value) {\n    var result = Buffer.alloc(length);\n    result.fill(value);\n    return result;\n  }\n  var pkcs5Padding = [filledBuffer(16, 16)];\n  for (var i = 1; i <= 16; i++)\n    pkcs5Padding.push(filledBuffer(i, i));\n  class CipherParams {\n    constructor(algorithm, keyLength, mode, key) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n      this.iv = null;\n    }\n  }\n  function isInstCipherParams(params) {\n    return !!(params.algorithm && params.key && params.keyLength && params.mode);\n  }\n  class Crypto2 {\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params) {\n      var key;\n      if (!params.key) {\n        throw new Error(\"Crypto.getDefaultParams: a key is required\");\n      }\n      if (typeof params.key === \"string\") {\n        key = bufferUtils.base64Decode(normaliseBase64(params.key));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = Buffer.from(params.key);\n      } else {\n        key = params.key;\n      }\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.length * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          \"Crypto.getDefaultParams: a keyLength of \" + params.keyLength + \" was specified, but the key actually has length \" + cipherParams.keyLength\n        );\n      }\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as a Buffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength) {\n      try {\n        return generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8);\n      } catch (err) {\n        throw new ErrorInfo(\"Failed to generate random key: \" + err.message, 500, 5e4, err);\n      }\n    }\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params, logger) {\n      var _a2;\n      var cipherParams = isInstCipherParams(params) ? params : this.getDefaultParams(params);\n      return {\n        cipherParams,\n        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null, logger)\n      };\n    }\n  }\n  Crypto2.CipherParams = CipherParams;\n  Crypto2;\n  class CBCCipher {\n    constructor(params, iv, logger) {\n      this.logger = logger;\n      this.encryptCipher = null;\n      this.algorithm = params.algorithm + \"-\" + String(params.keyLength) + \"-\" + params.mode;\n      this.key = params.key;\n      this.iv = iv;\n    }\n    async encrypt(plaintext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.encrypt()\", \"\");\n      const iv = await this.getIv();\n      if (!this.encryptCipher) {\n        this.encryptCipher = import_crypto2.default.createCipheriv(this.algorithm, this.key, iv);\n      }\n      var plaintextBuffer = bufferUtils.toBuffer(plaintext);\n      var plaintextLength = plaintextBuffer.length, paddedLength = getPaddedLength(plaintextLength);\n      var cipherOut = this.encryptCipher.update(\n        Buffer.concat([plaintextBuffer, pkcs5Padding[paddedLength - plaintextLength]])\n      );\n      var ciphertext = Buffer.concat([iv, cipherOut]);\n      return ciphertext;\n    }\n    async decrypt(ciphertext) {\n      var decryptCipher = import_crypto2.default.createDecipheriv(this.algorithm, this.key, ciphertext.slice(0, DEFAULT_BLOCKLENGTH)), plaintext = decryptCipher.update(ciphertext.slice(DEFAULT_BLOCKLENGTH)), final = decryptCipher.final();\n      if (final && final.length)\n        plaintext = Buffer.concat([plaintext, final]);\n      return plaintext;\n    }\n    async getIv() {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        return iv;\n      }\n      var randomBlock = await generateRandom(DEFAULT_BLOCKLENGTH);\n      if (!this.encryptCipher) {\n        return randomBlock;\n      } else {\n        return this.encryptCipher.update(randomBlock);\n      }\n    }\n  }\n  return Crypto2;\n};\n\n// src/platform/nodejs/lib/util/http.ts\nvar import_got = __toESM(__webpack_require__(/*! got */ \"(ssr)/./node_modules/got/dist/source/index.js\"));\nvar import_http5 = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar import_https = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar globalAgentPool = [];\nvar _a;\nvar Http2 = (_a = class {\n  constructor(client) {\n    this.agent = null;\n    this.supportsAuthHeaders = true;\n    this.supportsLinkHeaders = true;\n    this.checkConnectivity = async () => {\n      var _a2, _b, _c, _d, _e;\n      if ((_a2 = this.client) == null ? void 0 : _a2.options.disableConnectivityCheck) {\n        return true;\n      }\n      const connectivityCheckUrl = ((_b = this.client) == null ? void 0 : _b.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;\n      const connectivityCheckParams = (_d = (_c = this.client) == null ? void 0 : _c.options.connectivityCheckParams) != null ? _d : null;\n      const connectivityUrlIsDefault = !((_e = this.client) == null ? void 0 : _e.options.connectivityCheckUrl);\n      const { error, statusCode, body } = await this.doUri(\n        HttpMethods_default.Get,\n        connectivityCheckUrl,\n        null,\n        null,\n        connectivityCheckParams\n      );\n      if (!error && !connectivityUrlIsDefault) {\n        return isSuccessCode(statusCode);\n      }\n      return !error && (body == null ? void 0 : body.toString().trim()) === \"yes\";\n    };\n    this.client = client != null ? client : null;\n  }\n  async doUri(method, uri, headers, body, params) {\n    var _a2;\n    const agentOptions = this.client && this.client.options.restAgentOptions || defaults_default.restAgentOptions;\n    const doOptions = { headers: headers || void 0, responseType: \"buffer\" };\n    if (!this.agent) {\n      const persistedAgent = (_a2 = globalAgentPool.find((x) => shallowEquals(agentOptions, x.options))) == null ? void 0 : _a2.agents;\n      if (persistedAgent) {\n        this.agent = persistedAgent;\n      } else {\n        this.agent = {\n          http: new import_http5.default.Agent(agentOptions),\n          https: new import_https.default.Agent(agentOptions)\n        };\n        globalAgentPool.push({\n          options: agentOptions,\n          agents: this.agent\n        });\n      }\n    }\n    if (body) {\n      doOptions.body = body;\n    }\n    if (params)\n      doOptions.searchParams = params;\n    doOptions.agent = this.agent;\n    doOptions.url = uri;\n    doOptions.timeout = {\n      request: (this.client && this.client.options.timeouts || defaults_default.TIMEOUTS).httpRequestTimeout\n    };\n    doOptions.retry = { limit: 0 };\n    try {\n      const res = await import_got.default[method](doOptions);\n      return this._handler(null, res, res.body);\n    } catch (err) {\n      if (err instanceof import_got.default.HTTPError) {\n        return this._handler(null, err.response, err.response.body);\n      }\n      return this._handler(err);\n    }\n  }\n  shouldFallback(err) {\n    const { code, statusCode } = err;\n    return code === \"ENETUNREACH\" || code === \"EHOSTUNREACH\" || code === \"EHOSTDOWN\" || code === \"ETIMEDOUT\" || code === \"ESOCKETTIMEDOUT\" || code === \"ENOTFOUND\" || code === \"ECONNRESET\" || code === \"ECONNREFUSED\" || statusCode >= 500 && statusCode <= 504;\n  }\n  _handler(err, response, body) {\n    var _a2;\n    if (err) {\n      return { error: err };\n    }\n    const statusCode = response.statusCode, headers = response.headers;\n    if (statusCode >= 300) {\n      switch (headers[\"content-type\"]) {\n        case \"application/json\":\n          body = JSON.parse(body);\n          break;\n        case \"application/x-msgpack\":\n          if (!((_a2 = this.client) == null ? void 0 : _a2._MsgPack)) {\n            return { error: createMissingPluginError(\"MsgPack\") };\n          }\n          body = this.client._MsgPack.decode(body);\n          break;\n      }\n      const error = body.error ? ErrorInfo.fromValues(body.error) : new ErrorInfo(\n        headers[\"x-ably-errormessage\"] || \"Error response received from server: \" + statusCode + \" body was: \" + Platform.Config.inspect(body),\n        Number(headers[\"x-ably-errorcode\"]),\n        statusCode\n      );\n      return { error, body, headers, unpacked: true, statusCode };\n    }\n    return { error: null, body, headers, unpacked: false, statusCode };\n  }\n}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);\nvar http_default = Http2;\n\n// src/platform/nodejs/config.ts\nvar import_crypto3 = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_ws = __toESM(__webpack_require__(/*! ws */ \"(ssr)/./node_modules/ably/node_modules/ws/index.js\"));\nvar import_util2 = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar Config = {\n  agent: \"nodejs/\" + process.versions.node,\n  logTimestamps: true,\n  userAgent: null,\n  binaryType: \"nodebuffer\",\n  WebSocket: import_ws.default,\n  useProtocolHeartbeats: false,\n  supportsBinary: true,\n  preferBinary: true,\n  nextTick: process.nextTick,\n  inspect: import_util2.default.inspect,\n  stringByteSize: Buffer.byteLength,\n  inherits: import_util2.default.inherits,\n  addEventListener: null,\n  getRandomArrayBuffer: async function(byteLength) {\n    return import_util2.default.promisify(import_crypto3.default.randomBytes)(byteLength);\n  }\n};\nvar config_default = Config;\n\n// src/common/constants/XHRStates.ts\nvar XHRStates = /* @__PURE__ */ ((XHRStates2) => {\n  XHRStates2[XHRStates2[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n  XHRStates2[XHRStates2[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n  XHRStates2[XHRStates2[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n  XHRStates2[XHRStates2[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n  return XHRStates2;\n})(XHRStates || {});\nvar XHRStates_default = XHRStates;\n\n// src/common/lib/transport/comettransport.ts\nfunction shouldBeErrorAction(err) {\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n  if (err.code) {\n    if (auth_default.isTokenErr(err))\n      return false;\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code))\n      return true;\n    return err.code >= 4e4 && err.code < 5e4;\n  } else {\n    return false;\n  }\n}\nfunction protocolMessageFromRawError(err) {\n  if (shouldBeErrorAction(err)) {\n    return [fromValues3({ action: actions2.ERROR, error: err })];\n  } else {\n    return [fromValues3({ action: actions2.DISCONNECTED, error: err })];\n  }\n}\nvar CometTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(\n      connectionManager,\n      auth,\n      params,\n      /* binary not supported for comet so force JSON protocol */\n      true\n    );\n    /* Historical comment, back from when we supported JSONP:\n     *\n     * > For comet, we could do the auth update by aborting the current recv and\n     * > starting a new one with the new token, that'd be sufficient for realtime.\n     * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n     * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n     * > comet transports the same and do it for all of them. So we send the AUTH\n     * > instead, and don't need to abort the recv\n     *\n     * Now that weâ€™ve dropped JSONP support, we may be able to revisit the above;\n     * see https://github.com/ably/ably-js/issues/1214.\n     */\n    this.onAuthUpdated = (tokenDetails) => {\n      this.authParams = { access_token: tokenDetails.token };\n    };\n    this.stream = \"stream\" in params ? params.stream : true;\n    this.sendRequest = null;\n    this.recvRequest = null;\n    this.pendingCallback = null;\n    this.pendingItems = null;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const params = this.params;\n    const options = params.options;\n    const host = defaults_default.getHost(options, params.host);\n    const port = defaults_default.getPort(options);\n    const cometScheme = options.tls ? \"https://\" : \"http://\";\n    this.baseUri = cometScheme + host + \":\" + port + \"/comet/\";\n    const connectUri = this.baseUri + \"connect\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"uri: \" + connectUri);\n    whenPromiseSettles(this.auth.getAuthParams(), (err, authParams) => {\n      if (err) {\n        this.disconnect(err);\n        return;\n      }\n      if (this.isDisposed) {\n        return;\n      }\n      this.authParams = authParams;\n      const connectParams = this.params.getConnectParams(authParams);\n      if (\"stream\" in connectParams)\n        this.stream = connectParams.stream;\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"CometTransport.connect()\",\n        \"connectParams:\" + toQueryString(connectParams)\n      );\n      let preconnected = false;\n      const connectRequest = this.recvRequest = this.createRequest(\n        connectUri,\n        null,\n        connectParams,\n        null,\n        this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV\n      );\n      connectRequest.on(\"data\", (data) => {\n        if (!this.recvRequest) {\n          return;\n        }\n        if (!preconnected) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onData(data);\n      });\n      connectRequest.on(\"complete\", (err2) => {\n        if (!this.recvRequest) {\n          err2 = err2 || new ErrorInfo(\"Request cancelled\", 80003, 400);\n        }\n        this.recvRequest = null;\n        if (!preconnected && !err2) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onActivity();\n        if (err2) {\n          if (err2.code) {\n            this.onData(protocolMessageFromRawError(err2));\n          } else {\n            this.disconnect(err2);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      connectRequest.exec();\n    });\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestClose()\");\n    this._requestCloseOrDisconnect(true);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestDisconnect()\");\n    this._requestCloseOrDisconnect(false);\n  }\n  _requestCloseOrDisconnect(closing) {\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n    if (closeOrDisconnectUri) {\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);\n      request.on(\"complete\", (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"CometTransport.request\" + (closing ? \"Close()\" : \"Disconnect()\"),\n            \"request returned err = \" + inspectError(err)\n          );\n          this.finish(\"disconnected\", err);\n        }\n      });\n      request.exec();\n    }\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"\");\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      if (this.recvRequest) {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"aborting recv request\");\n        this.recvRequest.abort();\n        this.recvRequest = null;\n      }\n      this.finish(\"disconnected\", connectionerrors_default.disconnected());\n      Platform.Config.nextTick(() => {\n        this.emit(\"disposed\");\n      });\n    }\n  }\n  onConnect(message) {\n    var _a2;\n    if (this.isDisposed) {\n      return;\n    }\n    const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;\n    transport_default.prototype.onConnect.call(this, message);\n    const baseConnectionUri = this.baseUri + connectionStr;\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CometTransport.onConnect()\", \"baseUri = \" + baseConnectionUri);\n    this.sendUri = baseConnectionUri + \"/send\";\n    this.recvUri = baseConnectionUri + \"/recv\";\n    this.closeUri = baseConnectionUri + \"/close\";\n    this.disconnectUri = baseConnectionUri + \"/disconnect\";\n  }\n  send(message) {\n    if (this.sendRequest) {\n      this.pendingItems = this.pendingItems || [];\n      this.pendingItems.push(message);\n      return;\n    }\n    const pendingItems = this.pendingItems || [];\n    pendingItems.push(message);\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendAnyPending() {\n    const pendingItems = this.pendingItems;\n    if (!pendingItems) {\n      return;\n    }\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendItems(items) {\n    const sendRequest = this.sendRequest = this.createRequest(\n      this.sendUri,\n      null,\n      this.authParams,\n      this.encodeRequest(items),\n      XHRStates_default.REQ_SEND\n    );\n    sendRequest.on(\"complete\", (err, data) => {\n      if (err)\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"CometTransport.sendItems()\",\n          \"on complete: err = \" + inspectError(err)\n        );\n      this.sendRequest = null;\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      if (data) {\n        this.onData(data);\n      }\n      if (this.pendingItems) {\n        Platform.Config.nextTick(() => {\n          if (!this.sendRequest) {\n            this.sendAnyPending();\n          }\n        });\n      }\n    });\n    sendRequest.exec();\n  }\n  recv() {\n    if (this.recvRequest)\n      return;\n    if (!this.isConnected)\n      return;\n    const recvRequest = this.recvRequest = this.createRequest(\n      this.recvUri,\n      null,\n      this.authParams,\n      null,\n      this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL\n    );\n    recvRequest.on(\"data\", (data) => {\n      this.onData(data);\n    });\n    recvRequest.on(\"complete\", (err) => {\n      this.recvRequest = null;\n      this.onActivity();\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      Platform.Config.nextTick(() => {\n        this.recv();\n      });\n    });\n    recvRequest.exec();\n  }\n  onData(responseData) {\n    try {\n      const items = this.decodeResponse(responseData);\n      if (items && items.length)\n        for (let i = 0; i < items.length; i++)\n          this.onProtocolMessage(\n            fromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence)\n          );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"CometTransport.onData()\",\n        \"Unexpected exception handing channel event: \" + e.stack\n      );\n    }\n  }\n  encodeRequest(requestItems) {\n    return JSON.stringify(requestItems);\n  }\n  decodeResponse(responseData) {\n    if (typeof responseData == \"string\")\n      return JSON.parse(responseData);\n    return responseData;\n  }\n};\nvar comettransport_default = CometTransport;\n\n// src/platform/nodejs/lib/transport/nodecomettransport.js\nvar import_http6 = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar import_https2 = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar import_url = __toESM(__webpack_require__(/*! url */ \"url\"));\nvar import_util3 = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar noop3 = function() {\n};\nvar shortName2 = TransportNames.Comet;\nvar NodeCometTransport = class extends comettransport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.httpAgent = null;\n    this.httpsAgent = null;\n    this.pendingRequests = 0;\n    this.shortName = shortName2;\n  }\n  static isAvailable() {\n    return true;\n  }\n  toString() {\n    return \"NodeCometTransport; uri=\" + this.baseUri + \"; isConnected=\" + this.isConnected + \"; format=\" + this.format + \"; stream=\" + this.stream;\n  }\n  getAgent(tls) {\n    var prop = tls ? \"httpsAgent\" : \"httpAgent\", agent2 = this[prop];\n    if (!agent2)\n      agent2 = this[prop] = new (tls ? import_https2.default : import_http6.default).Agent({ keepAlive: true });\n    return agent2;\n  }\n  dispose() {\n    var self2 = this;\n    this.onceNoPending(function() {\n      if (self2.httpAgent)\n        self2.httpAgent.destroy();\n      if (self2.httpsAgent)\n        self2.httpsAgent.destroy();\n    });\n    comettransport_default.prototype.dispose.call(this);\n  }\n  /* valid in non-streaming mode only, or data only contains last update */\n  request(uri, params, body, requestMode, callback) {\n    var req = this.createRequest(uri, params, body, requestMode);\n    req.once(\"complete\", callback);\n    req.exec();\n    return req;\n  }\n  createRequest(uri, headers, params, body, requestMode) {\n    return new Request(uri, headers, params, body, requestMode, this.format, this.timeouts, this);\n  }\n  addPending() {\n    ++this.pendingRequests;\n  }\n  removePending() {\n    if (--this.pendingRequests <= 0) {\n      this.emit(\"nopending\");\n    }\n  }\n  onceNoPending(listener) {\n    if (this.pendingRequests == 0) {\n      listener();\n      return;\n    }\n    this.once(\"nopending\", listener);\n  }\n};\nvar Request = class extends eventemitter_default {\n  constructor(uri, headers, params, body, requestMode, format, timeouts, transport) {\n    super(transport.logger);\n    if (typeof uri == \"string\")\n      uri = import_url.default.parse(uri);\n    var tls = uri.protocol == \"https:\";\n    this.client = tls ? import_https2.default : import_http6.default;\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.transport = transport;\n    this.requestComplete = false;\n    this.req = this.res = null;\n    var method = \"GET\", contentType = format == \"msgpack\" ? \"application/x-msgpack\" : \"application/json\";\n    headers = headers ? mixin({}, headers) : {};\n    headers[\"accept\"] = contentType;\n    if (body) {\n      method = \"POST\";\n      if (!Buffer.isBuffer(body)) {\n        if (typeof body == \"object\")\n          body = JSON.stringify(body);\n        body = Buffer.from(body);\n      }\n      this.body = body;\n      headers[\"Content-Length\"] = body.length;\n      headers[\"Content-Type\"] = contentType;\n    }\n    var requestOptions = this.requestOptions = {\n      hostname: uri.hostname,\n      port: uri.port,\n      path: uri.path + toQueryString(params),\n      method,\n      headers\n    };\n    if (transport)\n      requestOptions.agent = transport.getAgent(tls);\n  }\n  exec() {\n    var timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, self2 = this;\n    var timer = this.timer = setTimeout(function() {\n      self2.abort();\n    }, timeout), req = this.req = this.client.request(this.requestOptions);\n    req.on(\n      \"error\",\n      this.onReqError = function(err) {\n        err = new PartialErrorInfo(\"Request error: \" + err.message, null, 400);\n        clearTimeout(timer);\n        self2.timer = null;\n        self2.complete(err);\n      }\n    );\n    req.on(\"response\", function(res) {\n      clearTimeout(timer);\n      self2.timer = null;\n      var statusCode = res.statusCode;\n      if (statusCode == HttpStatusCodes_default.NoContent) {\n        res.resume();\n        self2.complete();\n        return;\n      }\n      res.on(\n        \"error\",\n        self2.onResError = function(err) {\n          err = new PartialErrorInfo(\"Response error: \" + err.message, null, 400);\n          self2.complete(err);\n        }\n      );\n      self2.res = res;\n      if (self2.requestMode == XHRStates_default.REQ_RECV_STREAM && statusCode < 400) {\n        self2.readStream();\n      } else {\n        self2.readFully();\n      }\n    });\n    if (this.transport)\n      this.transport.addPending();\n    req.end(this.body);\n  }\n  readStream() {\n    var res = this.res, self2 = this;\n    this.chunks = [];\n    this.streamComplete = false;\n    function onChunk(chunk) {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        var msg = \"Malformed response body from server: \" + e.message;\n        logger_default.logAction(self2.logger, logger_default.LOG_ERROR, \"NodeCometTransport.Request.readStream()\", msg);\n        self2.complete(new PartialErrorInfo(msg, null, 400));\n        return;\n      }\n      self2.emit(\"data\", chunk);\n    }\n    res.on(\n      \"data\",\n      this.ondata = function(data) {\n        var newChunks = String(data).split(\"\\n\"), chunks = self2.chunks;\n        if (newChunks.length > 1 && chunks.length > 0) {\n          chunks.push(newChunks.shift());\n          self2.chunks = [];\n          onChunk(chunks.join(\"\"));\n        }\n        var trailingNewChunk = newChunks.pop();\n        if (trailingNewChunk.length) {\n          self2.chunks.push(trailingNewChunk);\n        }\n        newChunks.map(onChunk);\n      }\n    );\n    res.on(\"end\", function() {\n      self2.streamComplete = true;\n      process.nextTick(function() {\n        self2.complete();\n      });\n    });\n  }\n  readFully() {\n    var res = this.res, chunks = [], self2 = this;\n    res.on(\"data\", function(chunk) {\n      chunks.push(chunk);\n    });\n    res.on(\"end\", function() {\n      process.nextTick(function() {\n        var body = Buffer.concat(chunks), statusCode = res.statusCode;\n        try {\n          body = JSON.parse(String(body));\n        } catch (e) {\n          var msg = \"Malformed response body from server: \" + e.message;\n          logger_default.logAction(self2.logger, logger_default.LOG_ERROR, \"NodeCometTransport.Request.readFully()\", msg);\n          self2.complete(new PartialErrorInfo(msg, null, 400));\n          return;\n        }\n        if (statusCode < 400 || Array.isArray(body)) {\n          self2.complete(null, body);\n          return;\n        }\n        var err = body.error && ErrorInfo.fromValues(body.error);\n        if (!err) {\n          err = new PartialErrorInfo(\n            \"Error response received from server: \" + statusCode + \", body was: \" + import_util3.default.inspect(body),\n            null,\n            statusCode\n          );\n        }\n        self2.complete(err);\n      });\n    });\n  }\n  complete(err, body) {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (body)\n        this.emit(\"data\", body);\n      this.emit(\"complete\", err, body);\n      if (err) {\n        if (this.ondata && !this.streamComplete) {\n          if (this.ondata && this.res)\n            this.res.removeListener(\"data\", this.ondata);\n        }\n      }\n      if (this.transport) {\n        this.transport.removePending();\n      }\n    }\n  }\n  abort() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"NodeCometTransport.Request.abort()\", \"\");\n    var timer = this.timer;\n    if (timer) {\n      clearTimeout(timer);\n      this.timer = null;\n    }\n    var req = this.req;\n    if (req) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"NodeCometTransport.Request.abort()\", \"aborting request\");\n      req.removeListener(\"error\", this.onReqError);\n      req.on(\"error\", noop3);\n      req.abort();\n      this.req = null;\n    }\n    this.complete({ statusCode: 400, code: 80003, message: \"Cancelled\" });\n  }\n};\nvar nodecomettransport_default = NodeCometTransport;\n\n// src/platform/nodejs/lib/transport/index.ts\nvar transport_default2 = {\n  order: [TransportNames.Comet],\n  bundledImplementations: {\n    [TransportNames.WebSocket]: websockettransport_default,\n    [TransportNames.Comet]: nodecomettransport_default\n  }\n};\n\n// src/platform/nodejs/lib/util/defaults.ts\nvar Defaults2 = {\n  connectivityCheckUrl: \"https://internet-up.ably-realtime.com/is-the-internet-up.txt\",\n  wsConnectivityUrl: \"wss://ws-up.ably-realtime.com\",\n  /* Note: order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's supported. */\n  defaultTransports: [TransportNames.WebSocket],\n  restAgentOptions: { maxSockets: 40, keepAlive: true }\n};\nvar defaults_default2 = Defaults2;\n\n// src/platform/nodejs/index.ts\nvar msgpack = require_msgpack();\nvar Crypto = createCryptoClass(bufferutils_default);\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = bufferutils_default;\nPlatform.Http = http_default;\nPlatform.Config = config_default;\nPlatform.Transports = transport_default2;\nPlatform.WebStorage = null;\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\n  clientClass.Crypto = Crypto;\n  clientClass._MsgPack = msgpack;\n}\nlogger_default.initLogHandlers();\nPlatform.Defaults = getDefaults(defaults_default2);\nif (Platform.Config.agent) {\n  Platform.Defaults.agent += \" \" + Platform.Config.agent;\n}\nmodule.exports = {\n  ErrorInfo,\n  Rest: DefaultRest,\n  Realtime: DefaultRealtime,\n  msgpack: null,\n  protocolMessageFromDeserialized: fromDeserializedIncludingDependencies\n};\nif (typeof module.exports == \"object\" && typeof exports == \"object\") {\n  var __cp = (to, from, except, desc) => {\n    if ((from && typeof from === \"object\") || typeof from === \"function\") {\n      for (let key of Object.getOwnPropertyNames(from)) {\n        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)\n        Object.defineProperty(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,\n        });\n      }\n    }\n    return to;\n  };\n  module.exports = __cp(module.exports, exports);\n}\nreturn module.exports;\n}))\n//# sourceMappingURL=ably-node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9idWlsZC9hYmx5LW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBdUQ7QUFDL0QseUJBQXlCLG1CQUFPLENBQUMsOERBQUksR0FBRyxtQkFBTyxDQUFDLDBEQUFLO0FBQ3JELE1BQU0sS0FBSyxFQU1OO0FBQ0wsR0FBRztBQUNIO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQXdCO0FBQzFDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQXdCO0FBQzFDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGtCQUFrQixtQ0FBbUMsT0FBTztBQUN2STtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsa0JBQWtCLHNDQUFzQyxPQUFPO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGtCQUFrQixzQ0FBc0MsT0FBTztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQkFBa0Isc0NBQXNDLE9BQU87QUFDMUk7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYSx5REFBeUQsSUFBSTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLHlDQUF5QyxRQUFRLHVDQUF1QyxRQUFRLGdCQUFnQixRQUFRO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVLGNBQWMsUUFBUSxrQ0FBa0MsUUFBUSx1Q0FBdUMsUUFBUSxnQkFBZ0IsUUFBUTtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9RQUFvUSx3QkFBd0I7QUFDNVI7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG1CQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxjQUFjO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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TUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLDZFQUE2RSxtQkFBbUIsVUFBVTtBQUMxRztBQUNBO0FBQ0EsMENBQTBDLDJGQUEyRjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQ0FBcUMsQ0FBVTtBQUNoRTtBQUNBO0FBQ0EsNEJBQTRCLHVDQUF1QztBQUNuRTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RCxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRIO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQTREO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBcUQ7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQsTUFBTTtBQUNOLHlCQUF5Qiw2QkFBNkI7QUFDdEQsTUFBTTtBQUNOLDJFQUEyRTtBQUMzRTtBQUNBLHlCQUF5Qiw2REFBNkQ7QUFDdEYsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5QkFBeUIseUVBQXlFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7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QSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxFQUFFLHFCQUFxQixHQUFHLGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQ0FBb0M7QUFDOUQsSUFBSTtBQUNKLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtB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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9idWlsZC9hYmx5LW5vZGUuanM/ZTNkNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKkBsaWNlbnNlIENvcHlyaWdodCAyMDE1LTIwMjIgQWJseSBSZWFsLXRpbWUgTHRkIChhYmx5LmNvbSlcblxuQWJseSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMy4xXG5odHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzXG5cblJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5jZSB2Mi4wKi8oZnVuY3Rpb24gKGcsIGYpIHtcbiAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZihyZXF1aXJlKCd3cycpLCByZXF1aXJlKCdnb3QnKSk7XG4gICAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoWyd3cycsICdnb3QnXSwgZik7XG4gICAgfSBlbHNlIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzKSB7XG4gICAgICBleHBvcnRzW1wiQWJseVwiXSA9IGYocmVxdWlyZSgnd3MnKSwgcmVxdWlyZSgnZ290JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnW1wiQWJseVwiXSA9IGYoZ1tcIndzXCJdLCBnW1wiZ290XCJdKTtcbiAgICB9XG4gIH0odGhpcywgKF9fZGEsIF9fZGIpID0+IHtcbnZhciBleHBvcnRzID0ge307XG52YXIgbW9kdWxlID0geyBleHBvcnRzIH07XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9mcm9tLmpzXG52YXIgcmVxdWlyZV9mcm9tID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvZnJvbS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICB2YXIgdmVyc2lvbjIgPSAoKHByb2Nlc3MgfHwge30pLnZlcnNpb24gfHwgXCJ2MC4wLjBcIikuc2xpY2UoMSkuc3BsaXQoXCIuXCIpWzBdO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE51bWJlcih2ZXJzaW9uMikgPCA2ID8gZnVuY3Rpb24gZnJvbShzb3VyY2UsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcjIoc291cmNlLCBlbmNvZGluZyk7XG4gICAgfSA6IGZ1bmN0aW9uIGZyb20oc291cmNlLCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIEJ1ZmZlcjIuZnJvbShzb3VyY2UsIGVuY29kaW5nKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvdG8uanNcbnZhciByZXF1aXJlX3RvID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvdG8uanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBzb3VyY2UudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9pcy5qc1xudmFyIHJlcXVpcmVfaXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9pcy5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIyLmlzQnVmZmVyKGJ1ZmZlcik7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL3N1YmFycmF5LmpzXG52YXIgcmVxdWlyZV9zdWJhcnJheSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL3N1YmFycmF5LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihzb3VyY2UsIGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiA/IHNvdXJjZS5zbGljZShmcm9tKSA6IHNvdXJjZS5zbGljZShmcm9tLCB0byk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL2pvaW4uanNcbnZhciByZXF1aXJlX2pvaW4gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9qb2luLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgQnVmZmVyMiA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldHMsIGhpbnQpIHtcbiAgICAgIHJldHVybiBoaW50ICE9PSB2b2lkIDAgPyBCdWZmZXIyLmNvbmNhdCh0YXJnZXRzLCBoaW50KSA6IEJ1ZmZlcjIuY29uY2F0KHRhcmdldHMpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9jb3B5LmpzXG52YXIgcmVxdWlyZV9jb3B5ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvY29weS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY29weTI7XG4gICAgZnVuY3Rpb24gY29weTIoc291cmNlLCB0YXJnZXQsIHRhcmdldF9zdGFydCwgc291cmNlX3N0YXJ0LCBzb3VyY2VfZW5kKSB7XG4gICAgICByZXR1cm4gc291cmNlLmNvcHkodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHNvdXJjZV9zdGFydCwgc291cmNlX2VuZCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvY3JlYXRlLmpzXG52YXIgcmVxdWlyZV9jcmVhdGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9jcmVhdGUuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciBCdWZmZXIyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgdmFyIHZlcnNpb24yID0gKChwcm9jZXNzIHx8IHt9KS52ZXJzaW9uIHx8IFwidjAuMC4wXCIpLnNsaWNlKDEpLnNwbGl0KFwiLlwiKVswXTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBOdW1iZXIodmVyc2lvbjIpIDwgNiA/IGZ1bmN0aW9uIGNyZWF0ZShzaXplKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcjIoc2l6ZSk7XG4gICAgfSA6IGZ1bmN0aW9uIGNyZWF0ZShzaXplKSB7XG4gICAgICByZXR1cm4gQnVmZmVyMi5hbGxvYyhzaXplKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvcmVhZC5qc1xudmFyIHJlcXVpcmVfcmVhZCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL3JlYWQuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciBwcm90byA9IHt9O1xuICAgIHZhciByZXggPSAvcmVhZC4rLztcbiAgICB2YXIgYnVpbGRGbjtcbiAgICBidWlsZEZuID0gZnVuY3Rpb24oa2V5Mikge1xuICAgICAgdmFyIGNvZGUgPSBcInJldHVybiBidWYuXCIgKyBrZXkyICsgXCIoXCIgKyBbXCJhXCIsIFwiYlwiLCBcImNcIl0uam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oW1wiYnVmXCIsIFwiYVwiLCBcImJcIiwgXCJjXCJdLCBjb2RlKTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHByb3RvO1xuICAgIGZvciAoa2V5IGluIEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgIGlmIChyZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHByb3RvW2tleV0gPSBidWlsZEZuKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy93cml0ZS5qc1xudmFyIHJlcXVpcmVfd3JpdGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy93cml0ZS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICB2YXIgcHJvdG8gPSB7fTtcbiAgICB2YXIgcmV4ID0gL3dyaXRlLisvO1xuICAgIHZhciBidWlsZEZuO1xuICAgIGJ1aWxkRm4gPSBmdW5jdGlvbihrZXkyKSB7XG4gICAgICB2YXIgY29kZSA9IFwicmV0dXJuIGJ1Zi5cIiArIGtleTIgKyBcIihcIiArIFtcImFcIiwgXCJiXCIsIFwiY1wiXS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihbXCJidWZcIiwgXCJhXCIsIFwiYlwiLCBcImNcIl0sIGNvZGUpO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcHJvdG87XG4gICAgZm9yIChrZXkgaW4gQnVmZmVyMi5wcm90b3R5cGUpIHtcbiAgICAgIGlmIChyZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHByb3RvW2tleV0gPSBidWlsZEZuKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfYm9wcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgcHJvdG8gPSB7fTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwcm90bztcbiAgICBwcm90by5mcm9tID0gcmVxdWlyZV9mcm9tKCk7XG4gICAgcHJvdG8udG8gPSByZXF1aXJlX3RvKCk7XG4gICAgcHJvdG8uaXMgPSByZXF1aXJlX2lzKCk7XG4gICAgcHJvdG8uc3ViYXJyYXkgPSByZXF1aXJlX3N1YmFycmF5KCk7XG4gICAgcHJvdG8uam9pbiA9IHJlcXVpcmVfam9pbigpO1xuICAgIHByb3RvLmNvcHkgPSByZXF1aXJlX2NvcHkoKTtcbiAgICBwcm90by5jcmVhdGUgPSByZXF1aXJlX2NyZWF0ZSgpO1xuICAgIG1peChyZXF1aXJlX3JlYWQoKSwgcHJvdG8pO1xuICAgIG1peChyZXF1aXJlX3dyaXRlKCksIHByb3RvKTtcbiAgICBmdW5jdGlvbiBtaXgoZnJvbSwgaW50bykge1xuICAgICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgICAgaW50b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AYWJseS9tc2dwYWNrLWpzL21zZ3BhY2suanNcbnZhciByZXF1aXJlX21zZ3BhY2sgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQGFibHkvbXNncGFjay1qcy9tc2dwYWNrLmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYm9wcyA9IHJlcXVpcmVfYm9wcygpO1xuICAgIGV4cG9ydHMyLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBzcGFyc2UpIHtcbiAgICAgIHZhciBzaXplID0gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgaWYgKHNpemUgPT0gMClcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHZhciBidWZmZXIgPSBib3BzLmNyZWF0ZShzaXplKTtcbiAgICAgIGVuY29kZTIodmFsdWUsIGJ1ZmZlciwgMCwgc3BhcnNlKTtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfTtcbiAgICBleHBvcnRzMi5kZWNvZGUgPSBkZWNvZGUzO1xuICAgIHZhciBTSF9MXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpO1xuICAgIHZhciBTSF9SXzMyID0gMSAvIFNIX0xfMzI7XG4gICAgZnVuY3Rpb24gcmVhZEludDY0QkUoYnVmLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkSW50MzJCRShvZmZzZXQgKyAwKSAqIFNIX0xfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVUludDY0QkUoYnVmLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMCkgKiBTSF9MXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICAgIGlmICh2YWwgPCA5MjIzMzcyMDM2ODU0Nzc2ZTMpIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRShNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpLCBvZmZzZXQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKDIxNDc0ODM2NDcsIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKDQyOTQ5NjcyOTUsIG9mZnNldCArIDQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVJbnQ2NEJFKGJ1ZiwgdmFsLCBvZmZzZXQpIHtcbiAgICAgIGlmICh2YWwgPCAxODQ0Njc0NDA3MzcwOTU1MmUzKSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKE1hdGguZmxvb3IodmFsICogU0hfUl8zMiksIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoNDI5NDk2NzI5NSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoNDI5NDk2NzI5NSwgb2Zmc2V0ICsgNCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIERlY29kZXIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgRGVjb2Rlci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoICogMiA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGEgbWFwIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2UoKTtcbiAgICAgICAgdmFsdWVba2V5XSA9IHRoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIERlY29kZXIucHJvdG90eXBlLmJpbiA9IERlY29kZXIucHJvdG90eXBlLmJ1ZiA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGEgYmluYXJ5IG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBib3BzLnN1YmFycmF5KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgRGVjb2Rlci5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID4gdGhpcy5idWZmZXJMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgbWVzc2FnZXBhY2sgZGV0ZWN0ZWQ6IGJ1ZmZlciBzaXplIHdhcyAke3RoaXMuYnVmZmVyTGVuZ3RofSwgYnV0IHJlZmVyZW5jZWQgYSBzdHJpbmcgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGJvcHMudG8oYm9wcy5zdWJhcnJheSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbGVuZ3RoKSk7XG4gICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIG1lc3NhZ2VwYWNrIGRldGVjdGVkOiBidWZmZXIgc2l6ZSB3YXMgJHt0aGlzLmJ1ZmZlckxlbmd0aH0sIGJ1dCByZWZlcmVuY2VkIGFuIGFycmF5IG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSB0aGlzLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLmJ1ZmZlclt0aGlzLm9mZnNldF07XG4gICAgICB2YXIgdmFsdWUsIGxlbmd0aCwgZXh0VHlwZTtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFsZm9ybWVkIG1lc3NhZ2VwYWNrIChyZWZlcmVuY2VkIG9mZnNldCBpcyBvdXRzaWRlIGJ1ZmZlcilcIik7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAxMjgpID09PSAwKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjQwKSA9PT0gMTI4KSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAxNTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyNDApID09PSAxNDQpIHtcbiAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDE1O1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlICYgMjI0KSA9PT0gMTYwKSB7XG4gICAgICAgIGxlbmd0aCA9IHR5cGUgJiAzMTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyMjQpID09PSAyMjQpIHtcbiAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDE5MjpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDE5NDpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAxOTU6XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAxOTY6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTc6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTg6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgY2FzZSAxOTk6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDIpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDMpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDE6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDUpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDY7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbihsZW5ndGgpXTtcbiAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRGbG9hdEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZERvdWJsZUJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuYnVmZmVyW3RoaXMub2Zmc2V0ICsgMV07XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA1OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA2OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA3OlxuICAgICAgICAgIHZhbHVlID0gcmVhZFVJbnQ2NEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIwODpcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZEludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA5OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMTA6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRJbnQzMkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMTpcbiAgICAgICAgICB2YWx1ZSA9IHJlYWRJbnQ2NEJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMjpcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAyKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiBleHRUeXBlID09PSAwICYmIHZhbHVlID09PSAwID8gdm9pZCAwIDogW2V4dFR5cGUsIHZhbHVlXTtcbiAgICAgICAgY2FzZSAyMTM6XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbigyKV07XG4gICAgICAgIGNhc2UgMjE0OlxuICAgICAgICAgIGV4dFR5cGUgPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiBbZXh0VHlwZSwgdGhpcy5iaW4oNCldO1xuICAgICAgICBjYXNlIDIxNTpcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gW2V4dFR5cGUsIHRoaXMuYmluKDgpXTtcbiAgICAgICAgY2FzZSAyMTY6XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbigxNildO1xuICAgICAgICBjYXNlIDIxNzpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxODpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIxOTpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MzJCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIxOlxuICAgICAgICAgIGxlbmd0aCA9IGJvcHMucmVhZFVJbnQzMkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjI6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDE2QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjM6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSAweFwiICsgdHlwZS50b1N0cmluZygxNikpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZGVjb2RlMyhidWZmZXIpIHtcbiAgICAgIHZhciBkZWNvZGVyID0gbmV3IERlY29kZXIoYnVmZmVyKTtcbiAgICAgIHZhciB2YWx1ZSA9IGRlY29kZXIucGFyc2UoKTtcbiAgICAgIGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1ZmZlci5sZW5ndGggLSBkZWNvZGVyLm9mZnNldCArIFwiIHRyYWlsaW5nIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB2YWwgPSB2YWx1ZVtlXSwgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgICAgIHJldHVybiAoIXNwYXJzZSB8fCB2YWwgIT09IHZvaWQgMCAmJiB2YWwgIT09IG51bGwpICYmIChcImZ1bmN0aW9uXCIgIT09IHR5cGUgfHwgISF2YWwudG9KU09OKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUyKHZhbHVlLCBidWZmZXIsIG9mZnNldCwgc3BhcnNlLCBpc01hcEVsZW1lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFyIGxlbmd0aCwgc2l6ZTtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gYm9wcy5mcm9tKHZhbHVlKTtcbiAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IGxlbmd0aCB8IDE2MDtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjE3O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50OChidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDIpO1xuICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjE4O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MTZCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDMpO1xuICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTk7XG4gICAgICAgICAgYm9wcy53cml0ZVVJbnQzMkJFKGJ1ZmZlciwgbGVuZ3RoLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgNSk7XG4gICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib3BzLmlzKHZhbHVlKSkge1xuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDE5NjtcbiAgICAgICAgICBib3BzLndyaXRlVUludDgoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGJvcHMuY29weSh2YWx1ZSwgYnVmZmVyLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDE5NztcbiAgICAgICAgICBib3BzLndyaXRlVUludDE2QkUoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGJvcHMuY29weSh2YWx1ZSwgYnVmZmVyLCBvZmZzZXQgKyAzKTtcbiAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMTk4O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MzJCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDUpO1xuICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDM7XG4gICAgICAgICAgYm9wcy53cml0ZURvdWJsZUJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMTI4KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA8IDI1Nikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDQ7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPCA2NTUzNikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDU7XG4gICAgICAgICAgICBib3BzLndyaXRlVUludDE2QkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gICAgICAgICAgICBib3BzLndyaXRlVUludDMyQkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMTg0NDY3NDQwNzM3MDk1NTJlMykge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDc7XG4gICAgICAgICAgICB3cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMzIpIHtcbiAgICAgICAgICBib3BzLndyaXRlSW50OChidWZmZXIsIHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMTI4KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDg7XG4gICAgICAgICAgYm9wcy53cml0ZUludDgoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IC0zMjc2OCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjA5O1xuICAgICAgICAgIGJvcHMud3JpdGVJbnQxNkJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMjE0NzQ4MzY0OCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjEwO1xuICAgICAgICAgIGJvcHMud3JpdGVJbnQzMkJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtOTIyMzM3MjAzNjg1NDc3NmUzKSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTE7XG4gICAgICAgICAgd3JpdGVJbnQ2NEJFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gc21hbGwgLTB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChzcGFyc2UgJiYgaXNNYXBFbGVtZW50KVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIxMjtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gMDtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDJdID0gMDtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNwYXJzZSAmJiBpc01hcEVsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMTkyO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID8gMTk1IDogMTk0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgICAgIHJldHVybiBlbmNvZGUyKHZhbHVlLnRvSlNPTigpLCBidWZmZXIsIG9mZnNldCwgc3BhcnNlKTtcbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHNpemUgPSAwO1xuICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gbGVuZ3RoIHwgKGlzQXJyYXkgPyAxNDQgOiAxMjgpO1xuICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSBpc0FycmF5ID8gMjIwIDogMjIyO1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MTZCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gaXNBcnJheSA/IDIyMSA6IDIyMztcbiAgICAgICAgICBib3BzLndyaXRlVUludDMyQkUoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHNpemUgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSArPSBlbmNvZGUyKHZhbHVlW2ldLCBidWZmZXIsIG9mZnNldCArIHNpemUsIHNwYXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgc2l6ZSArPSBlbmNvZGUyKGtleSwgYnVmZmVyLCBvZmZzZXQgKyBzaXplKTtcbiAgICAgICAgICAgIHNpemUgKz0gZW5jb2RlMih2YWx1ZVtrZXldLCBidWZmZXIsIG9mZnNldCArIHNpemUsIHNwYXJzZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIiArIHR5cGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXplb2YodmFsdWUsIHNwYXJzZSwgaXNNYXBFbGVtZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHZhciBsZW5ndGgsIHNpemU7XG4gICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZW5ndGggPSBib3BzLmZyb20odmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib3BzLmlzKHZhbHVlKSkge1xuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAyNTYpIHtcbiAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDI1NilcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDY1NTM2KVxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgNDI5NDk2NzI5NilcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDE4NDQ2NzQ0MDczNzA5NTUyZTMpXG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gLTMyKVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAodmFsdWUgPj0gLTEyOClcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgaWYgKHZhbHVlID49IC0zMjc2OClcbiAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KVxuICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICBpZiAodmFsdWUgPj0gLTkyMjMzNzIwMzY4NTQ3NzZlMylcbiAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHNwYXJzZSAmJiBpc01hcEVsZW1lbnQgPyAwIDogMTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gc3BhcnNlICYmIGlzTWFwRWxlbWVudCA/IDAgOiAzO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcbiAgICAgICAgcmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHNpemUgPSAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSArPSBzaXplb2YodmFsdWVbaV0sIHNwYXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBzaXplICs9IHNpemVvZihrZXkpICsgc2l6ZW9mKHZhbHVlW2tleV0sIHNwYXJzZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgICAgIHJldHVybiAxICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICByZXR1cm4gMyArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgICByZXR1cm4gNSArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4XCIgKyBsZW5ndGgudG9TdHJpbmcoMTYpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gc3JjL2NvbW1vbi9wbGF0Zm9ybS50c1xudmFyIFBsYXRmb3JtID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIudHNcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5mdW5jdGlvbiBwYWQodGltZVNlZ21lbnQsIHRocmVlKSB7XG4gIHJldHVybiBgJHt0aW1lU2VnbWVudH1gLnBhZFN0YXJ0KHRocmVlID8gMyA6IDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZXIobG9nZ2VyKSB7XG4gIHJldHVybiBQbGF0Zm9ybS5Db25maWcubG9nVGltZXN0YW1wcyA/IGZ1bmN0aW9uKG1zZykge1xuICAgIGNvbnN0IHRpbWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsb2dnZXIoXG4gICAgICBwYWQodGltZS5nZXRIb3VycygpKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0TWludXRlcygpKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0U2Vjb25kcygpKSArIFwiLlwiICsgcGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDEpICsgXCIgXCIgKyBtc2dcbiAgICApO1xuICB9IDogZnVuY3Rpb24obXNnKSB7XG4gICAgbG9nZ2VyKG1zZyk7XG4gIH07XG59XG52YXIgZ2V0RGVmYXVsdExvZ2dlcnMgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIGxldCBjb25zb2xlTG9nZ2VyO1xuICBsZXQgZXJyb3JMb2dnZXI7XG4gIGlmICh0eXBlb2YgKChfYTIgPSBnbG9iYWxPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbE9iamVjdC5jb25zb2xlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGVMb2dnZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICAgIGVycm9yTG9nZ2VyID0gY29uc29sZS53YXJuID8gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH0gOiBjb25zb2xlTG9nZ2VyO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIFtjb25zb2xlTG9nZ2VyLCBlcnJvckxvZ2dlcl0ubWFwKGdldEhhbmRsZXIpO1xufTtcbnZhciBfTG9nZ2VyID0gY2xhc3MgX0xvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVwcmVjYXRlZCA9IChkZXNjcmlwdGlvbiwgbXNnKSA9PiB7XG4gICAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZyhgJHtkZXNjcmlwdGlvbn0gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uICR7bXNnfWApO1xuICAgIH07XG4gICAgLyogV2hlcmUgYSBsb2dnaW5nIG9wZXJhdGlvbiBpcyBleHBlbnNpdmUsIHN1Y2ggYXMgc2VyaWFsaXNhdGlvbiBvZiBkYXRhLCB1c2Ugc2hvdWxkTG9nIHdpbGwgcHJldmVudFxuICAgICAgdGhlIG9iamVjdCBiZWluZyBzZXJpYWxpc2VkIGlmIHRoZSBsb2cgbGV2ZWwgd2lsbCBub3Qgb3V0cHV0IHRoZSBtZXNzYWdlICovXG4gICAgdGhpcy5zaG91bGRMb2cgPSAobGV2ZWwpID0+IHtcbiAgICAgIHJldHVybiBsZXZlbCA8PSB0aGlzLmxvZ0xldmVsO1xuICAgIH07XG4gICAgdGhpcy5zZXRMb2cgPSAobGV2ZWwsIGhhbmRsZXIpID0+IHtcbiAgICAgIGlmIChsZXZlbCAhPT0gdm9pZCAwKVxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gbGV2ZWw7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gdm9pZCAwKVxuICAgICAgICB0aGlzLmxvZ0hhbmRsZXIgPSB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfTtcbiAgICB0aGlzLmxvZ0xldmVsID0gX0xvZ2dlci5kZWZhdWx0TG9nTGV2ZWw7XG4gICAgdGhpcy5sb2dIYW5kbGVyID0gX0xvZ2dlci5kZWZhdWx0TG9nSGFuZGxlcjtcbiAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IF9Mb2dnZXIuZGVmYXVsdExvZ0Vycm9ySGFuZGxlcjtcbiAgfVxuICBzdGF0aWMgaW5pdExvZ0hhbmRsZXJzKCkge1xuICAgIGNvbnN0IFtsb2dIYW5kbGVyLCBsb2dFcnJvckhhbmRsZXJdID0gZ2V0RGVmYXVsdExvZ2dlcnMoKTtcbiAgICB0aGlzLmRlZmF1bHRMb2dIYW5kbGVyID0gbG9nSGFuZGxlcjtcbiAgICB0aGlzLmRlZmF1bHRMb2dFcnJvckhhbmRsZXIgPSBsb2dFcnJvckhhbmRsZXI7XG4gICAgdGhpcy5kZWZhdWx0TG9nZ2VyID0gbmV3IF9Mb2dnZXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgdG8gdGhpcyBtZXRob2QgYXJlIG5ldmVyIHN0cmlwcGVkIGJ5IHRoZSBgc3RyaXBMb2dzYCBlc2J1aWxkIHBsdWdpbi4gVXNlIGl0IGZvciBsb2cgc3RhdGVtZW50cyB0aGF0IHlvdSB3aXNoIHRvIGFsd2F5cyBiZSBpbmNsdWRlZCBpbiB0aGUgbW9kdWxhciB2YXJpYW50IG9mIHRoZSBTREsuXG4gICAqL1xuICBzdGF0aWMgbG9nQWN0aW9uTm9TdHJpcChsb2dnZXIsIGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICBsb2dnZXIubG9nQWN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICB9XG4gIGxvZ0FjdGlvbihsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9nKGxldmVsKSkge1xuICAgICAgKGxldmVsID09PSAxIC8qIEVycm9yICovID8gdGhpcy5sb2dFcnJvckhhbmRsZXIgOiB0aGlzLmxvZ0hhbmRsZXIpKFwiQWJseTogXCIgKyBhY3Rpb24gKyBcIjogXCIgKyBtZXNzYWdlLCBsZXZlbCk7XG4gICAgfVxuICB9XG4gIHJlbmFtZWRDbGllbnRPcHRpb24ob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nKFxuICAgICAgYFRoZSBcXGAke29sZE5hbWV9XFxgIGNsaWVudCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGAke25ld05hbWV9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgXFxgJHtuZXdOYW1lfVxcYCBpbnN0ZWFkLiBcXGAke29sZE5hbWV9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLmBcbiAgICApO1xuICB9XG4gIHJlbmFtZWRNZXRob2QoY2xhc3NOYW1lLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBgXFxgJHtjbGFzc05hbWV9XFxgXFx1MjAxOXMgXFxgJHtvbGROYW1lfVxcYCBtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGAke25ld05hbWV9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgXFxgJHtuZXdOYW1lfVxcYCBpbnN0ZWFkLiBcXGAke29sZE5hbWV9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLmBcbiAgICApO1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZyhtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9nKDEgLyogRXJyb3IgKi8pKSB7XG4gICAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlcihgQWJseTogRGVwcmVjYXRpb24gd2FybmluZyAtICR7bWVzc2FnZX1gLCAxIC8qIEVycm9yICovKTtcbiAgICB9XG4gIH1cbn07XG5fTG9nZ2VyLmRlZmF1bHRMb2dMZXZlbCA9IDEgLyogRXJyb3IgKi87XG4vLyBwdWJsaWMgY29uc3RhbnRzXG5fTG9nZ2VyLkxPR19OT05FID0gMCAvKiBOb25lICovO1xuX0xvZ2dlci5MT0dfRVJST1IgPSAxIC8qIEVycm9yICovO1xuX0xvZ2dlci5MT0dfTUFKT1IgPSAyIC8qIE1ham9yICovO1xuX0xvZ2dlci5MT0dfTUlOT1IgPSAzIC8qIE1pbm9yICovO1xuX0xvZ2dlci5MT0dfTUlDUk8gPSA0IC8qIE1pY3JvICovO1xuLyogcHVibGljIHN0YXRpYyBmdW5jdGlvbnMgKi9cbi8qKlxuICogSW4gdGhlIG1vZHVsYXIgdmFyaWFudCBvZiB0aGUgU0RLLCB0aGUgYHN0cmlwTG9nc2AgZXNidWlsZCBwbHVnaW4gc3RyaXBzIG91dCBhbGwgY2FsbHMgdG8gdGhpcyBtZXRob2QgKHdoZW4gaW52b2tlZCBhcyBgTG9nZ2VyLmxvZ0FjdGlvbiguLi4pYCkgZXhjZXB0IHdoZW4gY2FsbGVkIHdpdGggbGV2ZWwgYExvZ2dlci5MT0dfRVJST1JgLiBJZiB5b3Ugd2lzaCBmb3IgYSBsb2cgc3RhdGVtZW50IHRvIG5ldmVyIGJlIHN0cmlwcGVkLCB1c2UgdGhlIHtAbGluayBsb2dBY3Rpb25Ob1N0cmlwfSBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBUaGUgYWZvcmVtZW50aW9uZWQgcGx1Z2luIGV4cGVjdHMgYGxldmVsYCB0byBiZSBhbiBleHByZXNzaW9uIG9mIHRoZSBmb3JtIGBMb2dnZXIuTE9HXypgOyB0aGF0IGlzLCB5b3UgY2Fu4oCZdCBkeW5hbWljYWxseSBzcGVjaWZ5IHRoZSBsb2cgbGV2ZWwuXG4gKi9cbl9Mb2dnZXIubG9nQWN0aW9uID0gKGxvZ2dlciwgbGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkgPT4ge1xuICBfTG9nZ2VyLmxvZ0FjdGlvbk5vU3RyaXAobG9nZ2VyLCBsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKTtcbn07XG52YXIgTG9nZ2VyID0gX0xvZ2dlcjtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IExvZ2dlcjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC91dGlscy50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgRm9ybWF0OiAoKSA9PiBGb3JtYXQsXG4gIGFsbFNhbWU6ICgpID0+IGFsbFNhbWUsXG4gIGFsbFRvTG93ZXJDYXNlOiAoKSA9PiBhbGxUb0xvd2VyQ2FzZSxcbiAgYWxsVG9VcHBlckNhc2U6ICgpID0+IGFsbFRvVXBwZXJDYXNlLFxuICBhcnJDaG9vc2VOOiAoKSA9PiBhcnJDaG9vc2VOLFxuICBhcnJEZWxldGVWYWx1ZTogKCkgPT4gYXJyRGVsZXRlVmFsdWUsXG4gIGFyckVxdWFsczogKCkgPT4gYXJyRXF1YWxzLFxuICBhcnJJbnRlcnNlY3Q6ICgpID0+IGFyckludGVyc2VjdCxcbiAgYXJySW50ZXJzZWN0T2I6ICgpID0+IGFyckludGVyc2VjdE9iLFxuICBhcnJQb3BSYW5kb21FbGVtZW50OiAoKSA9PiBhcnJQb3BSYW5kb21FbGVtZW50LFxuICBhcnJTdWJ0cmFjdDogKCkgPT4gYXJyU3VidHJhY3QsXG4gIGFycldpdGhvdXRWYWx1ZTogKCkgPT4gYXJyV2l0aG91dFZhbHVlLFxuICBjaGVhcFJhbmRTdHI6ICgpID0+IGNoZWFwUmFuZFN0cixcbiAgY29udGFpbnNWYWx1ZTogKCkgPT4gY29udGFpbnNWYWx1ZSxcbiAgY29weTogKCkgPT4gY29weSxcbiAgY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yOiAoKSA9PiBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IsXG4gIGRhdGFTaXplQnl0ZXM6ICgpID0+IGRhdGFTaXplQnl0ZXMsXG4gIGRlY29kZUJvZHk6ICgpID0+IGRlY29kZUJvZHksXG4gIGVuY29kZUJvZHk6ICgpID0+IGVuY29kZUJvZHksXG4gIGVuc3VyZUFycmF5OiAoKSA9PiBlbnN1cmVBcnJheSxcbiAgZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllczogKCkgPT4gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyxcbiAgZ2V0QmFja29mZkNvZWZmaWNpZW50OiAoKSA9PiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQsXG4gIGdldEdsb2JhbE9iamVjdDogKCkgPT4gZ2V0R2xvYmFsT2JqZWN0LFxuICBnZXRKaXR0ZXJDb2VmZmljaWVudDogKCkgPT4gZ2V0Sml0dGVyQ29lZmZpY2llbnQsXG4gIGdldFJldHJ5VGltZTogKCkgPT4gZ2V0UmV0cnlUaW1lLFxuICBpbmhlcml0czogKCkgPT4gaW5oZXJpdHMsXG4gIGluc3BlY3RCb2R5OiAoKSA9PiBpbnNwZWN0Qm9keSxcbiAgaW5zcGVjdEVycm9yOiAoKSA9PiBpbnNwZWN0RXJyb3IsXG4gIGludGVyc2VjdDogKCkgPT4gaW50ZXJzZWN0LFxuICBpc0VtcHR5OiAoKSA9PiBpc0VtcHR5LFxuICBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbzogKCkgPT4gaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8sXG4gIGlzTmlsOiAoKSA9PiBpc05pbCxcbiAgaXNPYmplY3Q6ICgpID0+IGlzT2JqZWN0LFxuICBrZXlzQXJyYXk6ICgpID0+IGtleXNBcnJheSxcbiAgbWF0Y2hEZXJpdmVkQ2hhbm5lbDogKCkgPT4gbWF0Y2hEZXJpdmVkQ2hhbm5lbCxcbiAgbWl4aW46ICgpID0+IG1peGluLFxuICBwYXJzZVF1ZXJ5U3RyaW5nOiAoKSA9PiBwYXJzZVF1ZXJ5U3RyaW5nLFxuICBwcm90b3R5cGljYWxDbG9uZTogKCkgPT4gcHJvdG90eXBpY2FsQ2xvbmUsXG4gIHJhbmRvbVN0cmluZzogKCkgPT4gcmFuZG9tU3RyaW5nLFxuICBzaGFsbG93Q2xvbmU6ICgpID0+IHNoYWxsb3dDbG9uZSxcbiAgc2hhbGxvd0VxdWFsczogKCkgPT4gc2hhbGxvd0VxdWFscyxcbiAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3I6ICgpID0+IHRocm93TWlzc2luZ1BsdWdpbkVycm9yLFxuICB0b0Jhc2U2NDogKCkgPT4gdG9CYXNlNjQsXG4gIHRvUXVlcnlTdHJpbmc6ICgpID0+IHRvUXVlcnlTdHJpbmcsXG4gIHZhbHVlc0FycmF5OiAoKSA9PiB2YWx1ZXNBcnJheSxcbiAgd2hlblByb21pc2VTZXR0bGVzOiAoKSA9PiB3aGVuUHJvbWlzZVNldHRsZXMsXG4gIHdpdGhUaW1lb3V0QXN5bmM6ICgpID0+IHdpdGhUaW1lb3V0QXN5bmNcbn0pO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8udHNcbmZ1bmN0aW9uIHRvU3RyaW5nKGVycikge1xuICBsZXQgcmVzdWx0ID0gXCJbXCIgKyBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKGVyci5tZXNzYWdlKVxuICAgIHJlc3VsdCArPSBcIjogXCIgKyBlcnIubWVzc2FnZTtcbiAgaWYgKGVyci5zdGF0dXNDb2RlKVxuICAgIHJlc3VsdCArPSBcIjsgc3RhdHVzQ29kZT1cIiArIGVyci5zdGF0dXNDb2RlO1xuICBpZiAoZXJyLmNvZGUpXG4gICAgcmVzdWx0ICs9IFwiOyBjb2RlPVwiICsgZXJyLmNvZGU7XG4gIGlmIChlcnIuY2F1c2UpXG4gICAgcmVzdWx0ICs9IFwiOyBjYXVzZT1cIiArIGluc3BlY3RFcnJvcihlcnIuY2F1c2UpO1xuICBpZiAoZXJyLmhyZWYgJiYgIShlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmRleE9mKFwiaGVscC5hYmx5LmlvXCIpID4gLTEpKVxuICAgIHJlc3VsdCArPSBcIjsgc2VlIFwiICsgZXJyLmhyZWYgKyBcIiBcIjtcbiAgcmVzdWx0ICs9IFwiXVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEVycm9ySW5mbyA9IGNsYXNzIF9FcnJvckluZm8gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfRXJyb3JJbmZvLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSB9ID0gdmFsdWVzO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc3RhdHVzQ29kZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JJbmZvLmZyb21WYWx1ZXMoKTogaW52YWxpZCB2YWx1ZXM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QodmFsdWVzKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24obmV3IF9FcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgcmVzdWx0LmhyZWYgPSBcImh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yL1wiICsgcmVzdWx0LmNvZGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgUGFydGlhbEVycm9ySW5mbyA9IGNsYXNzIF9QYXJ0aWFsRXJyb3JJbmZvIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1BhcnRpYWxFcnJvckluZm8ucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlIH0gPSB2YWx1ZXM7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiIHx8ICFpc05pbChjb2RlKSAmJiB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCAhaXNOaWwoc3RhdHVzQ29kZSkgJiYgdHlwZW9mIHN0YXR1c0NvZGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnRpYWxFcnJvckluZm8uZnJvbVZhbHVlcygpOiBpbnZhbGlkIHZhbHVlczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdCh2YWx1ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihuZXcgX1BhcnRpYWxFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgcmVzdWx0LmhyZWYgPSBcImh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yL1wiICsgcmVzdWx0LmNvZGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvdXRpbHMudHNcbmZ1bmN0aW9uIHJhbmRvbVBvc24oYXJyT3JTdHIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyck9yU3RyLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJnc1tpXTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGNvcHkoc3JjKSB7XG4gIHJldHVybiBtaXhpbih7fSwgc3JjKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KG9iaikge1xuICBpZiAoaXNOaWwob2JqKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXR1cm4gW29ial07XG59XG5mdW5jdGlvbiBpc09iamVjdChvYikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iKSA9PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNFbXB0eShvYikge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzTmlsKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2IpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE9iamVjdCgpO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpXG4gICAgcmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwcm90b3R5cGljYWxDbG9uZShvYiwgb3duUHJvcGVydGllcykge1xuICBjbGFzcyBGIHtcbiAgfVxuICBGLnByb3RvdHlwZSA9IG9iO1xuICBjb25zdCByZXN1bHQgPSBuZXcgRigpO1xuICBpZiAob3duUHJvcGVydGllcylcbiAgICBtaXhpbihyZXN1bHQsIG93blByb3BlcnRpZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGlmIChQbGF0Zm9ybS5Db25maWcuaW5oZXJpdHMpIHtcbiAgICBQbGF0Zm9ybS5Db25maWcuaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gcHJvdG90eXBpY2FsQ2xvbmUoc3VwZXJDdG9yLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogY3RvciB9KTtcbn07XG5mdW5jdGlvbiBjb250YWluc1ZhbHVlKG9iLCB2YWwpIHtcbiAgZm9yIChjb25zdCBpIGluIG9iKSB7XG4gICAgaWYgKG9iW2ldID09IHZhbClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdChhcnIsIG9iKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iKSA/IGFyckludGVyc2VjdChhcnIsIG9iKSA6IGFyckludGVyc2VjdE9iKGFyciwgb2IpO1xufVxuZnVuY3Rpb24gYXJySW50ZXJzZWN0KGFycjEsIGFycjIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1lbWJlciA9IGFycjFbaV07XG4gICAgaWYgKGFycjIuaW5kZXhPZihtZW1iZXIpICE9IC0xKVxuICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJySW50ZXJzZWN0T2IoYXJyLCBvYikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZW1iZXIgPSBhcnJbaV07XG4gICAgaWYgKG1lbWJlciBpbiBvYilcbiAgICAgIHJlc3VsdC5wdXNoKG1lbWJlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFyclN1YnRyYWN0KGFycjEsIGFycjIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnIxW2ldO1xuICAgIGlmIChhcnIyLmluZGV4T2YoZWxlbWVudCkgPT0gLTEpXG4gICAgICByZXN1bHQucHVzaChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJyRGVsZXRlVmFsdWUoYXJyLCB2YWwpIHtcbiAgY29uc3QgaWR4ID0gYXJyLmluZGV4T2YodmFsKTtcbiAgY29uc3QgcmVzID0gaWR4ICE9IC0xO1xuICBpZiAocmVzKVxuICAgIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFycldpdGhvdXRWYWx1ZShhcnIsIHZhbCkge1xuICBjb25zdCBuZXdBcnIgPSBhcnIuc2xpY2UoKTtcbiAgYXJyRGVsZXRlVmFsdWUobmV3QXJyLCB2YWwpO1xuICByZXR1cm4gbmV3QXJyO1xufVxuZnVuY3Rpb24ga2V5c0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpIHtcbiAgICBpZiAob3duT25seSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWx1ZXNBcnJheShvYiwgb3duT25seSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKSB7XG4gICAgaWYgKG93bk9ubHkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpXG4gICAgICBjb250aW51ZTtcbiAgICByZXN1bHQucHVzaChvYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMob2IsIGZuKSB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApICYmIG9iW3Byb3BdKSB7XG4gICAgICBmbihwcm9wKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbFNhbWUoYXJyLCBwcm9wKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZmlyc3QgPSBhcnJbMF1bcHJvcF07XG4gIHJldHVybiBhcnIuZXZlcnkoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtW3Byb3BdID09PSBmaXJzdDtcbiAgfSk7XG59XG52YXIgRm9ybWF0ID0gLyogQF9fUFVSRV9fICovICgoRm9ybWF0MikgPT4ge1xuICBGb3JtYXQyW1wibXNncGFja1wiXSA9IFwibXNncGFja1wiO1xuICBGb3JtYXQyW1wianNvblwiXSA9IFwianNvblwiO1xuICByZXR1cm4gRm9ybWF0Mjtcbn0pKEZvcm1hdCB8fCB7fSk7XG5mdW5jdGlvbiBhcnJQb3BSYW5kb21FbGVtZW50KGFycikge1xuICByZXR1cm4gYXJyLnNwbGljZShyYW5kb21Qb3NuKGFyciksIDEpWzBdO1xufVxuZnVuY3Rpb24gdG9RdWVyeVN0cmluZyhwYXJhbXMpIHtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgaWYgKHBhcmFtcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcylcbiAgICAgIHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuICB9XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPyBcIj9cIiArIHBhcnRzLmpvaW4oXCImXCIpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmcocXVlcnkpIHtcbiAgbGV0IG1hdGNoO1xuICBjb25zdCBzZWFyY2ggPSAvKFtePyY9XSspPT8oW14mXSopL2c7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICB3aGlsZSAobWF0Y2ggPSBzZWFyY2guZXhlYyhxdWVyeSkpXG4gICAgcmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzJdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGVycikge1xuICByZXR1cm4gdHlwZW9mIGVyciA9PSBcIm9iamVjdFwiICYmIGVyciAhPT0gbnVsbCAmJiAoZXJyIGluc3RhbmNlb2YgRXJyb3JJbmZvIHx8IGVyciBpbnN0YW5jZW9mIFBhcnRpYWxFcnJvckluZm8pO1xufVxuZnVuY3Rpb24gaW5zcGVjdEVycm9yKGVycikge1xuICB2YXIgX2EyLCBfYjtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8ICgoX2EyID0gZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubmFtZSkgPT09IFwiRXJyb3JJbmZvXCIgfHwgKChfYiA9IGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkgPT09IFwiUGFydGlhbEVycm9ySW5mb1wiKVxuICAgIHJldHVybiBlcnIudG9TdHJpbmcoKTtcbiAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGVycik7XG59XG5mdW5jdGlvbiBpbnNwZWN0Qm9keShib2R5KSB7XG4gIGlmIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYm9keSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRhdGFTaXplQnl0ZXMoZGF0YSkge1xuICBpZiAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYnl0ZUxlbmd0aChkYXRhKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uQ29uZmlnLnN0cmluZ0J5dGVTaXplKGRhdGEpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIFV0aWxzLmRhdGFTaXplQnl0ZXMgdG8gYmUgYSBidWZmZXIgb3Igc3RyaW5nLCBidXQgd2FzOiBcIiArIHR5cGVvZiBkYXRhKTtcbn1cbmZ1bmN0aW9uIGNoZWFwUmFuZFN0cigpIHtcbiAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG59XG52YXIgcmFuZG9tU3RyaW5nID0gYXN5bmMgKG51bUJ5dGVzKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IFBsYXRmb3JtLkNvbmZpZy5nZXRSYW5kb21BcnJheUJ1ZmZlcihudW1CeXRlcyk7XG4gIHJldHVybiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoYnVmZmVyKTtcbn07XG5mdW5jdGlvbiBhcnJDaG9vc2VOKGFyciwgbikge1xuICBjb25zdCBudW1JdGVtcyA9IE1hdGgubWluKG4sIGFyci5sZW5ndGgpLCBtdXRhYmxlQXJyID0gYXJyLnNsaWNlKCksIHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUl0ZW1zOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChhcnJQb3BSYW5kb21FbGVtZW50KG11dGFibGVBcnIpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2hlblByb21pc2VTZXR0bGVzKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soZXJyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09IFwibXNncGFja1wiKSB7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgfVxuICAgIHJldHVybiBNc2dQYWNrLmRlY29kZShib2R5KTtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShTdHJpbmcoYm9keSkpO1xufVxuZnVuY3Rpb24gZW5jb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PSBcIm1zZ3BhY2tcIikge1xuICAgIGlmICghTXNnUGFjaykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTXNnUGFjay5lbmNvZGUoYm9keSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvZHkpO1xufVxuZnVuY3Rpb24gYWxsVG9Mb3dlckNhc2UoYXJyKSB7XG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWxsVG9VcHBlckNhc2UoYXJyKSB7XG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QmFja29mZkNvZWZmaWNpZW50KGNvdW50KSB7XG4gIHJldHVybiBNYXRoLm1pbigoY291bnQgKyAyKSAvIDMsIDIpO1xufVxuZnVuY3Rpb24gZ2V0Sml0dGVyQ29lZmZpY2llbnQoKSB7XG4gIHJldHVybiAxIC0gTWF0aC5yYW5kb20oKSAqIDAuMjtcbn1cbmZ1bmN0aW9uIGdldFJldHJ5VGltZShpbml0aWFsVGltZW91dCwgcmV0cnlBdHRlbXB0KSB7XG4gIHJldHVybiBpbml0aWFsVGltZW91dCAqIGdldEJhY2tvZmZDb2VmZmljaWVudChyZXRyeUF0dGVtcHQpICogZ2V0Sml0dGVyQ29lZmZpY2llbnQoKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbE9iamVjdCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbHMoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkuZXZlcnkoKGtleSkgPT4gc291cmNlW2tleV0gPT09IHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyh0YXJnZXQpLmV2ZXJ5KChrZXkpID0+IHRhcmdldFtrZXldID09PSBzb3VyY2Vba2V5XSk7XG59XG5mdW5jdGlvbiBtYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpIHtcbiAgY29uc3QgcmVnZXggPSAvXihcXFsoW14/XSopKD86KC4qKSlcXF0pPyguKykkLztcbiAgY29uc3QgbWF0Y2ggPSBuYW1lLm1hdGNoKHJlZ2V4KTtcbiAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gubGVuZ3RoIHx8IG1hdGNoLmxlbmd0aCA8IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwicmVnZXggbWF0Y2ggZmFpbGVkXCIsIDQwMCwgNDAwMTApO1xuICB9XG4gIGlmIChtYXRjaFsyXSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oYGNhbm5vdCB1c2UgYSBkZXJpdmVkIG9wdGlvbiB3aXRoIGEgJHttYXRjaFsyXX0gY2hhbm5lbGAsIDQwMCwgNDAwMTApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcXVhbGlmaWVyUGFyYW06IG1hdGNoWzNdIHx8IFwiXCIsXG4gICAgY2hhbm5lbE5hbWU6IG1hdGNoWzRdXG4gIH07XG59XG5mdW5jdGlvbiB0b0Jhc2U2NChzdHIpIHtcbiAgY29uc3QgYnVmZmVyVXRpbHMgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscztcbiAgY29uc3QgdGV4dEJ1ZmZlciA9IGJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoc3RyKTtcbiAgcmV0dXJuIGJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh0ZXh0QnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGFyckVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbih2YWwsIGkpIHtcbiAgICByZXR1cm4gdmFsID09PSBiW2ldO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcihwbHVnaW5OYW1lKSB7XG4gIHJldHVybiBuZXcgRXJyb3JJbmZvKGAke3BsdWdpbk5hbWV9IHBsdWdpbiBub3QgcHJvdmlkZWRgLCA0MDAxOSwgNDAwKTtcbn1cbmZ1bmN0aW9uIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpIHtcbiAgdGhyb3cgY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aFRpbWVvdXRBc3luYyhwcm9taXNlLCB0aW1lb3V0ID0gNWUzLCBlcnIgPSBcIlRpbWVvdXQgZXhwaXJlZFwiKSB7XG4gIGNvbnN0IGUgPSBuZXcgRXJyb3JJbmZvKGVyciwgNWU0LCA1MDApO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QoZSksIHRpbWVvdXQpKV0pO1xufVxuXG4vLyBwYWNrYWdlLmpzb25cbnZhciB2ZXJzaW9uID0gXCIyLjMuMVwiO1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL2RlZmF1bHRzLnRzXG52YXIgYWdlbnQgPSBcImFibHktanMvXCIgKyB2ZXJzaW9uO1xudmFyIERlZmF1bHRzID0ge1xuICBFTlZJUk9OTUVOVDogXCJcIixcbiAgUkVTVF9IT1NUOiBcInJlc3QuYWJseS5pb1wiLFxuICBSRUFMVElNRV9IT1NUOiBcInJlYWx0aW1lLmFibHkuaW9cIixcbiAgRkFMTEJBQ0tfSE9TVFM6IFtcbiAgICBcIkEuYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIkIuYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIkMuYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIkQuYWJseS1yZWFsdGltZS5jb21cIixcbiAgICBcIkUuYWJseS1yZWFsdGltZS5jb21cIlxuICBdLFxuICBQT1JUOiA4MCxcbiAgVExTX1BPUlQ6IDQ0MyxcbiAgVElNRU9VVFM6IHtcbiAgICAvKiBEb2N1bWVudGVkIGFzIG9wdGlvbnMgcGFyYW1zOiAqL1xuICAgIGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dDogMTVlMyxcbiAgICBzdXNwZW5kZWRSZXRyeVRpbWVvdXQ6IDNlNCxcbiAgICAvKiBVbmRvY3VtZW50ZWQsIGJ1dCBwYXJ0IG9mIHRoZSBhcGkgYW5kIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbWVyczogKi9cbiAgICBodHRwUmVxdWVzdFRpbWVvdXQ6IDFlNCxcbiAgICBodHRwTWF4UmV0cnlEdXJhdGlvbjogMTVlMyxcbiAgICBjaGFubmVsUmV0cnlUaW1lb3V0OiAxNWUzLFxuICAgIGZhbGxiYWNrUmV0cnlUaW1lb3V0OiA2ZTUsXG4gICAgLyogRm9yIGludGVybmFsIC8gdGVzdCB1c2Ugb25seTogKi9cbiAgICBjb25uZWN0aW9uU3RhdGVUdGw6IDEyZTQsXG4gICAgcmVhbHRpbWVSZXF1ZXN0VGltZW91dDogMWU0LFxuICAgIHJlY3ZUaW1lb3V0OiA5ZTQsXG4gICAgd2ViU29ja2V0Q29ubmVjdFRpbWVvdXQ6IDFlNCxcbiAgICB3ZWJTb2NrZXRTbG93VGltZW91dDogNGUzXG4gIH0sXG4gIGh0dHBNYXhSZXRyeUNvdW50OiAzLFxuICBtYXhNZXNzYWdlU2l6ZTogNjU1MzYsXG4gIHZlcnNpb24sXG4gIHByb3RvY29sVmVyc2lvbjogMyxcbiAgYWdlbnQsXG4gIGdldEhvc3QsXG4gIGdldFBvcnQsXG4gIGdldEh0dHBTY2hlbWUsXG4gIGVudmlyb25tZW50RmFsbGJhY2tIb3N0cyxcbiAgZ2V0RmFsbGJhY2tIb3N0cyxcbiAgZ2V0SG9zdHMsXG4gIGNoZWNrSG9zdCxcbiAgb2JqZWN0aWZ5T3B0aW9ucyxcbiAgbm9ybWFsaXNlT3B0aW9ucyxcbiAgZGVmYXVsdEdldEhlYWRlcnMsXG4gIGRlZmF1bHRQb3N0SGVhZGVyc1xufTtcbmZ1bmN0aW9uIGdldEhvc3Qob3B0aW9ucywgaG9zdCwgd3MpIHtcbiAgaWYgKHdzKVxuICAgIGhvc3QgPSBob3N0ID09IG9wdGlvbnMucmVzdEhvc3QgJiYgb3B0aW9ucy5yZWFsdGltZUhvc3QgfHwgaG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdDtcbiAgZWxzZVxuICAgIGhvc3QgPSBob3N0IHx8IG9wdGlvbnMucmVzdEhvc3Q7XG4gIHJldHVybiBob3N0O1xufVxuZnVuY3Rpb24gZ2V0UG9ydChvcHRpb25zLCB0bHMpIHtcbiAgcmV0dXJuIHRscyB8fCBvcHRpb25zLnRscyA/IG9wdGlvbnMudGxzUG9ydCA6IG9wdGlvbnMucG9ydDtcbn1cbmZ1bmN0aW9uIGdldEh0dHBTY2hlbWUob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy50bHMgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIjtcbn1cbmZ1bmN0aW9uIGVudmlyb25tZW50RmFsbGJhY2tIb3N0cyhlbnZpcm9ubWVudCkge1xuICByZXR1cm4gW1xuICAgIGVudmlyb25tZW50ICsgXCItYS1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIGVudmlyb25tZW50ICsgXCItYi1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIGVudmlyb25tZW50ICsgXCItYy1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIGVudmlyb25tZW50ICsgXCItZC1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIGVudmlyb25tZW50ICsgXCItZS1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbVwiXG4gIF07XG59XG5mdW5jdGlvbiBnZXRGYWxsYmFja0hvc3RzKG9wdGlvbnMpIHtcbiAgY29uc3QgZmFsbGJhY2tIb3N0cyA9IG9wdGlvbnMuZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQgPSB0eXBlb2Ygb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuaHR0cE1heFJldHJ5Q291bnQgOiBEZWZhdWx0cy5odHRwTWF4UmV0cnlDb3VudDtcbiAgcmV0dXJuIGZhbGxiYWNrSG9zdHMgPyBhcnJDaG9vc2VOKGZhbGxiYWNrSG9zdHMsIGh0dHBNYXhSZXRyeUNvdW50KSA6IFtdO1xufVxuZnVuY3Rpb24gZ2V0SG9zdHMob3B0aW9ucywgd3MpIHtcbiAgY29uc3QgaG9zdHMgPSBbb3B0aW9ucy5yZXN0SG9zdF0uY29uY2F0KGdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykpO1xuICByZXR1cm4gd3MgPyBob3N0cy5tYXAoKGhvc3QpID0+IGdldEhvc3Qob3B0aW9ucywgaG9zdCwgdHJ1ZSkpIDogaG9zdHM7XG59XG5mdW5jdGlvbiBjaGVja0hvc3QoaG9zdCkge1xuICBpZiAodHlwZW9mIGhvc3QgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiaG9zdCBtdXN0IGJlIGEgc3RyaW5nOyB3YXMgYSBcIiArIHR5cGVvZiBob3N0LCA0ZTQsIDQwMCk7XG4gIH1cbiAgaWYgKCFob3N0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJob3N0IG11c3Qgbm90IGJlIHplcm8tbGVuZ3RoXCIsIDRlNCwgNDAwKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVhbHRpbWVIb3N0KG9wdGlvbnMsIHByb2R1Y3Rpb24sIGVudmlyb25tZW50LCBsb2dnZXIpIHtcbiAgaWYgKG9wdGlvbnMucmVhbHRpbWVIb3N0KVxuICAgIHJldHVybiBvcHRpb25zLnJlYWx0aW1lSG9zdDtcbiAgaWYgKG9wdGlvbnMucmVzdEhvc3QpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkRlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnNcIixcbiAgICAgICdyZXN0SG9zdCBpcyBzZXQgdG8gXCInICsgb3B0aW9ucy5yZXN0SG9zdCArICdcIiBidXQgcmVhbHRpbWVIb3N0IGlzIG5vdCBzZXQsIHNvIHNldHRpbmcgcmVhbHRpbWVIb3N0IHRvIFwiJyArIG9wdGlvbnMucmVzdEhvc3QgKyAnXCIgdG9vLiBJZiB0aGlzIGlzIG5vdCB3aGF0IHlvdSB3YW50LCBwbGVhc2Ugc2V0IHJlYWx0aW1lSG9zdCBleHBsaWNpdGx5LidcbiAgICApO1xuICAgIHJldHVybiBvcHRpb25zLnJlc3RIb3N0O1xuICB9XG4gIHJldHVybiBwcm9kdWN0aW9uID8gRGVmYXVsdHMuUkVBTFRJTUVfSE9TVCA6IGVudmlyb25tZW50ICsgXCItXCIgKyBEZWZhdWx0cy5SRUFMVElNRV9IT1NUO1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dHMob3B0aW9ucykge1xuICBjb25zdCB0aW1lb3V0cyA9IHt9O1xuICBmb3IgKGNvbnN0IHByb3AgaW4gRGVmYXVsdHMuVElNRU9VVFMpIHtcbiAgICB0aW1lb3V0c1twcm9wXSA9IG9wdGlvbnNbcHJvcF0gfHwgRGVmYXVsdHMuVElNRU9VVFNbcHJvcF07XG4gIH1cbiAgcmV0dXJuIHRpbWVvdXRzO1xufVxuZnVuY3Rpb24gZ2V0QWdlbnRTdHJpbmcob3B0aW9ucykge1xuICBsZXQgYWdlbnRTdHIgPSBEZWZhdWx0cy5hZ2VudDtcbiAgaWYgKG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgZm9yICh2YXIgYWdlbnQyIGluIG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgICBhZ2VudFN0ciArPSBcIiBcIiArIGFnZW50MiArIFwiL1wiICsgb3B0aW9ucy5hZ2VudHNbYWdlbnQyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFnZW50U3RyO1xufVxuZnVuY3Rpb24gb2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBhbGxvd0tleU9yVG9rZW4sIHNvdXJjZUZvckVycm9yTWVzc2FnZSwgbG9nZ2VyLCBtb2R1bGFyUGx1Z2luc1RvSW5jbHVkZSkge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbXNnID0gYWxsb3dLZXlPclRva2VuID8gYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggZWl0aGVyIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0LCBhbiBBYmx5IEFQSSBrZXksIG9yIGFuIEFibHkgVG9rZW5gIDogYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYSBjbGllbnQgb3B0aW9ucyBvYmplY3RgO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxuICBsZXQgb3B0aW9uc09iajtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5kZXhPZihcIjpcIikgPT0gLTEpIHtcbiAgICAgIGlmICghYWxsb3dLZXlPclRva2VuKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGAke3NvdXJjZUZvckVycm9yTWVzc2FnZX0gY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGgganVzdCBhbiBBYmx5IFRva2VuOyB5b3UgbXVzdCBwcm92aWRlIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0IHdpdGggYSBcXGBwbHVnaW5zXFxgIHByb3BlcnR5LiAoU2V0IHRoaXMgQWJseSBUb2tlbiBhcyB0aGUgb2JqZWN0XFx1MjAxOXMgXFxgdG9rZW5cXGAgcHJvcGVydHkuKWA7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zT2JqID0geyB0b2tlbjogb3B0aW9ucyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWFsbG93S2V5T3JUb2tlbikge1xuICAgICAgICBjb25zdCBtc2cgPSBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRoIGp1c3QgYW4gQWJseSBBUEkga2V5OyB5b3UgbXVzdCBwcm92aWRlIGEgY2xpZW50IG9wdGlvbnMgb2JqZWN0IHdpdGggYSBcXGBwbHVnaW5zXFxgIHByb3BlcnR5LiAoU2V0IHRoaXMgQWJseSBBUEkga2V5IGFzIHRoZSBvYmplY3RcXHUyMDE5cyBcXGBrZXlcXGAgcHJvcGVydHkuKWA7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSgpYCwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zT2JqID0geyBrZXk6IG9wdGlvbnMgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9uc09iaiA9IG9wdGlvbnM7XG4gIH1cbiAgaWYgKG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSB7XG4gICAgb3B0aW9uc09iaiA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnNPYmopLCB7IHBsdWdpbnM6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBtb2R1bGFyUGx1Z2luc1RvSW5jbHVkZSksIG9wdGlvbnNPYmoucGx1Z2lucykgfSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNPYmo7XG59XG5mdW5jdGlvbiBub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMsIE1zZ1BhY2ssIGxvZ2dlcikge1xuICBjb25zdCBsb2dnZXJUb1VzZSA9IGxvZ2dlciAhPSBudWxsID8gbG9nZ2VyIDogbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcjtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXJUb1VzZSxcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgIFwiRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9uc1wiLFxuICAgICAgXCJjbG9zZU9uVW5sb2FkIHdhcyB0cnVlIGFuZCBhIHNlc3Npb24gcmVjb3ZlcnkgZnVuY3Rpb24gd2FzIHNldCAtIHRoZXNlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIHVuc2V0dGluZyB0aGUgbGF0dGVyXCJcbiAgICApO1xuICAgIG9wdGlvbnMucmVjb3ZlciA9IHZvaWQgMDtcbiAgfVxuICBpZiAoIShcImNsb3NlT25VbmxvYWRcIiBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9ICFvcHRpb25zLnJlY292ZXI7XG4gIH1cbiAgaWYgKCEoXCJxdWV1ZU1lc3NhZ2VzXCIgaW4gb3B0aW9ucykpXG4gICAgb3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gdHJ1ZTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50ICYmIFN0cmluZyhvcHRpb25zLmVudmlyb25tZW50KS50b0xvd2VyQ2FzZSgpIHx8IERlZmF1bHRzLkVOVklST05NRU5UO1xuICBjb25zdCBwcm9kdWN0aW9uID0gIWVudmlyb25tZW50IHx8IGVudmlyb25tZW50ID09PSBcInByb2R1Y3Rpb25cIjtcbiAgaWYgKCFvcHRpb25zLmZhbGxiYWNrSG9zdHMgJiYgIW9wdGlvbnMucmVzdEhvc3QgJiYgIW9wdGlvbnMucmVhbHRpbWVIb3N0ICYmICFvcHRpb25zLnBvcnQgJiYgIW9wdGlvbnMudGxzUG9ydCkge1xuICAgIG9wdGlvbnMuZmFsbGJhY2tIb3N0cyA9IHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5GQUxMQkFDS19IT1NUUyA6IGVudmlyb25tZW50RmFsbGJhY2tIb3N0cyhlbnZpcm9ubWVudCk7XG4gIH1cbiAgY29uc3QgcmVzdEhvc3QgPSBvcHRpb25zLnJlc3RIb3N0IHx8IChwcm9kdWN0aW9uID8gRGVmYXVsdHMuUkVTVF9IT1NUIDogZW52aXJvbm1lbnQgKyBcIi1cIiArIERlZmF1bHRzLlJFU1RfSE9TVCk7XG4gIGNvbnN0IHJlYWx0aW1lSG9zdCA9IGdldFJlYWx0aW1lSG9zdChvcHRpb25zLCBwcm9kdWN0aW9uLCBlbnZpcm9ubWVudCwgbG9nZ2VyVG9Vc2UpO1xuICAob3B0aW9ucy5mYWxsYmFja0hvc3RzIHx8IFtdKS5jb25jYXQocmVzdEhvc3QsIHJlYWx0aW1lSG9zdCkuZm9yRWFjaChjaGVja0hvc3QpO1xuICBvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgRGVmYXVsdHMuUE9SVDtcbiAgb3B0aW9ucy50bHNQb3J0ID0gb3B0aW9ucy50bHNQb3J0IHx8IERlZmF1bHRzLlRMU19QT1JUO1xuICBpZiAoIShcInRsc1wiIGluIG9wdGlvbnMpKVxuICAgIG9wdGlvbnMudGxzID0gdHJ1ZTtcbiAgY29uc3QgdGltZW91dHMgPSBnZXRUaW1lb3V0cyhvcHRpb25zKTtcbiAgaWYgKE1zZ1BhY2spIHtcbiAgICBpZiAoXCJ1c2VCaW5hcnlQcm90b2NvbFwiIGluIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBQbGF0Zm9ybS5Db25maWcuc3VwcG9ydHNCaW5hcnkgJiYgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IFBsYXRmb3JtLkNvbmZpZy5wcmVmZXJCaW5hcnk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChvcHRpb25zLmNsaWVudElkKSB7XG4gICAgaGVhZGVyc1tcIlgtQWJseS1DbGllbnRJZFwiXSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKG9wdGlvbnMuY2xpZW50SWQpKTtcbiAgfVxuICBpZiAoIShcImlkZW1wb3RlbnRSZXN0UHVibGlzaGluZ1wiIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSB0cnVlO1xuICB9XG4gIGxldCBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IG51bGw7XG4gIGxldCBjb25uZWN0aXZpdHlDaGVja1VybCA9IG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gIGlmIChvcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsKSB7XG4gICAgbGV0IFt1cmksIHFzXSA9IG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwuc3BsaXQoXCI/XCIpO1xuICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gcXMgPyBwYXJzZVF1ZXJ5U3RyaW5nKHFzKSA6IHt9O1xuICAgIGlmICh1cmkuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpIHtcbiAgICAgIHVyaSA9IFwiaHR0cHM6Ly9cIiArIHVyaTtcbiAgICB9XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB1cmk7XG4gIH1cbiAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgcmVhbHRpbWVIb3N0LFxuICAgIHJlc3RIb3N0LFxuICAgIG1heE1lc3NhZ2VTaXplOiBvcHRpb25zLm1heE1lc3NhZ2VTaXplIHx8IERlZmF1bHRzLm1heE1lc3NhZ2VTaXplLFxuICAgIHRpbWVvdXRzLFxuICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zLFxuICAgIGNvbm5lY3Rpdml0eUNoZWNrVXJsLFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpc2VDaGFubmVsT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhbm5lbE9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoY2hhbm5lbE9wdGlvbnMuY2lwaGVyKSB7XG4gICAgaWYgKCFDcnlwdG8yKVxuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJDcnlwdG9cIik7XG4gICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvMi5nZXRDaXBoZXIoY2hhbm5lbE9wdGlvbnMuY2lwaGVyLCBsb2dnZXIpO1xuICAgIGNoYW5uZWxPcHRpb25zLmNpcGhlciA9IGNpcGhlci5jaXBoZXJQYXJhbXM7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlciA9IGNpcGhlci5jaXBoZXI7XG4gIH0gZWxzZSBpZiAoXCJjaXBoZXJcIiBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgIGNoYW5uZWxPcHRpb25zLmNpcGhlciA9IHZvaWQgMDtcbiAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gbnVsbDtcbiAgfVxuICByZXR1cm4gY2hhbm5lbE9wdGlvbnM7XG59XG52YXIgY29udGVudFR5cGVzID0ge1xuICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgeG1sOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBodG1sOiBcInRleHQvaHRtbFwiLFxuICBtc2dwYWNrOiBcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiLFxuICB0ZXh0OiBcInRleHQvcGxhaW5cIlxufTtcbnZhciBkZWZhdWx0SGVhZGVyc09wdGlvbnMgPSB7XG4gIGZvcm1hdDogXCJqc29uXCIgLyoganNvbiAqLyxcbiAgcHJvdG9jb2xWZXJzaW9uOiBEZWZhdWx0cy5wcm90b2NvbFZlcnNpb25cbn07XG5mdW5jdGlvbiBkZWZhdWx0R2V0SGVhZGVycyhvcHRpb25zLCB7XG4gIGZvcm1hdCA9IGRlZmF1bHRIZWFkZXJzT3B0aW9ucy5mb3JtYXQsXG4gIHByb3RvY29sVmVyc2lvbiA9IGRlZmF1bHRIZWFkZXJzT3B0aW9ucy5wcm90b2NvbFZlcnNpb25cbn0gPSB7fSkge1xuICBjb25zdCBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0XTtcbiAgcmV0dXJuIHtcbiAgICBhY2NlcHQsXG4gICAgXCJYLUFibHktVmVyc2lvblwiOiBwcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICBcIkFibHktQWdlbnRcIjogZ2V0QWdlbnRTdHJpbmcob3B0aW9ucylcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQb3N0SGVhZGVycyhvcHRpb25zLCB7XG4gIGZvcm1hdCA9IGRlZmF1bHRIZWFkZXJzT3B0aW9ucy5mb3JtYXQsXG4gIHByb3RvY29sVmVyc2lvbiA9IGRlZmF1bHRIZWFkZXJzT3B0aW9ucy5wcm90b2NvbFZlcnNpb25cbn0gPSB7fSkge1xuICBsZXQgY29udGVudFR5cGU7XG4gIGNvbnN0IGFjY2VwdCA9IGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVzW2Zvcm1hdF07XG4gIHJldHVybiB7XG4gICAgYWNjZXB0LFxuICAgIFwiY29udGVudC10eXBlXCI6IGNvbnRlbnRUeXBlLFxuICAgIFwiWC1BYmx5LVZlcnNpb25cIjogcHJvdG9jb2xWZXJzaW9uLnRvU3RyaW5nKCksXG4gICAgXCJBYmx5LUFnZW50XCI6IGdldEFnZW50U3RyaW5nKG9wdGlvbnMpXG4gIH07XG59XG52YXIgZGVmYXVsdHNfZGVmYXVsdCA9IERlZmF1bHRzO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdHMocGxhdGZvcm1EZWZhdWx0cykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihEZWZhdWx0cywgcGxhdGZvcm1EZWZhdWx0cyk7XG59XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvbXVsdGljYXN0ZXIudHNcbnZhciBNdWx0aWNhc3RlciA9IGNsYXNzIF9NdWx0aWNhc3RlciB7XG4gIC8vIFByaXZhdGUgY29uc3RydWN0b3I7IHVzZSBzdGF0aWMgTXVsdGljYXN0ZXIuY3JlYXRlIGluc3RlYWRcbiAgY29uc3RydWN0b3IobG9nZ2VyLCBtZW1iZXJzKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycyB8fCBbXTtcbiAgfVxuICBjYWxsKGVyciwgcmVzdWx0KSB7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5tZW1iZXJzKSB7XG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWVtYmVyKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJNdWx0aWNhc3RlciBtdWx0aXBsZSBjYWxsYmFjayBoYW5kbGVyXCIsXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uOiBcIiArIGUgKyBcIjsgc3RhY2sgPSBcIiArIGUuc3RhY2tcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHB1c2goLi4uYXJncykge1xuICAgIHRoaXMubWVtYmVycy5wdXNoKC4uLmFyZ3MpO1xuICB9XG4gIGNyZWF0ZVByb21pc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHVzaCgoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXNvbHZlQWxsKHJlc3VsdCkge1xuICAgIHRoaXMuY2FsbChudWxsLCByZXN1bHQpO1xuICB9XG4gIHJlamVjdEFsbChlcnIpIHtcbiAgICB0aGlzLmNhbGwoZXJyKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGxvZ2dlciwgbWVtYmVycykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IF9NdWx0aWNhc3Rlcihsb2dnZXIsIG1lbWJlcnMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKChlcnIsIHJlc3VsdCkgPT4gaW5zdGFuY2UuY2FsbChlcnIsIHJlc3VsdCksIHtcbiAgICAgIHB1c2g6IChmbikgPT4gaW5zdGFuY2UucHVzaChmbiksXG4gICAgICBjcmVhdGVQcm9taXNlOiAoKSA9PiBpbnN0YW5jZS5jcmVhdGVQcm9taXNlKCksXG4gICAgICByZXNvbHZlQWxsOiAocmVzdWx0KSA9PiBpbnN0YW5jZS5yZXNvbHZlQWxsKHJlc3VsdCksXG4gICAgICByZWplY3RBbGw6IChlcnIpID0+IGluc3RhbmNlLnJlamVjdEFsbChlcnIpXG4gICAgfSk7XG4gIH1cbn07XG52YXIgbXVsdGljYXN0ZXJfZGVmYXVsdCA9IE11bHRpY2FzdGVyO1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9IdHRwTWV0aG9kcy50c1xudmFyIEh0dHBNZXRob2RzID0gLyogQF9fUFVSRV9fICovICgoSHR0cE1ldGhvZHMyKSA9PiB7XG4gIEh0dHBNZXRob2RzMltcIkdldFwiXSA9IFwiZ2V0XCI7XG4gIEh0dHBNZXRob2RzMltcIkRlbGV0ZVwiXSA9IFwiZGVsZXRlXCI7XG4gIEh0dHBNZXRob2RzMltcIlBvc3RcIl0gPSBcInBvc3RcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUHV0XCJdID0gXCJwdXRcIjtcbiAgSHR0cE1ldGhvZHMyW1wiUGF0Y2hcIl0gPSBcInBhdGNoXCI7XG4gIHJldHVybiBIdHRwTWV0aG9kczI7XG59KShIdHRwTWV0aG9kcyB8fCB7fSk7XG52YXIgSHR0cE1ldGhvZHNfZGVmYXVsdCA9IEh0dHBNZXRob2RzO1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9IdHRwU3RhdHVzQ29kZXMudHNcbnZhciBIdHRwU3RhdHVzQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChIdHRwU3RhdHVzQ29kZXMyKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlN1Y2Nlc3NcIl0gPSAyMDBdID0gXCJTdWNjZXNzXCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIk5vQ29udGVudFwiXSA9IDIwNF0gPSBcIk5vQ29udGVudFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJCYWRSZXF1ZXN0XCJdID0gNDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJVbmF1dGhvcml6ZWRcIl0gPSA0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiRm9yYmlkZGVuXCJdID0gNDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIlJlcXVlc3RUaW1lb3V0XCJdID0gNDA4XSA9IFwiUmVxdWVzdFRpbWVvdXRcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiXSA9IDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbiAgcmV0dXJuIEh0dHBTdGF0dXNDb2RlczI7XG59KShIdHRwU3RhdHVzQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gaXNTdWNjZXNzQ29kZShzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBzdGF0dXNDb2RlID49IDIwMCAvKiBTdWNjZXNzICovICYmIHN0YXR1c0NvZGUgPCA0MDAgLyogQmFkUmVxdWVzdCAqLztcbn1cbnZhciBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdCA9IEh0dHBTdGF0dXNDb2RlcztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2F1dGgudHNcbnZhciBNQVhfVE9LRU5fTEVOR1RIID0gTWF0aC5wb3coMiwgMTcpO1xuZnVuY3Rpb24gcmFuZG9tKCkge1xuICByZXR1cm4gKFwiMDAwMDAwXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTE2KSkuc2xpY2UoLTE2KTtcbn1cbmZ1bmN0aW9uIGlzUmVhbHRpbWUoY2xpZW50KSB7XG4gIHJldHVybiAhIWNsaWVudC5jb25uZWN0aW9uO1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSB7XG4gIGlmICghaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZXJyKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKGluc3BlY3RFcnJvcihlcnIpLCBlcnIuY29kZSB8fCA0MDE3MCwgZXJyLnN0YXR1c0NvZGUgfHwgNDAxKTtcbiAgfVxuICBpZiAoIWVyci5jb2RlKSB7XG4gICAgaWYgKGVyci5zdGF0dXNDb2RlID09PSA0MDMpIHtcbiAgICAgIGVyci5jb2RlID0gNDAzMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVyci5jb2RlID0gNDAxNzA7XG4gICAgICBlcnIuc3RhdHVzQ29kZSA9IDQwMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cbnZhciBobWFjID0gKHRleHQsIGtleSkgPT4ge1xuICBjb25zdCBidWZmZXJVdGlscyA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZSh0ZXh0KTtcbiAgY29uc3Qga2V5QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZShrZXkpO1xuICBjb25zdCBkaWdlc3QgPSBidWZmZXJVdGlscy5obWFjU2hhMjU2KHRleHRCdWZmZXIsIGtleUJ1ZmZlcik7XG4gIHJldHVybiBidWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGlnZXN0KTtcbn07XG5mdW5jdGlvbiBjMTRuKGNhcGFiaWxpdHkpIHtcbiAgaWYgKCFjYXBhYmlsaXR5KVxuICAgIHJldHVybiBcIlwiO1xuICBpZiAodHlwZW9mIGNhcGFiaWxpdHkgPT0gXCJzdHJpbmdcIilcbiAgICBjYXBhYmlsaXR5ID0gSlNPTi5wYXJzZShjYXBhYmlsaXR5KTtcbiAgY29uc3QgYzE0bkNhcGFiaWxpdHkgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qga2V5cyA9IGtleXNBcnJheShjYXBhYmlsaXR5LCB0cnVlKTtcbiAgaWYgKCFrZXlzKVxuICAgIHJldHVybiBcIlwiO1xuICBrZXlzLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgYzE0bkNhcGFiaWxpdHlba2V5c1tpXV0gPSBjYXBhYmlsaXR5W2tleXNbaV1dLnNvcnQoKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYzE0bkNhcGFiaWxpdHkpO1xufVxuZnVuY3Rpb24gbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QoYXV0aE9wdGlvbnMsIGxvZ2dlcikge1xuICBpZiAoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2tcIik7XG4gIH0gZWxzZSBpZiAoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybFwiKTtcbiAgfSBlbHNlIGlmIChhdXRoT3B0aW9ucy5rZXkpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmdcIik7XG4gIH0gZWxzZSBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBzdXBwbGllZCB0b2tlbiBvbmx5XCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1zZyA9IFwiYXV0aE9wdGlvbnMgbXVzdCBpbmNsdWRlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnNcIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aCgpXCIsIG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSB7XG4gIHJldHVybiBcInVzZVRva2VuQXV0aFwiIGluIG9wdGlvbnMgJiYgIW9wdGlvbnMudXNlVG9rZW5BdXRoO1xufVxuZnVuY3Rpb24gdXNlVG9rZW5BdXRoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMudXNlVG9rZW5BdXRoIHx8ICFiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykgJiYgKG9wdGlvbnMuYXV0aENhbGxiYWNrIHx8IG9wdGlvbnMuYXV0aFVybCB8fCBvcHRpb25zLnRva2VuIHx8IG9wdGlvbnMudG9rZW5EZXRhaWxzKTtcbn1cbmZ1bmN0aW9uIG5vV2F5VG9SZW5ldyhvcHRpb25zKSB7XG4gIHJldHVybiAhb3B0aW9ucy5rZXkgJiYgIW9wdGlvbnMuYXV0aENhbGxiYWNrICYmICFvcHRpb25zLmF1dGhVcmw7XG59XG52YXIgdHJJZCA9IDA7XG5mdW5jdGlvbiBnZXRUb2tlblJlcXVlc3RJZCgpIHtcbiAgcmV0dXJuIHRySWQrKztcbn1cbnZhciBBdXRoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGluaXRpYWxpemF0aW9uIGlzIGFsd2F5cyBvdmVyd3JpdHRlbiBhbmQgb25seSB1c2VkIHRvIHByZXZlbnQgYSBUeXBlU2NyaXB0IGNvbXBpbGVyIGVycm9yXG4gICAgdGhpcy5hdXRoT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMudG9rZW5QYXJhbXMgPSBvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcyB8fCB7fTtcbiAgICB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodXNlVG9rZW5BdXRoKG9wdGlvbnMpKSB7XG4gICAgICBpZiAobm9XYXlUb1JlbmV3KG9wdGlvbnMpKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJBdXRoKClcIixcbiAgICAgICAgICBcIldhcm5pbmc6IGxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NhdmVUb2tlbk9wdGlvbnMob3B0aW9ucy5kZWZhdWx0VG9rZW5QYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucywgdGhpcy5sb2dnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW9wdGlvbnMua2V5KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiTm8gYXV0aGVudGljYXRpb24gb3B0aW9ucyBwcm92aWRlZDsgbmVlZCBvbmUgb2Y6IGtleSwgYXV0aFVybCwgb3IgYXV0aENhbGxiYWNrIChvciBmb3IgdGVzdGluZyBvbmx5LCB0b2tlbiBvciB0b2tlbkRldGFpbHMpXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgoKVwiLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKG1zZywgNDAxNjAsIDQwMSk7XG4gICAgICB9XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJhbm9ueW1vdXMsIHVzaW5nIGJhc2ljIGF1dGhcIik7XG4gICAgICB0aGlzLl9zYXZlQmFzaWNPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgYXV0aG9yaXplKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIGlmIChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5rZXkgJiYgdGhpcy5hdXRoT3B0aW9ucy5rZXkgIT09IGF1dGhPcHRpb25zLmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byB1cGRhdGUgYXV0aCBvcHRpb25zIHdpdGggaW5jb21wYXRpYmxlIGtleVwiLCA0MDEwMiwgNDAxKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0b2tlbkRldGFpbHMgPSBhd2FpdCB0aGlzLl9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zICE9IG51bGwgPyB0b2tlblBhcmFtcyA6IG51bGwsIGF1dGhPcHRpb25zICE9IG51bGwgPyBhdXRoT3B0aW9ucyA6IG51bGwpO1xuICAgICAgaWYgKGlzUmVhbHRpbWUodGhpcy5jbGllbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKFxuICAgICAgICAgICAgdG9rZW5EZXRhaWxzLFxuICAgICAgICAgICAgKGVyciwgdG9rZW5EZXRhaWxzMikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHRva2VuRGV0YWlsczIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5EZXRhaWxzO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRoaXMuY2xpZW50LmNvbm5lY3Rpb24gJiYgZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0LkZvcmJpZGRlbikge1xuICAgICAgICB0aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIC8qIEZvciBpbnRlcm5hbCB1c2UsIGVnIGJ5IGNvbm5lY3Rpb25NYW5hZ2VyIC0gdXNlZnVsIHdoZW4gd2FudCB0byBjYWxsIGJhY2tcbiAgICogYXMgc29vbiBhcyB3ZSBoYXZlIHRoZSBuZXcgdG9rZW4sIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGl0IHRvIHRha2VcbiAgICogZWZmZWN0IG9uIHRoZSBjb25uZWN0aW9uIGFzICNhdXRob3JpemUgZG9lcyAqL1xuICBhc3luYyBfZm9yY2VOZXdUb2tlbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMsIHRoaXMubG9nZ2VyKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKHRydWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZWxldGUgdGhpcy50b2tlblBhcmFtcy50aW1lc3RhbXA7XG4gICAgICBkZWxldGUgdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWU7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlcXVlc3RUb2tlbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNvbHZlZEF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcbiAgICBjb25zdCByZXNvbHZlZFRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICBsZXQgdG9rZW5SZXF1ZXN0Q2FsbGJhY2ssIGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2tcIik7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmxcIik7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IChwYXJhbXMsIGNiKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gbWl4aW4oXG4gICAgICAgICAgeyBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpblwiIH0sXG4gICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoSGVhZGVyc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCB1c2VQb3N0ID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoTWV0aG9kICYmIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aE1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcInBvc3RcIjtcbiAgICAgICAgbGV0IHByb3ZpZGVkUXNQYXJhbXM7XG4gICAgICAgIGNvbnN0IHF1ZXJ5SWR4ID0gcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLmluZGV4T2YoXCI/XCIpO1xuICAgICAgICBpZiAocXVlcnlJZHggPiAtMSkge1xuICAgICAgICAgIHByb3ZpZGVkUXNQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZShxdWVyeUlkeCkpO1xuICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCA9IHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZSgwLCBxdWVyeUlkeCk7XG4gICAgICAgICAgaWYgKCF1c2VQb3N0KSB7XG4gICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhQYXJhbXMgPSBtaXhpbihcbiAgICAgICAgICAgICAgcHJvdmlkZWRRc1BhcmFtcyxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoUGFyYW1zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoUGFyYW1zID0gbWl4aW4oe30sIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFBhcmFtcyB8fCB7fSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgYXV0aFVybFJlcXVlc3RDYWxsYmFjayA9IChyZXN1bHQpID0+IHtcbiAgICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgICBsZXQgYm9keSA9IChfYTIgPSByZXN1bHQuYm9keSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFja1wiLFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIEVycm9yOiBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycyA9IChfYiA9IHJlc3VsdC5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudFR5cGVIZWFkZXJPckhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVIZWFkZXJPckhlYWRlcnMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZUhlYWRlck9ySGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQ7IGNvbnRlbnQtdHlwZTogXCIgKyBjb250ZW50VHlwZSArIFwiOyBib2R5OiBcIiArIGluc3BlY3RCb2R5KGJvZHkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICBjYihyZXN1bHQuZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LnVucGFja2VkKSB7XG4gICAgICAgICAgICBjYihudWxsLCBib2R5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpKVxuICAgICAgICAgICAgYm9keSA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYihuZXcgRXJyb3JJbmZvKFwiYXV0aFVybCByZXNwb25zZSBpcyBtaXNzaW5nIGEgY29udGVudC10eXBlIGhlYWRlclwiLCA0MDE3MCwgNDAxKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSA+IC0xLCB0ZXh0ID0gY29udGVudFR5cGUuaW5kZXhPZihcInRleHQvcGxhaW5cIikgPiAtMSB8fCBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vand0XCIpID4gLTE7XG4gICAgICAgICAgaWYgKCFqc29uICYmICF0ZXh0KSB7XG4gICAgICAgICAgICBjYihcbiAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcImF1dGhVcmwgcmVzcG9uZGVkIHdpdGggdW5hY2NlcHRhYmxlIGNvbnRlbnQtdHlwZSBcIiArIGNvbnRlbnRUeXBlICsgXCIsIHNob3VsZCBiZSBlaXRoZXIgdGV4dC9wbGFpbiwgYXBwbGljYXRpb24vand0IG9yIGFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgY2IobmV3IEVycm9ySW5mbyhcImF1dGhVcmwgcmVzcG9uc2UgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGhcIiwgNDAxNzAsIDQwMSksIG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY2IoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBlcnJvciBwcm9jZXNzaW5nIGF1dGhVUkwgcmVzcG9uc2U7IGVyciA9IFwiICsgZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYihudWxsLCBib2R5LCBjb250ZW50VHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrXCIsXG4gICAgICAgICAgXCJSZXF1ZXN0aW5nIHRva2VuIGZyb20gXCIgKyByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwgKyBcIjsgUGFyYW1zOiBcIiArIEpTT04uc3RyaW5naWZ5KGF1dGhQYXJhbXMpICsgXCI7IG1ldGhvZDogXCIgKyAodXNlUG9zdCA/IFwiUE9TVFwiIDogXCJHRVRcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHVzZVBvc3QpIHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXV0aEhlYWRlcnMgfHwge307XG4gICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG4gICAgICAgICAgY29uc3QgYm9keSA9IHRvUXVlcnlTdHJpbmcoYXV0aFBhcmFtcykuc2xpY2UoMSk7XG4gICAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kb1VyaShcbiAgICAgICAgICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LFxuICAgICAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwsXG4gICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgIHByb3ZpZGVkUXNQYXJhbXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGVyciA/IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2soZXJyKSA6IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2socmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuaHR0cC5kb1VyaShIdHRwTWV0aG9kc19kZWZhdWx0LkdldCwgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLCBhdXRoSGVhZGVycyB8fCB7fSwgbnVsbCwgYXV0aFBhcmFtcyksXG4gICAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGVyciA/IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2soZXJyKSA6IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2socmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLmtleSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKClcIixcbiAgICAgICAgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZ1wiXG4gICAgICApO1xuICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSAocGFyYW1zLCBjYikgPT4ge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgICAgdGhpcy5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCByZXNvbHZlZEF1dGhPcHRpb25zKSxcbiAgICAgICAgICAoZXJyLCByZXN1bHQpID0+IGNiKGVyciwgcmVzdWx0ICE9IG51bGwgPyByZXN1bHQgOiBudWxsKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gXCJOZWVkIGEgbmV3IHRva2VuLCBidXQgYXV0aE9wdGlvbnMgZG9lcyBub3QgaW5jbHVkZSBhbnkgd2F5IHRvIHJlcXVlc3Qgb25lIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSlcIjtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJBdXRoKClcIixcbiAgICAgICAgXCJsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscFwiXG4gICAgICApO1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhtc2csIDQwMTcxLCA0MDMpO1xuICAgIH1cbiAgICBpZiAoXCJjYXBhYmlsaXR5XCIgaW4gcmVzb2x2ZWRUb2tlblBhcmFtcylcbiAgICAgIHJlc29sdmVkVG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4oXG4gICAgICAgIHJlc29sdmVkVG9rZW5QYXJhbXMuY2FwYWJpbGl0eVxuICAgICAgKTtcbiAgICBjb25zdCB0b2tlblJlcXVlc3QgPSAoc2lnbmVkVG9rZW5QYXJhbXMsIHRva2VuQ2IpID0+IHtcbiAgICAgIGNvbnN0IGtleU5hbWUgPSBzaWduZWRUb2tlblBhcmFtcy5rZXlOYW1lLCBwYXRoID0gXCIva2V5cy9cIiArIGtleU5hbWUgKyBcIi9yZXF1ZXN0VG9rZW5cIiwgdG9rZW5VcmkgPSBmdW5jdGlvbihob3N0KSB7XG4gICAgICAgIHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICAgIGlmIChyZXNvbHZlZEF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKVxuICAgICAgICBtaXhpbihyZXF1ZXN0SGVhZGVycywgcmVzb2x2ZWRBdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKS5yZXF1ZXN0VG9rZW5cIixcbiAgICAgICAgXCJTZW5kaW5nIFBPU1QgdG8gXCIgKyBwYXRoICsgXCI7IFRva2VuIHBhcmFtczogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcylcbiAgICAgICk7XG4gICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgIHRoaXMuY2xpZW50Lmh0dHAuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCB0b2tlblVyaSwgcmVxdWVzdEhlYWRlcnMsIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKSwgbnVsbCksXG4gICAgICAgIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gdG9rZW5DYihlcnIpIDogdG9rZW5DYihyZXN1bHQuZXJyb3IsIHJlc3VsdC5ib2R5LCByZXN1bHQudW5wYWNrZWQpXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gZmFsc2UsIHRpbWVvdXRMZW5ndGggPSB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbXNnID0gXCJUb2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWVvdXRMZW5ndGggLyAxZTMgKyBcIiBzZWNvbmRzXCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8obXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICB9LCB0aW1lb3V0TGVuZ3RoKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrKHJlc29sdmVkVG9rZW5QYXJhbXMsIChlcnIsIHRva2VuUmVxdWVzdE9yRGV0YWlscywgY29udGVudFR5cGUpID0+IHtcbiAgICAgICAgaWYgKHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGVhclRpbWVvdXQodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsXG4gICAgICAgICAgICBcInRva2VuIHJlcXVlc3Qgc2lnbmluZyBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWplY3Qobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVG9rZW4gc3RyaW5nIGlzIGVtcHR5XCIsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJUb2tlbiBzdHJpbmcgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGggKHdhcyBcIiArIHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggKyBcIiBieXRlcylcIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRva2VuIHN0cmluZyB3YXMgbGl0ZXJhbCBudWxsL3VuZGVmaW5lZFwiLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHNbMF0gPT09IFwie1wiICYmICEoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2p3dFwiKSA+IC0xKSkge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIFwiVG9rZW4gd2FzIGRvdWJsZS1lbmNvZGVkOyBtYWtlIHN1cmUgeW91J3JlIG5vdCBKU09OLWVuY29kaW5nIGFuIGFscmVhZHkgZW5jb2RlZCB0b2tlbiByZXF1ZXN0IG9yIGRldGFpbHNcIixcbiAgICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHRva2VuOiB0b2tlblJlcXVlc3RPckRldGFpbHMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscyAhPT0gXCJvYmplY3RcIiB8fCB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBcIkV4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcgb3IgdG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCwgYnV0IGdvdCBhIFwiICsgdHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscztcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIG1zZyk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8obXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3RPckRldGFpbHMpLmxlbmd0aDtcbiAgICAgICAgaWYgKG9iamVjdFNpemUgPiBNQVhfVE9LRU5fTEVOR1RIICYmICFyZXNvbHZlZEF1dGhPcHRpb25zLnN1cHByZXNzTWF4TGVuZ3RoQ2hlY2spIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICBcIlRva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBzdHJpbmdpZmllZCBzaXplICh3YXMgXCIgKyBvYmplY3RTaXplICsgXCIgYnl0ZXMpXCIsXG4gICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICA0MDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJpc3N1ZWRcIiBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpIHtcbiAgICAgICAgICByZXNvbHZlKHRva2VuUmVxdWVzdE9yRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKFwia2V5TmFtZVwiIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBcIkV4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcsIHRva2VuIHJlcXVlc3Qgb2JqZWN0LCBvciB0b2tlbiBkZXRhaWxzIG9iamVjdFwiO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgbXNnKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5SZXF1ZXN0KHRva2VuUmVxdWVzdE9yRGV0YWlscywgKGVycjIsIHRva2VuUmVzcG9uc2UsIHVucGFja2VkKSA9PiB7XG4gICAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsXG4gICAgICAgICAgICAgIFwidG9rZW4gcmVxdWVzdCBBUEkgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyMilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWplY3Qobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyMikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXVucGFja2VkKVxuICAgICAgICAgICAgdG9rZW5SZXNwb25zZSA9IEpTT04ucGFyc2UodG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5nZXRUb2tlbigpXCIsIFwidG9rZW4gcmVjZWl2ZWRcIik7XG4gICAgICAgICAgcmVzb2x2ZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBzaWduIGEgdG9rZW4gcmVxdWVzdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogTk9URSB0aGlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiB0aGUga2V5IHZhbHVlIGlzIGF2YWlsYWJsZSBsb2NhbGx5LlxuICAgKiBPdGhlcndpc2UsIHNpZ25lZCB0b2tlbiByZXF1ZXN0cyBtdXN0IGJlIG9idGFpbmVkIGZyb20gdGhlIGtleVxuICAgKiBvd25lciAoZWl0aGVyIHVzaW5nIHRoZSB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIG9yIHVybCkuXG4gICAqXG4gICAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuICAgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBvcHRpb25zOlxuICAgKiAtIGtleTogICAgICAgICAgIHRoZSBrZXkgdG8gdXNlLiBJZiBub3Qgc3BlY2lmaWVkLCBhIGtleSBwYXNzZWQgaW4gY29uc3RydWN0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgKlxuICAgKiAtIHF1ZXJ5VGltZSAgICAgIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGFibHkgc3lzdGVtIHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XG4gICAqXG4gICAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHRva2VuUGFyYW1zXG4gICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuICAgKiAtIHR0bDogICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgdGhlIHRva2VuIGluIG1zLiBJZiBub25lIGlzIHNwZWNpZmllZFxuICAgKiAgICAgICAgICAgICAgICAgIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0XG4gICAqICAgICAgICAgICAgICAgICAgZXhjZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICAgKlxuICAgKiAtIGNhcGFiaWxpdHk6ICAgIChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cbiAgICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAqXG4gICAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJRCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuICAgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcbiAgICpcbiAgICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG4gICAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG4gICAqL1xuICBhc3luYyBjcmVhdGVUb2tlblJlcXVlc3QodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuICAgIHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICBjb25zdCBrZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJObyBrZXkgc3BlY2lmaWVkXCIsIDQwMTAxLCA0MDMpO1xuICAgIH1cbiAgICBjb25zdCBrZXlQYXJ0cyA9IGtleS5zcGxpdChcIjpcIiksIGtleU5hbWUgPSBrZXlQYXJ0c1swXSwga2V5U2VjcmV0ID0ga2V5UGFydHNbMV07XG4gICAgaWYgKCFrZXlTZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJJbnZhbGlkIGtleSBzcGVjaWZpZWRcIiwgNDAxMDEsIDQwMyk7XG4gICAgfVxuICAgIGlmICh0b2tlblBhcmFtcy5jbGllbnRJZCA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIGNhblxcdTIwMTl0IGJlIGFuIGVtcHR5IHN0cmluZ1wiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgaWYgKFwiY2FwYWJpbGl0eVwiIGluIHRva2VuUGFyYW1zKSB7XG4gICAgICB0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdCA9IG1peGluKHsga2V5TmFtZSB9LCB0b2tlblBhcmFtcyksIGNsaWVudElkID0gdG9rZW5QYXJhbXMuY2xpZW50SWQgfHwgXCJcIiwgdHRsID0gdG9rZW5QYXJhbXMudHRsIHx8IFwiXCIsIGNhcGFiaWxpdHkgPSB0b2tlblBhcmFtcy5jYXBhYmlsaXR5IHx8IFwiXCI7XG4gICAgaWYgKCFyZXF1ZXN0LnRpbWVzdGFtcCkge1xuICAgICAgcmVxdWVzdC50aW1lc3RhbXAgPSBhd2FpdCB0aGlzLmdldFRpbWVzdGFtcChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5xdWVyeVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHJlcXVlc3Qubm9uY2UgfHwgKHJlcXVlc3Qubm9uY2UgPSByYW5kb20oKSksIHRpbWVzdGFtcCA9IHJlcXVlc3QudGltZXN0YW1wO1xuICAgIGNvbnN0IHNpZ25UZXh0ID0gcmVxdWVzdC5rZXlOYW1lICsgXCJcXG5cIiArIHR0bCArIFwiXFxuXCIgKyBjYXBhYmlsaXR5ICsgXCJcXG5cIiArIGNsaWVudElkICsgXCJcXG5cIiArIHRpbWVzdGFtcCArIFwiXFxuXCIgKyBub25jZSArIFwiXFxuXCI7XG4gICAgcmVxdWVzdC5tYWMgPSByZXF1ZXN0Lm1hYyB8fCBobWFjKHNpZ25UZXh0LCBrZXlTZWNyZXQpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGguZ2V0VG9rZW5SZXF1ZXN0KClcIiwgXCJnZW5lcmF0ZWQgc2lnbmVkIHJlcXVlc3RcIik7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXV0aCBxdWVyeSBwYXJhbXMgdG8gdXNlIGZvciBhIHdlYnNvY2tldCBjb25uZWN0aW9uLFxuICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEF1dGhQYXJhbXMoKSB7XG4gICAgaWYgKHRoaXMubWV0aG9kID09IFwiYmFzaWNcIilcbiAgICAgIHJldHVybiB7IGtleTogdGhpcy5rZXkgfTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCB0b2tlbkRldGFpbHMgPSBhd2FpdCB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSk7XG4gICAgICBpZiAoIXRva2VuRGV0YWlscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRoLmdldEF1dGhQYXJhbXMoKTogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIHJldHVybmVkIG5vIGVycm9yIG9yIHRva2VuRGV0YWlsc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGFjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VuIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyIHRvIHVzZSBmb3IgYSBSRVNUIG9yIGNvbWV0IHJlcXVlc3QsXG4gICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0QXV0aEhlYWRlcnMoKSB7XG4gICAgaWYgKHRoaXMubWV0aG9kID09IFwiYmFzaWNcIikge1xuICAgICAgcmV0dXJuIHsgYXV0aG9yaXphdGlvbjogXCJCYXNpYyBcIiArIHRoaXMuYmFzaWNLZXkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG9rZW5EZXRhaWxzID0gYXdhaXQgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UpO1xuICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBhdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIiArIHRvQmFzZTY0KHRva2VuRGV0YWlscy50b2tlbikgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB0aW1lIGJhc2VkIG9uIHRoZSBsb2NhbCBjbG9jayxcbiAgICogb3IgaWYgdGhlIG9wdGlvbiBxdWVyeVRpbWUgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBzZXJ2ZXIgdGltZS5cbiAgICogVGhlIHNlcnZlciB0aW1lIG9mZnNldCBmcm9tIHRoZSBsb2NhbCB0aW1lIGlzIHN0b3JlZCBzbyB0aGF0XG4gICAqIG9ubHkgb25lIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIHRpbWUgaXMgZXZlciBuZWVkZWRcbiAgICovXG4gIGFzeW5jIGdldFRpbWVzdGFtcChxdWVyeVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNUaW1lT2Zmc2V0U2V0KCkgJiYgKHF1ZXJ5VGltZSB8fCB0aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC50aW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCk7XG4gICAgfVxuICB9XG4gIGdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpICsgKHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQgfHwgMCk7XG4gIH1cbiAgaXNUaW1lT2Zmc2V0U2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ICE9PSBudWxsO1xuICB9XG4gIF9zYXZlQmFzaWNPcHRpb25zKGF1dGhPcHRpb25zKSB7XG4gICAgdGhpcy5tZXRob2QgPSBcImJhc2ljXCI7XG4gICAgdGhpcy5rZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG4gICAgdGhpcy5iYXNpY0tleSA9IHRvQmFzZTY0KGF1dGhPcHRpb25zLmtleSk7XG4gICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHt9O1xuICAgIGlmIChcImNsaWVudElkXCIgaW4gYXV0aE9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgfVxuICB9XG4gIF9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIHRoaXMubWV0aG9kID0gXCJ0b2tlblwiO1xuICAgIGlmICh0b2tlblBhcmFtcykge1xuICAgICAgdGhpcy50b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMpIHtcbiAgICAgIGlmIChhdXRoT3B0aW9ucy50b2tlbikge1xuICAgICAgICBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMgPSB0eXBlb2YgYXV0aE9wdGlvbnMudG9rZW4gPT09IFwic3RyaW5nXCIgPyB7IHRva2VuOiBhdXRoT3B0aW9ucy50b2tlbiB9IDogYXV0aE9wdGlvbnMudG9rZW47XG4gICAgICB9XG4gICAgICBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzO1xuICAgICAgfVxuICAgICAgaWYgKFwiY2xpZW50SWRcIiBpbiBhdXRoT3B0aW9ucykge1xuICAgICAgICB0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zO1xuICAgIH1cbiAgfVxuICAvKiBAcGFyYW0gZm9yY2VTdXBlcnNlZGU6IGZvcmNlIGEgbmV3IHRva2VuIHJlcXVlc3QgZXZlbiBpZiB0aGVyZSdzIG9uZSBpblxuICAgKiBwcm9ncmVzcywgbWFraW5nIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyB3YWl0IGZvciB0aGUgbmV3IG9uZSAqL1xuICBhc3luYyBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZm9yY2VTdXBlcnNlZGUpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5EZXRhaWxzO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgaWYgKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbi5jbGllbnRJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIk1pc21hdGNoIGJldHdlZW4gY2xpZW50SWQgaW4gdG9rZW4gKFwiICsgdG9rZW4uY2xpZW50SWQgKyBcIikgYW5kIGN1cnJlbnQgY2xpZW50SWQgKFwiICsgdGhpcy5jbGllbnRJZCArIFwiKVwiLFxuICAgICAgICAgIDQwMTAyLFxuICAgICAgICAgIDQwM1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpIHx8ICF0b2tlbi5leHBpcmVzIHx8IHRva2VuLmV4cGlyZXMgPj0gdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJBdXRoLmdldFRva2VuKClcIixcbiAgICAgICAgICBcInVzaW5nIGNhY2hlZCB0b2tlbjsgZXhwaXJlcyA9IFwiICsgdG9rZW4uZXhwaXJlc1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLmdldFRva2VuKClcIiwgXCJkZWxldGluZyBleHBpcmVkIHRva2VuXCIpO1xuICAgICAgdGhpcy50b2tlbkRldGFpbHMgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCB8fCAodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbXVsdGljYXN0ZXJfZGVmYXVsdC5jcmVhdGUodGhpcy5sb2dnZXIpKSkuY3JlYXRlUHJvbWlzZSgpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCAhPT0gbnVsbCAmJiAhZm9yY2VTdXBlcnNlZGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCB0b2tlblJlcXVlc3RJZCA9IHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gZ2V0VG9rZW5SZXF1ZXN0SWQoKTtcbiAgICBsZXQgdG9rZW5SZXNwb25zZSwgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB0b2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0VG9rZW4odGhpcy50b2tlblBhcmFtcywgdGhpcy5hdXRoT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IGVycjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID4gdG9rZW5SZXF1ZXN0SWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJBdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscygpXCIsXG4gICAgICAgIFwiRGlzY2FyZGluZyB0b2tlbiByZXF1ZXN0IHJlc3BvbnNlOyBvdmVydGFrZW4gYnkgbmV3ZXIgb25lXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBudWxsO1xuICAgIGNvbnN0IG11bHRpY2FzdGVyID0gdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0O1xuICAgIHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICBtdWx0aWNhc3RlciA9PSBudWxsID8gdm9pZCAwIDogbXVsdGljYXN0ZXIucmVqZWN0QWxsKGNhdWdodEVycm9yKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBtdWx0aWNhc3RlciA9PSBudWxsID8gdm9pZCAwIDogbXVsdGljYXN0ZXIucmVzb2x2ZUFsbCh0aGlzLnRva2VuRGV0YWlscyA9IHRva2VuUmVzcG9uc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qIFVzZXItc2V0OiBjaGVjayB0eXBlcywgJyonIGlzIGRpc2FsbG93ZWQsIHRocm93IGFueSBlcnJvcnMgKi9cbiAgX3VzZXJTZXRDbGllbnRJZChjbGllbnRJZCkge1xuICAgIGlmICghKHR5cGVvZiBjbGllbnRJZCA9PT0gXCJzdHJpbmdcIiB8fCBjbGllbnRJZCA9PT0gbnVsbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsXCIsIDQwMDEyLCA0MDApO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50SWQgPT09IFwiKlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAnQ2FuXFx1MjAxOXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIGluc3RhbnRpYXRlIHRoZSBsaWJyYXJ5IHdpdGgge2RlZmF1bHRUb2tlblBhcmFtczoge2NsaWVudElkOiBcIipcIn19KSwgb3IgaWYgY2FsbGluZyBhdXRob3JpemUoKSwgcGFzcyBpdCBpbiBhcyBhIHRva2VuUGFyYW06IGF1dGhvcml6ZSh7Y2xpZW50SWQ6IFwiKlwifSwgYXV0aE9wdGlvbnMpJyxcbiAgICAgICAgNDAwMTIsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuICAgICAgaWYgKGVycilcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICAvKiBBYmx5LXNldDogbm8gdHlwZWNoZWNraW5nLCAnKicgaXMgYWxsb3dlZCBidXQgbm90IHNldCBvbiB0aGlzLmNsaWVudElkKSwgcmV0dXJuIGVycm9ycyB0byB0aGUgY2FsbGVyICovXG4gIF91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCkge1xuICAgIGlmICh0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2goY2xpZW50SWQpKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIlVuZXhwZWN0ZWQgY2xpZW50SWQgbWlzbWF0Y2g6IGNsaWVudCBoYXMgXCIgKyB0aGlzLmNsaWVudElkICsgXCIsIHJlcXVlc3RlZCBcIiArIGNsaWVudElkO1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhtc2csIDQwMTAyLCA0MDEpO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoKVwiLCBtc2cpO1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGllbnRJZCA9IHRoaXMudG9rZW5QYXJhbXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBfdG9rZW5DbGllbnRJZE1pc21hdGNoKHRva2VuQ2xpZW50SWQpIHtcbiAgICByZXR1cm4gISEodGhpcy5jbGllbnRJZCAmJiB0aGlzLmNsaWVudElkICE9PSBcIipcIiAmJiB0b2tlbkNsaWVudElkICYmIHRva2VuQ2xpZW50SWQgIT09IFwiKlwiICYmIHRoaXMuY2xpZW50SWQgIT09IHRva2VuQ2xpZW50SWQpO1xuICB9XG4gIHN0YXRpYyBpc1Rva2VuRXJyKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgJiYgZXJyb3IuY29kZSA+PSA0MDE0MCAmJiBlcnJvci5jb2RlIDwgNDAxNTA7XG4gIH1cbiAgcmV2b2tlVG9rZW5zKHNwZWNpZmllcnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5yZXZva2VUb2tlbnMoc3BlY2lmaWVycywgb3B0aW9ucyk7XG4gIH1cbn07XG52YXIgYXV0aF9kZWZhdWx0ID0gQXV0aDtcblxuLy8gc3JjL2NvbW1vbi90eXBlcy9odHRwLnRzXG5mdW5jdGlvbiBwYXJhbVN0cmluZyhwYXJhbXMpIHtcbiAgY29uc3QgcGFyYW1QYWlycyA9IFtdO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBuZWVkbGUgaW4gcGFyYW1zKSB7XG4gICAgICBwYXJhbVBhaXJzLnB1c2gobmVlZGxlICsgXCI9XCIgKyBwYXJhbXNbbmVlZGxlXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbVBhaXJzLmpvaW4oXCImXCIpO1xufVxuZnVuY3Rpb24gYXBwZW5kaW5nUGFyYW1zKHVyaSwgcGFyYW1zKSB7XG4gIHJldHVybiB1cmkgKyAocGFyYW1zID8gXCI/XCIgOiBcIlwiKSArIHBhcmFtU3RyaW5nKHBhcmFtcyk7XG59XG5mdW5jdGlvbiBsb2dSZXN1bHQocmVzdWx0LCBtZXRob2QsIHVyaSwgcGFyYW1zLCBsb2dnZXIpIHtcbiAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkIEVycm9yOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnJvcilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkh0dHAuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgSGVhZGVyczogXCIgKyBwYXJhbVN0cmluZyhyZXN1bHQuaGVhZGVycykgKyBcIjsgU3RhdHVzQ29kZTogXCIgKyByZXN1bHQuc3RhdHVzQ29kZSArIFwiOyBCb2R5XCIgKyAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIocmVzdWx0LmJvZHkpID8gXCIgKEJhc2U2NCk6IFwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHJlc3VsdC5ib2R5KSA6IFwiOiBcIiArIHJlc3VsdC5ib2R5KVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxvZ1JlcXVlc3QobWV0aG9kLCB1cmksIGJvZHksIHBhcmFtcywgbG9nZ2VyKSB7XG4gIGlmIChsb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJIdHRwLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJTZW5kaW5nOyBcIiArIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykgKyBcIjsgQm9keVwiICsgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpID8gXCIgKEJhc2U2NCk6IFwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGJvZHkpIDogXCI6IFwiICsgYm9keSlcbiAgICApO1xuICB9XG59XG52YXIgSHR0cCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wbGF0Zm9ybUh0dHAgPSBuZXcgUGxhdGZvcm0uSHR0cChjbGllbnQpO1xuICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSB0aGlzLnBsYXRmb3JtSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSA/ICgpID0+IHRoaXMucGxhdGZvcm1IdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCkgOiB2b2lkIDA7XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hMiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvZ2dlcikgIT0gbnVsbCA/IF9iIDogbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlcjtcbiAgfVxuICBnZXQgc3VwcG9ydHNBdXRoSGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybUh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycztcbiAgfVxuICBnZXQgc3VwcG9ydHNMaW5rSGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybUh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycztcbiAgfVxuICBfZ2V0SG9zdHMoY2xpZW50KSB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGNsaWVudC5jb25uZWN0aW9uLCBjb25uZWN0aW9uSG9zdCA9IGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5ob3N0O1xuICAgIGlmIChjb25uZWN0aW9uSG9zdCkge1xuICAgICAgcmV0dXJuIFtjb25uZWN0aW9uSG9zdF0uY29uY2F0KGRlZmF1bHRzX2RlZmF1bHQuZ2V0RmFsbGJhY2tIb3N0cyhjbGllbnQub3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhjbGllbnQub3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgbm90IHRocm93IGFueSBlcnJvcnM7IHJhdGhlciwgaXQgd2lsbCBjb21tdW5pY2F0ZSBhbnkgZXJyb3IgYnkgcG9wdWxhdGluZyB0aGUge0BsaW5rIFJlcXVlc3RSZXN1bHQuZXJyb3J9IHByb3BlcnR5IG9mIHRoZSByZXR1cm5lZCB7QGxpbmsgUmVxdWVzdFJlc3VsdH0uXG4gICAqL1xuICBhc3luYyBkbyhtZXRob2QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgRXJyb3JJbmZvKFwiaHR0cC5kbyBjYWxsZWQgd2l0aG91dCBjbGllbnRcIiwgNWU0LCA1MDApIH07XG4gICAgICB9XG4gICAgICBjb25zdCB1cmlGcm9tSG9zdCA9IHR5cGVvZiBwYXRoID09PSBcImZ1bmN0aW9uXCIgPyBwYXRoIDogZnVuY3Rpb24oaG9zdCkge1xuICAgICAgICByZXR1cm4gY2xpZW50LmJhc2VVcmkoaG9zdCkgKyBwYXRoO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGYWxsYmFjayA9IGNsaWVudC5fY3VycmVudEZhbGxiYWNrO1xuICAgICAgaWYgKGN1cnJlbnRGYWxsYmFjaykge1xuICAgICAgICBpZiAoY3VycmVudEZhbGxiYWNrLnZhbGlkVW50aWwgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kb1VyaShtZXRob2QsIHVyaUZyb21Ib3N0KGN1cnJlbnRGYWxsYmFjay5ob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yICYmIHRoaXMucGxhdGZvcm1IdHRwLnNob3VsZEZhbGxiYWNrKHJlc3VsdC5lcnJvcikpIHtcbiAgICAgICAgICAgIGNsaWVudC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvKG1ldGhvZCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnQuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGhvc3RzID0gdGhpcy5fZ2V0SG9zdHMoY2xpZW50KTtcbiAgICAgIGlmIChob3N0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9VcmkobWV0aG9kLCB1cmlGcm9tSG9zdChob3N0c1swXSksIGhlYWRlcnMsIGJvZHksIHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBsZXQgdHJ5QUhvc3RTdGFydGVkQXQgPSBudWxsO1xuICAgICAgY29uc3QgdHJ5QUhvc3QgPSBhc3luYyAoY2FuZGlkYXRlSG9zdHMsIHBlcnNpc3RPblN1Y2Nlc3MpID0+IHtcbiAgICAgICAgY29uc3QgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgICAgIHRyeUFIb3N0U3RhcnRlZEF0ID0gdHJ5QUhvc3RTdGFydGVkQXQgIT0gbnVsbCA/IHRyeUFIb3N0U3RhcnRlZEF0IDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZG9VcmkobWV0aG9kLCB1cmlGcm9tSG9zdChob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvciAmJiB0aGlzLnBsYXRmb3JtSHR0cC5zaG91bGRGYWxsYmFjayhyZXN1bHQuZXJyb3IpICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gRGF0ZS5ub3coKSAtIHRyeUFIb3N0U3RhcnRlZEF0LmdldFRpbWUoKTtcbiAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPiBjbGllbnQub3B0aW9ucy50aW1lb3V0cy5odHRwTWF4UmV0cnlEdXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgYFRpbWVvdXQgZm9yIHRyeWluZyBmYWxsYmFjayBob3N0cyByZXRyaWVzLiBUb3RhbCBlbGFwc2VkIHRpbWUgZXhjZWVkZWQgdGhlICR7Y2xpZW50Lm9wdGlvbnMudGltZW91dHMuaHR0cE1heFJldHJ5RHVyYXRpb259bXMgbGltaXRgLFxuICAgICAgICAgICAgICAgIDUwMDAzLFxuICAgICAgICAgICAgICAgIDUwMFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ5QUhvc3QoY2FuZGlkYXRlSG9zdHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJzaXN0T25TdWNjZXNzKSB7XG4gICAgICAgICAgY2xpZW50Ll9jdXJyZW50RmFsbGJhY2sgPSB7XG4gICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgdmFsaWRVbnRpbDogRGF0ZS5ub3coKSArIGNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmZhbGxiYWNrUmV0cnlUaW1lb3V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0cnlBSG9zdChob3N0cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogbmV3IEVycm9ySW5mbyhgVW5leHBlY3RlZCBlcnJvciBpbiBIdHRwLmRvOiAke2luc3BlY3RFcnJvcihlcnIpfWAsIDUwMCwgNWU0KSB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBub3QgdGhyb3cgYW55IGVycm9yczsgcmF0aGVyLCBpdCB3aWxsIGNvbW11bmljYXRlIGFueSBlcnJvciBieSBwb3B1bGF0aW5nIHRoZSB7QGxpbmsgUmVxdWVzdFJlc3VsdC5lcnJvcn0gcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIHtAbGluayBSZXF1ZXN0UmVzdWx0fS5cbiAgICovXG4gIGFzeW5jIGRvVXJpKG1ldGhvZCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgbG9nUmVxdWVzdChtZXRob2QsIHVyaSwgYm9keSwgcGFyYW1zLCB0aGlzLmxvZ2dlcik7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBsYXRmb3JtSHR0cC5kb1VyaShtZXRob2QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zKTtcbiAgICAgIGlmICh0aGlzLmxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICBsb2dSZXN1bHQocmVzdWx0LCBtZXRob2QsIHVyaSwgcGFyYW1zLCB0aGlzLmxvZ2dlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBFcnJvckluZm8oYFVuZXhwZWN0ZWQgZXJyb3IgaW4gSHR0cC5kb1VyaTogJHtpbnNwZWN0RXJyb3IoZXJyKX1gLCA1MDAsIDVlNCkgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9iYXNlY2xpZW50LnRzXG52YXIgQmFzZUNsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIFRoZXNlIGV4cG9ydHMgYXJlIGZvciB1c2UgYnkgVU1EIHBsdWdpbnM7IHJlYXNvbiBiZWluZyBzbyB0aGF0IGNvbnN0cnVjdG9ycyBhbmQgc3RhdGljIG1ldGhvZHMgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZXNlIHBsdWdpbnMgd2l0aG91dCBuZWVkaW5nIHRvIGltcG9ydCB0aGUgY2xhc3NlcyBkaXJlY3RseSBhbmQgcmVzdWx0IGluIHRoZSBjbGFzcyBleGlzdGluZyBpbiBib3RoIHRoZSBwbHVnaW4gYW5kIHRoZSBjb3JlIGxpYnJhcnkuXG4gICAgICovXG4gICAgdGhpcy5QbGF0Zm9ybSA9IFBsYXRmb3JtO1xuICAgIHRoaXMuRXJyb3JJbmZvID0gRXJyb3JJbmZvO1xuICAgIHRoaXMuTG9nZ2VyID0gbG9nZ2VyX2RlZmF1bHQ7XG4gICAgdGhpcy5EZWZhdWx0cyA9IGRlZmF1bHRzX2RlZmF1bHQ7XG4gICAgdGhpcy5VdGlscyA9IHV0aWxzX2V4cG9ydHM7XG4gICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgdGhpcy5fYWRkaXRpb25hbEhUVFBSZXF1ZXN0SW1wbGVtZW50YXRpb25zID0gKF9hMiA9IG9wdGlvbnMucGx1Z2lucykgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgbG9nZ2VyX2RlZmF1bHQoKTtcbiAgICB0aGlzLmxvZ2dlci5zZXRMb2cob3B0aW9ucy5sb2dMZXZlbCwgb3B0aW9ucy5sb2dIYW5kbGVyKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiQmFzZUNsaWVudCgpXCIsXG4gICAgICBcImluaXRpYWxpemVkIHdpdGggY2xpZW50T3B0aW9ucyBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KG9wdGlvbnMpXG4gICAgKTtcbiAgICB0aGlzLl9Nc2dQYWNrID0gKF9jID0gKF9iID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuTXNnUGFjaykgIT0gbnVsbCA/IF9jIDogbnVsbDtcbiAgICBjb25zdCBub3JtYWxPcHRpb25zID0gdGhpcy5vcHRpb25zID0gZGVmYXVsdHNfZGVmYXVsdC5ub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMsIHRoaXMuX01zZ1BhY2ssIHRoaXMubG9nZ2VyKTtcbiAgICBpZiAobm9ybWFsT3B0aW9ucy5rZXkpIHtcbiAgICAgIGNvbnN0IGtleU1hdGNoID0gbm9ybWFsT3B0aW9ucy5rZXkubWF0Y2goL14oW146XFxzXSspOihbXjouXFxzXSspJC8pO1xuICAgICAgaWYgKCFrZXlNYXRjaCkge1xuICAgICAgICBjb25zdCBtc2cgPSBcImludmFsaWQga2V5IHBhcmFtZXRlclwiO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJCYXNlQ2xpZW50KClcIiwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhtc2csIDQwNDAwLCA0MDQpO1xuICAgICAgfVxuICAgICAgbm9ybWFsT3B0aW9ucy5rZXlOYW1lID0ga2V5TWF0Y2hbMV07XG4gICAgICBub3JtYWxPcHRpb25zLmtleVNlY3JldCA9IGtleU1hdGNoWzJdO1xuICAgIH1cbiAgICBpZiAoXCJjbGllbnRJZFwiIGluIG5vcm1hbE9wdGlvbnMpIHtcbiAgICAgIGlmICghKHR5cGVvZiBub3JtYWxPcHRpb25zLmNsaWVudElkID09PSBcInN0cmluZ1wiIHx8IG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IG51bGwpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbFwiLCA0MDAxMiwgNDAwKTtcbiAgICAgIGVsc2UgaWYgKG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IFwiKlwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICdDYW5cXHUyMDE5dCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgdXNlIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSknLFxuICAgICAgICAgIDQwMDEyLFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJCYXNlQ2xpZW50KClcIiwgXCJzdGFydGVkOyB2ZXJzaW9uID0gXCIgKyBkZWZhdWx0c19kZWZhdWx0LnZlcnNpb24pO1xuICAgIHRoaXMuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLmh0dHAgPSBuZXcgSHR0cCh0aGlzKTtcbiAgICB0aGlzLmF1dGggPSBuZXcgYXV0aF9kZWZhdWx0KHRoaXMsIG5vcm1hbE9wdGlvbnMpO1xuICAgIHRoaXMuX3Jlc3QgPSAoKF9kID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2QuUmVzdCkgPyBuZXcgb3B0aW9ucy5wbHVnaW5zLlJlc3QodGhpcykgOiBudWxsO1xuICAgIHRoaXMuX0NyeXB0byA9IChfZiA9IChfZSA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLkNyeXB0bykgIT0gbnVsbCA/IF9mIDogbnVsbDtcbiAgICB0aGlzLl9fRmlsdGVyZWRTdWJzY3JpcHRpb25zID0gKF9oID0gKF9nID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2cuTWVzc2FnZUludGVyYWN0aW9ucykgIT0gbnVsbCA/IF9oIDogbnVsbDtcbiAgfVxuICBnZXQgcmVzdCgpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3QpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUmVzdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3Q7XG4gIH1cbiAgZ2V0IF9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLl9fRmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1lc3NhZ2VJbnRlcmFjdGlvbnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fRmlsdGVyZWRTdWJzY3JpcHRpb25zO1xuICB9XG4gIGdldCBjaGFubmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmNoYW5uZWxzO1xuICB9XG4gIGdldCBwdXNoKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3QucHVzaDtcbiAgfVxuICBnZXQgZGV2aWNlKCkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKCEoKF9hMiA9IHRoaXMub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpIHx8ICF0aGlzLnB1c2guTG9jYWxEZXZpY2UpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZXZpY2UpIHtcbiAgICAgIHRoaXMuX2RldmljZSA9IHRoaXMucHVzaC5Mb2NhbERldmljZS5sb2FkKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGV2aWNlO1xuICB9XG4gIGJhc2VVcmkoaG9zdCkge1xuICAgIHJldHVybiBkZWZhdWx0c19kZWZhdWx0LmdldEh0dHBTY2hlbWUodGhpcy5vcHRpb25zKSArIGhvc3QgKyBcIjpcIiArIGRlZmF1bHRzX2RlZmF1bHQuZ2V0UG9ydCh0aGlzLm9wdGlvbnMsIGZhbHNlKTtcbiAgfVxuICBhc3luYyBzdGF0cyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnN0YXRzKHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgdGltZShwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnRpbWUocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KG1ldGhvZCwgcGF0aCwgdmVyc2lvbjIsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycykge1xuICAgIHJldHVybiB0aGlzLnJlc3QucmVxdWVzdChtZXRob2QsIHBhdGgsIHZlcnNpb24yLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMpO1xuICB9XG4gIGJhdGNoUHVibGlzaChzcGVjT3JTcGVjcykge1xuICAgIHJldHVybiB0aGlzLnJlc3QuYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKTtcbiAgfVxuICBiYXRjaFByZXNlbmNlKGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5iYXRjaFByZXNlbmNlKGNoYW5uZWxzKTtcbiAgfVxuICBzZXRMb2cobG9nT3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyLnNldExvZyhsb2dPcHRpb25zLmxldmVsLCBsb2dPcHRpb25zLmhhbmRsZXIpO1xuICB9XG59O1xuQmFzZUNsaWVudC5QbGF0Zm9ybSA9IFBsYXRmb3JtO1xudmFyIGJhc2VjbGllbnRfZGVmYXVsdCA9IEJhc2VDbGllbnQ7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2RldmljZWRldGFpbHMudHNcbnZhciBEZXZpY2VEZXRhaWxzID0gY2xhc3MgX0RldmljZURldGFpbHMge1xuICB0b0pTT04oKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRldmljZVNlY3JldDogdGhpcy5kZXZpY2VTZWNyZXQsXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIGZvcm1GYWN0b3I6IHRoaXMuZm9ybUZhY3RvcixcbiAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICBkZXZpY2VJZGVudGl0eVRva2VuOiB0aGlzLmRldmljZUlkZW50aXR5VG9rZW4sXG4gICAgICBwdXNoOiB7XG4gICAgICAgIHJlY2lwaWVudDogKF9hMiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZWNpcGllbnQsXG4gICAgICAgIHN0YXRlOiAoX2IgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zdGF0ZSxcbiAgICAgICAgZXJyb3I6IChfYyA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmVycm9yXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgIGxldCByZXN1bHQgPSBcIltEZXZpY2VEZXRhaWxzXCI7XG4gICAgaWYgKHRoaXMuaWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGlkPVwiICsgdGhpcy5pZDtcbiAgICBpZiAodGhpcy5wbGF0Zm9ybSlcbiAgICAgIHJlc3VsdCArPSBcIjsgcGxhdGZvcm09XCIgKyB0aGlzLnBsYXRmb3JtO1xuICAgIGlmICh0aGlzLmZvcm1GYWN0b3IpXG4gICAgICByZXN1bHQgKz0gXCI7IGZvcm1GYWN0b3I9XCIgKyB0aGlzLmZvcm1GYWN0b3I7XG4gICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNsaWVudElkPVwiICsgdGhpcy5jbGllbnRJZDtcbiAgICBpZiAodGhpcy5tZXRhZGF0YSlcbiAgICAgIHJlc3VsdCArPSBcIjsgbWV0YWRhdGE9XCIgKyB0aGlzLm1ldGFkYXRhO1xuICAgIGlmICh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pXG4gICAgICByZXN1bHQgKz0gXCI7IGRldmljZUlkZW50aXR5VG9rZW49XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pO1xuICAgIGlmICgoX2EyID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlY2lwaWVudClcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5yZWNpcGllbnQ9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2gucmVjaXBpZW50KTtcbiAgICBpZiAoKF9iID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc3RhdGUpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2guc3RhdGU9XCIgKyB0aGlzLnB1c2guc3RhdGU7XG4gICAgaWYgKChfYyA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmVycm9yKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLmVycm9yPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLmVycm9yKTtcbiAgICBpZiAoKF9kID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2QubWV0YWRhdGEpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2gubWV0YWRhdGE9XCIgKyB0aGlzLnB1c2gubWV0YWRhdGE7XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIHRvUmVxdWVzdEJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgfVxuICBzdGF0aWMgZnJvbVJlc3BvbnNlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgcmV0dXJuIF9EZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheShib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9EZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHZhbHVlcy5lcnJvciA9IHZhbHVlcy5lcnJvciAmJiBFcnJvckluZm8uZnJvbVZhbHVlcyh2YWx1ZXMuZXJyb3IpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfRGV2aWNlRGV0YWlscygpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tTG9jYWxEZXZpY2UoZGV2aWNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9EZXZpY2VEZXRhaWxzKCksIGRldmljZSk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICBjb25zdCBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgcmVzdWx0W2ldID0gX0RldmljZURldGFpbHMuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgZGV2aWNlZGV0YWlsc19kZWZhdWx0ID0gRGV2aWNlRGV0YWlscztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc291cmNlLnRzXG5hc3luYyBmdW5jdGlvbiB3aXRoQXV0aERldGFpbHMoY2xpZW50LCBoZWFkZXJzLCBwYXJhbXMsIG9wQ2FsbGJhY2spIHtcbiAgaWYgKGNsaWVudC5odHRwLnN1cHBvcnRzQXV0aEhlYWRlcnMpIHtcbiAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IGNsaWVudC5hdXRoLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgcmV0dXJuIG9wQ2FsbGJhY2sobWl4aW4oYXV0aEhlYWRlcnMsIGhlYWRlcnMpLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGF1dGhQYXJhbXMgPSBhd2FpdCBjbGllbnQuYXV0aC5nZXRBdXRoUGFyYW1zKCk7XG4gICAgcmV0dXJuIG9wQ2FsbGJhY2soaGVhZGVycywgbWl4aW4oYXV0aFBhcmFtcywgcGFyYW1zKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuZW52ZWxvcGUocmVzdWx0LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgaWYgKHJlc3VsdC5lcnIgJiYgIXJlc3VsdC5ib2R5KSB7XG4gICAgcmV0dXJuIHsgZXJyOiByZXN1bHQuZXJyIH07XG4gIH1cbiAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Ob0NvbnRlbnQpIHtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVzdWx0KSwgeyBib2R5OiBbXSwgdW5wYWNrZWQ6IHRydWUgfSk7XG4gIH1cbiAgbGV0IGJvZHkgPSByZXN1bHQuYm9keTtcbiAgaWYgKCFyZXN1bHQudW5wYWNrZWQpIHtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBlcnI6IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKGluc3BlY3RFcnJvcihlKSwgbnVsbCkgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFib2R5KSB7XG4gICAgcmV0dXJuIHsgZXJyOiBuZXcgUGFydGlhbEVycm9ySW5mbyhcInVuZW52ZWxvcGUoKTogUmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nXCIsIG51bGwpIH07XG4gIH1cbiAgY29uc3QgeyBzdGF0dXNDb2RlOiB3cmFwcGVkU3RhdHVzQ29kZSwgcmVzcG9uc2UsIGhlYWRlcnM6IHdyYXBwZWRIZWFkZXJzIH0gPSBib2R5O1xuICBpZiAod3JhcHBlZFN0YXR1c0NvZGUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQpLCB7IGJvZHksIHVucGFja2VkOiB0cnVlIH0pO1xuICB9XG4gIGlmICh3cmFwcGVkU3RhdHVzQ29kZSA8IDIwMCB8fCB3cmFwcGVkU3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICBsZXQgd3JhcHBlZEVyciA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yIHx8IHJlc3VsdC5lcnI7XG4gICAgaWYgKCF3cmFwcGVkRXJyKSB7XG4gICAgICB3cmFwcGVkRXJyID0gbmV3IEVycm9yKFwiRXJyb3IgaW4gdW5lbnZlbG9waW5nIFwiICsgYm9keSk7XG4gICAgICB3cmFwcGVkRXJyLnN0YXR1c0NvZGUgPSB3cmFwcGVkU3RhdHVzQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyOiB3cmFwcGVkRXJyLCBib2R5OiByZXNwb25zZSwgaGVhZGVyczogd3JhcHBlZEhlYWRlcnMsIHVucGFja2VkOiB0cnVlLCBzdGF0dXNDb2RlOiB3cmFwcGVkU3RhdHVzQ29kZSB9O1xuICB9XG4gIHJldHVybiB7IGVycjogcmVzdWx0LmVyciwgYm9keTogcmVzcG9uc2UsIGhlYWRlcnM6IHdyYXBwZWRIZWFkZXJzLCB1bnBhY2tlZDogdHJ1ZSwgc3RhdHVzQ29kZTogd3JhcHBlZFN0YXR1c0NvZGUgfTtcbn1cbmZ1bmN0aW9uIGxvZ1Jlc3VsdDIocmVzdWx0LCBtZXRob2QsIHBhdGgsIHBhcmFtcywgbG9nZ2VyKSB7XG4gIGlmIChyZXN1bHQuZXJyKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiUmVjZWl2ZWQgRXJyb3I7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHBhdGgsIHBhcmFtcykgKyBcIjsgRXJyb3I6IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJSZWNlaXZlZDsgXCIgKyBhcHBlbmRpbmdQYXJhbXMocGF0aCwgcGFyYW1zKSArIFwiOyBIZWFkZXJzOiBcIiArIHBhcmFtU3RyaW5nKHJlc3VsdC5oZWFkZXJzKSArIFwiOyBTdGF0dXNDb2RlOiBcIiArIHJlc3VsdC5zdGF0dXNDb2RlICsgXCI7IEJvZHk6IFwiICsgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKHJlc3VsdC5ib2R5KSA/IFwiIChCYXNlNjQpOiBcIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShyZXN1bHQuYm9keSkgOiBcIjogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChyZXN1bHQuYm9keSkpXG4gICAgKTtcbiAgfVxufVxudmFyIFJlc291cmNlID0gY2xhc3MgX1Jlc291cmNlIHtcbiAgc3RhdGljIGFzeW5jIGdldChjbGllbnQsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBjbGllbnQsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IgIT0gbnVsbCA/IHRocm93RXJyb3IgOiBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlbGV0ZShjbGllbnQsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuRGVsZXRlLCBjbGllbnQsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBwb3N0KGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5Qb3N0LCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBwYXRjaChjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUGF0Y2gsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHB1dChjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpIHtcbiAgICByZXR1cm4gX1Jlc291cmNlLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBjbGllbnQsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIHRocm93RXJyb3IpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkbyhtZXRob2QsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIGlmIChlbnZlbG9wZSkge1xuICAgICAgKHBhcmFtcyA9IHBhcmFtcyB8fCB7fSlbXCJlbnZlbG9wZVwiXSA9IGVudmVsb3BlO1xuICAgIH1cbiAgICBjb25zdCBsb2dnZXIgPSBjbGllbnQubG9nZ2VyO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGRvUmVxdWVzdChoZWFkZXJzMiwgcGFyYW1zMikge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmIChsb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgbGV0IGRlY29kZWRCb2R5ID0gYm9keTtcbiAgICAgICAgaWYgKCgoX2EyID0gaGVhZGVyczJbXCJjb250ZW50LXR5cGVcIl0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaW5kZXhPZihcIm1zZ3BhY2tcIikpID4gMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudC5fTXNnUGFjaykge1xuICAgICAgICAgICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQm9keSA9IGNsaWVudC5fTXNnUGFjay5kZWNvZGUoYm9keSk7XG4gICAgICAgICAgfSBjYXRjaCAoZGVjb2RlRXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgICAgICAgICBcIlNlbmRpbmcgTXNnUGFjayBEZWNvZGluZyBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IoZGVjb2RlRXJyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJSZXNvdXJjZS5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgICAgICBcIlNlbmRpbmc7IFwiICsgYXBwZW5kaW5nUGFyYW1zKHBhdGgsIHBhcmFtczIpICsgXCI7IEJvZHk6IFwiICsgZGVjb2RlZEJvZHlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGh0dHBSZXN1bHQgPSBhd2FpdCBjbGllbnQuaHR0cC5kbyhtZXRob2QsIHBhdGgsIGhlYWRlcnMyLCBib2R5LCBwYXJhbXMyKTtcbiAgICAgIGlmIChodHRwUmVzdWx0LmVycm9yICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGh0dHBSZXN1bHQuZXJyb3IpKSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5hdXRoLmF1dGhvcml6ZShudWxsLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHdpdGhBdXRoRGV0YWlscyhjbGllbnQsIGhlYWRlcnMyLCBwYXJhbXMyLCBkb1JlcXVlc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyOiBodHRwUmVzdWx0LmVycm9yLFxuICAgICAgICBib2R5OiBodHRwUmVzdWx0LmJvZHksXG4gICAgICAgIGhlYWRlcnM6IGh0dHBSZXN1bHQuaGVhZGVycyxcbiAgICAgICAgdW5wYWNrZWQ6IGh0dHBSZXN1bHQudW5wYWNrZWQsXG4gICAgICAgIHN0YXR1c0NvZGU6IGh0dHBSZXN1bHQuc3RhdHVzQ29kZVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHdpdGhBdXRoRGV0YWlscyhjbGllbnQsIGhlYWRlcnMsIHBhcmFtcywgZG9SZXF1ZXN0KTtcbiAgICBpZiAoZW52ZWxvcGUpIHtcbiAgICAgIHJlc3VsdCA9IHVuZW52ZWxvcGUocmVzdWx0LCBjbGllbnQuX01zZ1BhY2ssIGVudmVsb3BlKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgbG9nUmVzdWx0MihyZXN1bHQsIG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBsb2dnZXIpO1xuICAgIH1cbiAgICBpZiAodGhyb3dFcnJvcikge1xuICAgICAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdCk7XG4gICAgICAgIGRlbGV0ZSByZXNwb25zZS5lcnI7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciByZXNvdXJjZV9kZWZhdWx0ID0gUmVzb3VyY2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9wYWdpbmF0ZWRyZXNvdXJjZS50c1xuZnVuY3Rpb24gZ2V0UmVsUGFyYW1zKGxpbmtVcmwpIHtcbiAgY29uc3QgdXJsTWF0Y2ggPSBsaW5rVXJsLm1hdGNoKC9eXFwuXFwvKFxcdyspXFw/KC4qKSQvKTtcbiAgcmV0dXJuIHVybE1hdGNoICYmIHVybE1hdGNoWzJdICYmIHBhcnNlUXVlcnlTdHJpbmcodXJsTWF0Y2hbMl0pO1xufVxuZnVuY3Rpb24gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKSB7XG4gIGlmICh0eXBlb2YgbGlua0hlYWRlciA9PSBcInN0cmluZ1wiKVxuICAgIGxpbmtIZWFkZXIgPSBsaW5rSGVhZGVyLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgcmVsUGFyYW1zID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua0hlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmtNYXRjaCA9IGxpbmtIZWFkZXJbaV0ubWF0Y2goL15cXHMqPCguKyk+O1xccypyZWw9XCIoXFx3KylcIiQvKTtcbiAgICBpZiAobGlua01hdGNoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBnZXRSZWxQYXJhbXMobGlua01hdGNoWzFdKTtcbiAgICAgIGlmIChwYXJhbXMpXG4gICAgICAgIHJlbFBhcmFtc1tsaW5rTWF0Y2hbMl1dID0gcGFyYW1zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVsUGFyYW1zO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHVzZUhQUikge1xuICByZXR1cm4gISh1c2VIUFIgJiYgKGJvZHkgfHwgdHlwZW9mIGVyci5jb2RlID09PSBcIm51bWJlclwiKSk7XG59XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGJvZHlIYW5kbGVyLCB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlICE9IG51bGwgPyBlbnZlbG9wZSA6IG51bGw7XG4gICAgdGhpcy5ib2R5SGFuZGxlciA9IGJvZHlIYW5kbGVyO1xuICAgIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlIHx8IGZhbHNlO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZGVsZXRlKHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIHBvc3QocGFyYW1zLCBib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIHB1dChwYXJhbXMsIGJvZHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnB1dCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBwYXRjaChwYXJhbXMsIGJvZHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBhdGNoKHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIGhhbmRsZVBhZ2UocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5lcnIgJiYgcmV0dXJuRXJyT25seShyZXN1bHQuZXJyLCByZXN1bHQuYm9keSwgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiUGFnaW5hdGVkUmVzb3VyY2UuaGFuZGxlUGFnZSgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBlcnJvciBnZXR0aW5nIHJlc291cmNlOiBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyKVxuICAgICAgKTtcbiAgICAgIHRocm93IHJlc3VsdC5lcnI7XG4gICAgfVxuICAgIGxldCBpdGVtcywgbGlua0hlYWRlciwgcmVsUGFyYW1zO1xuICAgIHRyeSB7XG4gICAgICBpdGVtcyA9IHJlc3VsdC5zdGF0dXNDb2RlID09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0Lk5vQ29udGVudCA/IFtdIDogYXdhaXQgdGhpcy5ib2R5SGFuZGxlcihyZXN1bHQuYm9keSwgcmVzdWx0LmhlYWRlcnMgfHwge30sIHJlc3VsdC51bnBhY2tlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgcmVzdWx0LmVyciB8fCBlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmhlYWRlcnMgJiYgKGxpbmtIZWFkZXIgPSByZXN1bHQuaGVhZGVyc1tcIkxpbmtcIl0gfHwgcmVzdWx0LmhlYWRlcnNbXCJsaW5rXCJdKSkge1xuICAgICAgcmVsUGFyYW1zID0gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbmV3IEh0dHBQYWdpbmF0ZWRSZXNwb25zZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHJlc3VsdC5oZWFkZXJzIHx8IHt9LFxuICAgICAgICByZXN1bHQuc3RhdHVzQ29kZSxcbiAgICAgICAgcmVsUGFyYW1zLFxuICAgICAgICByZXN1bHQuZXJyXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBhZ2luYXRlZFJlc3VsdCh0aGlzLCBpdGVtcywgcmVsUGFyYW1zKTtcbiAgICB9XG4gIH1cbn07XG52YXIgUGFnaW5hdGVkUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcykge1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzO1xuICAgIGlmIChyZWxQYXJhbXMpIHtcbiAgICAgIGlmIChcImZpcnN0XCIgaW4gcmVsUGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZmlyc3QgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjIuZ2V0KHJlbFBhcmFtcy5maXJzdCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoXCJjdXJyZW50XCIgaW4gcmVsUGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmMi5nZXQocmVsUGFyYW1zLmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChcIm5leHRcIiBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjIuZ2V0KHJlbFBhcmFtcy5uZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJuZXh0XCIgaW4gcmVsUGFyYW1zO1xuICAgICAgfTtcbiAgICAgIHRoaXMuaXNMYXN0ID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gISgoX2EyID0gdGhpcy5oYXNOZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwodGhpcykpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyogV2UgYXNzdW1lIHRoYXQgb25seSB0aGUgaW5pdGlhbCByZXF1ZXN0IGNhbiBiZSBhIFBPU1QsIGFuZCB0aGF0IGFjY2Vzc2luZ1xuICAgKiB0aGUgcmVzdCBvZiBhIG11bHRpcGFnZSBzZXQgb2YgcmVzdWx0cyBjYW4gYWx3YXlzIGJlIGRvbmUgd2l0aCBHRVQgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMucmVzb3VyY2U7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQocmVzLmNsaWVudCwgcmVzLnBhdGgsIHJlcy5oZWFkZXJzLCBwYXJhbXMsIHJlcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiByZXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG59O1xudmFyIEh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUGFnaW5hdGVkUmVzdWx0IHtcbiAgY29uc3RydWN0b3IocmVzb3VyY2UsIGl0ZW1zLCBoZWFkZXJzLCBzdGF0dXNDb2RlLCByZWxQYXJhbXMsIGVycikge1xuICAgIHN1cGVyKHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3VjY2VzcyA9IHN0YXR1c0NvZGUgPCAzMDAgJiYgc3RhdHVzQ29kZSA+PSAyMDA7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVyciAmJiBlcnIuY29kZTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgc3VjY2VzczogdGhpcy5zdWNjZXNzLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgZXJyb3JDb2RlOiB0aGlzLmVycm9yQ29kZSxcbiAgICAgIGVycm9yTWVzc2FnZTogdGhpcy5lcnJvck1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xudmFyIHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQgPSBQYWdpbmF0ZWRSZXNvdXJjZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24udHNcbnZhciBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBjbGFzcyBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24ge1xuICAvKipcbiAgICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG4gICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZFxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiW1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uXCI7XG4gICAgaWYgKHRoaXMuY2hhbm5lbClcbiAgICAgIHJlc3VsdCArPSBcIjsgY2hhbm5lbD1cIiArIHRoaXMuY2hhbm5lbDtcbiAgICBpZiAodGhpcy5kZXZpY2VJZClcbiAgICAgIHJlc3VsdCArPSBcIjsgZGV2aWNlSWQ9XCIgKyB0aGlzLmRldmljZUlkO1xuICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjbGllbnRJZD1cIiArIHRoaXMuY2xpZW50SWQ7XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGZyb21SZXNwb25zZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgYm9keSA9IGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICAgIHJldHVybiBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSwgdmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICByZXN1bHRbaV0gPSBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5fUHVzaENoYW5uZWxTdWJzY3JpcHRpb24udG9SZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHk7XG52YXIgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XG52YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdCA9IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcHVzaC50c1xudmFyIFB1c2ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHZhciBfYTI7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5hZG1pbiA9IG5ldyBBZG1pbihjbGllbnQpO1xuICAgIGlmIChQbGF0Zm9ybS5Db25maWcucHVzaCAmJiAoKF9hMiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkpIHtcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5BY3RpdmF0aW9uU3RhdGVNYWNoaW5lKGNsaWVudCk7XG4gICAgICB0aGlzLkxvY2FsRGV2aWNlID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLmxvY2FsRGV2aWNlRmFjdG9yeShkZXZpY2VkZXRhaWxzX2RlZmF1bHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhY3RpdmF0ZShyZWdpc3RlckNhbGxiYWNrLCB1cGRhdGVGYWlsZWRDYWxsYmFjaykge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoISgoX2EyID0gdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlTWFjaGluZSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRoaXMgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZCBhcyBhIHRhcmdldCBvZiBwdXNoIG5vdGlmaWNhdGlvbnNcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGVNYWNoaW5lLmFjdGl2YXRlZENhbGxiYWNrKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiQWN0aXZhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLmFjdGl2YXRlZENhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS51cGRhdGVGYWlsZWRDYWxsYmFjayA9IHVwZGF0ZUZhaWxlZENhbGxiYWNrO1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuaGFuZGxlRXZlbnQoXG4gICAgICAgIG5ldyB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5DYWxsZWRBY3RpdmF0ZSh0aGlzLnN0YXRlTWFjaGluZSwgcmVnaXN0ZXJDYWxsYmFjaylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGVhY3RpdmF0ZShkZXJlZ2lzdGVyQ2FsbGJhY2spIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKCEoKF9hMiA9IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5QdXNoKSkge1xuICAgICAgICByZWplY3QoY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUaGlzIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYSB0YXJnZXQgb2YgcHVzaCBub3RpZmljYXRpb25zXCIsIDRlNCwgNDAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlTWFjaGluZS5kZWFjdGl2YXRlZENhbGxiYWNrKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiRGVhY3RpdmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuZGVhY3RpdmF0ZWRDYWxsYmFjayA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuaGFuZGxlRXZlbnQoXG4gICAgICAgIG5ldyB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5DYWxsZWREZWFjdGl2YXRlKHRoaXMuc3RhdGVNYWNoaW5lLCBkZXJlZ2lzdGVyQ2FsbGJhY2spXG4gICAgICApO1xuICAgIH0pO1xuICB9XG59O1xudmFyIEFkbWluID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmRldmljZVJlZ2lzdHJhdGlvbnMgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9ucyhjbGllbnQpO1xuICAgIHRoaXMuY2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBuZXcgQ2hhbm5lbFN1YnNjcmlwdGlvbnMoY2xpZW50KTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlY2lwaWVudCwgcGF5bG9hZCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSksIHBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSBtaXhpbih7IHJlY2lwaWVudCB9LCBwYXlsb2FkKTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChjbGllbnQsIFwiL3B1c2gvcHVibGlzaFwiLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCB0cnVlKTtcbiAgfVxufTtcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICBhc3luYyBzYXZlKGRldmljZSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGJvZHkgPSBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVZhbHVlcyhkZXZpY2UpO1xuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSksIHBhcmFtcyA9IHt9O1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnB1dChcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UuaWQpLFxuICAgICAgcmVxdWVzdEJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICByZXNwb25zZS51bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0KGRldmljZUlkT3JEZXRhaWxzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSBcInN0cmluZ1wiIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNnZXQgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzXCIsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQuZ2V0KFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB7fSxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gZGV2aWNlZGV0YWlsc19kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgcmVzcG9uc2UudW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICApO1xuICB9XG4gIGFzeW5jIGxpc3QocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zXCIsIGhlYWRlcnMsIGVudmVsb3BlLCBhc3luYyBmdW5jdGlvbihib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpIHtcbiAgICAgIHJldHVybiBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgICB1bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICAgKTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZW1vdmUoZGV2aWNlSWRPckRldGFpbHMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pLCBwYXJhbXMgPSB7fSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSBcInN0cmluZ1wiIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNyZW1vdmUgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzXCIsXG4gICAgICAgIDRlNCxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0W1wiZGVsZXRlXCJdKFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlV2hlcmUocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0W1wiZGVsZXRlXCJdKGNsaWVudCwgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zXCIsIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgdHJ1ZSk7XG4gIH1cbn07XG52YXIgQ2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBjbGFzcyBfQ2hhbm5lbFN1YnNjcmlwdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAvKiBDaGFubmVsU3Vic2NyaXB0aW9ucyBoYXZlIG5vIHVuaXF1ZSBpZDsgcmVtb3Zpbmcgb25lIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlV2hlcmUgYnkgaXRzIHByb3BlcnRpZXMgKi9cbiAgICB0aGlzLnJlbW92ZSA9IF9DaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmU7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgYXN5bmMgc2F2ZShzdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBib2R5ID0gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdC5mcm9tVmFsdWVzKHN1YnNjcmlwdGlvbik7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KSwgcGFyYW1zID0ge307XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIGNsaWVudCxcbiAgICAgIFwiL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnNcIixcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgIHJlc3BvbnNlLnVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgKTtcbiAgfVxuICBhc3luYyBsaXN0KHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIFwiL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgcmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgICB1bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICAgKTtcbiAgICB9KS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyByZW1vdmVXaGVyZShwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHRbXCJkZWxldGVcIl0oY2xpZW50LCBcIi9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zXCIsIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgdHJ1ZSk7XG4gIH1cbiAgYXN5bmMgbGlzdENoYW5uZWxzKHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIFwiL3B1c2gvY2hhbm5lbHNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgY29uc3QgcGFyc2VkQm9keSA9ICF1bnBhY2tlZCAmJiBmb3JtYXQgPyBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KSA6IGJvZHk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZEJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFyc2VkQm9keVtpXSA9IFN0cmluZyhwYXJzZWRCb2R5W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRCb2R5O1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG59O1xudmFyIHB1c2hfZGVmYXVsdCA9IFB1c2g7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL21lc3NhZ2UudHNcbmZ1bmN0aW9uIG5vcm1hbGlzZUNvbnRleHQoY29udGV4dCkge1xuICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuY2hhbm5lbE9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhbm5lbE9wdGlvbnM6IGNvbnRleHQsXG4gICAgICBwbHVnaW5zOiB7fSxcbiAgICAgIGJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jaXBoZXIpIHtcbiAgICBpZiAoIUNyeXB0bzIpXG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIkNyeXB0b1wiKTtcbiAgICBjb25zdCBjaXBoZXIgPSBDcnlwdG8yLmdldENpcGhlcihvcHRpb25zLmNpcGhlciwgbG9nZ2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2lwaGVyOiBjaXBoZXIuY2lwaGVyUGFyYW1zLFxuICAgICAgY2hhbm5lbENpcGhlcjogY2lwaGVyLmNpcGhlclxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VTaXplKG1zZykge1xuICBsZXQgc2l6ZSA9IDA7XG4gIGlmIChtc2cubmFtZSkge1xuICAgIHNpemUgKz0gbXNnLm5hbWUubGVuZ3RoO1xuICB9XG4gIGlmIChtc2cuY2xpZW50SWQpIHtcbiAgICBzaXplICs9IG1zZy5jbGllbnRJZC5sZW5ndGg7XG4gIH1cbiAgaWYgKG1zZy5leHRyYXMpIHtcbiAgICBzaXplICs9IEpTT04uc3RyaW5naWZ5KG1zZy5leHRyYXMpLmxlbmd0aDtcbiAgfVxuICBpZiAobXNnLmRhdGEpIHtcbiAgICBzaXplICs9IGRhdGFTaXplQnl0ZXMobXNnLmRhdGEpO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWQobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgY29uc3QgbXNnID0gZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMoQ3J5cHRvMiwgbG9nZ2VyLCBpbnB1dE9wdGlvbnMgIT0gbnVsbCA/IGlucHV0T3B0aW9ucyA6IG51bGwpO1xuICB0cnkge1xuICAgIGF3YWl0IGRlY29kZShtc2csIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIk1lc3NhZ2UuZnJvbUVuY29kZWQoKVwiLCBlLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBtc2c7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZEFycmF5KGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHJldHVybiBmcm9tRW5jb2RlZChsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIG9wdGlvbnMpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KG1zZywgb3B0aW9ucykge1xuICBsZXQgZGF0YSA9IG1zZy5kYXRhLCBlbmNvZGluZyA9IG1zZy5lbmNvZGluZywgY2lwaGVyID0gb3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuICBlbmNvZGluZyA9IGVuY29kaW5nID8gZW5jb2RpbmcgKyBcIi9cIiA6IFwiXCI7XG4gIGlmICghUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICBkYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMudXRmOEVuY29kZShTdHJpbmcoZGF0YSkpO1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgKyBcInV0Zi04L1wiO1xuICB9XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBhd2FpdCBjaXBoZXIuZW5jcnlwdChkYXRhKTtcbiAgbXNnLmRhdGEgPSBjaXBoZXJ0ZXh0O1xuICBtc2cuZW5jb2RpbmcgPSBlbmNvZGluZyArIFwiY2lwaGVyK1wiICsgY2lwaGVyLmFsZ29yaXRobTtcbiAgcmV0dXJuIG1zZztcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY29kZShtc2csIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YSA9IG1zZy5kYXRhO1xuICBjb25zdCBuYXRpdmVEYXRhVHlwZSA9IHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgfHwgUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkgfHwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDA7XG4gIGlmICghbmF0aXZlRGF0YVR5cGUpIHtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgbXNnLmRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgIG1zZy5lbmNvZGluZyA9IG1zZy5lbmNvZGluZyA/IG1zZy5lbmNvZGluZyArIFwiL2pzb25cIiA6IFwianNvblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiRGF0YSB0eXBlIGlzIHVuc3VwcG9ydGVkXCIsIDQwMDEzLCA0MDApO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuY2lwaGVyKSB7XG4gICAgcmV0dXJuIGVuY3J5cHQobXNnLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbXNnO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBlbmNvZGVBcnJheShtZXNzYWdlcywgb3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiBlbmNvZGUobWVzc2FnZSwgb3B0aW9ucykpKTtcbn1cbnZhciBzZXJpYWxpemUgPSBlbmNvZGVCb2R5O1xuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKG1lc3NhZ2UsIGlucHV0Q29udGV4dCkge1xuICBjb25zdCBjb250ZXh0ID0gbm9ybWFsaXNlQ29udGV4dChpbnB1dENvbnRleHQpO1xuICBsZXQgbGFzdFBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG4gIGNvbnN0IGVuY29kaW5nID0gbWVzc2FnZS5lbmNvZGluZztcbiAgaWYgKGVuY29kaW5nKSB7XG4gICAgY29uc3QgeGZvcm1zID0gZW5jb2Rpbmcuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCwgZW5jb2RpbmdzVG9Qcm9jZXNzID0geGZvcm1zLmxlbmd0aCwgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICBsZXQgeGZvcm0gPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID0gZW5jb2RpbmdzVG9Qcm9jZXNzKSA+IDApIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB4Zm9ybXNbLS1lbmNvZGluZ3NUb1Byb2Nlc3NdLm1hdGNoKC8oWy1cXHddKykoXFwrKFtcXHctXSspKT8vKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgeGZvcm0gPSBtYXRjaFsxXTtcbiAgICAgICAgc3dpdGNoICh4Zm9ybSkge1xuICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGRhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjREZWNvZGUoU3RyaW5nKGRhdGEpKTtcbiAgICAgICAgICAgIGlmIChsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA9PSB4Zm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGxhc3RQYXlsb2FkID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhEZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiY2lwaGVyXCI6XG4gICAgICAgICAgICBpZiAoY29udGV4dC5jaGFubmVsT3B0aW9ucyAhPSBudWxsICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2lwaGVyICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcikge1xuICAgICAgICAgICAgICBjb25zdCB4Zm9ybUFsZ29yaXRobSA9IG1hdGNoWzNdLCBjaXBoZXIgPSBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gICAgICAgICAgICAgIGlmICh4Zm9ybUFsZ29yaXRobSAhPSBjaXBoZXIuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZSB3aXRoIGdpdmVuIGNpcGhlcjsgaW5jb21wYXRpYmxlIGNpcGhlciBwYXJhbXNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGNpcGhlci5kZWNyeXB0KGRhdGEpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2U7IG5vdCBhbiBlbmNyeXB0ZWQgY2hhbm5lbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidmNkaWZmXCI6XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQucGx1Z2lucyB8fCAhY29udGV4dC5wbHVnaW5zLnZjZGlmZikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTWlzc2luZyBWY2RpZmYgZGVjb2RlciAoaHR0cHM6Ly9naXRodWIuY29tL2FibHktZm9ya3MvdmNkaWZmLWRlY29kZXIpXCIsIDQwMDE5LCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJEZWx0YSBkZWNvZGluZyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlciAobmVlZCBBcnJheUJ1ZmZlciAmIFVpbnQ4QXJyYXkpXCIsXG4gICAgICAgICAgICAgICAgNDAwMjAsXG4gICAgICAgICAgICAgICAgNDAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgZGVsdGFCYXNlID0gY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWx0YUJhc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkZWx0YUJhc2UgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKGRlbHRhQmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGVsdGFCYXNlQnVmZmVyID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMudG9CdWZmZXIoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgICBkYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYXJyYXlCdWZmZXJWaWV3VG9CdWZmZXIoY29udGV4dC5wbHVnaW5zLnZjZGlmZi5kZWNvZGUoZGF0YSwgZGVsdGFCYXNlQnVmZmVyKSk7XG4gICAgICAgICAgICAgIGxhc3RQYXlsb2FkID0gZGF0YTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlZjZGlmZiBkZWx0YSBkZWNvZGUgZmFpbGVkIHdpdGggXCIgKyBlLCA0MDAxOCwgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyID0gZTtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiRXJyb3IgcHJvY2Vzc2luZyB0aGUgXCIgKyB4Zm9ybSArIFwiIGVuY29kaW5nLCBkZWNvZGVyIHJldHVybmVkIFxcdTIwMThcIiArIGVyci5tZXNzYWdlICsgXCJcXHUyMDE5XCIsXG4gICAgICAgIGVyci5jb2RlIHx8IDQwMDEzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG1lc3NhZ2UuZW5jb2RpbmcgPSBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA8PSAwID8gbnVsbCA6IHhmb3Jtcy5zbGljZSgwLCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCkuam9pbihcIi9cIik7XG4gICAgICBtZXNzYWdlLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuICBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkID0gbGFzdFBheWxvYWQ7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsIGxvZ2dlciwgTXNnUGFjaywgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQpIHtcbiAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1zZyA9IGJvZHlbaV0gPSBmcm9tVmFsdWVzKGJvZHlbaV0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBkZWNvZGUobXNnLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KClcIiwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvZHk7XG59XG5mdW5jdGlvbiBmcm9tVmFsdWVzKHZhbHVlcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgTWVzc2FnZSgpLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICBjb25zdCBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICByZXN1bHRbaV0gPSBmcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlc1NpemUobWVzc2FnZXMpIHtcbiAgbGV0IG1zZywgdG90YWwgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbXNnID0gbWVzc2FnZXNbaV07XG4gICAgdG90YWwgKz0gbXNnLnNpemUgfHwgKG1zZy5zaXplID0gZ2V0TWVzc2FnZVNpemUobXNnKSk7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufVxudmFyIE1lc3NhZ2UgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGxldCBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgaWYgKGRhdGEgJiYgUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nID8gZW5jb2RpbmcgKyBcIi9iYXNlNjRcIiA6IFwiYmFzZTY0XCI7XG4gICAgICAgIGRhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMudG9CdWZmZXIoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgY29ubmVjdGlvbklkOiB0aGlzLmNvbm5lY3Rpb25JZCxcbiAgICAgIGNvbm5lY3Rpb25LZXk6IHRoaXMuY29ubmVjdGlvbktleSxcbiAgICAgIGV4dHJhczogdGhpcy5leHRyYXMsXG4gICAgICBlbmNvZGluZyxcbiAgICAgIGRhdGFcbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCByZXN1bHQgPSBcIltNZXNzYWdlXCI7XG4gICAgaWYgKHRoaXMubmFtZSlcbiAgICAgIHJlc3VsdCArPSBcIjsgbmFtZT1cIiArIHRoaXMubmFtZTtcbiAgICBpZiAodGhpcy5pZClcbiAgICAgIHJlc3VsdCArPSBcIjsgaWQ9XCIgKyB0aGlzLmlkO1xuICAgIGlmICh0aGlzLnRpbWVzdGFtcClcbiAgICAgIHJlc3VsdCArPSBcIjsgdGltZXN0YW1wPVwiICsgdGhpcy50aW1lc3RhbXA7XG4gICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNsaWVudElkPVwiICsgdGhpcy5jbGllbnRJZDtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uSWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNvbm5lY3Rpb25JZD1cIiArIHRoaXMuY29ubmVjdGlvbklkO1xuICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgcmVzdWx0ICs9IFwiOyBlbmNvZGluZz1cIiArIHRoaXMuZW5jb2Rpbmc7XG4gICAgaWYgKHRoaXMuZXh0cmFzKVxuICAgICAgcmVzdWx0ICs9IFwiOyBleHRyYXMgPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YT1cIiArIHRoaXMuZGF0YTtcbiAgICAgIGVsc2UgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKHRoaXMuZGF0YSkpXG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YSAoYnVmZmVyKT1cIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh0aGlzLmRhdGEpO1xuICAgICAgZWxzZVxuICAgICAgICByZXN1bHQgKz0gXCI7IGRhdGEgKGpzb24pPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXh0cmFzKVxuICAgICAgcmVzdWx0ICs9IFwiOyBleHRyYXM9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhcyk7XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgbWVzc2FnZV9kZWZhdWx0ID0gTWVzc2FnZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvcHJlc2VuY2VtZXNzYWdlLnRzXG52YXIgYWN0aW9ucyA9IFtcImFic2VudFwiLCBcInByZXNlbnRcIiwgXCJlbnRlclwiLCBcImxlYXZlXCIsIFwidXBkYXRlXCJdO1xuZnVuY3Rpb24gdG9BY3Rpb25WYWx1ZShhY3Rpb25TdHJpbmcpIHtcbiAgcmV0dXJuIGFjdGlvbnMuaW5kZXhPZihhY3Rpb25TdHJpbmcpO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWQyKGxvZ2dlciwgZW5jb2RlZCwgb3B0aW9ucykge1xuICBjb25zdCBtc2cgPSBmcm9tVmFsdWVzMihlbmNvZGVkLCB0cnVlKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBkZWNvZGUyKG1zZywgb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQoKVwiLCBlLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBtc2c7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZEFycmF5Mihsb2dnZXIsIGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gZnJvbUVuY29kZWQyKGxvZ2dlciwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGZyb21WYWx1ZXMyKHZhbHVlcywgc3RyaW5naWZ5QWN0aW9uKSB7XG4gIGlmIChzdHJpbmdpZnlBY3Rpb24pIHtcbiAgICB2YWx1ZXMuYWN0aW9uID0gYWN0aW9uc1t2YWx1ZXMuYWN0aW9uXTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJlc2VuY2VNZXNzYWdlKCksIHZhbHVlcyk7XG59XG52YXIgZGVjb2RlMiA9IGRlY29kZTtcbmFzeW5jIGZ1bmN0aW9uIGZyb21SZXNwb25zZUJvZHkyKGJvZHksIG9wdGlvbnMsIGxvZ2dlciwgTXNnUGFjaywgZm9ybWF0KSB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIGlmIChmb3JtYXQpIHtcbiAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1zZyA9IG1lc3NhZ2VzW2ldID0gZnJvbVZhbHVlczIoYm9keVtpXSwgdHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGRlY29kZTIobXNnLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiUHJlc2VuY2VNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkoKVwiLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVzc2FnZXM7XG59XG5mdW5jdGlvbiBmcm9tVmFsdWVzQXJyYXkyKHZhbHVlcykge1xuICBjb25zdCBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICByZXN1bHRbaV0gPSBmcm9tVmFsdWVzMih2YWx1ZXNbaV0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZnJvbURhdGEoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFByZXNlbmNlTWVzc2FnZSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBmcm9tVmFsdWVzMih7XG4gICAgZGF0YVxuICB9KTtcbn1cbnZhciBQcmVzZW5jZU1lc3NhZ2UgPSBjbGFzcyB7XG4gIC8qIFJldHVybnMgd2hldGhlciB0aGlzIHByZXNlbmNlTWVzc2FnZSBpcyBzeW50aGVzaXplZCwgaS5lLiB3YXMgbm90IGFjdHVhbGx5XG4gICAqIHNlbnQgYnkgdGhlIGNvbm5lY3Rpb24gKHVzdWFsbHkgbWVhbnMgYSBsZWF2ZSBldmVudCBzZW50IDE1cyBhZnRlciBhXG4gICAqIGRpc2Nvbm5lY3Rpb24pLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIHN5bnRoZXNpemVkIG1lc3NhZ2VzIGNhbm5vdCBiZVxuICAgKiBjb21wYXJlZCBmb3IgbmV3bmVzcyBieSBpZCBsZXhpY29ncmFwaGljYWxseSAtIFJUUDJiMVxuICAgKi9cbiAgaXNTeW50aGVzaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaWQgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWQuc3Vic3RyaW5nKHRoaXMuY29ubmVjdGlvbklkLmxlbmd0aCwgMCkgIT09IHRoaXMuY29ubmVjdGlvbklkO1xuICB9XG4gIC8qIFJUUDJiMiAqL1xuICBwYXJzZUlkKCkge1xuICAgIGlmICghdGhpcy5pZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBhcnNlSWQoKTogUHJlc2VuY2UgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGFuIGlkXCIpO1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5pZC5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbm5lY3Rpb25JZDogcGFydHNbMF0sXG4gICAgICBtc2dTZXJpYWw6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICBpbmRleDogcGFyc2VJbnQocGFydHNbMl0sIDEwKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgbGV0IGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcbiAgICBpZiAoZGF0YSAmJiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArIFwiL2Jhc2U2NFwiIDogXCJiYXNlNjRcIjtcbiAgICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy50b0J1ZmZlcihkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAvKiBDb252ZXJ0IHByZXNlbmNlIGFjdGlvbiBiYWNrIHRvIGFuIGludCBmb3Igc2VuZGluZyB0byBBYmx5ICovXG4gICAgICBhY3Rpb246IHRvQWN0aW9uVmFsdWUodGhpcy5hY3Rpb24pLFxuICAgICAgZGF0YSxcbiAgICAgIGVuY29kaW5nLFxuICAgICAgZXh0cmFzOiB0aGlzLmV4dHJhc1xuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiW1ByZXNlbmNlTWVzc2FnZVwiO1xuICAgIHJlc3VsdCArPSBcIjsgYWN0aW9uPVwiICsgdGhpcy5hY3Rpb247XG4gICAgaWYgKHRoaXMuaWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGlkPVwiICsgdGhpcy5pZDtcbiAgICBpZiAodGhpcy50aW1lc3RhbXApXG4gICAgICByZXN1bHQgKz0gXCI7IHRpbWVzdGFtcD1cIiArIHRoaXMudGltZXN0YW1wO1xuICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjbGllbnRJZD1cIiArIHRoaXMuY2xpZW50SWQ7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbklkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjb25uZWN0aW9uSWQ9XCIgKyB0aGlzLmNvbm5lY3Rpb25JZDtcbiAgICBpZiAodGhpcy5lbmNvZGluZylcbiAgICAgIHJlc3VsdCArPSBcIjsgZW5jb2Rpbmc9XCIgKyB0aGlzLmVuY29kaW5nO1xuICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YT1cIiArIHRoaXMuZGF0YTtcbiAgICAgIGVsc2UgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKHRoaXMuZGF0YSkpXG4gICAgICAgIHJlc3VsdCArPSBcIjsgZGF0YSAoYnVmZmVyKT1cIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh0aGlzLmRhdGEpO1xuICAgICAgZWxzZVxuICAgICAgICByZXN1bHQgKz0gXCI7IGRhdGEgKGpzb24pPVwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXh0cmFzKSB7XG4gICAgICByZXN1bHQgKz0gXCI7IGV4dHJhcz1cIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQgPSBQcmVzZW5jZU1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0cHJlc2VuY2UudHNcbnZhciBSZXN0UHJlc2VuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RQcmVzZW5jZS5nZXQoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLmNoYW5uZWwuY2xpZW50LnJlc3QucHJlc2VuY2VNaXhpbi5iYXNlUGF0aCh0aGlzKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIChib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZyb21SZXNwb25zZUJvZHkyKFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICAgICAgdW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLmdldChwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGhpc3RvcnkocGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVzdFByZXNlbmNlLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNsaWVudC5yZXN0LnByZXNlbmNlTWl4aW4uaGlzdG9yeSh0aGlzLCBwYXJhbXMpO1xuICB9XG59O1xudmFyIHJlc3RwcmVzZW5jZV9kZWZhdWx0ID0gUmVzdFByZXNlbmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdGNoYW5uZWwudHNcbnZhciBNU0dfSURfRU5UUk9QWV9CWVRFUyA9IDk7XG5mdW5jdGlvbiBhbGxFbXB0eUlkcyhtZXNzYWdlcykge1xuICByZXR1cm4gbWVzc2FnZXMuZXZlcnkoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHJldHVybiAhbWVzc2FnZS5pZDtcbiAgfSk7XG59XG52YXIgUmVzdENoYW5uZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oY2xpZW50LmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlc3RDaGFubmVsKClcIiwgXCJzdGFydGVkOyBuYW1lID0gXCIgKyBuYW1lKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgcmVzdHByZXNlbmNlX2RlZmF1bHQodGhpcyk7XG4gICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKChfYTIgPSBjbGllbnQuX0NyeXB0bykgIT0gbnVsbCA/IF9hMiA6IG51bGwsIHRoaXMubG9nZ2VyLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgaWYgKChfYiA9IGNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5QdXNoKSB7XG4gICAgICB0aGlzLl9wdXNoID0gbmV3IGNsaWVudC5vcHRpb25zLnBsdWdpbnMuUHVzaC5QdXNoQ2hhbm5lbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHB1c2goKSB7XG4gICAgaWYgKCF0aGlzLl9wdXNoKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlB1c2hcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdXNoO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBub3JtYWxpc2VDaGFubmVsT3B0aW9ucygoX2EyID0gdGhpcy5jbGllbnQuX0NyeXB0bykgIT0gbnVsbCA/IF9hMiA6IG51bGwsIHRoaXMubG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBoaXN0b3J5KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF0sIHNlY29uZCA9IGFyZ3NbMV07XG4gICAgbGV0IG1lc3NhZ2VzO1xuICAgIGxldCBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiB8fCBmaXJzdCA9PT0gbnVsbCkge1xuICAgICAgbWVzc2FnZXMgPSBbZnJvbVZhbHVlcyh7IG5hbWU6IGZpcnN0LCBkYXRhOiBzZWNvbmQgfSldO1xuICAgICAgcGFyYW1zID0gYXJnc1syXTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpcnN0KSkge1xuICAgICAgbWVzc2FnZXMgPSBbZnJvbVZhbHVlcyhmaXJzdCldO1xuICAgICAgcGFyYW1zID0gYXJnc1sxXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3QpKSB7XG4gICAgICBtZXNzYWdlcyA9IGZyb21WYWx1ZXNBcnJheShmaXJzdCk7XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIlRoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1wiLFxuICAgICAgICA0MDAxMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBvcHRpb25zID0gY2xpZW50Lm9wdGlvbnMsIGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gY2xpZW50Lm9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyAmJiBhbGxFbXB0eUlkcyhtZXNzYWdlcykpIHtcbiAgICAgIGNvbnN0IG1zZ0lkQmFzZSA9IGF3YWl0IHJhbmRvbVN0cmluZyhNU0dfSURfRU5UUk9QWV9CWVRFUyk7XG4gICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBtc2dJZEJhc2UgKyBcIjpcIiArIGluZGV4LnRvU3RyaW5nKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHNpemUgPSBnZXRNZXNzYWdlc1NpemUobWVzc2FnZXMpLCBtYXhNZXNzYWdlU2l6ZSA9IG9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgaWYgKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKCB3YXMgXCIgKyBzaXplICsgXCIgYnl0ZXM7IGxpbWl0IGlzIFwiICsgbWF4TWVzc2FnZVNpemUgKyBcIiBieXRlcylcIixcbiAgICAgICAgNDAwMDksXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fcHVibGlzaChzZXJpYWxpemUobWVzc2FnZXMsIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KSwgaGVhZGVycywgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBfcHVibGlzaChyZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zKSB7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KFxuICAgICAgdGhpcy5jbGllbnQsXG4gICAgICB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5iYXNlUGF0aCh0aGlzKSArIFwiL21lc3NhZ2VzXCIsXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbi5zdGF0dXModGhpcyk7XG4gIH1cbn07XG52YXIgcmVzdGNoYW5uZWxfZGVmYXVsdCA9IFJlc3RDaGFubmVsO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9zdGF0cy50c1xudmFyIFN0YXRzID0gY2xhc3MgX1N0YXRzIHtcbiAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgdGhpcy5lbnRyaWVzID0gdmFsdWVzICYmIHZhbHVlcy5lbnRyaWVzIHx8IHZvaWQgMDtcbiAgICB0aGlzLnNjaGVtYSA9IHZhbHVlcyAmJiB2YWx1ZXMuc2NoZW1hIHx8IHZvaWQgMDtcbiAgICB0aGlzLmFwcElkID0gdmFsdWVzICYmIHZhbHVlcy5hcHBJZCB8fCB2b2lkIDA7XG4gICAgdGhpcy5pblByb2dyZXNzID0gdmFsdWVzICYmIHZhbHVlcy5pblByb2dyZXNzIHx8IHZvaWQgMDtcbiAgICB0aGlzLnVuaXQgPSB2YWx1ZXMgJiYgdmFsdWVzLnVuaXQgfHwgdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHZhbHVlcyAmJiB2YWx1ZXMuaW50ZXJ2YWxJZCB8fCB2b2lkIDA7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBfU3RhdHModmFsdWVzKTtcbiAgfVxufTtcbnZhciBzdGF0c19kZWZhdWx0ID0gU3RhdHM7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0Y2hhbm5lbG1peGluLnRzXG52YXIgUmVzdENoYW5uZWxNaXhpbiA9IGNsYXNzIHtcbiAgc3RhdGljIGJhc2VQYXRoKGNoYW5uZWwpIHtcbiAgICByZXR1cm4gXCIvY2hhbm5lbHMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoY2hhbm5lbC5uYW1lKTtcbiAgfVxuICBzdGF0aWMgaGlzdG9yeShjaGFubmVsLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBjaGFubmVsLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSBjaGFubmVsLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBvcHRpb25zID0gY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoY2xpZW50LCB0aGlzLmJhc2VQYXRoKGNoYW5uZWwpICsgXCIvbWVzc2FnZXNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgcmV0dXJuIGF3YWl0IGZyb21SZXNwb25zZUJvZHkoXG4gICAgICAgIGJvZHksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNoYW5uZWwubG9nZ2VyLFxuICAgICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICAgIHVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgICApO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBzdGF0dXMoY2hhbm5lbCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IGNoYW5uZWwuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2hhbm5lbC5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChcbiAgICAgIGNoYW5uZWwuY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB7fSxcbiAgICAgIGZvcm1hdCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdHByZXNlbmNlbWl4aW4udHNcbnZhciBSZXN0UHJlc2VuY2VNaXhpbiA9IGNsYXNzIHtcbiAgc3RhdGljIGJhc2VQYXRoKHByZXNlbmNlKSB7XG4gICAgcmV0dXJuIFJlc3RDaGFubmVsTWl4aW4uYmFzZVBhdGgocHJlc2VuY2UuY2hhbm5lbCkgKyBcIi9wcmVzZW5jZVwiO1xuICB9XG4gIHN0YXRpYyBhc3luYyBoaXN0b3J5KHByZXNlbmNlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBvcHRpb25zID0gcHJlc2VuY2UuY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoY2xpZW50LCB0aGlzLmJhc2VQYXRoKHByZXNlbmNlKSArIFwiL2hpc3RvcnlcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgcmV0dXJuIGF3YWl0IGZyb21SZXNwb25zZUJvZHkyKFxuICAgICAgICBib2R5LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBwcmVzZW5jZS5sb2dnZXIsXG4gICAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgICAgdW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICAgICk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0LnRzXG52YXIgUmVzdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jaGFubmVsTWl4aW4gPSBSZXN0Q2hhbm5lbE1peGluO1xuICAgIHRoaXMucHJlc2VuY2VNaXhpbiA9IFJlc3RQcmVzZW5jZU1peGluO1xuICAgIC8vIGV4cG9zZWQgZm9yIHBsdWdpbnMgYnV0IHNob3VsZG4ndCBiZSBidW5kbGVkIHdpdGggbWluaW1hbCByZWFsdGltZVxuICAgIHRoaXMuUmVzb3VyY2UgPSByZXNvdXJjZV9kZWZhdWx0O1xuICAgIHRoaXMuRGV2aWNlRGV0YWlscyA9IGRldmljZWRldGFpbHNfZGVmYXVsdDtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxzKHRoaXMuY2xpZW50KTtcbiAgICB0aGlzLnB1c2ggPSBuZXcgcHVzaF9kZWZhdWx0KHRoaXMuY2xpZW50KTtcbiAgfVxuICBhc3luYyBzdGF0cyhwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKSwgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdDtcbiAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdCh0aGlzLmNsaWVudCwgXCIvc3RhdHNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgY29uc3Qgc3RhdHNWYWx1ZXMgPSB1bnBhY2tlZCA/IGJvZHkgOiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0c1ZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RhdHNWYWx1ZXNbaV0gPSBzdGF0c19kZWZhdWx0LmZyb21WYWx1ZXMoc3RhdHNWYWx1ZXNbaV0pO1xuICAgICAgcmV0dXJuIHN0YXRzVmFsdWVzO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHRpbWUocGFyYW1zKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgdGltZVVyaSA9IChob3N0KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQuYmFzZVVyaShob3N0KSArIFwiL3RpbWVcIjtcbiAgICB9O1xuICAgIGxldCB7IGVycm9yLCBib2R5LCB1bnBhY2tlZCB9ID0gYXdhaXQgdGhpcy5jbGllbnQuaHR0cC5kbyhcbiAgICAgIEh0dHBNZXRob2RzX2RlZmF1bHQuR2V0LFxuICAgICAgdGltZVVyaSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBudWxsLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoIXVucGFja2VkKVxuICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgY29uc3QgdGltZSA9IGJvZHlbMF07XG4gICAgaWYgKCF0aW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiSW50ZXJuYWwgZXJyb3IgKHVuZXhwZWN0ZWQgcmVzdWx0IHR5cGUgZnJvbSBHRVQgL3RpbWUpXCIsIDVlNCwgNTAwKTtcbiAgICB9XG4gICAgdGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCA9IHRpbWUgLSBEYXRlLm5vdygpO1xuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QobWV0aG9kLCBwYXRoLCB2ZXJzaW9uMiwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBbZW5jb2RlciwgZGVjb2RlciwgZm9ybWF0XSA9ICgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50Ll9Nc2dQYWNrKSB7XG4gICAgICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJNc2dQYWNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGhpcy5jbGllbnQuX01zZ1BhY2suZW5jb2RlLCB0aGlzLmNsaWVudC5fTXNnUGFjay5kZWNvZGUsIFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi9dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtKU09OLnN0cmluZ2lmeSwgSlNPTi5wYXJzZSwgXCJqc29uXCIgLyoganNvbiAqL107XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICBjb25zdCBlbnZlbG9wZSA9IHRoaXMuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdDtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29uc3QgX21ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBfbWV0aG9kID09IFwiZ2V0XCIgPyBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0LCBwcm90b2NvbFZlcnNpb246IHZlcnNpb24yIH0pIDogZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQsIHByb3RvY29sVmVyc2lvbjogdmVyc2lvbjIgfSk7XG4gICAgaWYgKHR5cGVvZiBib2R5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBib2R5ID0gKF9hMiA9IGVuY29kZXIoYm9keSkpICE9IG51bGwgPyBfYTIgOiBudWxsO1xuICAgIH1cbiAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjdXN0b21IZWFkZXJzKSB7XG4gICAgICBtaXhpbihoZWFkZXJzLCBjdXN0b21IZWFkZXJzKTtcbiAgICB9XG4gICAgY29uc3QgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChcbiAgICAgIHRoaXMuY2xpZW50LFxuICAgICAgcGF0aCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIGZ1bmN0aW9uKHJlc2JvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlQXJyYXkodW5wYWNrZWQgPyByZXNib2R5IDogZGVjb2RlcihyZXNib2R5KSk7XG4gICAgICB9LFxuICAgICAgLyogdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlOiAqL1xuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgaWYgKCFQbGF0Zm9ybS5IdHRwLm1ldGhvZHMuaW5jbHVkZXMoX21ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbnN1cHBvcnRlZCBtZXRob2QgXCIgKyBfbWV0aG9kLCA0MDUwMCwgNDA1KTtcbiAgICB9XG4gICAgaWYgKFBsYXRmb3JtLkh0dHAubWV0aG9kc1dpdGhCb2R5LmluY2x1ZGVzKF9tZXRob2QpKSB7XG4gICAgICByZXR1cm4gcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhZ2luYXRlZFJlc291cmNlW19tZXRob2RdKHBhcmFtcyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoUHVibGlzaChzcGVjT3JTcGVjcykge1xuICAgIGxldCByZXF1ZXN0Qm9keURUTztcbiAgICBsZXQgc2luZ2xlU3BlY01vZGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3BlY09yU3BlY3MpKSB7XG4gICAgICByZXF1ZXN0Qm9keURUTyA9IHNwZWNPclNwZWNzO1xuICAgICAgc2luZ2xlU3BlY01vZGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdEJvZHlEVE8gPSBbc3BlY09yU3BlY3NdO1xuICAgICAgc2luZ2xlU3BlY01vZGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkocmVxdWVzdEJvZHlEVE8sIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KHRoaXMuY2xpZW50LCBcIi9tZXNzYWdlc1wiLCByZXF1ZXN0Qm9keSwgaGVhZGVycywge30sIG51bGwsIHRydWUpO1xuICAgIGNvbnN0IGJhdGNoUmVzdWx0cyA9IHJlc3BvbnNlLnVucGFja2VkID8gcmVzcG9uc2UuYm9keSA6IGRlY29kZUJvZHkocmVzcG9uc2UuYm9keSwgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgaWYgKHNpbmdsZVNwZWNNb2RlKSB7XG4gICAgICByZXR1cm4gYmF0Y2hSZXN1bHRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmF0Y2hSZXN1bHRzO1xuICAgIH1cbiAgfVxuICBhc3luYyBiYXRjaFByZXNlbmNlKGNoYW5uZWxzKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgY2hhbm5lbHNQYXJhbSA9IGNoYW5uZWxzLmpvaW4oXCIsXCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQodGhpcy5jbGllbnQsIFwiL3ByZXNlbmNlXCIsIGhlYWRlcnMsIHsgY2hhbm5lbHM6IGNoYW5uZWxzUGFyYW0gfSwgbnVsbCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnVucGFja2VkID8gcmVzcG9uc2UuYm9keSA6IGRlY29kZUJvZHkocmVzcG9uc2UuYm9keSwgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gIH1cbiAgYXN5bmMgcmV2b2tlVG9rZW5zKHNwZWNpZmllcnMsIG9wdGlvbnMpIHtcbiAgICBpZiAodXNlVG9rZW5BdXRoKHRoaXMuY2xpZW50Lm9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiQ2Fubm90IHJldm9rZSB0b2tlbnMgd2hlbiB1c2luZyB0b2tlbiBhdXRoXCIsIDQwMTYyLCA0MDEpO1xuICAgIH1cbiAgICBjb25zdCBrZXlOYW1lID0gdGhpcy5jbGllbnQub3B0aW9ucy5rZXlOYW1lO1xuICAgIGxldCByZXNvbHZlZE9wdGlvbnMgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgY29uc3QgcmVxdWVzdEJvZHlEVE8gPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICB0YXJnZXRzOiBzcGVjaWZpZXJzLm1hcCgoc3BlY2lmaWVyKSA9PiBgJHtzcGVjaWZpZXIudHlwZX06JHtzcGVjaWZpZXIudmFsdWV9YClcbiAgICB9LCByZXNvbHZlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoXG4gICAgICB0aGlzLmNsaWVudCxcbiAgICAgIGAva2V5cy8ke2tleU5hbWV9L3Jldm9rZVRva2Vuc2AsXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB7fSxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgfVxufTtcbnZhciBDaGFubmVscyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5hbGwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBnZXQobmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIGxldCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICB0aGlzLmFsbFtuYW1lXSA9IGNoYW5uZWwgPSBuZXcgcmVzdGNoYW5uZWxfZGVmYXVsdCh0aGlzLmNsaWVudCwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgIGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG4gIC8qIEluY2x1ZGVkIHRvIHN1cHBvcnQgY2VydGFpbiBuaWNoZSB1c2UtY2FzZXM7IG1vc3QgdXNlcnMgc2hvdWxkIGlnbm9yZSB0aGlzLlxuICAgKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZyAqL1xuICByZWxlYXNlKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5hbGxbU3RyaW5nKG5hbWUpXTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2Jhc2VyZXN0LnRzXG52YXIgQmFzZVJlc3QgPSBjbGFzcyBleHRlbmRzIGJhc2VjbGllbnRfZGVmYXVsdCB7XG4gIC8qXG4gICAqIFRoZSBwdWJsaWMgdHlwaW5ncyBkZWNsYXJlIHRoYXQgdGhpcyBvbmx5IGFjY2VwdHMgYW4gb2JqZWN0LCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG9uZSBvZiB0aGVzZSB0aGluZ3M6XG4gICAqXG4gICAqIDEuIHBhc3NlcyBhIHN0cmluZyAod2hpY2ggaXMgcXVpdGUgbGlrZWx5IGlmIHRoZXnigJlyZSBlLmcuIG1pZ3JhdGluZyBmcm9tIHRoZSBkZWZhdWx0IHZhcmlhbnQgdG8gdGhlIG1vZHVsYXIgdmFyaWFudClcbiAgICogMi4gcGFzc2VzIG5vIGFyZ3VtZW50IGF0IGFsbFxuICAgKlxuICAgKiB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoZXNlIGNhc2VzIGFyZSBwb3NzaWJsZSBzbyB0aGF0IGl0IGZvcmNlcyB1cyB0byBoYW5kbGUgdGhlbS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihkZWZhdWx0c19kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucywgZmFsc2UsIFwiQmFzZVJlc3RcIiwgbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgeyBSZXN0IH0pKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L21vZHVsYXJwbHVnaW5zLnRzXG52YXIgYWxsQ29tbW9uTW9kdWxhclBsdWdpbnMgPSB7IFJlc3QgfTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGVmYXVsdG1lc3NhZ2UudHNcbnZhciBEZWZhdWx0TWVzc2FnZSA9IGNsYXNzIGV4dGVuZHMgbWVzc2FnZV9kZWZhdWx0IHtcbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZChsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWQsIGlucHV0T3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkQXJyYXkoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkQXJyYXkobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgUGxhdGZvcm0uQ3J5cHRvLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIC8vIFVzZWQgYnkgdGVzdHNcbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IG1lc3NhZ2VfZGVmYXVsdCgpLCB2YWx1ZXMpO1xuICB9XG4gIC8vIFVzZWQgYnkgdGVzdHNcbiAgc3RhdGljIGFzeW5jIGVuY29kZShtc2csIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZW5jb2RlKG1zZywgb3B0aW9ucyk7XG4gIH1cbiAgLy8gVXNlZCBieSB0ZXN0c1xuICBzdGF0aWMgYXN5bmMgZGVjb2RlKG1lc3NhZ2UsIGlucHV0Q29udGV4dCkge1xuICAgIHJldHVybiBkZWNvZGUobWVzc2FnZSwgaW5wdXRDb250ZXh0KTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGVmYXVsdHByZXNlbmNlbWVzc2FnZS50c1xudmFyIERlZmF1bHRQcmVzZW5jZU1lc3NhZ2UgPSBjbGFzcyBleHRlbmRzIHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0IHtcbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZDIobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheTIobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgZW5jb2RlZEFycmF5LCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMsIHN0cmluZ2lmeUFjdGlvbikge1xuICAgIHJldHVybiBmcm9tVmFsdWVzMih2YWx1ZXMsIHN0cmluZ2lmeUFjdGlvbik7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9kZWZhdWx0cmVzdC50c1xudmFyIF9EZWZhdWx0UmVzdCA9IGNsYXNzIF9EZWZhdWx0UmVzdCBleHRlbmRzIEJhc2VSZXN0IHtcbiAgLy8gVGhlIHB1YmxpYyB0eXBpbmdzIGRlY2xhcmUgdGhhdCB0aGlzIHJlcXVpcmVzIGFuIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gZW1pdCBhIGdvb2QgZXJyb3IgbWVzc2FnZSBpbiB0aGUgY2FzZSB3aGVyZSBhIG5vbi1UeXBlU2NyaXB0IHVzZXIgZG9lcyBub3QgcGFzcyBhbiBhcmd1bWVudCwgdGVsbCB0aGUgY29tcGlsZXIgdGhhdCB0aGlzIGlzIHBvc3NpYmxlIHNvIHRoYXQgaXQgZm9yY2VzIHVzIHRvIGhhbmRsZSBpdC5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGNvbnN0IE1zZ1BhY2sgPSBfRGVmYXVsdFJlc3QuX01zZ1BhY2s7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEZWZhdWx0UmVzdC5fTXNnUGFjayB0byBoYXZlIGJlZW4gc2V0XCIpO1xuICAgIH1cbiAgICBzdXBlcihcbiAgICAgIGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCB0cnVlLCBcIlJlc3RcIiwgbG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYWxsQ29tbW9uTW9kdWxhclBsdWdpbnMpLCB7XG4gICAgICAgIENyeXB0bzogKF9hMiA9IF9EZWZhdWx0UmVzdC5DcnlwdG8pICE9IG51bGwgPyBfYTIgOiB2b2lkIDAsXG4gICAgICAgIE1zZ1BhY2s6IChfYiA9IF9EZWZhdWx0UmVzdC5fTXNnUGFjaykgIT0gbnVsbCA/IF9iIDogdm9pZCAwXG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIHN0YXRpYyBnZXQgQ3J5cHRvKCkge1xuICAgIGlmICh0aGlzLl9DcnlwdG8gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX0NyeXB0bztcbiAgfVxuICBzdGF0aWMgc2V0IENyeXB0byhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX0NyeXB0byA9IG5ld1ZhbHVlO1xuICB9XG59O1xuX0RlZmF1bHRSZXN0Ll9DcnlwdG8gPSBudWxsO1xuX0RlZmF1bHRSZXN0Lk1lc3NhZ2UgPSBEZWZhdWx0TWVzc2FnZTtcbl9EZWZhdWx0UmVzdC5QcmVzZW5jZU1lc3NhZ2UgPSBEZWZhdWx0UHJlc2VuY2VNZXNzYWdlO1xuX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrID0gbnVsbDtcbi8vIFVzZWQgYnkgdGVzdHNcbl9EZWZhdWx0UmVzdC5fSHR0cCA9IEh0dHA7XG52YXIgRGVmYXVsdFJlc3QgPSBfRGVmYXVsdFJlc3Q7XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvZXZlbnRlbWl0dGVyLnRzXG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIobG9nZ2VyLCBldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgbGlzdGVuZXIuYXBwbHkoZXZlbnRUaGlzLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgIFwiRXZlbnRFbWl0dGVyLmVtaXQoKVwiLFxuICAgICAgXCJVbmV4cGVjdGVkIGxpc3RlbmVyIGV4Y2VwdGlvbjogXCIgKyBlICsgXCI7IHN0YWNrID0gXCIgKyAoZSAmJiBlLnN0YWNrKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHRhcmdldExpc3RlbmVycywgbGlzdGVuZXIsIGV2ZW50RmlsdGVyKSB7XG4gIGxldCBsaXN0ZW5lcnM7XG4gIGxldCBpbmRleDtcbiAgbGV0IGV2ZW50TmFtZTtcbiAgZm9yIChsZXQgdGFyZ2V0TGlzdGVuZXJzSW5kZXggPSAwOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCA8IHRhcmdldExpc3RlbmVycy5sZW5ndGg7IHRhcmdldExpc3RlbmVyc0luZGV4KyspIHtcbiAgICBsaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdO1xuICAgIGlmIChldmVudEZpbHRlcikge1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50RmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgd2hpbGUgKChpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSkgIT09IC0xKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50RmlsdGVyICYmIGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF1bZXZlbnRGaWx0ZXJdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdGVuZXJzKSkge1xuICAgICAgZm9yIChldmVudE5hbWUgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGlzdGVuZXJzLCBldmVudE5hbWUpICYmIEFycmF5LmlzQXJyYXkobGlzdGVuZXJzW2V2ZW50TmFtZV0pKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoW2xpc3RlbmVyc10sIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgRXZlbnRFbWl0dGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmFueSA9IFtdO1xuICAgIHRoaXMuZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbnlPbmNlID0gW107XG4gICAgdGhpcy5ldmVudHNPbmNlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgb24oLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzBdO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgW2V2ZW50LCBsaXN0ZW5lcl0gPSBhcmdzO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50TGlzdGVuZXIub24oKTogSW52YWxpZCBhcmd1bWVudHM6IFwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmlsKGV2ZW50KSkge1xuICAgICAgICB0aGlzLmFueS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgZXZlbnQuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8ICh0aGlzLmV2ZW50c1tldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb2ZmKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMCB8fCBpc05pbChhcmdzWzBdKSAmJiBpc05pbChhcmdzWzFdKSkge1xuICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgIHRoaXMuZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICAgIHRoaXMuZXZlbnRzT25jZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBhcmdzO1xuICAgIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gICAgbGV0IGV2ZW50ID0gbnVsbDtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgfHwgIXNlY29uZEFyZykge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZmlyc3RBcmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudCA9IGZpcnN0QXJnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBbZXZlbnQsIGxpc3RlbmVyXSA9IFtmaXJzdEFyZywgc2Vjb25kQXJnXTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyICYmIGlzTmlsKGV2ZW50KSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuYW55LCB0aGlzLmV2ZW50cywgdGhpcy5hbnlPbmNlLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZXZlbnQuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuZXZlbnRzLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lciwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudDsgZXhjbHVkZXMgb25jZSBldmVudHNcbiAgICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBvciBub25lIGZvciAnYW55J1xuICAgKiBAcmV0dXJuIGFycmF5IG9mIGV2ZW50cywgb3IgbnVsbCBpZiBub25lXG4gICAqL1xuICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICAgIGlmICh0aGlzLmV2ZW50c09uY2VbZXZlbnRdKVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuZXZlbnRzT25jZVtldmVudF0pO1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGggPyBsaXN0ZW5lcnMgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbnkubGVuZ3RoID8gdGhpcy5hbnkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGFuIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyXG4gICAqL1xuICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXZlbnRUaGlzID0geyBldmVudCB9O1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgIGlmICh0aGlzLmFueU9uY2UubGVuZ3RoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55T25jZSk7XG4gICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW55Lmxlbmd0aCkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueSk7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50c09uY2VMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuICAgIGlmIChldmVudHNPbmNlTGlzdGVuZXJzKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c09uY2VMaXN0ZW5lcnMpO1xuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50c0xpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoZXZlbnRzTGlzdGVuZXJzKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c0xpc3RlbmVycyk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgY2FsbExpc3RlbmVyKHRoaXMubG9nZ2VyLCBldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuICBvbmNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmIChhcmdDb3VudCA9PT0gMCB8fCBhcmdDb3VudCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5vbmNlKGV2ZW50LCByZXNvbHZlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBhcmdzO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmlyc3RBcmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5hbnlPbmNlLnB1c2goZmlyc3RBcmcpO1xuICAgIH0gZWxzZSBpZiAoaXNOaWwoZmlyc3RBcmcpKSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgdGhpcy5hbnlPbmNlLnB1c2goc2Vjb25kQXJnKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3RBcmcpKSB7XG4gICAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgICBjb25zdCBsaXN0ZW5lcldyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgaW5uZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgZmlyc3RBcmcuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICBzZWxmMi5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHNlY29uZEFyZy5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGZpcnN0QXJnLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgIHNlbGYyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXJXcmFwcGVyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNPbmNlW2ZpcnN0QXJnXSB8fCAodGhpcy5ldmVudHNPbmNlW2ZpcnN0QXJnXSA9IFtdKTtcbiAgICAgIGlmIChzZWNvbmRBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOlwiICsgUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHNlY29uZEFyZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYSBzdGF0ZSBldmVudCBhbmQgZmlyZSBpbW1lZGlhdGVseSBpZiBjdXJyZW50U3RhdGUgbWF0Y2hlcyB0YXJnZXRTdGF0ZVxuICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIGV2ZW50IHRvIGxpc3RlbiB0b1xuICAgKiBAcGFyYW0gY3VycmVudFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgb2JqZWN0XG4gICAqL1xuICBhc3luYyB3aGVuU3RhdGUodGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0U3RhdGUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGN1cnJlbnRTdGF0ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlblN0YXRlIHJlcXVpcmVzIGEgdmFsaWQgc3RhdGUgU3RyaW5nIGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0U3RhdGUgPT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm9uY2UodGFyZ2V0U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBldmVudGVtaXR0ZXJfZGVmYXVsdCA9IEV2ZW50RW1pdHRlcjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvcHJvdG9jb2xtZXNzYWdlLnRzXG52YXIgYWN0aW9uczIgPSB7XG4gIEhFQVJUQkVBVDogMCxcbiAgQUNLOiAxLFxuICBOQUNLOiAyLFxuICBDT05ORUNUOiAzLFxuICBDT05ORUNURUQ6IDQsXG4gIERJU0NPTk5FQ1Q6IDUsXG4gIERJU0NPTk5FQ1RFRDogNixcbiAgQ0xPU0U6IDcsXG4gIENMT1NFRDogOCxcbiAgRVJST1I6IDksXG4gIEFUVEFDSDogMTAsXG4gIEFUVEFDSEVEOiAxMSxcbiAgREVUQUNIOiAxMixcbiAgREVUQUNIRUQ6IDEzLFxuICBQUkVTRU5DRTogMTQsXG4gIE1FU1NBR0U6IDE1LFxuICBTWU5DOiAxNixcbiAgQVVUSDogMTcsXG4gIEFDVElWQVRFOiAxOFxufTtcbnZhciBBY3Rpb25OYW1lID0gW107XG5PYmplY3Qua2V5cyhhY3Rpb25zMikuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIEFjdGlvbk5hbWVbYWN0aW9uczJbbmFtZV1dID0gbmFtZTtcbn0pO1xudmFyIGZsYWdzID0ge1xuICAvKiBDaGFubmVsIGF0dGFjaCBzdGF0ZSBmbGFncyAqL1xuICBIQVNfUFJFU0VOQ0U6IDEgPDwgMCxcbiAgSEFTX0JBQ0tMT0c6IDEgPDwgMSxcbiAgUkVTVU1FRDogMSA8PCAyLFxuICBUUkFOU0lFTlQ6IDEgPDwgNCxcbiAgQVRUQUNIX1JFU1VNRTogMSA8PCA1LFxuICAvKiBDaGFubmVsIG1vZGUgZmxhZ3MgKi9cbiAgUFJFU0VOQ0U6IDEgPDwgMTYsXG4gIFBVQkxJU0g6IDEgPDwgMTcsXG4gIFNVQlNDUklCRTogMSA8PCAxOCxcbiAgUFJFU0VOQ0VfU1VCU0NSSUJFOiAxIDw8IDE5XG59O1xudmFyIGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKGZsYWdzKTtcbmZsYWdzLk1PREVfQUxMID0gZmxhZ3MuUFJFU0VOQ0UgfCBmbGFncy5QVUJMSVNIIHwgZmxhZ3MuU1VCU0NSSUJFIHwgZmxhZ3MuUFJFU0VOQ0VfU1VCU0NSSUJFO1xuZnVuY3Rpb24gdG9TdHJpbmdBcnJheShhcnJheSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0udG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlsgXCIgKyByZXN1bHQuam9pbihcIiwgXCIpICsgXCIgXVwiO1xufVxudmFyIGNoYW5uZWxNb2RlcyA9IFtcIlBSRVNFTkNFXCIsIFwiUFVCTElTSFwiLCBcIlNVQlNDUklCRVwiLCBcIlBSRVNFTkNFX1NVQlNDUklCRVwiXTtcbnZhciBzZXJpYWxpemUyID0gZW5jb2RlQm9keTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQsIE1zZ1BhY2ssIHByZXNlbmNlTWVzc2FnZVBsdWdpbiwgZm9ybWF0KSB7XG4gIGNvbnN0IGRlc2VyaWFsaXplZCA9IGRlY29kZUJvZHkoc2VyaWFsaXplZCwgTXNnUGFjaywgZm9ybWF0KTtcbiAgcmV0dXJuIGZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4pO1xufVxuZnVuY3Rpb24gZnJvbURlc2VyaWFsaXplZChkZXNlcmlhbGl6ZWQsIHByZXNlbmNlTWVzc2FnZVBsdWdpbikge1xuICBjb25zdCBlcnJvciA9IGRlc2VyaWFsaXplZC5lcnJvcjtcbiAgaWYgKGVycm9yKVxuICAgIGRlc2VyaWFsaXplZC5lcnJvciA9IEVycm9ySW5mby5mcm9tVmFsdWVzKGVycm9yKTtcbiAgY29uc3QgbWVzc2FnZXMgPSBkZXNlcmlhbGl6ZWQubWVzc2FnZXM7XG4gIGlmIChtZXNzYWdlcylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgbWVzc2FnZXNbaV0gPSBmcm9tVmFsdWVzKG1lc3NhZ2VzW2ldKTtcbiAgY29uc3QgcHJlc2VuY2UgPSBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4gPyBkZXNlcmlhbGl6ZWQucHJlc2VuY2UgOiB2b2lkIDA7XG4gIGlmIChwcmVzZW5jZU1lc3NhZ2VQbHVnaW4pIHtcbiAgICBpZiAocHJlc2VuY2UgJiYgcHJlc2VuY2VNZXNzYWdlUGx1Z2luKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVzZW5jZS5sZW5ndGg7IGkrKylcbiAgICAgICAgcHJlc2VuY2VbaV0gPSBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4ucHJlc2VuY2VNZXNzYWdlRnJvbVZhbHVlcyhwcmVzZW5jZVtpXSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFByb3RvY29sTWVzc2FnZSgpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBkZXNlcmlhbGl6ZWQpLCB7IHByZXNlbmNlIH0pKTtcbn1cbmZ1bmN0aW9uIGZyb21EZXNlcmlhbGl6ZWRJbmNsdWRpbmdEZXBlbmRlbmNpZXMoZGVzZXJpYWxpemVkKSB7XG4gIHJldHVybiBmcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCwgeyBwcmVzZW5jZU1lc3NhZ2VGcm9tVmFsdWVzOiBmcm9tVmFsdWVzMiwgcHJlc2VuY2VNZXNzYWdlc0Zyb21WYWx1ZXNBcnJheTogZnJvbVZhbHVlc0FycmF5MiB9KTtcbn1cbmZ1bmN0aW9uIGZyb21WYWx1ZXMzKHZhbHVlcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkobXNnLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4pIHtcbiAgbGV0IHJlc3VsdCA9IFwiW1Byb3RvY29sTWVzc2FnZVwiO1xuICBpZiAobXNnLmFjdGlvbiAhPT0gdm9pZCAwKVxuICAgIHJlc3VsdCArPSBcIjsgYWN0aW9uPVwiICsgQWN0aW9uTmFtZVttc2cuYWN0aW9uXSB8fCBtc2cuYWN0aW9uO1xuICBjb25zdCBzaW1wbGVBdHRyaWJ1dGVzID0gW1wiaWRcIiwgXCJjaGFubmVsXCIsIFwiY2hhbm5lbFNlcmlhbFwiLCBcImNvbm5lY3Rpb25JZFwiLCBcImNvdW50XCIsIFwibXNnU2VyaWFsXCIsIFwidGltZXN0YW1wXCJdO1xuICBsZXQgYXR0cmlidXRlO1xuICBmb3IgKGxldCBhdHRyaWJJbmRleCA9IDA7IGF0dHJpYkluZGV4IDwgc2ltcGxlQXR0cmlidXRlcy5sZW5ndGg7IGF0dHJpYkluZGV4KyspIHtcbiAgICBhdHRyaWJ1dGUgPSBzaW1wbGVBdHRyaWJ1dGVzW2F0dHJpYkluZGV4XTtcbiAgICBpZiAobXNnW2F0dHJpYnV0ZV0gIT09IHZvaWQgMClcbiAgICAgIHJlc3VsdCArPSBcIjsgXCIgKyBhdHRyaWJ1dGUgKyBcIj1cIiArIG1zZ1thdHRyaWJ1dGVdO1xuICB9XG4gIGlmIChtc2cubWVzc2FnZXMpXG4gICAgcmVzdWx0ICs9IFwiOyBtZXNzYWdlcz1cIiArIHRvU3RyaW5nQXJyYXkoZnJvbVZhbHVlc0FycmF5KG1zZy5tZXNzYWdlcykpO1xuICBpZiAobXNnLnByZXNlbmNlICYmIHByZXNlbmNlTWVzc2FnZVBsdWdpbilcbiAgICByZXN1bHQgKz0gXCI7IHByZXNlbmNlPVwiICsgdG9TdHJpbmdBcnJheShwcmVzZW5jZU1lc3NhZ2VQbHVnaW4ucHJlc2VuY2VNZXNzYWdlc0Zyb21WYWx1ZXNBcnJheShtc2cucHJlc2VuY2UpKTtcbiAgaWYgKG1zZy5lcnJvcilcbiAgICByZXN1bHQgKz0gXCI7IGVycm9yPVwiICsgRXJyb3JJbmZvLmZyb21WYWx1ZXMobXNnLmVycm9yKS50b1N0cmluZygpO1xuICBpZiAobXNnLmF1dGggJiYgbXNnLmF1dGguYWNjZXNzVG9rZW4pXG4gICAgcmVzdWx0ICs9IFwiOyB0b2tlbj1cIiArIG1zZy5hdXRoLmFjY2Vzc1Rva2VuO1xuICBpZiAobXNnLmZsYWdzKVxuICAgIHJlc3VsdCArPSBcIjsgZmxhZ3M9XCIgKyBmbGFnTmFtZXMuZmlsdGVyKG1zZy5oYXNGbGFnKS5qb2luKFwiLFwiKTtcbiAgaWYgKG1zZy5wYXJhbXMpIHtcbiAgICBsZXQgc3RyaW5naWZpZWRQYXJhbXMgPSBcIlwiO1xuICAgIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMobXNnLnBhcmFtcywgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgaWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyaW5naWZpZWRQYXJhbXMgKz0gXCI7IFwiO1xuICAgICAgfVxuICAgICAgc3RyaW5naWZpZWRQYXJhbXMgKz0gcHJvcCArIFwiPVwiICsgbXNnLnBhcmFtc1twcm9wXTtcbiAgICB9KTtcbiAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBwYXJhbXM9W1wiICsgc3RyaW5naWZpZWRQYXJhbXMgKyBcIl1cIjtcbiAgICB9XG4gIH1cbiAgcmVzdWx0ICs9IFwiXVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFByb3RvY29sTWVzc2FnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYXNGbGFnID0gKGZsYWcpID0+IHtcbiAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIGZsYWdzW2ZsYWddKSA+IDA7XG4gICAgfTtcbiAgfVxuICBzZXRGbGFnKGZsYWcpIHtcbiAgICByZXR1cm4gdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBmbGFnc1tmbGFnXTtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmZsYWdzICYmIHRoaXMuZmxhZ3MgJiBmbGFncy5NT0RFX0FMTDtcbiAgfVxuICBlbmNvZGVNb2Rlc1RvRmxhZ3MobW9kZXMpIHtcbiAgICBtb2Rlcy5mb3JFYWNoKChtb2RlKSA9PiB0aGlzLnNldEZsYWcobW9kZSkpO1xuICB9XG4gIGRlY29kZU1vZGVzRnJvbUZsYWdzKCkge1xuICAgIGNvbnN0IG1vZGVzID0gW107XG4gICAgY2hhbm5lbE1vZGVzLmZvckVhY2goKG1vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0ZsYWcobW9kZSkpIHtcbiAgICAgICAgbW9kZXMucHVzaChtb2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZXMubGVuZ3RoID4gMCA/IG1vZGVzIDogdm9pZCAwO1xuICB9XG59O1xudmFyIHByb3RvY29sbWVzc2FnZV9kZWZhdWx0ID0gUHJvdG9jb2xNZXNzYWdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvbWVzc2FnZXF1ZXVlLnRzXG52YXIgTWVzc2FnZVF1ZXVlID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHN1cGVyKGxvZ2dlcik7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICB9XG4gIGNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmxlbmd0aDtcbiAgfVxuICBwdXNoKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc2hpZnQoKTtcbiAgfVxuICBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzW3RoaXMubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgY29weUFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5zbGljZSgpO1xuICB9XG4gIGFwcGVuZChtZXNzYWdlcykge1xuICAgIHRoaXMubWVzc2FnZXMucHVzaC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG4gIH1cbiAgcHJlcGVuZChtZXNzYWdlcykge1xuICAgIHRoaXMubWVzc2FnZXMudW5zaGlmdC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG4gIH1cbiAgY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50LCBlcnIpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKVwiLFxuICAgICAgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnRcbiAgICApO1xuICAgIGVyciA9IGVyciB8fCBudWxsO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcztcbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcygpOiBjb21wbGV0ZU1lc3NhZ2VzIGNhbGxlZCBvbiBhbnkgZW1wdHkgTWVzc2FnZVF1ZXVlXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IG1lc3NhZ2VzWzBdO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY29uc3Qgc3RhcnRTZXJpYWwgPSBmaXJzdC5tZXNzYWdlLm1zZ1NlcmlhbDtcbiAgICAgIGNvbnN0IGVuZFNlcmlhbCA9IHNlcmlhbCArIGNvdW50O1xuICAgICAgaWYgKGVuZFNlcmlhbCA+IHN0YXJ0U2VyaWFsKSB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCwgZW5kU2VyaWFsIC0gc3RhcnRTZXJpYWwpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgY29tcGxldGVNZXNzYWdlcykge1xuICAgICAgICAgIG1lc3NhZ2UuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICB0aGlzLmVtaXQoXCJpZGxlXCIpO1xuICAgIH1cbiAgfVxuICBjb21wbGV0ZUFsbE1lc3NhZ2VzKGVycikge1xuICAgIHRoaXMuY29tcGxldGVNZXNzYWdlcygwLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBOdW1iZXIuTUFYX1ZBTFVFLCBlcnIpO1xuICB9XG4gIHJlc2V0U2VuZEF0dGVtcHRlZCgpIHtcbiAgICBmb3IgKGxldCBtc2cgb2YgdGhpcy5tZXNzYWdlcykge1xuICAgICAgbXNnLnNlbmRBdHRlbXB0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIk1lc3NhZ2VRdWV1ZS5jbGVhcigpXCIsXG4gICAgICBcImNsZWFyaW5nIFwiICsgdGhpcy5tZXNzYWdlcy5sZW5ndGggKyBcIiBtZXNzYWdlc1wiXG4gICAgKTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5lbWl0KFwiaWRsZVwiKTtcbiAgfVxufTtcbnZhciBtZXNzYWdlcXVldWVfZGVmYXVsdCA9IE1lc3NhZ2VRdWV1ZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L3Byb3RvY29sLnRzXG52YXIgUGVuZGluZ01lc3NhZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5tZXJnZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhY3Rpb24gPSBtZXNzYWdlLmFjdGlvbjtcbiAgICB0aGlzLnNlbmRBdHRlbXB0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFja1JlcXVpcmVkID0gYWN0aW9uID09IGFjdGlvbnMyLk1FU1NBR0UgfHwgYWN0aW9uID09IGFjdGlvbnMyLlBSRVNFTkNFO1xuICB9XG59O1xudmFyIFByb3RvY29sID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgIHN1cGVyKHRyYW5zcG9ydC5sb2dnZXIpO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gbmV3IG1lc3NhZ2VxdWV1ZV9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0cmFuc3BvcnQub24oXCJhY2tcIiwgKHNlcmlhbCwgY291bnQpID0+IHtcbiAgICAgIHRoaXMub25BY2soc2VyaWFsLCBjb3VudCk7XG4gICAgfSk7XG4gICAgdHJhbnNwb3J0Lm9uKFwibmFja1wiLCAoc2VyaWFsLCBjb3VudCwgZXJyKSA9PiB7XG4gICAgICB0aGlzLm9uTmFjayhzZXJpYWwsIGNvdW50LCBlcnIpO1xuICAgIH0pO1xuICB9XG4gIG9uQWNrKHNlcmlhbCwgY291bnQpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJQcm90b2NvbC5vbkFjaygpXCIsIFwic2VyaWFsID0gXCIgKyBzZXJpYWwgKyBcIjsgY291bnQgPSBcIiArIGNvdW50KTtcbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQpO1xuICB9XG4gIG9uTmFjayhzZXJpYWwsIGNvdW50LCBlcnIpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgIFwiUHJvdG9jb2wub25OYWNrKClcIixcbiAgICAgIFwic2VyaWFsID0gXCIgKyBzZXJpYWwgKyBcIjsgY291bnQgPSBcIiArIGNvdW50ICsgXCI7IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICApO1xuICAgIGlmICghZXJyKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHNlbmQgbWVzc2FnZTsgY2hhbm5lbCBub3QgcmVzcG9uZGluZ1wiLCA1MDAwMSwgNTAwKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50LCBlcnIpO1xuICB9XG4gIG9uY2VJZGxlKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbWVzc2FnZVF1ZXVlID0gdGhpcy5tZXNzYWdlUXVldWU7XG4gICAgaWYgKG1lc3NhZ2VRdWV1ZS5jb3VudCgpID09PSAwKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXNzYWdlUXVldWUub25jZShcImlkbGVcIiwgbGlzdGVuZXIpO1xuICB9XG4gIHNlbmQocGVuZGluZ01lc3NhZ2UpIHtcbiAgICBpZiAocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQpIHtcbiAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gocGVuZGluZ01lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiUHJvdG9jb2wuc2VuZCgpXCIsXG4gICAgICAgIFwic2VuZGluZyBtc2c7IFwiICsgc3RyaW5naWZ5KHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UsIHRoaXMudHJhbnNwb3J0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlKVxuICAgICAgKTtcbiAgICB9XG4gICAgcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCA9IHRydWU7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZChwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgfVxuICBnZXRUcmFuc3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0O1xuICB9XG4gIGdldFBlbmRpbmdNZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY29weUFsbCgpO1xuICB9XG4gIGNsZWFyUGVuZGluZ01lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jbGVhcigpO1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydDtcbiAgICB0aGlzLm9uY2VJZGxlKGZ1bmN0aW9uKCkge1xuICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBwcm90b2NvbF9kZWZhdWx0ID0gUHJvdG9jb2w7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jb25uZWN0aW9uc3RhdGVjaGFuZ2UudHNcbnZhciBDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBjdXJyZW50LCByZXRyeUluLCByZWFzb24pIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICBpZiAocmV0cnlJbilcbiAgICAgIHRoaXMucmV0cnlJbiA9IHJldHJ5SW47XG4gICAgaWYgKHJlYXNvbilcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59O1xudmFyIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0ID0gQ29ubmVjdGlvblN0YXRlQ2hhbmdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbmVycm9ycy50c1xudmFyIENvbm5lY3Rpb25FcnJvckNvZGVzID0ge1xuICBESVNDT05ORUNURUQ6IDgwMDAzLFxuICBTVVNQRU5ERUQ6IDgwMDAyLFxuICBGQUlMRUQ6IDhlNCxcbiAgQ0xPU0lORzogODAwMTcsXG4gIENMT1NFRDogODAwMTcsXG4gIFVOS05PV05fQ09OTkVDVElPTl9FUlI6IDUwMDAyLFxuICBVTktOT1dOX0NIQU5ORUxfRVJSOiA1MDAwMVxufTtcbnZhciBDb25uZWN0aW9uRXJyb3JzID0ge1xuICBkaXNjb25uZWN0ZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuRElTQ09OTkVDVEVELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGVcIlxuICB9KSxcbiAgc3VzcGVuZGVkOiAoKSA9PiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgc3RhdHVzQ29kZTogNDAwLFxuICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLlNVU1BFTkRFRCxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gdG8gc2VydmVyIHVuYXZhaWxhYmxlXCJcbiAgfSksXG4gIGZhaWxlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5GQUlMRUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGZhaWxlZCBvciBkaXNjb25uZWN0ZWQgYnkgc2VydmVyXCJcbiAgfSksXG4gIGNsb3Npbmc6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0lORyxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gY2xvc2luZ1wiXG4gIH0pLFxuICBjbG9zZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0VELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBjbG9zZWRcIlxuICB9KSxcbiAgdW5rbm93bkNvbm5lY3Rpb25FcnI6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuVU5LTk9XTl9DT05ORUNUSU9OX0VSUixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIGNvbm5lY3Rpb24gZXJyb3JcIlxuICB9KSxcbiAgdW5rbm93bkNoYW5uZWxFcnI6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuVU5LTk9XTl9DT05ORUNUSU9OX0VSUixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIGNoYW5uZWwgZXJyb3JcIlxuICB9KVxufTtcbmZ1bmN0aW9uIGlzUmV0cmlhYmxlKGVycikge1xuICBpZiAoIWVyci5zdGF0dXNDb2RlIHx8ICFlcnIuY29kZSB8fCBlcnIuc3RhdHVzQ29kZSA+PSA1MDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhDb25uZWN0aW9uRXJyb3JDb2RlcykuaW5jbHVkZXMoZXJyLmNvZGUpO1xufVxudmFyIGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdCA9IENvbm5lY3Rpb25FcnJvcnM7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC90cmFuc3BvcnQudHNcbnZhciBjbG9zZU1lc3NhZ2UgPSBmcm9tVmFsdWVzMyh7IGFjdGlvbjogYWN0aW9uczIuQ0xPU0UgfSk7XG52YXIgZGlzY29ubmVjdE1lc3NhZ2UgPSBmcm9tVmFsdWVzMyh7IGFjdGlvbjogYWN0aW9uczIuRElTQ09OTkVDVCB9KTtcbnZhciBUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgZm9yY2VKc29uUHJvdG9jb2wpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uTWFuYWdlci5sb2dnZXIpO1xuICAgIGlmIChmb3JjZUpzb25Qcm90b2NvbCkge1xuICAgICAgcGFyYW1zLmZvcm1hdCA9IHZvaWQgMDtcbiAgICAgIHBhcmFtcy5oZWFydGJlYXRzID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy50aW1lb3V0cyA9IHBhcmFtcy5vcHRpb25zLnRpbWVvdXRzO1xuICAgIHRoaXMuZm9ybWF0ID0gcGFyYW1zLmZvcm1hdDtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5pc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0Q2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2goXCJjbG9zZWRcIiwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmNsb3NlZCgpKTtcbiAgfVxuICBkaXNjb25uZWN0KGVycikge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVyciB8fCBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQuZGlzY29ubmVjdGVkKCkpO1xuICB9XG4gIGZhaWwoZXJyKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2goXCJmYWlsZWRcIiwgZXJyIHx8IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5mYWlsZWQoKSk7XG4gIH1cbiAgZmluaXNoKGV2ZW50LCBlcnIpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCgoX2EyID0gdGhpcy5pZGxlVGltZXIpICE9IG51bGwgPyBfYTIgOiB2b2lkIDApO1xuICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLmVtaXQoZXZlbnQsIGVycik7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gIH1cbiAgb25Qcm90b2NvbE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICBcInJlY2VpdmVkIG9uIFwiICsgdGhpcy5zaG9ydE5hbWUgKyBcIjogXCIgKyBzdHJpbmdpZnkobWVzc2FnZSwgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSkgKyBcIjsgY29ubmVjdGlvbklkID0gXCIgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgY2FzZSBhY3Rpb25zMi5IRUFSVEJFQVQ6XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbk5vU3RyaXAoXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgICB0aGlzLnNob3J0TmFtZSArIFwiIGhlYXJ0YmVhdDsgY29ubmVjdGlvbklkID0gXCIgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVtaXQoXCJoZWFydGJlYXRcIiwgbWVzc2FnZS5pZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zMi5DT05ORUNURUQ6XG4gICAgICAgIHRoaXMub25Db25uZWN0KG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0ZWRcIiwgbWVzc2FnZS5lcnJvciwgbWVzc2FnZS5jb25uZWN0aW9uSWQsIG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMsIG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9uczIuQ0xPU0VEOlxuICAgICAgICB0aGlzLm9uQ2xvc2UobWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zMi5ESVNDT05ORUNURUQ6XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0KG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9uczIuQUNLOlxuICAgICAgICB0aGlzLmVtaXQoXCJhY2tcIiwgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9uczIuTkFDSzpcbiAgICAgICAgdGhpcy5lbWl0KFwibmFja1wiLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zMi5TWU5DOlxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zMi5BQ1RJVkFURTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMyLkFVVEg6XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLmF1dGguYXV0aG9yaXplKCksIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgICAgICAgXCJBYmx5IHJlcXVlc3RlZCByZS1hdXRoZW50aWNhdGlvbiwgYnV0IHVuYWJsZSB0byBvYnRhaW4gYSBuZXcgdG9rZW46IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMyLkVSUk9SOlxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKClcIixcbiAgICAgICAgICBcInJlY2VpdmVkIGVycm9yIGFjdGlvbjsgY29ubmVjdGlvbklkID0gXCIgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCArIFwiOyBlcnIgPSBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KG1lc3NhZ2UuZXJyb3IpICsgKG1lc3NhZ2UuY2hhbm5lbCA/IFwiLCBjaGFubmVsOiBcIiArIG1lc3NhZ2UuY2hhbm5lbCA6IFwiXCIpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtZXNzYWdlLmNoYW5uZWwgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMub25GYXRhbEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIG9uQ29ubmVjdChtZXNzYWdlKSB7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgaWYgKCFtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQub25Db25uZWN0KCk6IENvbm5lY3QgbWVzc2FnZSByZWNpZXZlZCB3aXRob3V0IGNvbm5lY3Rpb25EZXRhaWxzXCIpO1xuICAgIH1cbiAgICBjb25zdCBtYXhQcm9taXNlZElkbGUgPSBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcbiAgICBpZiAobWF4UHJvbWlzZWRJZGxlKSB7XG4gICAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG1heFByb21pc2VkSWRsZSArIHRoaXMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgIH1cbiAgfVxuICBvbkRpc2Nvbm5lY3QobWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQub25EaXNjb25uZWN0KClcIiwgXCJlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpKTtcbiAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIpO1xuICB9XG4gIG9uRmF0YWxFcnJvcihtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5vbkZhdGFsRXJyb3IoKVwiLCBcImVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycikpO1xuICAgIHRoaXMuZmluaXNoKFwiZmFpbGVkXCIsIGVycik7XG4gIH1cbiAgb25DbG9zZShtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5vbkNsb3NlKClcIiwgXCJlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpKTtcbiAgICB0aGlzLmZpbmlzaChcImNsb3NlZFwiLCBlcnIpO1xuICB9XG4gIHJlcXVlc3RDbG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQucmVxdWVzdENsb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5zZW5kKGNsb3NlTWVzc2FnZSk7XG4gIH1cbiAgcmVxdWVzdERpc2Nvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0LnJlcXVlc3REaXNjb25uZWN0KClcIiwgXCJcIik7XG4gICAgdGhpcy5zZW5kKGRpc2Nvbm5lY3RNZXNzYWdlKTtcbiAgfVxuICBwaW5nKGlkKSB7XG4gICAgY29uc3QgbXNnID0geyBhY3Rpb246IGFjdGlvbnMyLkhFQVJUQkVBVCB9O1xuICAgIGlmIChpZClcbiAgICAgIG1zZy5pZCA9IGlkO1xuICAgIHRoaXMuc2VuZChmcm9tVmFsdWVzMyhtc2cpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9mZigpO1xuICB9XG4gIG9uQWN0aXZpdHkoKSB7XG4gICAgaWYgKCF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubGFzdEFjdGl2aXR5ID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnNldElkbGVUaW1lcih0aGlzLm1heElkbGVJbnRlcnZhbCArIDEwMCk7XG4gIH1cbiAgc2V0SWRsZVRpbWVyKHRpbWVvdXQpIHtcbiAgICBpZiAoIXRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICB0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm9uSWRsZVRpbWVyRXhwaXJlKCk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgb25JZGxlVGltZXJFeHBpcmUoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RBY3Rpdml0eSB8fCAhdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydC5vbklkbGVUaW1lckV4cGlyZSgpOiBsYXN0QWN0aXZpdHkvbWF4SWRsZUludGVydmFsIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICBjb25zdCBzaW5jZUxhc3QgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG4gICAgY29uc3QgdGltZVJlbWFpbmluZyA9IHRoaXMubWF4SWRsZUludGVydmFsIC0gc2luY2VMYXN0O1xuICAgIGlmICh0aW1lUmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiTm8gYWN0aXZpdHkgc2VlbiBmcm9tIHJlYWx0aW1lIGluIFwiICsgc2luY2VMYXN0ICsgXCJtczsgYXNzdW1pbmcgY29ubmVjdGlvbiBoYXMgZHJvcHBlZFwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKClcIiwgbXNnKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdChuZXcgRXJyb3JJbmZvKG1zZywgODAwMDMsIDQwOCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldElkbGVUaW1lcih0aW1lUmVtYWluaW5nICsgMTAwKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHRyeUNvbm5lY3QodHJhbnNwb3J0Q3RvciwgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHRyYW5zcG9ydFBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0Q3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zKTtcbiAgICBsZXQgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyO1xuICAgIGNvbnN0IGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgY2FsbGJhY2soeyBldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVyciB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgPSBjb25uZWN0aW9uTWFuYWdlci5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0cmFuc3BvcnQub2ZmKFtcInByZWNvbm5lY3RcIiwgXCJkaXNjb25uZWN0ZWRcIiwgXCJmYWlsZWRcIl0pO1xuICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgIGVycm9yQ2IuY2FsbChcbiAgICAgICAgeyBldmVudDogXCJkaXNjb25uZWN0ZWRcIiB9LFxuICAgICAgICBuZXcgRXJyb3JJbmZvKFwiVGltZW91dCB3YWl0aW5nIGZvciB0cmFuc3BvcnQgdG8gaW5kaWNhdGUgaXRzZWxmIHZpYWJsZVwiLCA1ZTQsIDUwMClcbiAgICAgICk7XG4gICAgfSwgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG4gICAgdHJhbnNwb3J0Lm9uKFtcImZhaWxlZFwiLCBcImRpc2Nvbm5lY3RlZFwiXSwgZXJyb3JDYik7XG4gICAgdHJhbnNwb3J0Lm9uKFwicHJlY29ubmVjdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiVHJhbnNwb3J0LnRyeUNvbm5lY3QoKVwiLFxuICAgICAgICBcInZpYWJsZSB0cmFuc3BvcnQgXCIgKyB0cmFuc3BvcnRcbiAgICAgICk7XG4gICAgICBjbGVhclRpbWVvdXQodHJhbnNwb3J0QXR0ZW1wdFRpbWVyKTtcbiAgICAgIHRyYW5zcG9ydC5vZmYoW1wiZmFpbGVkXCIsIFwiZGlzY29ubmVjdGVkXCJdLCBlcnJvckNiKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG4gICAgfSk7XG4gICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gdHJhbnNwb3J0O1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiaXNBdmFpbGFibGUgbm90IGltcGxlbWVudGVkIGZvciB0cmFuc3BvcnRcIiwgNWU0LCA1MDApO1xuICB9XG59O1xudmFyIHRyYW5zcG9ydF9kZWZhdWx0ID0gVHJhbnNwb3J0O1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9UcmFuc3BvcnROYW1lLnRzXG52YXIgVHJhbnNwb3J0TmFtZXM7XG4oKFRyYW5zcG9ydE5hbWVzMikgPT4ge1xuICBUcmFuc3BvcnROYW1lczIuV2ViU29ja2V0ID0gXCJ3ZWJfc29ja2V0XCI7XG4gIFRyYW5zcG9ydE5hbWVzMi5Db21ldCA9IFwiY29tZXRcIjtcbiAgVHJhbnNwb3J0TmFtZXMyLlhoclBvbGxpbmcgPSBcInhocl9wb2xsaW5nXCI7XG59KShUcmFuc3BvcnROYW1lcyB8fCAoVHJhbnNwb3J0TmFtZXMgPSB7fSkpO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbm1hbmFnZXIudHNcbnZhciBnbG9iYWxPYmplY3QyID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBzZWxmO1xudmFyIGhhdmVXZWJTdG9yYWdlID0gKCkgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gdHlwZW9mIFBsYXRmb3JtLldlYlN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIgJiYgKChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvY2FsU3VwcG9ydGVkKTtcbn07XG52YXIgaGF2ZVNlc3Npb25TdG9yYWdlID0gKCkgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gdHlwZW9mIFBsYXRmb3JtLldlYlN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIgJiYgKChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNlc3Npb25TdXBwb3J0ZWQpO1xufTtcbnZhciBub29wID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gXCJhYmx5LXRyYW5zcG9ydC1wcmVmZXJlbmNlXCI7XG5mdW5jdGlvbiBidW5kbGVXaXRoKGRlc3QsIHNyYywgbWF4U2l6ZSkge1xuICBsZXQgYWN0aW9uO1xuICBpZiAoZGVzdC5jaGFubmVsICE9PSBzcmMuY2hhbm5lbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKGFjdGlvbiA9IGRlc3QuYWN0aW9uKSAhPT0gYWN0aW9uczIuUFJFU0VOQ0UgJiYgYWN0aW9uICE9PSBhY3Rpb25zMi5NRVNTQUdFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhY3Rpb24gIT09IHNyYy5hY3Rpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2luZCA9IGFjdGlvbiA9PT0gYWN0aW9uczIuUFJFU0VOQ0UgPyBcInByZXNlbmNlXCIgOiBcIm1lc3NhZ2VzXCIsIHByb3Bvc2VkID0gZGVzdFtraW5kXS5jb25jYXQoc3JjW2tpbmRdKSwgc2l6ZSA9IGdldE1lc3NhZ2VzU2l6ZShwcm9wb3NlZCk7XG4gIGlmIChzaXplID4gbWF4U2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWFsbFNhbWUocHJvcG9zZWQsIFwiY2xpZW50SWRcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFwcm9wb3NlZC5ldmVyeShmdW5jdGlvbihtc2cpIHtcbiAgICByZXR1cm4gIW1zZy5pZDtcbiAgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdFtraW5kXSA9IHByb3Bvc2VkO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlY29kZVJlY292ZXJ5S2V5KHJlY292ZXJ5S2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVjb3ZlcnlLZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbnZhciBUcmFuc3BvcnRQYXJhbXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGhvc3QsIG1vZGUsIGNvbm5lY3Rpb25LZXkpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uS2V5O1xuICAgIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICB9XG4gIGdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IGF1dGhQYXJhbXMgPyBjb3B5KGF1dGhQYXJhbXMpIDoge307XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgY2FzZSBcInJlc3VtZVwiOlxuICAgICAgICBwYXJhbXMucmVzdW1lID0gdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZWNvdmVyXCI6IHtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkob3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgIHBhcmFtcy5yZWNvdmVyID0gcmVjb3ZlcnlDb250ZXh0LmNvbm5lY3Rpb25LZXk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jbGllbnRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudElkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lY2hvTWVzc2FnZXMgPT09IGZhbHNlKSB7XG4gICAgICBwYXJhbXMuZWNobyA9IFwiZmFsc2VcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZm9ybWF0ICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyZWFtICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5zdHJlYW0gPSB0aGlzLnN0cmVhbTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0cyAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHRoaXMuaGVhcnRiZWF0cztcbiAgICB9XG4gICAgcGFyYW1zLnYgPSBkZWZhdWx0c19kZWZhdWx0LnByb3RvY29sVmVyc2lvbjtcbiAgICBwYXJhbXMuYWdlbnQgPSBnZXRBZ2VudFN0cmluZyh0aGlzLm9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyAhPT0gdm9pZCAwKSB7XG4gICAgICBtaXhpbihwYXJhbXMsIG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJbbW9kZT1cIiArIHRoaXMubW9kZTtcbiAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICByZXN1bHQgKz0gXCIsaG9zdD1cIiArIHRoaXMuaG9zdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgcmVzdWx0ICs9IFwiLGNvbm5lY3Rpb25LZXk9XCIgKyB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvcm1hdCkge1xuICAgICAgcmVzdWx0ICs9IFwiLGZvcm1hdD1cIiArIHRoaXMuZm9ybWF0O1xuICAgIH1cbiAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBDb25uZWN0aW9uTWFuYWdlciA9IGNsYXNzIF9Db25uZWN0aW9uTWFuYWdlciBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocmVhbHRpbWUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihyZWFsdGltZS5sb2dnZXIpO1xuICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0cyA9IHt9O1xuICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUgPSB7IGlzUHJvY2Vzc2luZzogZmFsc2UsIHF1ZXVlOiBbXSB9O1xuICAgIHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICB0aGlzLmluaXRUcmFuc3BvcnRzKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCB0aW1lb3V0cyA9IG9wdGlvbnMudGltZW91dHM7XG4gICAgY29uc3QgY29ubmVjdGluZ1RpbWVvdXQgPSB0aW1lb3V0cy53ZWJTb2NrZXRDb25uZWN0VGltZW91dCArIHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgdGhpcy5zdGF0ZXMgPSB7XG4gICAgICBpbml0aWFsaXplZDoge1xuICAgICAgICBzdGF0ZTogXCJpbml0aWFsaXplZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgY29ubmVjdGluZzoge1xuICAgICAgICBzdGF0ZTogXCJjb25uZWN0aW5nXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICByZXRyeURlbGF5OiBjb25uZWN0aW5nVGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgY29ubmVjdGVkOiB7XG4gICAgICAgIHN0YXRlOiBcImNvbm5lY3RlZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgc2VuZEV2ZW50czogdHJ1ZSxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgZGlzY29ubmVjdGVkOiB7XG4gICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMuZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0LFxuICAgICAgICBmYWlsU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBzdXNwZW5kZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwic3VzcGVuZGVkXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMuc3VzcGVuZGVkUmV0cnlUaW1lb3V0LFxuICAgICAgICBmYWlsU3RhdGU6IFwic3VzcGVuZGVkXCJcbiAgICAgIH0sXG4gICAgICBjbG9zaW5nOiB7XG4gICAgICAgIHN0YXRlOiBcImNsb3NpbmdcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LFxuICAgICAgICBmYWlsU3RhdGU6IFwiY2xvc2VkXCJcbiAgICAgIH0sXG4gICAgICBjbG9zZWQ6IHsgc3RhdGU6IFwiY2xvc2VkXCIsIHRlcm1pbmFsOiB0cnVlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6IFwiY2xvc2VkXCIgfSxcbiAgICAgIGZhaWxlZDogeyBzdGF0ZTogXCJmYWlsZWRcIiwgdGVybWluYWw6IHRydWUsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogXCJmYWlsZWRcIiB9XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMuaW5pdGlhbGl6ZWQ7XG4gICAgdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgdGhpcy5xdWV1ZWRNZXNzYWdlcyA9IG5ldyBtZXNzYWdlcXVldWVfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgIHRoaXMuY29ubmVjdGlvbkRldGFpbHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uSWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gdGltZW91dHMuY29ubmVjdGlvblN0YXRlVHRsO1xuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydHMgPSBpbnRlcnNlY3Qob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMsIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0cyk7XG4gICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcbiAgICBpZiAodGhpcy50cmFuc3BvcnRzLmluY2x1ZGVzKFRyYW5zcG9ydE5hbWVzLldlYlNvY2tldCkpIHtcbiAgICAgIHRoaXMud2ViU29ja2V0VHJhbnNwb3J0QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0cy5pbmNsdWRlcyhUcmFuc3BvcnROYW1lcy5YaHJQb2xsaW5nKSkge1xuICAgICAgdGhpcy5iYXNlVHJhbnNwb3J0ID0gVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZztcbiAgICB9IGVsc2UgaWYgKHRoaXMudHJhbnNwb3J0cy5pbmNsdWRlcyhUcmFuc3BvcnROYW1lcy5Db21ldCkpIHtcbiAgICAgIHRoaXMuYmFzZVRyYW5zcG9ydCA9IFRyYW5zcG9ydE5hbWVzLkNvbWV0O1xuICAgIH1cbiAgICB0aGlzLmh0dHBIb3N0cyA9IGRlZmF1bHRzX2RlZmF1bHQuZ2V0SG9zdHMob3B0aW9ucyk7XG4gICAgdGhpcy53c0hvc3RzID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhvcHRpb25zLCB0cnVlKTtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbnVsbDtcbiAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG4gICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIgPSAwO1xuICAgIHRoaXMud3NDaGVja1Jlc3VsdCA9IG51bGw7XG4gICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBudWxsO1xuICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gZmFsc2U7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLCBcInN0YXJ0ZWRcIik7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgIFwicmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbXCIgKyAob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMpICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImF2YWlsYWJsZSB0cmFuc3BvcnRzID0gW1wiICsgdGhpcy50cmFuc3BvcnRzICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImh0dHAgaG9zdHMgPSBbXCIgKyB0aGlzLmh0dHBIb3N0cyArIFwiXVwiXG4gICAgKTtcbiAgICBpZiAoIXRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwibm8gcmVxdWVzdGVkIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJyZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsIG1zZyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IFBsYXRmb3JtLkNvbmZpZy5hZGRFdmVudExpc3RlbmVyO1xuICAgIGlmIChhZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgdGhpcy5wZXJzaXN0Q29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgICAgICAgIFwiYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY2xvc2luZ1wiIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zdXNwZW5kZWQpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIgXFx1MjAxOG9ubGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwicmVhdHRlbXB0aW5nIGNvbm5lY3Rpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgKF9hMiA9IHRoaXMucGVuZGluZ1RyYW5zcG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vZmYoKTtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciBcXHUyMDE4b2ZmbGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwiZGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgLy8gVXNlZCBieSB0ZXN0c1xuICBzdGF0aWMgc3VwcG9ydGVkVHJhbnNwb3J0cyhhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHsgc3VwcG9ydGVkVHJhbnNwb3J0czoge30gfTtcbiAgICB0aGlzLmluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpO1xuICAgIHJldHVybiBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHM7XG4gIH1cbiAgc3RhdGljIGluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpIHtcbiAgICBjb25zdCBpbXBsZW1lbnRhdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgUGxhdGZvcm0uVHJhbnNwb3J0cy5idW5kbGVkSW1wbGVtZW50YXRpb25zKSwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucyk7XG4gICAgW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldCwgLi4uUGxhdGZvcm0uVHJhbnNwb3J0cy5vcmRlcl0uZm9yRWFjaCgodHJhbnNwb3J0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gaW1wbGVtZW50YXRpb25zW3RyYW5zcG9ydE5hbWVdO1xuICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHNbdHJhbnNwb3J0TmFtZV0gPSB0cmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW5pdFRyYW5zcG9ydHMoKSB7XG4gICAgX0Nvbm5lY3Rpb25NYW5hZ2VyLmluaXRUcmFuc3BvcnRzKHRoaXMucmVhbHRpbWUuX2FkZGl0aW9uYWxUcmFuc3BvcnRJbXBsZW1lbnRhdGlvbnMsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhob3N0LCBtb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xuICB9XG4gIGdldFRyYW5zcG9ydFBhcmFtcyhjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlY2lkZU1vZGUgPSAobW9kZUNiKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgIG1vZGVDYihcInJlc3VtZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVjb3ZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWNvdmVyRm4gPSB0aGlzLm9wdGlvbnMucmVjb3ZlciwgbGFzdFNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uUmVjb3ZlckRhdGEoKSwgc2Vzc2lvblJlY292ZXJ5TmFtZSA9IHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpO1xuICAgICAgaWYgKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YgcmVjb3ZlckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpXCIsXG4gICAgICAgICAgXCJDYWxsaW5nIGNsaWVudE9wdGlvbnMtcHJvdmlkZWQgcmVjb3ZlciBmdW5jdGlvbiB3aXRoIGxhc3Qgc2Vzc2lvbiBkYXRhIChyZWNvdmVyeSBzY29wZTogXCIgKyBzZXNzaW9uUmVjb3ZlcnlOYW1lICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmVjb3ZlckZuKGxhc3RTZXNzaW9uRGF0YSwgKHNob3VsZFJlY292ZXIpID0+IHtcbiAgICAgICAgICBpZiAoc2hvdWxkUmVjb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG4gICAgICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICB9O1xuICAgIGRlY2lkZU1vZGUoKG1vZGUpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydFBhcmFtcyA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKG51bGwsIG1vZGUpO1xuICAgICAgaWYgKG1vZGUgPT09IFwicmVjb3ZlclwiKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKVwiLFxuICAgICAgICAgIFwiVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSByZWNvdmVyOyByZWNvdmVyeUtleSA9IFwiICsgdGhpcy5vcHRpb25zLnJlY292ZXJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkodGhpcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5tc2dTZXJpYWwgPSByZWNvdmVyeUNvbnRleHQubXNnU2VyaWFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKClcIixcbiAgICAgICAgICBcIlRyYW5zcG9ydCBwYXJhbXMgPSBcIiArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh0cmFuc3BvcnRQYXJhbXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgYSBnaXZlbiB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgKiBAcGFyYW0gY2FuZGlkYXRlLCB0aGUgdHJhbnNwb3J0IHRvIHRyeVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpXCIsIFwidHJ5aW5nIFwiICsgY2FuZGlkYXRlKTtcbiAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0ID0gdHJhbnNwb3J0X2RlZmF1bHQudHJ5Q29ubmVjdChcbiAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0c1tjYW5kaWRhdGVdLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucmVhbHRpbWUuYXV0aCxcbiAgICAgIHRyYW5zcG9ydFBhcmFtcyxcbiAgICAgICh3cmFwcGVkRXJyLCB0cmFuc3BvcnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkKSB7XG4gICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgICAgICBcImNvbm5lY3Rpb24gXCIgKyBzdGF0ZS5zdGF0ZSArIFwiIHdoaWxlIHdlIHdlcmUgYXR0ZW1wdGluZyB0aGUgdHJhbnNwb3J0OyBjbG9zaW5nIFwiICsgdHJhbnNwb3J0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlZEVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KClcIixcbiAgICAgICAgICAgIFwidHJhbnNwb3J0IFwiICsgY2FuZGlkYXRlICsgXCIgXCIgKyB3cmFwcGVkRXJyLmV2ZW50ICsgXCIsIGVycjogXCIgKyB3cmFwcGVkRXJyLmVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih3cmFwcGVkRXJyLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gd3JhcHBlZEVyci5lcnJvcjtcbiAgICAgICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLnJlYWx0aW1lLmF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCksIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXRyaWFibGUod3JhcHBlZEVyci5lcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIGNhbmRpZGF0ZSArIFwiOyBzZXR0aW5nIHBlbmRpbmdcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGluZGljYXRlZCB0byBiZSB2aWFibGUsIGFuZCB0aGUgQ29ubmVjdGlvbk1hbmFnZXJcbiAgICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cbiAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAqL1xuICBzZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgY29uc3QgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQgKyBcIjsgbW9kZSA9IFwiICsgbW9kZVxuICAgICk7XG4gICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRyYW5zcG9ydC5vbmNlKFwiY29ubmVjdGVkXCIsIChlcnJvciwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgIGlmIChtb2RlID09PSBcInJlY292ZXJcIiAmJiB0aGlzLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnJlY292ZXI7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICB0cmFuc3BvcnQub24oW1wiZGlzY29ubmVjdGVkXCIsIFwiY2xvc2VkXCIsIFwiZmFpbGVkXCJdLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZjIuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnQucGVuZGluZ1wiLCB0cmFuc3BvcnQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXIgZGVjaWRlcyB0aGF0XG4gICAqIGl0IHdpbGwgbm93IGJlIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGFjdGl2YXRlZFxuICAgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0IHRoZSB0cmFuc3BvcnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCB0aGUgaWQgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKi9cbiAgYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0XG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIiwgXCJlcnJvciA9IFwiICsgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbklkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25JZCA9ICBcIiArIGNvbm5lY3Rpb25JZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25EZXRhaWxzID0gIFwiICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCk7XG4gICAgY29uc3QgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsIGNvbm5lY3RlZFN0YXRlID0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcImN1cnJlbnQgc3RhdGUgPSBcIiArIGV4aXN0aW5nU3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyB0cmFuc3BvcnQgYW5kIGFiYW5kb25pbmdcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQ7XG4gICAgaWYgKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydCArIFwiIHNpbmNlIGl0IGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIGNvbm5lY3RlZFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0FjdGl2ZVByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbDtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IHByb3RvY29sX2RlZmF1bHQodHJhbnNwb3J0KTtcbiAgICB0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG4gICAgY29uc3QgY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gICAgaWYgKGNvbm5lY3Rpb25LZXkgJiYgdGhpcy5jb25uZWN0aW9uS2V5ICE9IGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCAhIWVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cmFuc3BvcnQub24oXG4gICAgICAgIFwiY29ubmVjdGVkXCIsXG4gICAgICAgIChjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzMikgPT4ge1xuICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlsczIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGNvbm5lY3RlZEVycikpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3I7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGVkXCIsIGVycm9yIH0pO1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yIHx8IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5hY3RpdmVcIiwgdHJhbnNwb3J0KTtcbiAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgPiAwKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgICAgXCJQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIiwgbmV3IG9uZSBpcyBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIikgZmluaXNoaW5nIHdpdGggXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgXCIgbWVzc2FnZXMgc3RpbGwgcGVuZGluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkFzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCB3YXMgYWxzbyB0aGUgdHJhbnNwb3J0IGZvciB0aGUgcHJldmlvdXMgYWN0aXZlIHByb3RvY29sOyB0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIjsgc3RhY2sgPSBcIiArIG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsIG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLmZpbmlzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBUaGlzIGNhbiBvY2N1clxuICAgKiBpbiBhbnkgdHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICovXG4gIGRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCBzdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBjdXJyZW50UHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sLCB3YXNBY3RpdmUgPSBjdXJyZW50UHJvdG9jb2wgJiYgY3VycmVudFByb3RvY29sLmdldFRyYW5zcG9ydCgpID09PSB0cmFuc3BvcnQsIHdhc1BlbmRpbmcgPSB0cmFuc3BvcnQgPT09IHRoaXMucGVuZGluZ1RyYW5zcG9ydCwgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IHRoaXMubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnRcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwic3RhdGUgPSBcIiArIHN0YXRlICsgKHdhc0FjdGl2ZSA/IFwiOyB3YXMgYWN0aXZlXCIgOiB3YXNQZW5kaW5nID8gXCI7IHdhcyBwZW5kaW5nXCIgOiBcIlwiKSArIChub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID8gXCJcIiA6IFwiOyBhbm90aGVyIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb25cIilcbiAgICApO1xuICAgIGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlKVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcInJlYXNvbiA9ICBcIiArIGVycm9yLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgaWYgKHdhc0FjdGl2ZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcIkdldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nIFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArIFwiIHBlbmRpbmcgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcbiAgICAgIGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IHRoaXMuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5pbmFjdGl2ZVwiLCB0cmFuc3BvcnQpO1xuICAgIGlmICh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiB8fCB3YXNBY3RpdmUgJiYgc3RhdGUgPT09IFwiZmFpbGVkXCIgfHwgc3RhdGUgPT09IFwiY2xvc2VkXCIgfHwgY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiBlcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID4gNTAwICYmIHRoaXMuaHR0cEhvc3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGUsIGVycm9yLCByZXRyeUltbWVkaWF0ZWx5OiB0cnVlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDb25uZWN0aW9uU3RhdGUgPSBzdGF0ZSA9PT0gXCJmYWlsZWRcIiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihlcnJvcikgPyBcImRpc2Nvbm5lY3RlZFwiIDogc3RhdGU7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IG5ld0Nvbm5lY3Rpb25TdGF0ZSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIC8qIEhlbHBlciB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gdHJhbnNwb3J0cyB3aGljaCBhcmUgcGVuZGluZyxcbiAgICogaGF2ZSBiZWVuIGNvbm5lY3RlZCwgYW5kIGFyZSBqdXN0IHdhaXRpbmcgZm9yIG9uY2VOb1BlbmRpbmcgdG8gZmlyZSBiZWZvcmVcbiAgICogYmVpbmcgYWN0aXZhdGVkICovXG4gIG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLnBlbmRpbmdUcmFuc3BvcnQgfHwgIXRoaXMucGVuZGluZ1RyYW5zcG9ydC5pc0Nvbm5lY3RlZDtcbiAgfVxuICBzZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGhhc0Nvbm5lY3Rpb25FcnJvcikge1xuICAgIGNvbnN0IHByZXZDb25uSWQgPSB0aGlzLmNvbm5lY3Rpb25JZCwgY29ubklkQ2hhbmdlZCA9IHByZXZDb25uSWQgJiYgcHJldkNvbm5JZCAhPT0gY29ubmVjdGlvbklkLCByZWNvdmVyRmFpbHVyZSA9ICFwcmV2Q29ubklkICYmIGhhc0Nvbm5lY3Rpb25FcnJvcjtcbiAgICBpZiAoY29ubklkQ2hhbmdlZCB8fCByZWNvdmVyRmFpbHVyZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpXCIsIFwiUmVzZXR0aW5nIG1zZ1NlcmlhbFwiKTtcbiAgICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucmVzZXRTZW5kQXR0ZW1wdGVkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZCAhPT0gY29ubmVjdGlvbklkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpXCIsXG4gICAgICAgIFwiTmV3IGNvbm5lY3Rpb25JZDsgcmVhdHRhY2hpbmcgYW55IGF0dGFjaGVkIGNoYW5uZWxzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xuICB9XG4gIGNsZWFyQ29ubmVjdGlvbigpIHtcbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICB0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgfVxuICBjcmVhdGVSZWNvdmVyeUtleSgpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG4gICAgICBtc2dTZXJpYWw6IHRoaXMubXNnU2VyaWFsLFxuICAgICAgY2hhbm5lbFNlcmlhbHM6IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuY2hhbm5lbFNlcmlhbHMoKVxuICAgIH0pO1xuICB9XG4gIGNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCkge1xuICAgIGlmICghdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpbmNlTGFzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICBpZiAoc2luY2VMYXN0ID4gdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgKyB0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKClcIixcbiAgICAgICAgXCJMYXN0IGtub3duIGFjdGl2aXR5IGZyb20gcmVhbHRpbWUgd2FzIFwiICsgc2luY2VMYXN0ICsgXCJtcyBhZ287IGRpc2NhcmRpbmcgY29ubmVjdGlvbiBzdGF0ZVwiXG4gICAgICApO1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gXCJzdXNwZW5kZWRcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgKi9cbiAgcGVyc2lzdENvbm5lY3Rpb24oKSB7XG4gICAgaWYgKGhhdmVTZXNzaW9uU3RvcmFnZSgpKSB7XG4gICAgICBjb25zdCByZWNvdmVyeUtleSA9IHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICAgIGlmIChyZWNvdmVyeUtleSkge1xuICAgICAgICB0aGlzLnNldFNlc3Npb25SZWNvdmVyRGF0YSh7XG4gICAgICAgICAgcmVjb3ZlcnlLZXksXG4gICAgICAgICAgZGlzY29ubmVjdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgbG9jYXRpb246IGdsb2JhbE9iamVjdDIubG9jYXRpb24sXG4gICAgICAgICAgY2xpZW50SWQ6IHRoaXMucmVhbHRpbWUuYXV0aC5jbGllbnRJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgKi9cbiAgdW5wZXJzaXN0Q29ubmVjdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCk7XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgKiBzdGF0ZSBtYW5hZ2VtZW50XG4gICAqKioqKioqKioqKioqKioqKioqKiovXG4gIGdldEVycm9yKCkge1xuICAgIGlmICh0aGlzLmVycm9yUmVhc29uKSB7XG4gICAgICBjb25zdCBuZXdFcnJvciA9IFBhcnRpYWxFcnJvckluZm8uZnJvbVZhbHVlcyh0aGlzLmVycm9yUmVhc29uKTtcbiAgICAgIG5ld0Vycm9yLmNhdXNlID0gdGhpcy5lcnJvclJlYXNvbjtcbiAgICAgIHJldHVybiBuZXdFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVFcnJvcigpO1xuICB9XG4gIGdldFN0YXRlRXJyb3IoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYTIgPSBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQpW3RoaXMuc3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpO1xuICB9XG4gIGFjdGl2ZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzIHx8IHRoaXMuc3RhdGUuc2VuZEV2ZW50cztcbiAgfVxuICBlbmFjdFN0YXRlQ2hhbmdlKHN0YXRlQ2hhbmdlKSB7XG4gICAgY29uc3QgYWN0aW9uID0gXCJDb25uZWN0aW9uIHN0YXRlXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAoc3RhdGVDaGFuZ2UucmVhc29uID8gXCI7IHJlYXNvbjogXCIgKyBzdGF0ZUNoYW5nZS5yZWFzb24gOiBcIlwiKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZW5hY3RTdGF0ZUNoYW5nZVwiLFxuICAgICAgXCJzZXR0aW5nIG5ldyBzdGF0ZTogXCIgKyBzdGF0ZUNoYW5nZS5jdXJyZW50ICsgXCI7IHJlYXNvbiA9IFwiICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiAmJiBzdGF0ZUNoYW5nZS5yZWFzb24ubWVzc2FnZSlcbiAgICApO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlQ2hhbmdlLmN1cnJlbnRdO1xuICAgIGlmIChzdGF0ZUNoYW5nZS5yZWFzb24pIHtcbiAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgfVxuICAgIGlmIChuZXdTdGF0ZS50ZXJtaW5hbCB8fCBuZXdTdGF0ZS5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbnN0YXRlXCIsIHN0YXRlQ2hhbmdlKTtcbiAgfVxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBDb25uZWN0aW9uTWFuYWdlciBjb25uZWN0aW9uIGxpZmVjeWNsZVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgc3RhcnRUcmFuc2l0aW9uVGltZXIodHJhbnNpdGlvblN0YXRlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKClcIixcbiAgICAgIFwidHJhbnNpdGlvblN0YXRlOiBcIiArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZVxuICAgICk7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKVwiLFxuICAgICAgICBcImNsZWFyaW5nIGFscmVhZHktcnVubmluZyB0aW1lclwiXG4gICAgICApO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBcIiArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSArIFwiIHRpbWVyIGV4cGlyZWRcIixcbiAgICAgICAgICBcInJlcXVlc3RpbmcgbmV3IHN0YXRlOiBcIiArIHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlIH0pO1xuICAgICAgfVxuICAgIH0sIHRyYW5zaXRpb25TdGF0ZS5yZXRyeURlbGF5KTtcbiAgfVxuICBjYW5jZWxUcmFuc2l0aW9uVGltZXIoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2FuY2VsVHJhbnNpdGlvblRpbWVyKClcIiwgXCJcIik7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFN1c3BlbmRUaW1lcigpIHtcbiAgICBpZiAodGhpcy5zdXNwZW5kVGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgICB0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWRcIixcbiAgICAgICAgICBcInJlcXVlc3RpbmcgbmV3IHN0YXRlOiBzdXNwZW5kZWRcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwic3VzcGVuZGVkXCI7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJzdXNwZW5kZWRcIiB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG4gIH1cbiAgY2hlY2tTdXNwZW5kVGltZXIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgIT09IFwiZGlzY29ubmVjdGVkXCIgJiYgc3RhdGUgIT09IFwic3VzcGVuZGVkXCIgJiYgc3RhdGUgIT09IFwiY29ubmVjdGluZ1wiKVxuICAgICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgfVxuICBjYW5jZWxTdXNwZW5kVGltZXIoKSB7XG4gICAgdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3VzcGVuZFRpbWVyKTtcbiAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKGludGVydmFsKSB7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlciByZXRyeSB0aW1lciBleHBpcmVkXCIsIFwicmV0cnlpbmdcIik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFdlYlNvY2tldFNsb3dUaW1lcigpIHtcbiAgICB0aGlzLndlYlNvY2tldFNsb3dUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgIFwiY2hlY2tpbmcgY29ubmVjdGl2aXR5XCJcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy53c0NoZWNrUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hlY2tXc0Nvbm5lY3Rpdml0eSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgXCJ3cyBjb25uZWN0aXZpdHkgY2hlY2sgc3VjY2VlZGVkXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMud3NDaGVja1Jlc3VsdCA9IHRydWU7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgICAgIFwid3MgY29ubmVjdGl2aXR5IGNoZWNrIGZhaWxlZFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFsdGltZS5odHRwLmNoZWNrQ29ubmVjdGl2aXR5KSB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKSwgKGVyciwgY29ubmVjdGl2aXR5KSA9PiB7XG4gICAgICAgICAgaWYgKGVyciB8fCAhY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgICAgICAgXCJodHRwIGNvbm5lY3Rpdml0eSBjaGVjayBmYWlsZWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0R2l2ZVVwVGltZXIoKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoe1xuICAgICAgICAgICAgICBzdGF0ZTogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gY29ubmVjdCAobmV0d29yayB1bnJlYWNoYWJsZSlcIiwgODAwMDMsIDQwNClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgV2ViU29ja2V0IHNsb3cgdGltZXJcIixcbiAgICAgICAgICAgICAgXCJodHRwIGNvbm5lY3Rpdml0eSBjaGVjayBzdWNjZWVkZWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy53ZWJTb2NrZXRTbG93VGltZW91dCk7XG4gIH1cbiAgY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCkge1xuICAgIGlmICh0aGlzLndlYlNvY2tldFNsb3dUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2ViU29ja2V0U2xvd1RpbWVyKTtcbiAgICAgIHRoaXMud2ViU29ja2V0U2xvd1RpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRXZWJTb2NrZXRHaXZlVXBUaW1lcih0cmFuc3BvcnRQYXJhbXMpIHtcbiAgICB0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjtcbiAgICAgIGlmICghdGhpcy53c0NoZWNrUmVzdWx0KSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgZ2l2ZSB1cCB0aW1lclwiLFxuICAgICAgICAgIFwid2Vic29ja2V0IGNvbm5lY3Rpb24gdG9vayBtb3JlIHRoYW4gMTBzOyBcIiArICh0aGlzLmJhc2VUcmFuc3BvcnQgPyBcInRyeWluZyBiYXNlIHRyYW5zcG9ydFwiIDogXCJcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVRyYW5zcG9ydCkge1xuICAgICAgICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gdHJ1ZTtcbiAgICAgICAgICAoX2EyID0gdGhpcy5wcm9wb3NlZFRyYW5zcG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kaXNwb3NlKCk7XG4gICAgICAgICAgKF9iID0gdGhpcy5wZW5kaW5nVHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2IuZGlzcG9zZSgpO1xuICAgICAgICAgIHRoaXMuY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCArK3RoaXMuY29ubmVjdENvdW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgZ2l2ZSB1cCB0aW1lclwiLFxuICAgICAgICAgICAgXCJ3ZWJzb2NrZXQgY29ubmVjdGl2aXR5IGFwcGVhcnMgdG8gYmUgdW5hdmFpbGFibGUgYnV0IG5vIG90aGVyIHRyYW5zcG9ydHMgdG8gdHJ5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLndlYlNvY2tldENvbm5lY3RUaW1lb3V0KTtcbiAgfVxuICBjYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpIHtcbiAgICBpZiAodGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIpO1xuICAgICAgdGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIG5vdGlmeVN0YXRlKGluZGljYXRlZCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGNvbnN0IHN0YXRlID0gaW5kaWNhdGVkLnN0YXRlO1xuICAgIGNvbnN0IHJldHJ5SW1tZWRpYXRlbHkgPSBzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkIHx8IGluZGljYXRlZC5yZXRyeUltbWVkaWF0ZWx5IHx8IHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcgJiYgaW5kaWNhdGVkLmVycm9yICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKGluZGljYXRlZC5lcnJvcikgJiYgISh0aGlzLmVycm9yUmVhc29uICYmIGF1dGhfZGVmYXVsdC5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKClcIixcbiAgICAgIFwibmV3IHN0YXRlOiBcIiArIHN0YXRlICsgKHJldHJ5SW1tZWRpYXRlbHkgPyBcIjsgd2lsbCByZXRyeSBjb25uZWN0aW9uIGltbWVkaWF0ZWx5XCIgOiBcIlwiKVxuICAgICk7XG4gICAgaWYgKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFdlYlNvY2tldFNsb3dUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0R2l2ZVVwVGltZXIoKTtcbiAgICB0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKGluZGljYXRlZC5zdGF0ZSk7XG4gICAgaWYgKHN0YXRlID09PSBcInN1c3BlbmRlZFwiIHx8IHN0YXRlID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQgPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZS50ZXJtaW5hbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW2luZGljYXRlZC5zdGF0ZV07XG4gICAgbGV0IHJldHJ5RGVsYXkgPSBuZXdTdGF0ZS5yZXRyeURlbGF5O1xuICAgIGlmIChuZXdTdGF0ZS5zdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIikge1xuICAgICAgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50Kys7XG4gICAgICByZXRyeURlbGF5ID0gZ2V0UmV0cnlUaW1lKG5ld1N0YXRlLnJldHJ5RGVsYXksIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZSA9IG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChcbiAgICAgIHRoaXMuc3RhdGUuc3RhdGUsXG4gICAgICBuZXdTdGF0ZS5zdGF0ZSxcbiAgICAgIHJldHJ5RGVsYXksXG4gICAgICBpbmRpY2F0ZWQuZXJyb3IgfHwgKChfYiA9IChfYTIgPSBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQpW25ld1N0YXRlLnN0YXRlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyKSlcbiAgICApO1xuICAgIGlmIChyZXRyeUltbWVkaWF0ZWx5KSB7XG4gICAgICBjb25zdCBhdXRvUmVjb25uZWN0ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGluZ1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2luY2VMYXN0ID0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgJiYgRGF0ZS5ub3coKSAtIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICsgMTtcbiAgICAgIGlmIChzaW5jZUxhc3QgJiYgc2luY2VMYXN0IDwgMWUzKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpXCIsXG4gICAgICAgICAgXCJMYXN0IHJlY29ubmVjdCBhdHRlbXB0IHdhcyBvbmx5IFwiICsgc2luY2VMYXN0ICsgXCJtcyBhZ28sIHdhaXRpbmcgYW5vdGhlciBcIiArICgxZTMgLSBzaW5jZUxhc3QpICsgXCJtcyBiZWZvcmUgdHJ5aW5nIGFnYWluXCJcbiAgICAgICAgKTtcbiAgICAgICAgc2V0VGltZW91dChhdXRvUmVjb25uZWN0LCAxZTMgLSBzaW5jZUxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKGF1dG9SZWNvbm5lY3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFwiZGlzY29ubmVjdGVkXCIgfHwgc3RhdGUgPT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICAgIHRoaXMuc3RhcnRSZXRyeVRpbWVyKHJldHJ5RGVsYXkpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwiZGlzY29ubmVjdGVkXCIgJiYgIXJldHJ5SW1tZWRpYXRlbHkgfHwgc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgfHwgbmV3U3RhdGUudGVybWluYWwpIHtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT0gXCJjb25uZWN0ZWRcIiAmJiAhdGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKClcIixcbiAgICAgICAgXCJCcm9rZW4gaW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gZ28gaW50byBjb25uZWN0ZWQgc3RhdGUsIGJ1dCB0aGVyZSBpcyBubyBhY3RpdmUgcHJvdG9jb2xcIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG4gICAgaWYgKHRoaXMuc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgdGhpcy5zZW5kUXVldWVkTWVzc2FnZXMoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzKSB7XG4gICAgICB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnByb3BvZ2F0ZUNvbm5lY3Rpb25JbnRlcnJ1cHRpb24oc3RhdGUsIGNoYW5nZS5yZWFzb24pO1xuICAgICAgdGhpcy5mYWlsUXVldWVkTWVzc2FnZXMoY2hhbmdlLnJlYXNvbik7XG4gICAgfVxuICB9XG4gIHJlcXVlc3RTdGF0ZShyZXF1ZXN0KSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3Qgc3RhdGUgPSByZXF1ZXN0LnN0YXRlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoKVwiLFxuICAgICAgXCJyZXF1ZXN0ZWQgc3RhdGU6IFwiICsgc3RhdGUgKyBcIjsgY3VycmVudCBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlLnN0YXRlXG4gICAgKTtcbiAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNhbmNlbFdlYlNvY2tldFNsb3dUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0R2l2ZVVwVGltZXIoKTtcbiAgICB0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuICAgIHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoc3RhdGUpO1xuICAgIGlmIChzdGF0ZSA9PSBcImNvbm5lY3RpbmdcIiAmJiB0aGlzLnN0YXRlLnN0YXRlID09IFwiY29ubmVjdGVkXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHN0YXRlID09IFwiY2xvc2luZ1wiICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gXCJjbG9zZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlXSwgY2hhbmdlID0gbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0KFxuICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSxcbiAgICAgIG5ld1N0YXRlLnN0YXRlLFxuICAgICAgbnVsbCxcbiAgICAgIHJlcXVlc3QuZXJyb3IgfHwgKChfYiA9IChfYTIgPSBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQpW25ld1N0YXRlLnN0YXRlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyKSlcbiAgICApO1xuICAgIHRoaXMuZW5hY3RTdGF0ZUNoYW5nZShjaGFuZ2UpO1xuICAgIGlmIChzdGF0ZSA9PSBcImNvbm5lY3RpbmdcIikge1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT0gXCJjbG9zaW5nXCIpIHtcbiAgICAgIHRoaXMuY2xvc2VJbXBsKCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0Q29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpXCIsXG4gICAgICAgIFwiTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QsIGJ1dCB3YXMgXCIgKyB0aGlzLnN0YXRlLnN0YXRlXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdXRoID0gdGhpcy5yZWFsdGltZS5hdXRoO1xuICAgIGNvbnN0IGNvbm5lY3RDb3VudCA9ICsrdGhpcy5jb25uZWN0Q291bnRlcjtcbiAgICBjb25zdCBjb25uZWN0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpO1xuICAgICAgdGhpcy5nZXRUcmFuc3BvcnRQYXJhbXMoKHRyYW5zcG9ydFBhcmFtcykgPT4ge1xuICAgICAgICBpZiAodHJhbnNwb3J0UGFyYW1zLm1vZGUgPT09IFwicmVjb3ZlclwiICYmIHRyYW5zcG9ydFBhcmFtcy5vcHRpb25zLnJlY292ZXIpIHtcbiAgICAgICAgICBjb25zdCByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleSh0cmFuc3BvcnRQYXJhbXMub3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnJlY292ZXJDaGFubmVscyhyZWNvdmVyeUNvbnRleHQuY2hhbm5lbFNlcmlhbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSB0aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKVwiLCBcInN0YXJ0aW5nIGNvbm5lY3Rpb25cIik7XG4gICAgdGhpcy5zdGFydFN1c3BlbmRUaW1lcigpO1xuICAgIHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY29ubmVjdGluZyk7XG4gICAgaWYgKGF1dGgubWV0aG9kID09PSBcImJhc2ljXCIpIHtcbiAgICAgIGNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXV0aENiID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSB0aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpIHtcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKGF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCksIGF1dGhDYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoYXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UpLCBhdXRoQ2IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKlxuICAgKiB0aGVyZSBhcmUsIGF0IG1vc3QsIHR3byB0cmFuc3BvcnRzIGF2YWlsYWJsZSB3aXRoIHdoaWNoIGEgY29ubmVjdGlvbiBtYXlcbiAgICogYmUgYXR0ZW1wdGVkOiB3ZWJfc29ja2V0IGFuZC9vciBhIGJhc2UgdHJhbnNwb3J0ICh4aHJfcG9sbGluZyBpbiBicm93c2VycyxcbiAgICogY29tZXQgaW4gbm9kZWpzKS4gd2ViX3NvY2tldCBpcyBhbHdheXMgcHJlZmVycmVkLCBhbmQgdGhlIGJhc2UgdHJhbnNwb3J0IGlzXG4gICAqIG9ubHkgdXNlZCBpbiBjYXNlIHdlYl9zb2NrZXQgY29ubmVjdGl2aXR5IGFwcGVhcnMgdG8gYmUgdW5hdmFpbGFibGUuXG4gICAqXG4gICAqIGNvbm5lY3RJbXBsIGJlZ2lucyB0aGUgdHJhbnNwb3J0IHNlbGVjdGlvbiBwcm9jZXNzIGJ5IGNoZWNraW5nIHdoaWNoIHRyYW5zcG9ydHNcbiAgICogYXJlIGF2YWlsYWJsZSwgYW5kIGlmIHRoZXJlIGlzIGEgY2FjaGVkIHByZWZlcmVuY2UuIEl0IHRoZW4gZGVmZXJzIHRvIHRoZVxuICAgKiB0cmFuc3BvcnQtc3BlY2lmaWMgY29ubmVjdCBtZXRob2RzOiBjb25uZWN0V3MgYW5kIGNvbm5lY3RCYXNlLlxuICAgKlxuICAgKiBJdCBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBpbnZhbGlkYXRpbmcgdGhlIGNhY2hlIGluIHRoZSBjYXNlIHRoYXQgYSBiYXNlXG4gICAqIHRyYW5zcG9ydCBwcmVmZXJlbmNlIGlzIHN0b3JlZCBidXQgd2ViIHNvY2tldCBjb25uZWN0aXZpdHkgaXMgbm93IGF2YWlsYWJsZS5cbiAgICpcbiAgICogaGFuZGxpbmcgb2YgdGhlIGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBmYWlsb3ZlciBmcm9tIHdlYl9zb2NrZXQgdG8gdGhlIGJhc2VcbiAgICogdHJhbnNwb3J0IGlzIGltcGxlbWVudGVkIGluIHRoZSBjb25uZWN0V3MgbWV0aG9kLlxuICAgKi9cbiAgY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuc3RhdGU7XG4gICAgaWYgKHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnN0YXRlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEltcGwoKVwiLFxuICAgICAgICBcIk11c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0LCBidXQgd2FzIFwiICsgc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zcG9ydFByZWZlcmVuY2UgPSB0aGlzLmdldFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICBpZiAodHJhbnNwb3J0UHJlZmVyZW5jZSAmJiB0cmFuc3BvcnRQcmVmZXJlbmNlID09PSB0aGlzLmJhc2VUcmFuc3BvcnQgJiYgdGhpcy53ZWJTb2NrZXRUcmFuc3BvcnRBdmFpbGFibGUpIHtcbiAgICAgIHRoaXMuY2hlY2tXc0Nvbm5lY3Rpdml0eSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLndzQ2hlY2tSZXN1bHQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFiYW5kb25lZFdlYlNvY2tldCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEltcGwoKTpcIixcbiAgICAgICAgICAgIFwid2ViIHNvY2tldCBjb25uZWN0aXZpdHkgYXZhaWxhYmxlLCBjYW5jZWxsaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdCB3aXRoIFwiICsgdGhpcy5iYXNlVHJhbnNwb3J0XG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgdGhpcy5jb25uZWN0V3ModHJhbnNwb3J0UGFyYW1zLCArK3RoaXMuY29ubmVjdENvdW50ZXIpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChub29wKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zcG9ydFByZWZlcmVuY2UgJiYgdHJhbnNwb3J0UHJlZmVyZW5jZSA9PT0gdGhpcy5iYXNlVHJhbnNwb3J0IHx8IHRoaXMuYmFzZVRyYW5zcG9ydCAmJiAhdGhpcy53ZWJTb2NrZXRUcmFuc3BvcnRBdmFpbGFibGUpIHtcbiAgICAgIHRoaXMuY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbm5lY3RXcyh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIGNvbm5lY3RXcyBzdGFydHMgdHdvIHRpbWVycyB0byBtb25pdG9yIHRoZSBzdWNjZXNzIG9mIGEgd2ViX3NvY2tldCBjb25uZWN0aW9uIGF0dGVtcHQ6XG4gICAqIC0gd2ViU29ja2V0U2xvd1RpbWVyOiBpZiB0aGlzIHRpbWVyIGZpcmVzIGJlZm9yZSB0aGUgY29ubmVjdGlvbiBzdWNjZWVkcyxcbiAgICogICBjbSB3aWxsIHNpbXVsdGFuZW91c2x5IGNoZWNrIHdlYnNvY2tldCBhbmQgaHR0cC94aHIgY29ubmVjdGl2aXR5LiBpZiB0aGUgaHR0cFxuICAgKiAgIGNvbm5lY3Rpdml0eSBjaGVjayBmYWlscywgd2UgZ2l2ZSB1cCB0aGUgY29ubmVjdGlvbiBzZXF1ZW5jZSBlbnRpcmVseSBhbmRcbiAgICogICB0cmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZC4gaWYgdGhlIHdlYnNvY2tldCBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbHMgdGhlblxuICAgKiAgIHdlIGFzc3VtZSBubyB3cyBjb25uZWN0aXZpdHkgYW5kIGZhaWxvdmVyIHRvIGJhc2UgdHJhbnNwb3J0LiBpbiB0aGUgY2FzZSB0aGF0XG4gICAqICAgdGhlIGNoZWNrcyBzdWNjZWVkLCB3ZSBjb250aW51ZSB3aXRoIHdlYnNvY2tldCBhbmQgd2FpdCBmb3IgaXQgdG8gdHJ5IGZhbGxiYWNrIGhvc3RzXG4gICAqICAgYW5kLCBpZiB1bnN1Y2Nlc3NmdWwsIHVsdGltYXRlbHkgdHJhbnNpdGlvbiB0byBkaXNjb25uZWN0ZWQuXG4gICAqIC0gd2ViU29ja2V0R2l2ZVVwVGltZXI6IGlmIHRoaXMgdGltZXIgZmlyZXMsIGFuZCB0aGUgcHJlY2VkaW5nIHdlYnNvY2tldFxuICAgKiAgIGNvbm5lY3Rpdml0eSBjaGVjayBpcyBzdGlsbCBwZW5kaW5nIHRoZW4gd2UgYXNzdW1lIHRoYXQgdGhlcmUgaXMgYW4gaXNzdWVcbiAgICogICB3aXRoIHRoZSB0cmFuc3BvcnQgYW5kIGZhbGxiYWNrIHRvIGJhc2UgdHJhbnNwb3J0LlxuICAgKi9cbiAgY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFdzKClcIik7XG4gICAgdGhpcy5zdGFydFdlYlNvY2tldFNsb3dUaW1lcigpO1xuICAgIHRoaXMuc3RhcnRXZWJTb2NrZXRHaXZlVXBUaW1lcih0cmFuc3BvcnRQYXJhbXMpO1xuICAgIHRoaXMudHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyhcIndlYl9zb2NrZXRcIiwgdHJhbnNwb3J0UGFyYW1zLCB0cnVlLCBjb25uZWN0Q291bnQsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLndzQ2hlY2tSZXN1bHQgIT09IGZhbHNlICYmICF0aGlzLmFiYW5kb25lZFdlYlNvY2tldDtcbiAgICB9KTtcbiAgfVxuICBjb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RCYXNlKClcIik7XG4gICAgaWYgKHRoaXMuYmFzZVRyYW5zcG9ydCkge1xuICAgICAgdGhpcy50cnlUcmFuc3BvcnRXaXRoRmFsbGJhY2tzKHRoaXMuYmFzZVRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zLCBmYWxzZSwgY29ubmVjdENvdW50LCAoKSA9PiB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7XG4gICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcIk5vIHRyYW5zcG9ydHMgbGVmdCB0byB0cnlcIiwgOGU0LCA0MDQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyh0cmFuc3BvcnROYW1lLCB0cmFuc3BvcnRQYXJhbXMsIHdzLCBjb25uZWN0Q291bnQsIHNob3VsZENvbnRpbnVlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3MoKVwiLFxuICAgICAgdHJhbnNwb3J0TmFtZVxuICAgICk7XG4gICAgY29uc3QgZ2l2ZVVwID0gKGVycikgPT4ge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IGVyciB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbmRpZGF0ZUhvc3RzID0gd3MgPyB0aGlzLndzSG9zdHMuc2xpY2UoKSA6IHRoaXMuaHR0cEhvc3RzLnNsaWNlKCk7XG4gICAgY29uc3QgaG9zdEF0dGVtcHRDYiA9IChmYXRhbCwgdHJhbnNwb3J0KSA9PiB7XG4gICAgICBpZiAoY29ubmVjdENvdW50ICE9PSB0aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghc2hvdWxkQ29udGludWUoKSkge1xuICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcbiAgICAgICAgdHJ5RmFsbGJhY2tIb3N0cygpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChubyBhdmFpbGFibGUgaG9zdClcIiwgODAwMDMsIDQwNCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IGhvc3Q7XG4gICAgY29uc3QgdHJ5RmFsbGJhY2tIb3N0cyA9ICgpID0+IHtcbiAgICAgIGlmICghY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgIGdpdmVVcChuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKGFuZCBubyBtb3JlIGZhbGxiYWNrIGhvc3RzIHRvIHRyeSlcIiwgODAwMDMsIDQwNCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSkge1xuICAgICAgICBnaXZlVXAobmV3IFBhcnRpYWxFcnJvckluZm8oXCJJbnRlcm5hbCBlcnJvcjogSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSBub3Qgc2V0XCIsIG51bGwsIDUwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICAgIHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpLFxuICAgICAgICAoZXJyLCBjb25uZWN0aXZpdHkpID0+IHtcbiAgICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSB0aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2hvdWxkQ29udGludWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBnaXZlVXAoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGdpdmVVcChuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGNvbm5lY3QgKG5ldHdvcmsgdW5yZWFjaGFibGUpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBhcnJQb3BSYW5kb21FbGVtZW50KGNhbmRpZGF0ZUhvc3RzKTtcbiAgICAgICAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnROYW1lLCBob3N0QXR0ZW1wdENiKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgICAgdHJ5RmFsbGJhY2tIb3N0cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnROYW1lLCBob3N0QXR0ZW1wdENiKTtcbiAgfVxuICBjbG9zZUltcGwoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIiwgXCJjbG9zaW5nIGNvbm5lY3Rpb25cIik7XG4gICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgICB0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNsb3NpbmcpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdUcmFuc3BvcnQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKVwiLFxuICAgICAgICBcIkNsb3NpbmcgcGVuZGluZyB0cmFuc3BvcnQ6IFwiICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0XG4gICAgICApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIixcbiAgICAgICAgXCJDbG9zaW5nIGFjdGl2ZSB0cmFuc3BvcnQ6IFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImNsb3NlZFwiIH0pO1xuICB9XG4gIG9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzLCBjYWxsYmFjaykge1xuICAgIHZhciBfYTI7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdGVkXCI6IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiU2VuZGluZyBBVVRIIG1lc3NhZ2Ugb24gYWN0aXZlIHRyYW5zcG9ydFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRyYW5zcG9ydCA9IChfYTIgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYW5zcG9ydCgpO1xuICAgICAgICBpZiAoYWN0aXZlVHJhbnNwb3J0ICYmIGFjdGl2ZVRyYW5zcG9ydC5vbkF1dGhVcGRhdGVkKSB7XG4gICAgICAgICAgYWN0aXZlVHJhbnNwb3J0Lm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoTXNnID0gZnJvbVZhbHVlczMoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uczIuQVVUSCxcbiAgICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICBhY2Nlc3NUb2tlbjogdG9rZW5EZXRhaWxzLnRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kKGF1dGhNc2cpO1xuICAgICAgICBjb25zdCBzdWNjZXNzTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmYWlsdXJlTGlzdGVuZXIgPSAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgICAgdGhpcy5vZmYoc3VjY2Vzc0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKGZhaWx1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgICBjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgdGhpcy5nZXRTdGF0ZUVycm9yKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbmNlKFwiY29ubmVjdGlvbmRldGFpbHNcIiwgc3VjY2Vzc0xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5vbihcImNvbm5lY3Rpb25zdGF0ZVwiLCBmYWlsdXJlTGlzdGVuZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKClcIixcbiAgICAgICAgICBcIkFib3J0aW5nIGN1cnJlbnQgY29ubmVjdGlvbiBhdHRlbXB0cyBpbiBvcmRlciB0byBzdGFydCBhZ2FpbiB3aXRoIHRoZSBuZXcgYXV0aCBkZXRhaWxzXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpXCIsXG4gICAgICAgICAgXCJDb25uZWN0aW9uIHN0YXRlIGlzIFwiICsgdGhpcy5zdGF0ZS5zdGF0ZSArIFwiOyB3YWl0aW5nIHVudGlsIGVpdGhlciBjb25uZWN0ZWQgb3IgZmFpbGVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKHN0YXRlQ2hhbmdlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjb25uZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhpcy5vZmYobGlzdGVuZXIpO1xuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjbG9zZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgICAgICAgdGhpcy5vZmYobGlzdGVuZXIpO1xuICAgICAgICAgICAgICBjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgdGhpcy5nZXRTdGF0ZUVycm9yKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbihcImNvbm5lY3Rpb25zdGF0ZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXRlID09PSBcImNvbm5lY3RpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgIFwiRGlzY29ubmVjdGluZyBhbGwgdHJhbnNwb3J0c1wiXG4gICAgKTtcbiAgICB0aGlzLmNvbm5lY3RDb3VudGVyKys7XG4gICAgaWYgKHRoaXMucGVuZGluZ1RyYW5zcG9ydCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIHBlbmRpbmcgdHJhbnNwb3J0OiBcIiArIHRoaXMucGVuZGluZ1RyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQ7XG4gICAgaWYgKHRoaXMucHJvcG9zZWRUcmFuc3BvcnQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyBwcm9wb3NlZCB0cmFuc3BvcnQ6IFwiICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0XG4gICAgICApO1xuICAgICAgdGhpcy5wcm9wb3NlZFRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQ7XG4gICAgaWYgKHRoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0OiBcIiArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KClcbiAgICAgICk7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKlxuICAgKiBldmVudCBxdWV1ZWluZ1xuICAgKioqKioqKioqKioqKioqKioqL1xuICBzZW5kKG1zZywgcXVldWVFdmVudCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kKClcIiwgXCJzZW5kaW5nIGV2ZW50XCIpO1xuICAgICAgdGhpcy5zZW5kSW1wbChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRRdWV1ZSA9IHF1ZXVlRXZlbnQgJiYgc3RhdGUucXVldWVFdmVudHM7XG4gICAgaWYgKCFzaG91bGRRdWV1ZSkge1xuICAgICAgY29uc3QgZXJyID0gXCJyZWplY3RpbmcgZXZlbnQsIHF1ZXVlRXZlbnQgd2FzIFwiICsgcXVldWVFdmVudCArIFwiLCBzdGF0ZSB3YXMgXCIgKyBzdGF0ZS5zdGF0ZTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKVwiLCBlcnIpO1xuICAgICAgY2FsbGJhY2sodGhpcy5lcnJvclJlYXNvbiB8fCBuZXcgRXJyb3JJbmZvKGVyciwgOWU0LCA0MDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpXCIsXG4gICAgICAgIFwicXVldWVpbmcgbXNnOyBcIiArIHN0cmluZ2lmeShtc2csIHRoaXMucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlKG1zZywgY2FsbGJhY2spO1xuICB9XG4gIHNlbmRJbXBsKHBlbmRpbmdNZXNzYWdlKSB7XG4gICAgY29uc3QgbXNnID0gcGVuZGluZ01lc3NhZ2UubWVzc2FnZTtcbiAgICBpZiAocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQgJiYgIXBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQpIHtcbiAgICAgIG1zZy5tc2dTZXJpYWwgPSB0aGlzLm1zZ1NlcmlhbCsrO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5zZW5kKHBlbmRpbmdNZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZEltcGwoKVwiLFxuICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGluIHRyYW5zcG9ydC5zZW5kKCk6IFwiICsgZS5zdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcXVldWUobXNnLCBjYWxsYmFjaykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlKClcIiwgXCJxdWV1ZWluZyBldmVudFwiKTtcbiAgICBjb25zdCBsYXN0UXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5sYXN0KCk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICBpZiAobGFzdFF1ZXVlZCAmJiAhbGFzdFF1ZXVlZC5zZW5kQXR0ZW1wdGVkICYmIGJ1bmRsZVdpdGgobGFzdFF1ZXVlZC5tZXNzYWdlLCBtc2csIG1heFNpemUpKSB7XG4gICAgICBpZiAoIWxhc3RRdWV1ZWQubWVyZ2VkKSB7XG4gICAgICAgIGxhc3RRdWV1ZWQuY2FsbGJhY2sgPSBtdWx0aWNhc3Rlcl9kZWZhdWx0LmNyZWF0ZSh0aGlzLmxvZ2dlciwgW2xhc3RRdWV1ZWQuY2FsbGJhY2tdKTtcbiAgICAgICAgbGFzdFF1ZXVlZC5tZXJnZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGFzdFF1ZXVlZC5jYWxsYmFjay5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5wdXNoKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG4gICAgfVxuICB9XG4gIHNlbmRRdWV1ZWRNZXNzYWdlcygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZFF1ZXVlZE1lc3NhZ2VzKClcIixcbiAgICAgIFwic2VuZGluZyBcIiArIHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKSArIFwiIHF1ZXVlZCBtZXNzYWdlc1wiXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ01lc3NhZ2U7XG4gICAgd2hpbGUgKHBlbmRpbmdNZXNzYWdlID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5zaGlmdCgpKVxuICAgICAgdGhpcy5zZW5kSW1wbChwZW5kaW5nTWVzc2FnZSk7XG4gIH1cbiAgcXVldWVQZW5kaW5nTWVzc2FnZXMocGVuZGluZ01lc3NhZ2VzKSB7XG4gICAgaWYgKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIucXVldWVQZW5kaW5nTWVzc2FnZXMoKVwiLFxuICAgICAgICBcInF1ZXVlaW5nIFwiICsgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCArIFwiIHBlbmRpbmcgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHJlcGVuZChwZW5kaW5nTWVzc2FnZXMpO1xuICAgIH1cbiAgfVxuICBmYWlsUXVldWVkTWVzc2FnZXMoZXJyKSB7XG4gICAgY29uc3QgbnVtUXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpO1xuICAgIGlmIChudW1RdWV1ZWQgPiAwKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZmFpbFF1ZXVlZE1lc3NhZ2VzKClcIixcbiAgICAgICAgXCJmYWlsaW5nIFwiICsgbnVtUXVldWVkICsgXCIgcXVldWVkIG1lc3NhZ2VzLCBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICApO1xuICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb21wbGV0ZUFsbE1lc3NhZ2VzKGVycik7XG4gICAgfVxuICB9XG4gIG9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUucXVldWUucHVzaCh7IG1lc3NhZ2UsIHRyYW5zcG9ydCB9KTtcbiAgICBpZiAoIXRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLmlzUHJvY2Vzc2luZykge1xuICAgICAgdGhpcy5wcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpO1xuICAgIH1cbiAgfVxuICBwcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBlbmRpbmdDaGFubmVsTWVzc2FnZSA9IHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICB0aGlzLnByb2Nlc3NDaGFubmVsTWVzc2FnZShwZW5kaW5nQ2hhbm5lbE1lc3NhZ2UubWVzc2FnZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIucHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKSByZWNlaXZlZCBlcnJvciBcIixcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzTmV4dFBlbmRpbmdDaGFubmVsTWVzc2FnZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb2Nlc3NDaGFubmVsTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgYXdhaXQgdGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgcGluZygpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXRlICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHBpbmcgc2VydmljZTsgbm90IGNvbm5lY3RlZFwiLCA0ZTQsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IChfYTIgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYW5zcG9ydCgpO1xuICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICB0aHJvdyB0aGlzLmdldFN0YXRlRXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIucGluZygpXCIsIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQpO1xuICAgIGNvbnN0IHBpbmdTdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaWQgPSBjaGVhcFJhbmRTdHIoKTtcbiAgICByZXR1cm4gd2l0aFRpbWVvdXRBc3luYyhcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uSGVhcnRiZWF0ID0gKHJlc3BvbnNlSWQpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2VJZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoXCJoZWFydGJlYXRcIiwgb25IZWFydGJlYXQpO1xuICAgICAgICAgICAgcmVzb2x2ZShEYXRlLm5vdygpIC0gcGluZ1N0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5vbihcImhlYXJ0YmVhdFwiLCBvbkhlYXJ0YmVhdCk7XG4gICAgICAgIHRyYW5zcG9ydC5waW5nKGlkKTtcbiAgICAgIH0pLFxuICAgICAgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG4gICAgICBcIlRpbWVvdXQgd2FpdGluZyBmb3IgaGVhcnRiZWF0IHJlc3BvbnNlXCJcbiAgICApO1xuICB9XG4gIGFib3J0KGVycm9yKSB7XG4gICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5mYWlsKGVycm9yKTtcbiAgfVxuICBnZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgfHwgaGF2ZVdlYlN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKSk7XG4gIH1cbiAgcGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0KSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gdHJhbnNwb3J0LnNob3J0TmFtZTtcbiAgICBpZiAoaGF2ZVdlYlN0b3JhZ2UoKSkge1xuICAgICAgKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lLCB0cmFuc3BvcnQuc2hvcnROYW1lKTtcbiAgICB9XG4gIH1cbiAgdW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuICAgIGlmIChoYXZlV2ViU3RvcmFnZSgpKSB7XG4gICAgICAoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpO1xuICAgIH1cbiAgfVxuICAvKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZHVyaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdHMsIHNvIGltcGxlbWVudHMgUlNBNGMxLCBSU0E0YzIsXG4gICAqIGFuZCBSU0E0ZC4gSXQgaXMgZ2VuZXJhbGx5IG5vdCBpbnZva2VkIGZvciBzZXJ2ZXJzaWRlLXRyaWdnZXJlZCByZWF1dGhzIG9yIG1hbnVhbFxuICAgKiByZWF1dGhzLCBzbyBSU0E0YzMgZG9lcyBub3QgYXBwbHksIGV4Y2VwdCAocGVyIHBlciBSU0E0ZDEpIGluIHRoZSBjYXNlIHRoYXQgdGhlIGF1dGhcbiAgICogc2VydmVyIHJldHVybnMgNDAzLiAqL1xuICBhY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09IDQwMTcxKSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gNDAxMDIpIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IGVyciB9KTtcbiAgICB9IGVsc2UgaWYgKGVyci5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Gb3JiaWRkZW4pIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmV0dXJuZWQgNDAzOyBmYWlsaW5nIHRoZSBjb25uZWN0aW9uXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSgpXCIsIG1zZyk7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiBuZXcgRXJyb3JJbmZvKG1zZywgODAwMTksIDQwMywgZXJyKSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gXCJDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXF1ZXN0IGZhaWxlZFwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemVcIiwgbXNnKTtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdGhpcy5zdGF0ZS5mYWlsU3RhdGUsIGVycm9yOiBuZXcgRXJyb3JJbmZvKG1zZywgODAwMTksIDQwMSwgZXJyKSB9KTtcbiAgICB9XG4gIH1cbiAgb25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KSB7XG4gICAgaWYgKCFjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gY29ubmVjdGlvbkRldGFpbHM7XG4gICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemUgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50SWQgPSBjb25uZWN0aW9uRGV0YWlscy5jbGllbnRJZDtcbiAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMucmVhbHRpbWUuYXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKClcIiwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB0cmFuc3BvcnQuZmFpbChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICBpZiAoY29ubmVjdGlvblN0YXRlVHRsKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICB9XG4gICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbmRldGFpbHNcIiwgY29ubmVjdGlvbkRldGFpbHMpO1xuICB9XG4gIGNoZWNrV3NDb25uZWN0aXZpdHkoKSB7XG4gICAgY29uc3Qgd3MgPSBuZXcgUGxhdGZvcm0uQ29uZmlnLldlYlNvY2tldChkZWZhdWx0c19kZWZhdWx0LndzQ29ubmVjdGl2aXR5VXJsKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBzZXNzaW9uUmVjb3ZlcnlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVjb3ZlcnlLZXlTdG9yYWdlTmFtZSB8fCBcImFibHktY29ubmVjdGlvbi1yZWNvdmVyeVwiO1xuICB9XG4gIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCkpKTtcbiAgfVxuICBzZXRTZXNzaW9uUmVjb3ZlckRhdGEodmFsdWUpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNldFNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCksIHZhbHVlKSk7XG4gIH1cbiAgY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmICgoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmVTZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpKSk7XG4gIH1cbn07XG52YXIgY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvY29ubmVjdGlvbi50c1xudmFyIENvbm5lY3Rpb24gPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoYWJseSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGFibHkubG9nZ2VyKTtcbiAgICB0aGlzLndoZW5TdGF0ZSA9IChzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGV2ZW50ZW1pdHRlcl9kZWZhdWx0LnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgfTtcbiAgICB0aGlzLmFibHkgPSBhYmx5O1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdChhYmx5LCBvcHRpb25zKTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZTtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oXCJjb25uZWN0aW9uc3RhdGVcIiwgKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUgPSBzdGF0ZUNoYW5nZS5jdXJyZW50O1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHN0YXRlLCBzdGF0ZUNoYW5nZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKFwidXBkYXRlXCIsIChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHN0YXRlQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbi5jb25uZWN0KClcIiwgXCJcIik7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gIH1cbiAgYXN5bmMgcGluZygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLnBpbmcoKVwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5waW5nKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbi5jbG9zZSgpXCIsIFwiY29ubmVjdGlvbktleSA9IFwiICsgdGhpcy5rZXkpO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY2xvc2luZ1wiIH0pO1xuICB9XG4gIGdldCByZWNvdmVyeUtleSgpIHtcbiAgICB0aGlzLmxvZ2dlci5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBcIlRoZSBgQ29ubmVjdGlvbi5yZWNvdmVyeUtleWAgYXR0cmlidXRlIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHRoZSBgQ29ubmVjdGlvbi5jcmVhdGVSZWNvdmVyeUtleSgpYCBtZXRob2QuIFJlcGxhY2UgeW91ciB1c2FnZSBvZiBgcmVjb3ZlcnlLZXlgIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiBgY3JlYXRlUmVjb3ZlcnlLZXkoKWAuIGByZWNvdmVyeUtleWAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gIH1cbiAgY3JlYXRlUmVjb3ZlcnlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgfVxufTtcbnZhciBjb25uZWN0aW9uX2RlZmF1bHQgPSBDb25uZWN0aW9uO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvY2hhbm5lbHN0YXRlY2hhbmdlLnRzXG52YXIgQ2hhbm5lbFN0YXRlQ2hhbmdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwcmV2aW91cywgY3VycmVudCwgcmVzdW1lZCwgaGFzQmFja2xvZywgcmVhc29uKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgdGhpcy5yZXN1bWVkID0gcmVzdW1lZDtcbiAgICAgIHRoaXMuaGFzQmFja2xvZyA9IGhhc0JhY2tsb2c7XG4gICAgfVxuICAgIGlmIChyZWFzb24pXG4gICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgfVxufTtcbnZhciBjaGFubmVsc3RhdGVjaGFuZ2VfZGVmYXVsdCA9IENoYW5uZWxTdGF0ZUNoYW5nZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lY2hhbm5lbC50c1xudmFyIG5vb3AyID0gZnVuY3Rpb24oKSB7XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVDaGFubmVsT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIFwicGFyYW1zXCIgaW4gb3B0aW9ucyAmJiAhaXNPYmplY3Qob3B0aW9ucy5wYXJhbXMpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXCJvcHRpb25zLnBhcmFtcyBtdXN0IGJlIGFuIG9iamVjdFwiLCA0ZTQsIDQwMCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgXCJtb2Rlc1wiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5tb2RlcykpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKFwib3B0aW9ucy5tb2RlcyBtdXN0IGJlIGFuIGFycmF5XCIsIDRlNCwgNDAwKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLm1vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50TW9kZSA9IG9wdGlvbnMubW9kZXNbaV07XG4gICAgICBpZiAoIWN1cnJlbnRNb2RlIHx8IHR5cGVvZiBjdXJyZW50TW9kZSAhPT0gXCJzdHJpbmdcIiB8fCAhY2hhbm5lbE1vZGVzLmluY2x1ZGVzKFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2UuY2FsbChjdXJyZW50TW9kZSkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKFwiSW52YWxpZCBjaGFubmVsIG1vZGU6IFwiICsgY3VycmVudE1vZGUsIDRlNCwgNDAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBSZWFsdGltZUNoYW5uZWwgPSBjbGFzcyBfUmVhbHRpbWVDaGFubmVsIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBzdXBlcihjbGllbnQubG9nZ2VyKTtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMuaGlzdG9yeSA9IGFzeW5jIGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgICBjb25zdCByZXN0TWl4aW4gPSB0aGlzLmNsaWVudC5yZXN0LmNoYW5uZWxNaXhpbjtcbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkXCIsIDRlNCwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgXCJ1bnRpbEF0dGFjaCB3YXMgc3BlY2lmaWVkIGFuZCBjaGFubmVsIGlzIGF0dGFjaGVkLCBidXQgYXR0YWNoU2VyaWFsIGlzIG5vdCBkZWZpbmVkXCIsXG4gICAgICAgICAgICA0ZTQsXG4gICAgICAgICAgICA0MDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG4gICAgICAgIHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgICB9O1xuICAgIHRoaXMud2hlblN0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRlbWl0dGVyX2RlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lQ2hhbm5lbCgpXCIsIFwic3RhcnRlZDsgbmFtZSA9IFwiICsgbmFtZSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IGNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuX3ByZXNlbmNlID0gY2xpZW50Ll9SZWFsdGltZVByZXNlbmNlID8gbmV3IGNsaWVudC5fUmVhbHRpbWVQcmVzZW5jZS5SZWFsdGltZVByZXNlbmNlKHRoaXMpIDogbnVsbDtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5zdGF0ZSA9IFwiaW5pdGlhbGl6ZWRcIjtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgYXR0YWNoU2VyaWFsOiB2b2lkIDAsXG4gICAgICBjaGFubmVsU2VyaWFsOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0ZWRGbGFncyA9IG51bGw7XG4gICAgdGhpcy5fbW9kZSA9IG51bGw7XG4gICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG4gICAgdGhpcy5fZGVjb2RpbmdDb250ZXh0ID0ge1xuICAgICAgY2hhbm5lbE9wdGlvbnM6IHRoaXMuY2hhbm5lbE9wdGlvbnMsXG4gICAgICBwbHVnaW5zOiBjbGllbnQub3B0aW9ucy5wbHVnaW5zIHx8IHt9LFxuICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHZvaWQgMFxuICAgIH07XG4gICAgdGhpcy5fbGFzdFBheWxvYWQgPSB7XG4gICAgICBtZXNzYWdlSWQ6IG51bGwsXG4gICAgICBwcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsOiBudWxsLFxuICAgICAgZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzczogbnVsbFxuICAgIH07XG4gICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIGlmICgoX2IgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuUHVzaCkge1xuICAgICAgdGhpcy5fcHVzaCA9IG5ldyBjbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guUHVzaENoYW5uZWwodGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBwcmVzZW5jZSgpIHtcbiAgICBpZiAoIXRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlJlYWx0aW1lUHJlc2VuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmVzZW5jZTtcbiAgfVxuICBnZXQgcHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX3B1c2gpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiUHVzaFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1c2g7XG4gIH1cbiAgaW52YWxpZFN0YXRlRXJyb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXG4gICAgICBcIkNoYW5uZWwgb3BlcmF0aW9uIGZhaWxlZCBhcyBjaGFubmVsIHN0YXRlIGlzIFwiICsgdGhpcy5zdGF0ZSxcbiAgICAgIDkwMDAxLFxuICAgICAgNDAwLFxuICAgICAgdGhpcy5lcnJvclJlYXNvbiB8fCB2b2lkIDBcbiAgICApO1xuICB9XG4gIHN0YXRpYyBwcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cbiAgYXN5bmMgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBwcmV2aW91c0NoYW5uZWxPcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICBjb25zdCBlcnIgPSB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKChfYTIgPSB0aGlzLmNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLl9kZWNvZGluZ0NvbnRleHQpXG4gICAgICB0aGlzLl9kZWNvZGluZ0NvbnRleHQuY2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgIGlmICh0aGlzLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhvcHRpb25zLCBwcmV2aW91c0NoYW5uZWxPcHRpb25zKSkge1xuICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5vbmNlKFxuICAgICAgICAgIFtcImF0dGFjaGVkXCIsIFwidXBkYXRlXCIsIFwiZGV0YWNoZWRcIiwgXCJmYWlsZWRcIl0sXG4gICAgICAgICAgZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWplY3Qoc3RhdGVDaGFuZ2UucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMsIHByZXZPcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiIHx8IHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoaW5nXCIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcykge1xuICAgICAgY29uc3QgcmVxdWVzdGVkUGFyYW1zID0gb21pdEFnZW50KG9wdGlvbnMucGFyYW1zKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUGFyYW1zID0gb21pdEFnZW50KHByZXZPcHRpb25zLnBhcmFtcyk7XG4gICAgICBpZiAoT2JqZWN0LmtleXMocmVxdWVzdGVkUGFyYW1zKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGV4aXN0aW5nUGFyYW1zKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXNoYWxsb3dFcXVhbHMoZXhpc3RpbmdQYXJhbXMsIHJlcXVlc3RlZFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGVzKSB7XG4gICAgICBpZiAoIXByZXZPcHRpb25zLm1vZGVzIHx8ICFhcnJFcXVhbHMob3B0aW9ucy5tb2RlcywgcHJldk9wdGlvbnMubW9kZXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcHVibGlzaCguLi5hcmdzKSB7XG4gICAgbGV0IG1lc3NhZ2VzID0gYXJnc1swXTtcbiAgICBsZXQgYXJnQ291bnQgPSBhcmdzLmxlbmd0aDtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAoYXJnQ291bnQgPT0gMSkge1xuICAgICAgaWYgKGlzT2JqZWN0KG1lc3NhZ2VzKSlcbiAgICAgICAgbWVzc2FnZXMgPSBbZnJvbVZhbHVlcyhtZXNzYWdlcyldO1xuICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlcykpXG4gICAgICAgIG1lc3NhZ2VzID0gZnJvbVZhbHVlc0FycmF5KG1lc3NhZ2VzKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIlRoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1wiLFxuICAgICAgICAgIDQwMDEzLFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlcyA9IFtmcm9tVmFsdWVzKHsgbmFtZTogYXJnc1swXSwgZGF0YTogYXJnc1sxXSB9KV07XG4gICAgfVxuICAgIGNvbnN0IG1heE1lc3NhZ2VTaXplID0gdGhpcy5jbGllbnQub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICBhd2FpdCBlbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucyk7XG4gICAgY29uc3Qgc2l6ZSA9IGdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyk7XG4gICAgaWYgKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKCB3YXMgXCIgKyBzaXplICsgXCIgYnl0ZXM7IGxpbWl0IGlzIFwiICsgbWF4TWVzc2FnZVNpemUgKyBcIiBieXRlcylcIixcbiAgICAgICAgNDAwMDksXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3B1Ymxpc2gobWVzc2FnZXMsIChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpKTtcbiAgICB9KTtcbiAgfVxuICBfcHVibGlzaChtZXNzYWdlcywgY2FsbGJhY2spIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwucHVibGlzaCgpXCIsIFwibWVzc2FnZSBjb3VudCA9IFwiICsgbWVzc2FnZXMubGVuZ3RoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICBjYWxsYmFjayhFcnJvckluZm8uZnJvbVZhbHVlcyh0aGlzLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwucHVibGlzaCgpXCIsXG4gICAgICAgICAgXCJzZW5kaW5nIG1lc3NhZ2U7IGNoYW5uZWwgc3RhdGUgaXMgXCIgKyBzdGF0ZVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBtc2cgPSBuZXcgcHJvdG9jb2xtZXNzYWdlX2RlZmF1bHQoKTtcbiAgICAgICAgbXNnLmFjdGlvbiA9IGFjdGlvbnMyLk1FU1NBR0U7XG4gICAgICAgIG1zZy5jaGFubmVsID0gdGhpcy5uYW1lO1xuICAgICAgICBtc2cubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uRXZlbnQobWVzc2FnZXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwub25FdmVudCgpXCIsIFwicmVjZWl2ZWQgbWVzc2FnZVwiKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuZW1pdChtZXNzYWdlLm5hbWUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9hdHRhY2goZmFsc2UsIG51bGwsIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG4gIF9hdHRhY2goZm9yY2VSZWF0dGFjaCwgYXR0YWNoUmVhc29uLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5fYXR0YWNoKClcIixcbiAgICAgICAgICAgIFwiQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiBcIiArIGVyci50b1N0cmluZygpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgY2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGluZ1wiIHx8IGZvcmNlUmVhdHRhY2gpIHtcbiAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIsIGF0dGFjaFJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhudWxsLCBzdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soXG4gICAgICAgICAgICBzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGF0dGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gXCIgKyB0aGlzLmV2ZW50LCA5ZTQsIDUwMClcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG5ldyBFcnJvckluZm8oXCJBdHRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBkZXRhY2ggcmVxdWVzdFwiLCA5ZTQsIDQwOSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaEltcGwoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmF0dGFjaEltcGwoKVwiLCBcInNlbmRpbmcgQVRUQUNIIG1lc3NhZ2VcIik7XG4gICAgY29uc3QgYXR0YWNoTXNnID0gZnJvbVZhbHVlczMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zMi5BVFRBQ0gsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBwYXJhbXM6IHRoaXMuY2hhbm5lbE9wdGlvbnMucGFyYW1zLFxuICAgICAgLy8gUlRMNGMxOiBJbmNsdWRlcyB0aGUgY2hhbm5lbCBzZXJpYWwgdG8gcmVzdW1lIGZyb20gYSBwcmV2aW91cyBtZXNzYWdlXG4gICAgICAvLyBvciBhdHRhY2htZW50LlxuICAgICAgY2hhbm5lbFNlcmlhbDogdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWxcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fcmVxdWVzdGVkRmxhZ3MpIHtcbiAgICAgIGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3ModGhpcy5fcmVxdWVzdGVkRmxhZ3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jaGFubmVsT3B0aW9ucy5tb2Rlcykge1xuICAgICAgYXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyhhbGxUb1VwcGVyQ2FzZSh0aGlzLmNoYW5uZWxPcHRpb25zLm1vZGVzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hdHRhY2hSZXN1bWUpIHtcbiAgICAgIGF0dGFjaE1zZy5zZXRGbGFnKFwiQVRUQUNIX1JFU1VNRVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcbiAgICAgIGF0dGFjaE1zZy5jaGFubmVsU2VyaWFsID0gdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbDtcbiAgICB9XG4gICAgdGhpcy5zZW5kTWVzc2FnZShhdHRhY2hNc2csIG5vb3AyKTtcbiAgfVxuICBhc3luYyBkZXRhY2goKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJkZXRhY2hlZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBkZXRhY2g7IGNoYW5uZWwgc3RhdGUgPSBmYWlsZWRcIiwgOTAwMDEsIDQwMCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImRldGFjaGluZ1wiKTtcbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGRldGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gXCIgKyB0aGlzLmV2ZW50LCA5ZTQsIDUwMClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJEZXRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBhdHRhY2ggcmVxdWVzdFwiLCA5ZTQsIDQwOSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoSW1wbChjYWxsYmFjaykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5kZXRhY2goKVwiLCBcInNlbmRpbmcgREVUQUNIIG1lc3NhZ2VcIik7XG4gICAgY29uc3QgbXNnID0gZnJvbVZhbHVlczMoeyBhY3Rpb246IGFjdGlvbnMyLkRFVEFDSCwgY2hhbm5lbDogdGhpcy5uYW1lIH0pO1xuICAgIHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayB8fCBub29wMik7XG4gIH1cbiAgYXN5bmMgc3Vic2NyaWJlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSA9IF9SZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmdzKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3JJbmZvLmZyb21WYWx1ZXModGhpcy5pbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ICYmIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIHRoaXMuY2xpZW50Ll9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMuc3Vic2NyaWJlRmlsdGVyKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hdHRhY2goKTtcbiAgfVxuICB1bnN1YnNjcmliZSguLi5hcmdzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSA9IF9SZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmdzKTtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmICFsaXN0ZW5lciB8fCAoKF9hMiA9IHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmhhcyhsaXN0ZW5lcikpKSB7XG4gICAgICB0aGlzLmNsaWVudC5fRmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldEFuZERlbGV0ZUZpbHRlcmVkU3Vic2NyaXB0aW9ucyh0aGlzLCBldmVudCwgbGlzdGVuZXIpLmZvckVhY2goKGwpID0+IHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYobCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgc3luYygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICAgIHRocm93IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiVW5hYmxlIHRvIHN5bmMgdG8gY2hhbm5lbDsgbm90IGF0dGFjaGVkXCIsIDRlNCk7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBzeW5jTWVzc2FnZSA9IGZyb21WYWx1ZXMzKHsgYWN0aW9uOiBhY3Rpb25zMi5TWU5DLCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgaWYgKHRoaXMuc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICAgIHN5bmNNZXNzYWdlLmNoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsO1xuICAgIH1cbiAgICBjb25uZWN0aW9uTWFuYWdlci5zZW5kKHN5bmNNZXNzYWdlKTtcbiAgfVxuICBzZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZW5kKG1zZywgdGhpcy5jbGllbnQub3B0aW9ucy5xdWV1ZU1lc3NhZ2VzLCBjYWxsYmFjayk7XG4gIH1cbiAgc2VuZFByZXNlbmNlKHByZXNlbmNlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1zZyA9IGZyb21WYWx1ZXMzKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uczIuUFJFU0VOQ0UsXG4gICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICBwcmVzZW5jZTogQXJyYXkuaXNBcnJheShwcmVzZW5jZSkgPyB0aGlzLmNsaWVudC5fUmVhbHRpbWVQcmVzZW5jZS5wcmVzZW5jZU1lc3NhZ2VzRnJvbVZhbHVlc0FycmF5KHByZXNlbmNlKSA6IFt0aGlzLmNsaWVudC5fUmVhbHRpbWVQcmVzZW5jZS5wcmVzZW5jZU1lc3NhZ2VGcm9tVmFsdWVzKHByZXNlbmNlKV1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuICB9XG4gIC8vIEFjY2VzcyB0byB0aGlzIG1ldGhvZCBpcyBzeW5jaHJvbmlzZWQgYnkgQ29ubmVjdGlvbk1hbmFnZXIjcHJvY2Vzc0NoYW5uZWxNZXNzYWdlLCBpbiBvcmRlciB0byBzeW5jaHJvbmlzZSBhY2Nlc3MgdG8gdGhlIHN0YXRlIHN0b3JlZCBpbiBfZGVjb2RpbmdDb250ZXh0LlxuICBhc3luYyBwcm9jZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zMi5BVFRBQ0hFRCB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9uczIuTUVTU0FHRSB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9uczIuUFJFU0VOQ0UpIHtcbiAgICAgIHRoaXMuc2V0Q2hhbm5lbFNlcmlhbChtZXNzYWdlLmNoYW5uZWxTZXJpYWwpO1xuICAgIH1cbiAgICBsZXQgc3luY0NoYW5uZWxTZXJpYWwsIGlzU3luYyA9IGZhbHNlO1xuICAgIHN3aXRjaCAobWVzc2FnZS5hY3Rpb24pIHtcbiAgICAgIGNhc2UgYWN0aW9uczIuQVRUQUNIRUQ6IHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgdGhpcy5fbW9kZSA9IG1lc3NhZ2UuZ2V0TW9kZSgpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zIHx8IHt9O1xuICAgICAgICBjb25zdCBtb2Rlc0Zyb21GbGFncyA9IG1lc3NhZ2UuZGVjb2RlTW9kZXNGcm9tRmxhZ3MoKTtcbiAgICAgICAgdGhpcy5tb2RlcyA9IG1vZGVzRnJvbUZsYWdzICYmIGFsbFRvTG93ZXJDYXNlKG1vZGVzRnJvbUZsYWdzKSB8fCB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VtZWQgPSBtZXNzYWdlLmhhc0ZsYWcoXCJSRVNVTUVEXCIpO1xuICAgICAgICBjb25zdCBoYXNQcmVzZW5jZSA9IG1lc3NhZ2UuaGFzRmxhZyhcIkhBU19QUkVTRU5DRVwiKTtcbiAgICAgICAgY29uc3QgaGFzQmFja2xvZyA9IG1lc3NhZ2UuaGFzRmxhZyhcIkhBU19CQUNLTE9HXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJlc2VuY2Uub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2VfZGVmYXVsdCh0aGlzLnN0YXRlLCB0aGlzLnN0YXRlLCByZXN1bWVkLCBoYXNCYWNrbG9nLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KFwidXBkYXRlXCIsIGNoYW5nZSk7XG4gICAgICAgICAgaWYgKCFyZXN1bWVkIHx8IHRoaXMuY2hhbm5lbE9wdGlvbnMudXBkYXRlT25BdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIGNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFwiZGV0YWNoaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImF0dGFjaGVkXCIsIG1lc3NhZ2UuZXJyb3IsIHJlc3VtZWQsIGhhc1ByZXNlbmNlLCBoYXNCYWNrbG9nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgYWN0aW9uczIuREVUQUNIRUQ6IHtcbiAgICAgICAgY29uc3QgZGV0YWNoRXJyID0gbWVzc2FnZS5lcnJvciA/IEVycm9ySW5mby5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpIDogbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgZGV0YWNoZWRcIiwgOTAwMDEsIDQwNCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIsIGRldGFjaEVycik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJzdXNwZW5kZWRcIiwgZGV0YWNoRXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIsIGRldGFjaEVycik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMyLlNZTkM6XG4gICAgICAgIGlzU3luYyA9IHRydWU7XG4gICAgICAgIHN5bmNDaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnByZXNlbmNlKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhY3Rpb25zMi5QUkVTRU5DRToge1xuICAgICAgICBjb25zdCBwcmVzZW5jZSA9IG1lc3NhZ2UucHJlc2VuY2U7XG4gICAgICAgIGlmICghcHJlc2VuY2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkLCBjb25uZWN0aW9uSWQsIHRpbWVzdGFtcCB9ID0gbWVzc2FnZTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIGxldCBwcmVzZW5jZU1zZztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVzZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcmVzZW5jZU1zZyA9IHByZXNlbmNlW2ldO1xuICAgICAgICAgICAgYXdhaXQgZGVjb2RlMihwcmVzZW5jZU1zZywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIXByZXNlbmNlTXNnLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgICAgcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgICAgICAgICAgaWYgKCFwcmVzZW5jZU1zZy50aW1lc3RhbXApXG4gICAgICAgICAgICAgIHByZXNlbmNlTXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmICghcHJlc2VuY2VNc2cuaWQpXG4gICAgICAgICAgICAgIHByZXNlbmNlTXNnLmlkID0gaWQgKyBcIjpcIiArIGk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgICAgICAgIGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICAgICAgdGhpcy5fcHJlc2VuY2Uuc2V0UHJlc2VuY2UocHJlc2VuY2UsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBhY3Rpb25zMi5NRVNTQUdFOiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgICAgICdNZXNzYWdlIFwiJyArIG1lc3NhZ2UuaWQgKyAnXCIgc2tpcHBlZCBhcyB0aGlzIGNoYW5uZWwgXCInICsgdGhpcy5uYW1lICsgJ1wiIHN0YXRlIGlzIG5vdCBcImF0dGFjaGVkXCIgKHN0YXRlIGlzIFwiJyArIHRoaXMuc3RhdGUgKyAnXCIpLidcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMsIGZpcnN0TWVzc2FnZSA9IG1lc3NhZ2VzWzBdLCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLCBpZCA9IG1lc3NhZ2UuaWQsIGNvbm5lY3Rpb25JZCA9IG1lc3NhZ2UuY29ubmVjdGlvbklkLCB0aW1lc3RhbXAgPSBtZXNzYWdlLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKGZpcnN0TWVzc2FnZS5leHRyYXMgJiYgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YSAmJiBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhLmZyb20gIT09IHRoaXMuX2xhc3RQYXlsb2FkLm1lc3NhZ2VJZCkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdEZWx0YSBtZXNzYWdlIGRlY29kZSBmYWlsdXJlIC0gcHJldmlvdXMgbWVzc2FnZSBub3QgYXZhaWxhYmxlIGZvciBtZXNzYWdlIFwiJyArIG1lc3NhZ2UuaWQgKyAnXCIgb24gdGhpcyBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIi4nO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsIG1zZyk7XG4gICAgICAgICAgdGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkobmV3IEVycm9ySW5mbyhtc2csIDQwMDE4LCA0MDApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGRlY29kZShtc2csIHRoaXMuX2RlY29kaW5nQ29udGV4dCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgICAgICAgIGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5jb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgNDAwMTg6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBjYXNlIDQwMDE5OlxuICAgICAgICAgICAgICBjYXNlIDQwMDIxOlxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJmYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW1zZy5jb25uZWN0aW9uSWQpXG4gICAgICAgICAgICBtc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgICAgICAgIGlmICghbXNnLnRpbWVzdGFtcClcbiAgICAgICAgICAgIG1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgaWYgKCFtc2cuaWQpXG4gICAgICAgICAgICBtc2cuaWQgPSBpZCArIFwiOlwiICsgaTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQgPSBsYXN0TWVzc2FnZS5pZDtcbiAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgdGhpcy5vbkV2ZW50KG1lc3NhZ2VzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMyLkVSUk9SOiB7XG4gICAgICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UuZXJyb3I7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT0gODAwMTYpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImZhaWxlZFwiLCBFcnJvckluZm8uZnJvbVZhbHVlcyhlcnIpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwucHJvY2Vzc01lc3NhZ2UoKVwiLFxuICAgICAgICAgIFwiRmF0YWwgcHJvdG9jb2wgZXJyb3I6IHVucmVjb2duaXNlZCBhY3Rpb24gKFwiICsgbWVzc2FnZS5hY3Rpb24gKyBcIilcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFib3J0KGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC51bmtub3duQ2hhbm5lbEVycigpKTtcbiAgICB9XG4gIH1cbiAgX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgIFwiU3RhcnRpbmcgZGVjb2RlIGZhaWx1cmUgcmVjb3ZlcnkgcHJvY2Vzcy5cIlxuICAgICAgKTtcbiAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgdGhpcy5fYXR0YWNoKHRydWUsIHJlYXNvbiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25BdHRhY2hlZCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLm9uQXR0YWNoZWRcIixcbiAgICAgIFwiYWN0aXZhdGluZyBjaGFubmVsOyBuYW1lID0gXCIgKyB0aGlzLm5hbWVcbiAgICApO1xuICB9XG4gIG5vdGlmeVN0YXRlKHN0YXRlLCByZWFzb24sIHJlc3VtZWQsIGhhc1ByZXNlbmNlLCBoYXNCYWNrbG9nKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5ub3RpZnlTdGF0ZVwiLFxuICAgICAgXCJuYW1lID0gXCIgKyB0aGlzLm5hbWUgKyBcIiwgY3VycmVudCBzdGF0ZSA9IFwiICsgdGhpcy5zdGF0ZSArIFwiLCBub3RpZnlpbmcgc3RhdGUgXCIgKyBzdGF0ZVxuICAgICk7XG4gICAgdGhpcy5jbGVhclN0YXRlVGltZXIoKTtcbiAgICBpZiAoW1wiZGV0YWNoZWRcIiwgXCJzdXNwZW5kZWRcIiwgXCJmYWlsZWRcIl0uaW5jbHVkZXMoc3RhdGUpKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlLmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgcmVhc29uKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcInN1c3BlbmRlZFwiICYmIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgdGhpcy5zdGFydFJldHJ5VGltZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgfVxuICAgIGlmIChyZWFzb24pIHtcbiAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSByZWFzb247XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2VfZGVmYXVsdCh0aGlzLnN0YXRlLCBzdGF0ZSwgcmVzdW1lZCwgaGFzQmFja2xvZywgcmVhc29uKTtcbiAgICBjb25zdCBhY3Rpb24gPSAnQ2hhbm5lbCBzdGF0ZSBmb3IgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCInO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzdGF0ZSArIChyZWFzb24gPyBcIjsgcmVhc29uOiBcIiArIHJlYXNvbiA6IFwiXCIpO1xuICAgIGlmIChzdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgIT09IFwiYXR0YWNoaW5nXCIgJiYgc3RhdGUgIT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICB0aGlzLm9uQXR0YWNoZWQoKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHRoaXMuX2F0dGFjaFJlc3VtZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJkZXRhY2hpbmdcIiB8fCBzdGF0ZSA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICAgIHRoaXMuZW1pdChzdGF0ZSwgY2hhbmdlKTtcbiAgfVxuICByZXF1ZXN0U3RhdGUoc3RhdGUsIHJlYXNvbikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwucmVxdWVzdFN0YXRlXCIsXG4gICAgICBcIm5hbWUgPSBcIiArIHRoaXMubmFtZSArIFwiLCBzdGF0ZSA9IFwiICsgc3RhdGVcbiAgICApO1xuICAgIHRoaXMubm90aWZ5U3RhdGUoc3RhdGUsIHJlYXNvbik7XG4gICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICB9XG4gIGNoZWNrUGVuZGluZ1N0YXRlKCkge1xuICAgIGNvbnN0IGNtU3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlO1xuICAgIGlmICghY21TdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlXCIsXG4gICAgICAgIFwic2VuZEV2ZW50cyBpcyBmYWxzZTsgc3RhdGUgaXMgXCIgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlXCIsXG4gICAgICBcIm5hbWUgPSBcIiArIHRoaXMubmFtZSArIFwiLCBzdGF0ZSA9IFwiICsgdGhpcy5zdGF0ZVxuICAgICk7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XG4gICAgICAgIHRoaXMuYXR0YWNoSW1wbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgdGhpcy5kZXRhY2hJbXBsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aW1lb3V0UGVuZGluZ1N0YXRlKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBcImF0dGFjaGluZ1wiOiB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckluZm8oXCJDaGFubmVsIGF0dGFjaCB0aW1lZCBvdXRcIiwgOTAwMDcsIDQwOCk7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJzdXNwZW5kZWRcIiwgZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgZGV0YWNoIHRpbWVkIG91dFwiLCA5MDAwNywgNDA4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImF0dGFjaGVkXCIsIGVycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZVRpbWVyKSB7XG4gICAgICB0aGlzLnN0YXRlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWVDaGFubmVsLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZ1wiLCBcInRpbWVyIGV4cGlyZWRcIik7XG4gICAgICAgIHRoaXMuc3RhdGVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dFBlbmRpbmdTdGF0ZSgpO1xuICAgICAgfSwgdGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgY2xlYXJTdGF0ZVRpbWVyKCkge1xuICAgIGNvbnN0IHN0YXRlVGltZXIgPSB0aGlzLnN0YXRlVGltZXI7XG4gICAgaWYgKHN0YXRlVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzdGF0ZVRpbWVyKTtcbiAgICAgIHRoaXMuc3RhdGVUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXJ0UmV0cnlUaW1lcigpIHtcbiAgICBpZiAodGhpcy5yZXRyeVRpbWVyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucmV0cnlDb3VudCsrO1xuICAgIGNvbnN0IHJldHJ5RGVsYXkgPSBnZXRSZXRyeVRpbWUodGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cy5jaGFubmVsUmV0cnlUaW1lb3V0LCB0aGlzLnJldHJ5Q291bnQpO1xuICAgIHRoaXMucmV0cnlUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwgcmV0cnkgdGltZXIgZXhwaXJlZFwiLFxuICAgICAgICAgIFwiYXR0ZW1wdGluZyBhIG5ldyBhdHRhY2hcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImF0dGFjaGluZ1wiKTtcbiAgICAgIH1cbiAgICB9LCByZXRyeURlbGF5KTtcbiAgfVxuICBjYW5jZWxSZXRyeVRpbWVyKCkge1xuICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xuICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyogQHJldHVybnMgbnVsbCAoaWYgY2FuIHNhZmVseSBiZSByZWxlYXNlZCkgfCBFcnJvckluZm8gKGlmIGNhbm5vdCkgKi9cbiAgZ2V0UmVsZWFzZUVycigpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAocyA9PT0gXCJpbml0aWFsaXplZFwiIHx8IHMgPT09IFwiZGV0YWNoZWRcIiB8fCBzID09PSBcImZhaWxlZFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXG4gICAgICBcIkNhbiBvbmx5IHJlbGVhc2UgYSBjaGFubmVsIGluIGEgc3RhdGUgd2hlcmUgdGhlcmUgaXMgbm8gcG9zc2liaWxpdHkgb2YgZnVydGhlciB1cGRhdGVzIGZyb20gdGhlIHNlcnZlciBiZWluZyByZWNlaXZlZCAoaW5pdGlhbGl6ZWQsIGRldGFjaGVkLCBvciBmYWlsZWQpOyB3YXMgXCIgKyBzLFxuICAgICAgOTAwMDEsXG4gICAgICA0MDBcbiAgICApO1xuICB9XG4gIHNldENoYW5uZWxTZXJpYWwoY2hhbm5lbFNlcmlhbCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwuc2V0Q2hhbm5lbFNlcmlhbCgpXCIsXG4gICAgICBcIlVwZGF0aW5nIGNoYW5uZWwgc2VyaWFsOyBzZXJpYWwgPSBcIiArIGNoYW5uZWxTZXJpYWwgKyBcIjsgcHJldmlvdXMgPSBcIiArIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsXG4gICAgKTtcbiAgICBpZiAoY2hhbm5lbFNlcmlhbCkge1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBjaGFubmVsU2VyaWFsO1xuICAgIH1cbiAgfVxuICBhc3luYyBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnN0YXR1cyh0aGlzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIG9taXRBZ2VudChjaGFubmVsUGFyYW1zKSB7XG4gIGNvbnN0IF9hMiA9IGNoYW5uZWxQYXJhbXMgfHwge30sIHsgYWdlbnQ6IF8gfSA9IF9hMiwgcGFyYW1zV2l0aG91dEFnZW50ID0gX19vYmpSZXN0KF9hMiwgW1wiYWdlbnRcIl0pO1xuICByZXR1cm4gcGFyYW1zV2l0aG91dEFnZW50O1xufVxudmFyIHJlYWx0aW1lY2hhbm5lbF9kZWZhdWx0ID0gUmVhbHRpbWVDaGFubmVsO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZXJlYWx0aW1lLnRzXG52YXIgX0Jhc2VSZWFsdGltZSA9IGNsYXNzIF9CYXNlUmVhbHRpbWUgZXh0ZW5kcyBiYXNlY2xpZW50X2RlZmF1bHQge1xuICAvKlxuICAgKiBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgb25seSBhY2NlcHRzIGFuIG9iamVjdCwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gZW1pdCBhIGdvb2QgZXJyb3IgbWVzc2FnZSBpbiB0aGUgY2FzZSB3aGVyZSBhIG5vbi1UeXBlU2NyaXB0IHVzZXIgZG9lcyBvbmUgb2YgdGhlc2UgdGhpbmdzOlxuICAgKlxuICAgKiAxLiBwYXNzZXMgYSBzdHJpbmcgKHdoaWNoIGlzIHF1aXRlIGxpa2VseSBpZiB0aGV54oCZcmUgZS5nLiBtaWdyYXRpbmcgZnJvbSB0aGUgZGVmYXVsdCB2YXJpYW50IHRvIHRoZSBtb2R1bGFyIHZhcmlhbnQpXG4gICAqIDIuIHBhc3NlcyBubyBhcmd1bWVudCBhdCBhbGxcbiAgICpcbiAgICogdGVsbCB0aGUgY29tcGlsZXIgdGhhdCB0aGVzZSBjYXNlcyBhcmUgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIHRoZW0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgc3VwZXIoZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGZhbHNlLCBcIkJhc2VSZWFsdGltZVwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyKSk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUoKVwiLCBcIlwiKTtcbiAgICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBgQWJseS5SZWFsdGltZSBpbnN0YW5jZSBjYW5ub3QgYmUgdXNlZCBpbiBWZXJjZWwgRWRnZSBydW50aW1lLiBJZiB5b3UgYXJlIHJ1bm5pbmcgVmVyY2VsIEVkZ2UgZnVuY3Rpb25zLCBwbGVhc2UgcmVwbGFjZSB5b3VyIFwibmV3IEFibHkuUmVhbHRpbWUoKVwiIHdpdGggXCJuZXcgQWJseS5SZXN0KClcIiBhbmQgdXNlIEFibHkgUmVzdCBBUEkgaW5zdGVhZCBvZiB0aGUgUmVhbHRpbWUgQVBJLiBJZiB5b3UgYXJlIHNlcnZlci1yZW5kZXJpbmcgeW91ciBhcHBsaWNhdGlvbiBpbiB0aGUgVmVyY2VsIEVkZ2UgcnVudGltZSwgcGxlYXNlIHVzZSB0aGUgY29uZGl0aW9uIFwiaWYgKHR5cGVvZiBFZGdlUnVudGltZSA9PT0gJ3N0cmluZycpXCIgdG8gcHJldmVudCBpbnN0YW50aWF0aW5nIEFibHkuUmVhbHRpbWUgaW5zdGFuY2UgZHVyaW5nIFNTUiBpbiB0aGUgVmVyY2VsIEVkZ2UgcnVudGltZS5gLFxuICAgICAgICA0ZTQsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fYWRkaXRpb25hbFRyYW5zcG9ydEltcGxlbWVudGF0aW9ucyA9IF9CYXNlUmVhbHRpbWUudHJhbnNwb3J0SW1wbGVtZW50YXRpb25zRnJvbVBsdWdpbnModGhpcy5vcHRpb25zLnBsdWdpbnMpO1xuICAgIHRoaXMuX1JlYWx0aW1lUHJlc2VuY2UgPSAoX2IgPSAoX2EyID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUmVhbHRpbWVQcmVzZW5jZSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgY29ubmVjdGlvbl9kZWZhdWx0KHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5fY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHMyKHRoaXMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlKVxuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gIH1cbiAgc3RhdGljIHRyYW5zcG9ydEltcGxlbWVudGF0aW9uc0Zyb21QbHVnaW5zKHBsdWdpbnMpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRzID0ge307XG4gICAgaWYgKHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuV2ViU29ja2V0VHJhbnNwb3J0KSB7XG4gICAgICB0cmFuc3BvcnRzW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldF0gPSBwbHVnaW5zLldlYlNvY2tldFRyYW5zcG9ydDtcbiAgICB9XG4gICAgaWYgKHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuWEhSUG9sbGluZykge1xuICAgICAgdHJhbnNwb3J0c1tUcmFuc3BvcnROYW1lcy5YaHJQb2xsaW5nXSA9IHBsdWdpbnMuWEhSUG9sbGluZztcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gIH1cbiAgZ2V0IGNoYW5uZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFubmVscztcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lLmNvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lLmNsb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gIH1cbn07XG4vLyBpbnRlcm5hbCBBUEkgdG8gbWFrZSBFdmVudEVtaXR0ZXIgdXNhYmxlIGluIG90aGVyIFNES3Ncbl9CYXNlUmVhbHRpbWUuRXZlbnRFbWl0dGVyID0gZXZlbnRlbWl0dGVyX2RlZmF1bHQ7XG52YXIgQmFzZVJlYWx0aW1lID0gX0Jhc2VSZWFsdGltZTtcbnZhciBDaGFubmVsczIgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocmVhbHRpbWUpIHtcbiAgICBzdXBlcihyZWFsdGltZS5sb2dnZXIpO1xuICAgIHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICB0aGlzLmFsbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub24oXCJ0cmFuc3BvcnQuYWN0aXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMub25UcmFuc3BvcnRBY3RpdmUoKTtcbiAgICB9KTtcbiAgfVxuICBjaGFubmVsU2VyaWFscygpIHtcbiAgICBsZXQgc2VyaWFscyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBrZXlzQXJyYXkodGhpcy5hbGwsIHRydWUpKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgICBpZiAoY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwpIHtcbiAgICAgICAgc2VyaWFsc1tuYW1lXSA9IGNoYW5uZWwucHJvcGVydGllcy5jaGFubmVsU2VyaWFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFscztcbiAgfVxuICAvLyByZWNvdmVyQ2hhbm5lbHMgZ2V0cyB0aGUgZ2l2ZW4gY2hhbm5lbHMgYW5kIHNldHMgdGhlaXIgY2hhbm5lbCBzZXJpYWxzLlxuICByZWNvdmVyQ2hhbm5lbHMoY2hhbm5lbFNlcmlhbHMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Yga2V5c0FycmF5KGNoYW5uZWxTZXJpYWxzLCB0cnVlKSkge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBjaGFubmVsU2VyaWFsc1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgLy8gQWNjZXNzIHRvIHRoaXMgbWV0aG9kIGlzIHN5bmNocm9uaXNlZCBieSBDb25uZWN0aW9uTWFuYWdlciNwcm9jZXNzQ2hhbm5lbE1lc3NhZ2UuXG4gIGFzeW5jIHByb2Nlc3NDaGFubmVsTWVzc2FnZShtc2cpIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IG1zZy5jaGFubmVsO1xuICAgIGlmIChjaGFubmVsTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ2hhbm5lbHMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBldmVudCB1bnNwZWNpZmllZCBjaGFubmVsLCBhY3Rpb24gPSBcIiArIG1zZy5hY3Rpb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ2hhbm5lbHMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBldmVudCBmb3Igbm9uLWV4aXN0ZW50IGNoYW5uZWw6IFwiICsgY2hhbm5lbE5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGNoYW5uZWwucHJvY2Vzc01lc3NhZ2UobXNnKTtcbiAgfVxuICAvKiBjYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBiZWNvbWVzIGNvbm5lY3RlZDsgcmVhdHRlbXB0IGF0dGFjaC9kZXRhY2hcbiAgICogZm9yIGNoYW5uZWxzIHRoYXQgYXJlIGF0dGFjaGluZyBvciBkZXRhY2hpbmcuICovXG4gIG9uVHJhbnNwb3J0QWN0aXZlKCkge1xuICAgIGZvciAoY29uc3QgY2hhbm5lbE5hbWUgaW4gdGhpcy5hbGwpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIiB8fCBjaGFubmVsLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgIGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICBjaGFubmVsLl9hdHRhY2goZmFsc2UsIG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgY2hhbm5lbC5yZXF1ZXN0U3RhdGUoXCJhdHRhY2hpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIENvbm5lY3Rpb24gaW50ZXJydXB0aW9ucyAoaWUgd2hlbiB0aGUgY29ubmVjdGlvbiB3aWxsIG5vIGxvbmdlciBxdWV1ZVxuICAgKiBldmVudHMpIGltcGx5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBmb3IgYW55IGNoYW5uZWwgd2hpY2ggaXMgZWl0aGVyXG4gICAqIGF0dGFjaGVkLCBwZW5kaW5nLCBvciB3aWxsIGF0dGVtcHQgdG8gYmVjb21lIGF0dGFjaGVkIGluIHRoZSBmdXR1cmUgKi9cbiAgcHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihjb25uZWN0aW9uU3RhdGUsIHJlYXNvbikge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlID0ge1xuICAgICAgY2xvc2luZzogXCJkZXRhY2hlZFwiLFxuICAgICAgY2xvc2VkOiBcImRldGFjaGVkXCIsXG4gICAgICBmYWlsZWQ6IFwiZmFpbGVkXCIsXG4gICAgICBzdXNwZW5kZWQ6IFwic3VzcGVuZGVkXCJcbiAgICB9O1xuICAgIGNvbnN0IGZyb21DaGFubmVsU3RhdGVzID0gW1wiYXR0YWNoaW5nXCIsIFwiYXR0YWNoZWRcIiwgXCJkZXRhY2hpbmdcIiwgXCJzdXNwZW5kZWRcIl07XG4gICAgY29uc3QgdG9DaGFubmVsU3RhdGUgPSBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZVtjb25uZWN0aW9uU3RhdGVdO1xuICAgIGZvciAoY29uc3QgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcbiAgICAgIGlmIChmcm9tQ2hhbm5lbFN0YXRlcy5pbmNsdWRlcyhjaGFubmVsLnN0YXRlKSkge1xuICAgICAgICBjaGFubmVsLm5vdGlmeVN0YXRlKHRvQ2hhbm5lbFN0YXRlLCByZWFzb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQobmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIGxldCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV0gPSBuZXcgcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQodGhpcy5yZWFsdGltZSwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgIGlmIChjaGFubmVsLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucywgY2hhbm5lbC5jaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIkNoYW5uZWxzLmdldCgpIGNhbm5vdCBiZSB1c2VkIHRvIHNldCBjaGFubmVsIG9wdGlvbnMgdGhhdCB3b3VsZCBjYXVzZSB0aGUgY2hhbm5lbCB0byByZWF0dGFjaC4gUGxlYXNlLCB1c2UgUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIDRlNCxcbiAgICAgICAgICA0MDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG4gIGdldERlcml2ZWQobmFtZSwgZGVyaXZlT3B0aW9ucywgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICBpZiAoZGVyaXZlT3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIGNvbnN0IGZpbHRlciA9IHRvQmFzZTY0KGRlcml2ZU9wdGlvbnMuZmlsdGVyKTtcbiAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hEZXJpdmVkQ2hhbm5lbChuYW1lKTtcbiAgICAgIG5hbWUgPSBgW2ZpbHRlcj0ke2ZpbHRlcn0ke21hdGNoLnF1YWxpZmllclBhcmFtfV0ke21hdGNoLmNoYW5uZWxOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gIH1cbiAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gIHJlbGVhc2UobmFtZSkge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWxlYXNlRXJyID0gY2hhbm5lbC5nZXRSZWxlYXNlRXJyKCk7XG4gICAgaWYgKHJlbGVhc2VFcnIpIHtcbiAgICAgIHRocm93IHJlbGVhc2VFcnI7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmFsbFtuYW1lXTtcbiAgfVxufTtcbnZhciBiYXNlcmVhbHRpbWVfZGVmYXVsdCA9IEJhc2VSZWFsdGltZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lcHJlc2VuY2UudHNcbmZ1bmN0aW9uIGdldENsaWVudElkKHJlYWx0aW1lUHJlc2VuY2UpIHtcbiAgcmV0dXJuIHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5jbGllbnQuYXV0aC5jbGllbnRJZDtcbn1cbmZ1bmN0aW9uIGlzQW5vbnltb3VzT3JXaWxkY2FyZChyZWFsdGltZVByZXNlbmNlKSB7XG4gIGNvbnN0IHJlYWx0aW1lID0gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLmNsaWVudDtcbiAgY29uc3QgY2xpZW50SWQgPSByZWFsdGltZS5hdXRoLmNsaWVudElkO1xuICByZXR1cm4gKCFjbGllbnRJZCB8fCBjbGllbnRJZCA9PT0gXCIqXCIpICYmIHJlYWx0aW1lLmNvbm5lY3Rpb24uc3RhdGUgPT09IFwiY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiB3YWl0QXR0YWNoZWQoY2hhbm5lbCwgY2FsbGJhY2ssIGFjdGlvbikge1xuICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICBhY3Rpb24oKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICB3aGVuUHJvbWlzZVNldHRsZXMoY2hhbm5lbC5hdHRhY2goKSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2FsbGJhY2soRXJyb3JJbmZvLmZyb21WYWx1ZXMoY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5ld2VyVGhhbihpdGVtLCBleGlzdGluZykge1xuICBpZiAoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgcmV0dXJuIGl0ZW0udGltZXN0YW1wID49IGV4aXN0aW5nLnRpbWVzdGFtcDtcbiAgfVxuICBjb25zdCBpdGVtT3JkZXJpbmdzID0gaXRlbS5wYXJzZUlkKCksIGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xuICBpZiAoaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPT09IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbCkge1xuICAgIHJldHVybiBpdGVtT3JkZXJpbmdzLmluZGV4ID4gZXhpc3RpbmdPcmRlcmluZ3MuaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID4gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsO1xuICB9XG59XG52YXIgUmVhbHRpbWVQcmVzZW5jZSA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgc3VwZXIoY2hhbm5lbC5sb2dnZXIpO1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgdGhpcy5zeW5jQ29tcGxldGUgPSBmYWxzZTtcbiAgICB0aGlzLm1lbWJlcnMgPSBuZXcgUHJlc2VuY2VNYXAodGhpcywgKGl0ZW0pID0+IGl0ZW0uY2xpZW50SWQgKyBcIjpcIiArIGl0ZW0uY29ubmVjdGlvbklkKTtcbiAgICB0aGlzLl9teU1lbWJlcnMgPSBuZXcgUHJlc2VuY2VNYXAodGhpcywgKGl0ZW0pID0+IGl0ZW0uY2xpZW50SWQpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgfVxuICBhc3luYyBlbnRlcihkYXRhKSB7XG4gICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIGVudGVyIGEgcHJlc2VuY2UgY2hhbm5lbFwiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodm9pZCAwLCB2b2lkIDAsIGRhdGEsIFwiZW50ZXJcIik7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKGRhdGEpIHtcbiAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gdXBkYXRlIHByZXNlbmNlIGRhdGFcIiwgNDAwMTIsIDQwMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHZvaWQgMCwgdm9pZCAwLCBkYXRhLCBcInVwZGF0ZVwiKTtcbiAgfVxuICBhc3luYyBlbnRlckNsaWVudChjbGllbnRJZCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHZvaWQgMCwgY2xpZW50SWQsIGRhdGEsIFwiZW50ZXJcIik7XG4gIH1cbiAgYXN5bmMgdXBkYXRlQ2xpZW50KGNsaWVudElkLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodm9pZCAwLCBjbGllbnRJZCwgZGF0YSwgXCJ1cGRhdGVcIik7XG4gIH1cbiAgYXN5bmMgX2VudGVyT3JVcGRhdGVDbGllbnQoaWQsIGNsaWVudElkLCBkYXRhLCBhY3Rpb24pIHtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgIGlmICghY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyBjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLlwiICsgYWN0aW9uICsgXCJDbGllbnQoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyBjaGFubmVsLm5hbWUgKyBcIiwgaWQgPSBcIiArIGlkICsgXCIsIGNsaWVudCA9IFwiICsgKGNsaWVudElkIHx8IFwiKGltcGxpY2l0KSBcIiArIGdldENsaWVudElkKHRoaXMpKVxuICAgICk7XG4gICAgY29uc3QgcHJlc2VuY2UgPSBmcm9tRGF0YShkYXRhKTtcbiAgICBwcmVzZW5jZS5hY3Rpb24gPSBhY3Rpb247XG4gICAgaWYgKGlkKSB7XG4gICAgICBwcmVzZW5jZS5pZCA9IGlkO1xuICAgIH1cbiAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgfVxuICAgIGF3YWl0IGVuY29kZShwcmVzZW5jZSwgY2hhbm5lbC5jaGFubmVsT3B0aW9ucyk7XG4gICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZSwgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICAgIGNoYW5uZWwuYXR0YWNoKCk7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG4gICAgICAgICAgICBwcmVzZW5jZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXG4gICAgICAgICAgXCJVbmFibGUgdG8gXCIgKyBhY3Rpb24gKyBcIiBwcmVzZW5jZSBjaGFubmVsIHdoaWxlIGluIFwiICsgY2hhbm5lbC5zdGF0ZSArIFwiIHN0YXRlXCIsXG4gICAgICAgICAgOTAwMDFcbiAgICAgICAgKTtcbiAgICAgICAgZXJyLmNvZGUgPSA5MDAwMTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBsZWF2ZShkYXRhKSB7XG4gICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgaGF2ZSBiZWVuIHNwZWNpZmllZCB0byBlbnRlciBvciBsZWF2ZSBhIHByZXNlbmNlIGNoYW5uZWxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlYXZlQ2xpZW50KHZvaWQgMCwgZGF0YSk7XG4gIH1cbiAgYXN5bmMgbGVhdmVDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgIGlmICghY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyBjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLmxlYXZlQ2xpZW50KClcIixcbiAgICAgIFwibGVhdmluZzsgY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUgKyBcIiwgY2xpZW50ID0gXCIgKyBjbGllbnRJZFxuICAgICk7XG4gICAgY29uc3QgcHJlc2VuY2UgPSBmcm9tRGF0YShkYXRhKTtcbiAgICBwcmVzZW5jZS5hY3Rpb24gPSBcImxlYXZlXCI7XG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgIGNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlLCAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgIHByZXNlbmNlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgICAgICBjYXNlIFwiZmFpbGVkXCI6IHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlVuYWJsZSB0byBsZWF2ZSBwcmVzZW5jZSBjaGFubmVsIChpbmNvbXBhdGlibGUgc3RhdGUpXCIsIDkwMDAxKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlamVjdChjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICBjb25zdCB3YWl0Rm9yU3luYyA9ICFwYXJhbXMgfHwgKFwid2FpdEZvclN5bmNcIiBpbiBwYXJhbXMgPyBwYXJhbXMud2FpdEZvclN5bmMgOiB0cnVlKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZnVuY3Rpb24gcmV0dXJuTWVtYmVycyhtZW1iZXJzKSB7XG4gICAgICAgIHJlc29sdmUocGFyYW1zID8gbWVtYmVycy5saXN0KHBhcmFtcykgOiBtZW1iZXJzLnZhbHVlcygpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoYW5uZWwuc3RhdGUgPT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICAgICAgaWYgKHdhaXRGb3JTeW5jKSB7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICAgIGNvZGU6IDkxMDA1LFxuICAgICAgICAgICAgICBtZXNzYWdlOiBcIlByZXNlbmNlIHN0YXRlIGlzIG91dCBvZiBzeW5jIGR1ZSB0byBjaGFubmVsIGJlaW5nIGluIHRoZSBTVVNQRU5ERUQgc3RhdGVcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybk1lbWJlcnModGhpcy5tZW1iZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3YWl0QXR0YWNoZWQoXG4gICAgICAgIHRoaXMuY2hhbm5lbCxcbiAgICAgICAgKGVycikgPT4gcmVqZWN0KGVyciksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjb25zdCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzO1xuICAgICAgICAgIGlmICh3YWl0Rm9yU3luYykge1xuICAgICAgICAgICAgbWVtYmVycy53YWl0U3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBoaXN0b3J5KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lUHJlc2VuY2UuaGlzdG9yeSgpXCIsIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5uYW1lKTtcbiAgICBjb25zdCByZXN0TWl4aW4gPSB0aGlzLmNoYW5uZWwuY2xpZW50LnJlc3QucHJlc2VuY2VNaXhpbjtcbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuICAgICAgaWYgKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgIGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG4gICAgICAgIHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMuY2hhbm5lbC5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgXCJvcHRpb24gdW50aWxBdHRhY2ggcmVxdWlyZXMgdGhlIGNoYW5uZWwgdG8gYmUgYXR0YWNoZWQsIHdhczogXCIgKyB0aGlzLmNoYW5uZWwuc3RhdGUsXG4gICAgICAgICAgNGU0LFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgfVxuICBzZXRQcmVzZW5jZShwcmVzZW5jZVNldCwgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLnNldFByZXNlbmNlKClcIixcbiAgICAgIFwicmVjZWl2ZWQgcHJlc2VuY2UgZm9yIFwiICsgcHJlc2VuY2VTZXQubGVuZ3RoICsgXCIgcGFydGljaXBhbnRzOyBzeW5jQ2hhbm5lbFNlcmlhbCA9IFwiICsgc3luY0NoYW5uZWxTZXJpYWxcbiAgICApO1xuICAgIGxldCBzeW5jQ3Vyc29yLCBtYXRjaDtcbiAgICBjb25zdCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzLCBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsIGJyb2FkY2FzdE1lc3NhZ2VzID0gW10sIGNvbm5JZCA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQ7XG4gICAgaWYgKGlzU3luYykge1xuICAgICAgdGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuICAgICAgaWYgKHN5bmNDaGFubmVsU2VyaWFsICYmIChtYXRjaCA9IHN5bmNDaGFubmVsU2VyaWFsLm1hdGNoKC9eW1xcdy1dKzooLiopJC8pKSkge1xuICAgICAgICBzeW5jQ3Vyc29yID0gbWF0Y2hbMV07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2VuY2VTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByZXNlbmNlID0gZnJvbVZhbHVlczIocHJlc2VuY2VTZXRbaV0pO1xuICAgICAgc3dpdGNoIChwcmVzZW5jZS5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcImxlYXZlXCI6XG4gICAgICAgICAgaWYgKG1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCAmJiAhcHJlc2VuY2UuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgICAgICAgICBteU1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbnRlclwiOlxuICAgICAgICBjYXNlIFwicHJlc2VudFwiOlxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgaWYgKG1lbWJlcnMucHV0KHByZXNlbmNlKSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCkge1xuICAgICAgICAgICAgbXlNZW1iZXJzLnB1dChwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTeW5jICYmICFzeW5jQ3Vyc29yKSB7XG4gICAgICBtZW1iZXJzLmVuZFN5bmMoKTtcbiAgICAgIHRoaXMuY2hhbm5lbC5zeW5jQ2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnJvYWRjYXN0TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByZXNlbmNlID0gYnJvYWRjYXN0TWVzc2FnZXNbaV07XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChwcmVzZW5jZS5hY3Rpb24sIHByZXNlbmNlKTtcbiAgICB9XG4gIH1cbiAgb25BdHRhY2hlZChoYXNQcmVzZW5jZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBoYXNQcmVzZW5jZSA9IFwiICsgaGFzUHJlc2VuY2VcbiAgICApO1xuICAgIGlmIChoYXNQcmVzZW5jZSkge1xuICAgICAgdGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XG4gICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpO1xuICAgIGNvbnN0IHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLCBwZW5kaW5nUHJlc0NvdW50ID0gcGVuZGluZ1ByZXNlbmNlLmxlbmd0aDtcbiAgICBpZiAocGVuZGluZ1ByZXNDb3VudCkge1xuICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICAgIGNvbnN0IHByZXNlbmNlQXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IG11bHRpY2FzdGVyID0gbXVsdGljYXN0ZXJfZGVmYXVsdC5jcmVhdGUodGhpcy5sb2dnZXIpO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlJlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZFwiLFxuICAgICAgICBcInNlbmRpbmcgXCIgKyBwZW5kaW5nUHJlc0NvdW50ICsgXCIgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzXCJcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmdQcmVzQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBldmVudCA9IHBlbmRpbmdQcmVzZW5jZVtpXTtcbiAgICAgICAgcHJlc2VuY2VBcnJheS5wdXNoKGV2ZW50LnByZXNlbmNlKTtcbiAgICAgICAgbXVsdGljYXN0ZXIucHVzaChldmVudC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlQXJyYXksIG11bHRpY2FzdGVyKTtcbiAgICB9XG4gIH1cbiAgYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc1ByZXNlbmNlLCBlcnIpIHtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgdGhpcy5vbkF0dGFjaGVkKGhhc1ByZXNlbmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgdGhpcy5fY2xlYXJNeU1lbWJlcnMoKTtcbiAgICAgICAgdGhpcy5tZW1iZXJzLmNsZWFyKCk7XG4gICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgIHRoaXMuZmFpbFBlbmRpbmdQcmVzZW5jZShlcnIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZmFpbFBlbmRpbmdQcmVzZW5jZShlcnIpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLmZhaWxQZW5kaW5nUHJlc2VuY2VcIixcbiAgICAgICAgXCJjaGFubmVsOyBuYW1lID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSArIFwiLCBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7IGkrKylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZVtpXS5jYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgfVxuICB9XG4gIF9jbGVhck15TWVtYmVycygpIHtcbiAgICB0aGlzLl9teU1lbWJlcnMuY2xlYXIoKTtcbiAgfVxuICBfZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpIHtcbiAgICBjb25zdCBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsIHJlZW50ZXJDYiA9IChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJQcmVzZW5jZSBhdXRvLXJlLWVudGVyIGZhaWxlZDogXCIgKyBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEVyciA9IG5ldyBFcnJvckluZm8obXNnLCA5MTAwNCwgNDAwKTtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpXCIsIG1zZyk7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2VfZGVmYXVsdCh0aGlzLmNoYW5uZWwuc3RhdGUsIHRoaXMuY2hhbm5lbC5zdGF0ZSwgdHJ1ZSwgZmFsc2UsIHdyYXBwZWRFcnIpO1xuICAgICAgICB0aGlzLmNoYW5uZWwuZW1pdChcInVwZGF0ZVwiLCBjaGFuZ2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBtZW1iZXJLZXkgaW4gbXlNZW1iZXJzLm1hcCkge1xuICAgICAgY29uc3QgZW50cnkgPSBteU1lbWJlcnMubWFwW21lbWJlcktleV07XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpXCIsXG4gICAgICAgICdBdXRvLXJlZW50ZXJpbmcgY2xpZW50SWQgXCInICsgZW50cnkuY2xpZW50SWQgKyAnXCIgaW50byB0aGUgcHJlc2VuY2Ugc2V0J1xuICAgICAgKTtcbiAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGVudHJ5LmlkLCBlbnRyeS5jbGllbnRJZCwgZW50cnkuZGF0YSwgXCJlbnRlclwiKSwgcmVlbnRlckNiKTtcbiAgICB9XG4gIH1cbiAgX3N5bnRoZXNpemVMZWF2ZXMoaXRlbXMpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgY29uc3QgcHJlc2VuY2UgPSBmcm9tVmFsdWVzMih7XG4gICAgICAgIGFjdGlvbjogXCJsZWF2ZVwiLFxuICAgICAgICBjb25uZWN0aW9uSWQ6IGl0ZW0uY29ubmVjdGlvbklkLFxuICAgICAgICBjbGllbnRJZDogaXRlbS5jbGllbnRJZCxcbiAgICAgICAgZGF0YTogaXRlbS5kYXRhLFxuICAgICAgICBlbmNvZGluZzogaXRlbS5lbmNvZGluZyxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9KTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuZW1pdChcImxlYXZlXCIsIHByZXNlbmNlKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoLi4uX2FyZ3MpIHtcbiAgICBjb25zdCBhcmdzID0gcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgIGlmIChjaGFubmVsLnN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aHJvdyBFcnJvckluZm8uZnJvbVZhbHVlcyhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpO1xuICAgIH1cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICBhd2FpdCBjaGFubmVsLmF0dGFjaCgpO1xuICB9XG4gIHVuc3Vic2NyaWJlKC4uLl9hcmdzKSB7XG4gICAgY29uc3QgYXJncyA9IHJlYWx0aW1lY2hhbm5lbF9kZWZhdWx0LnByb2Nlc3NMaXN0ZW5lckFyZ3MoX2FyZ3MpO1xuICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICB9XG59O1xudmFyIFByZXNlbmNlTWFwID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHByZXNlbmNlLCBtZW1iZXJLZXkpIHtcbiAgICBzdXBlcihwcmVzZW5jZS5sb2dnZXIpO1xuICAgIHRoaXMucHJlc2VuY2UgPSBwcmVzZW5jZTtcbiAgICB0aGlzLm1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgdGhpcy5tZW1iZXJLZXkgPSBtZW1iZXJLZXk7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xuICB9XG4gIGdldENsaWVudChjbGllbnRJZCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgIGlmIChpdGVtLmNsaWVudElkID09IGNsaWVudElkICYmIGl0ZW0uYWN0aW9uICE9IFwiYWJzZW50XCIpXG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxpc3QocGFyYW1zKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIGNsaWVudElkID0gcGFyYW1zICYmIHBhcmFtcy5jbGllbnRJZCwgY29ubmVjdGlvbklkID0gcGFyYW1zICYmIHBhcmFtcy5jb25uZWN0aW9uSWQsIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgY29uc3QgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImFic2VudFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjbGllbnRJZCAmJiBjbGllbnRJZCAhPSBpdGVtLmNsaWVudElkKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjb25uZWN0aW9uSWQgJiYgY29ubmVjdGlvbklkICE9IGl0ZW0uY29ubmVjdGlvbklkKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHB1dChpdGVtKSB7XG4gICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImVudGVyXCIgfHwgaXRlbS5hY3Rpb24gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgIGl0ZW0gPSBmcm9tVmFsdWVzMihpdGVtKTtcbiAgICAgIGl0ZW0uYWN0aW9uID0gXCJwcmVzZW50XCI7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICBpZiAodGhpcy5yZXNpZHVhbE1lbWJlcnMpXG4gICAgICBkZWxldGUgdGhpcy5yZXNpZHVhbE1lbWJlcnNba2V5XTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgIGlmIChpdGVtLmFjdGlvbiAhPSBcImFic2VudFwiKVxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZW1vdmUoaXRlbSkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgaXRlbSA9IGZyb21WYWx1ZXMyKGl0ZW0pO1xuICAgICAgaXRlbS5hY3Rpb24gPSBcImFic2VudFwiO1xuICAgICAgbWFwW2tleV0gPSBpdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgbWFwW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXJ0U3luYygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC5zdGFydFN5bmMoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArIFwiOyBzeW5jSW5Qcm9ncmVzcyA9IFwiICsgc3luY0luUHJvZ3Jlc3NcbiAgICApO1xuICAgIGlmICghdGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBjb3B5KG1hcCk7XG4gICAgICB0aGlzLnNldEluUHJvZ3Jlc3ModHJ1ZSk7XG4gICAgfVxuICB9XG4gIGVuZFN5bmMoKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUHJlc2VuY2VNYXAuZW5kU3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKHN5bmNJblByb2dyZXNzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlcktleSBpbiBtYXApIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgaWYgKGVudHJ5LmFjdGlvbiA9PT0gXCJhYnNlbnRcIikge1xuICAgICAgICAgIGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wcmVzZW5jZS5fc3ludGhlc2l6ZUxlYXZlcyh2YWx1ZXNBcnJheSh0aGlzLnJlc2lkdWFsTWVtYmVycykpO1xuICAgICAgZm9yIChjb25zdCBtZW1iZXJLZXkgaW4gdGhpcy5yZXNpZHVhbE1lbWJlcnMpIHtcbiAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgICAgdGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwic3luY1wiKTtcbiAgfVxuICB3YWl0U3luYyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUHJlc2VuY2VNYXAud2FpdFN5bmMoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArIFwiOyBzeW5jSW5Qcm9ncmVzcyA9IFwiICsgc3luY0luUHJvZ3Jlc3NcbiAgICApO1xuICAgIGlmICghc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub25jZShcInN5bmNcIiwgY2FsbGJhY2spO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gIH1cbiAgc2V0SW5Qcm9ncmVzcyhpblByb2dyZXNzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUHJlc2VuY2VNYXAuc2V0SW5Qcm9ncmVzcygpXCIsIFwiaW5Qcm9ncmVzcyA9IFwiICsgaW5Qcm9ncmVzcyk7XG4gICAgdGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGluUHJvZ3Jlc3M7XG4gICAgdGhpcy5wcmVzZW5jZS5zeW5jQ29tcGxldGUgPSAhaW5Qcm9ncmVzcztcbiAgfVxufTtcbnZhciByZWFsdGltZXByZXNlbmNlX2RlZmF1bHQgPSBSZWFsdGltZVByZXNlbmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvd2Vic29ja2V0dHJhbnNwb3J0LnRzXG52YXIgc2hvcnROYW1lID0gVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0O1xuZnVuY3Rpb24gaXNOb2RlV2ViU29ja2V0KHdzKSB7XG4gIHJldHVybiAhIXdzLm9uO1xufVxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgdHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSBQbGF0Zm9ybS5Db25maWcudXNlUHJvdG9jb2xIZWFydGJlYXRzO1xuICAgIHRoaXMud3NIb3N0ID0gcGFyYW1zLmhvc3Q7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHJldHVybiAhIVBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQ7XG4gIH1cbiAgY3JlYXRlV2ViU29ja2V0KHVyaSwgY29ubmVjdFBhcmFtcykge1xuICAgIHRoaXMudXJpID0gdXJpICsgdG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFBsYXRmb3JtLkNvbmZpZy5XZWJTb2NrZXQodGhpcy51cmkpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIldlYlNvY2tldFRyYW5zcG9ydDsgdXJpPVwiICsgdGhpcy51cmk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwic3RhcnRpbmdcIik7XG4gICAgdHJhbnNwb3J0X2RlZmF1bHQucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcbiAgICBjb25zdCBzZWxmMiA9IHRoaXMsIHBhcmFtcyA9IHRoaXMucGFyYW1zLCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgY29uc3Qgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/IFwid3NzOi8vXCIgOiBcIndzOi8vXCI7XG4gICAgY29uc3Qgd3NVcmkgPSB3c1NjaGVtZSArIHRoaXMud3NIb3N0ICsgXCI6XCIgKyBkZWZhdWx0c19kZWZhdWx0LmdldFBvcnQob3B0aW9ucykgKyBcIi9cIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwidXJpOiBcIiArIHdzVXJpKTtcbiAgICB3aGVuUHJvbWlzZVNldHRsZXMoXG4gICAgICB0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcygpLFxuICAgICAgZnVuY3Rpb24oZXJyLCBhdXRoUGFyYW1zKSB7XG4gICAgICAgIGlmIChzZWxmMi5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbVN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gaW4gYXV0aFBhcmFtcylcbiAgICAgICAgICBwYXJhbVN0ciArPSBcIiBcIiArIHBhcmFtICsgXCI6IFwiICsgYXV0aFBhcmFtc1twYXJhbV0gKyBcIjtcIjtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHNlbGYyLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgICAgXCJhdXRoUGFyYW1zOlwiICsgcGFyYW1TdHIgKyBcIiBlcnI6IFwiICsgZXJyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBzZWxmMi5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSBwYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSBzZWxmMi53c0Nvbm5lY3Rpb24gPSBzZWxmMi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpO1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5iaW5hcnlUeXBlID0gUGxhdGZvcm0uQ29uZmlnLmJpbmFyeVR5cGU7XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZjIub25Xc09wZW4oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NDbG9zZShldik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NEYXRhKGV2LmRhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgc2VsZjIub25Xc0Vycm9yKGV2KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc05vZGVXZWJTb2NrZXQod3NDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9uKFwicGluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZjIub25BY3Rpdml0eSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgc2VsZjIubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIGNyZWF0aW5nIHdlYnNvY2tldDogZXJyID0gXCIgKyAoZS5zdGFjayB8fCBlLm1lc3NhZ2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmMi5kaXNjb25uZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICBpZiAoIXdzQ29ubmVjdGlvbikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKVwiLCBcIk5vIHNvY2tldCBjb25uZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgd3NDb25uZWN0aW9uLnNlbmQoXG4gICAgICAgIHNlcmlhbGl6ZTIobWVzc2FnZSwgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fTXNnUGFjaywgdGhpcy5wYXJhbXMuZm9ybWF0KVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIkV4Y2VwdGlvbiBmcm9tIHdzIGNvbm5lY3Rpb24gd2hlbiB0cnlpbmcgdG8gc2VuZDogXCIgKyBpbnNwZWN0RXJyb3IoZSk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpXCIsIG1zZyk7XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBuZXcgRXJyb3JJbmZvKG1zZywgNWU0LCA1MDApKTtcbiAgICB9XG4gIH1cbiAgb25Xc0RhdGEoZGF0YSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKVwiLFxuICAgICAgXCJkYXRhIHJlY2VpdmVkOyBsZW5ndGggPSBcIiArIGRhdGEubGVuZ3RoICsgXCI7IHR5cGUgPSBcIiArIHR5cGVvZiBkYXRhXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vblByb3RvY29sTWVzc2FnZShcbiAgICAgICAgZGVzZXJpYWxpemUoXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Nc2dQYWNrLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgdGhpcy5mb3JtYXRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgbWVzc2FnZTogXCIgKyBlLnN0YWNrXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBvbldzT3BlbigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKVwiLCBcIm9wZW5lZCBXZWJTb2NrZXRcIik7XG4gICAgdGhpcy5lbWl0KFwicHJlY29ubmVjdFwiKTtcbiAgfVxuICBvbldzQ2xvc2UoZXYpIHtcbiAgICBsZXQgd2FzQ2xlYW4sIGNvZGU7XG4gICAgaWYgKHR5cGVvZiBldiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb2RlID0gZXYuY29kZTtcbiAgICAgIHdhc0NsZWFuID0gZXYud2FzQ2xlYW4gfHwgY29kZSA9PT0gMWUzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gZXY7XG4gICAgICB3YXNDbGVhbiA9IGNvZGUgPT0gMWUzO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgaWYgKHdhc0NsZWFuKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKClcIiwgXCJDbGVhbmx5IGNsb3NlZCBXZWJTb2NrZXRcIik7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiV2Vic29ja2V0IGNsb3NlZFwiLCA4MDAwMywgNDAwKTtcbiAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiVW5jbGVhbiBkaXNjb25uZWN0aW9uIG9mIFdlYlNvY2tldCA7IGNvZGUgPSBcIiArIGNvZGUsIGVyciA9IG5ldyBFcnJvckluZm8obXNnLCA4MDAwMywgNDAwKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiZGlzcG9zZWRcIik7XG4gIH1cbiAgb25Xc0Vycm9yKGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpXCIsXG4gICAgICBcIkVycm9yIGZyb20gV2ViU29ja2V0OiBcIiArIGVyci5tZXNzYWdlXG4gICAgKTtcbiAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KEVycm9yKGVyci5tZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiXCIpO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgY29uc3Qgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgaWYgKHdzQ29ubmVjdGlvbikge1xuICAgICAgd3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIldlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJjbG9zaW5nIHdlYnNvY2tldFwiKTtcbiAgICAgICAgaWYgKCF3c0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpOiB3c0Nvbm5lY3Rpb24gaXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgd3NDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG52YXIgd2Vic29ja2V0dHJhbnNwb3J0X2RlZmF1bHQgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9maWx0ZXJlZHN1YnNjcmlwdGlvbnMudHNcbnZhciBGaWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSBjbGFzcyB7XG4gIHN0YXRpYyBzdWJzY3JpYmVGaWx0ZXIoY2hhbm5lbCwgZmlsdGVyLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGZpbHRlcmVkTGlzdGVuZXIgPSAobSkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgY29uc3QgbWFwcGluZyA9IHtcbiAgICAgICAgbmFtZTogbS5uYW1lLFxuICAgICAgICByZWZUaW1lc2VyaWFsOiAoX2IgPSAoX2EyID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2IudGltZXNlcmlhbCxcbiAgICAgICAgcmVmVHlwZTogKF9kID0gKF9jID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfZC50eXBlLFxuICAgICAgICBpc1JlZjogISEoKF9mID0gKF9lID0gbS5leHRyYXMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfZi50aW1lc2VyaWFsKSxcbiAgICAgICAgY2xpZW50SWQ6IG0uY2xpZW50SWRcbiAgICAgIH07XG4gICAgICBpZiAoT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5maW5kKFxuICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gbWFwcGluZ1trZXldICE9PSB2YWx1ZSA6IGZhbHNlXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKG0pO1xuICAgIH07XG4gICAgdGhpcy5hZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbihjaGFubmVsLCBmaWx0ZXIsIGxpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKTtcbiAgICBjaGFubmVsLnN1YnNjcmlwdGlvbnMub24oZmlsdGVyZWRMaXN0ZW5lcik7XG4gIH1cbiAgLy8gQWRkcyBhIG5ldyBmaWx0ZXJlZCBzdWJzY3JpcHRpb25cbiAgc3RhdGljIGFkZEZpbHRlcmVkU3Vic2NyaXB0aW9uKGNoYW5uZWwsIGZpbHRlciwgcmVhbExpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoIWNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGlmIChjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgY29uc3QgcmVhbExpc3RlbmVyTWFwID0gY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0KHJlYWxMaXN0ZW5lcik7XG4gICAgICByZWFsTGlzdGVuZXJNYXAuc2V0KGZpbHRlciwgKChfYTIgPSByZWFsTGlzdGVuZXJNYXAgPT0gbnVsbCA/IHZvaWQgMCA6IHJlYWxMaXN0ZW5lck1hcC5nZXQoZmlsdGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb25jYXQoZmlsdGVyZWRMaXN0ZW5lcikpIHx8IFtmaWx0ZXJlZExpc3RlbmVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLnNldChcbiAgICAgICAgcmVhbExpc3RlbmVyLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW2ZpbHRlciwgW2ZpbHRlcmVkTGlzdGVuZXJdXV0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKGNoYW5uZWwsIGZpbHRlciwgcmVhbExpc3RlbmVyKSB7XG4gICAgaWYgKCFjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIXJlYWxMaXN0ZW5lciAmJiBmaWx0ZXIpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmVudHJpZXMoKSkubWFwKChba2V5LCBmaWx0ZXJNYXBzXSkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBsZXQgbGlzdGVuZXJNYXBzID0gZmlsdGVyTWFwcy5nZXQoZmlsdGVyKTtcbiAgICAgICAgZmlsdGVyTWFwcy5kZWxldGUoZmlsdGVyKTtcbiAgICAgICAgaWYgKGZpbHRlck1hcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIChfYTIgPSBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJNYXBzO1xuICAgICAgfSkucmVkdWNlKFxuICAgICAgICAocHJldiwgY3VyKSA9PiBjdXIgPyBwcmV2LmNvbmNhdCguLi5jdXIpIDogcHJldixcbiAgICAgICAgW11cbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVhbExpc3RlbmVyIHx8ICFjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZWFsTGlzdGVuZXJNYXAgPSBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5nZXQocmVhbExpc3RlbmVyKTtcbiAgICBpZiAoIWZpbHRlcikge1xuICAgICAgY29uc3QgbGlzdGVuZXJzMiA9IEFycmF5LmZyb20ocmVhbExpc3RlbmVyTWFwLnZhbHVlcygpKS5yZWR1Y2UoKHByZXYsIGN1cikgPT4gcHJldi5jb25jYXQoLi4uY3VyKSwgW10pO1xuICAgICAgY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZGVsZXRlKHJlYWxMaXN0ZW5lcik7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzMjtcbiAgICB9XG4gICAgbGV0IGxpc3RlbmVycyA9IHJlYWxMaXN0ZW5lck1hcC5nZXQoZmlsdGVyKTtcbiAgICByZWFsTGlzdGVuZXJNYXAuZGVsZXRlKGZpbHRlcik7XG4gICAgcmV0dXJuIGxpc3RlbmVycyB8fCBbXTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2RlZmF1bHRyZWFsdGltZS50c1xudmFyIF9EZWZhdWx0UmVhbHRpbWUgPSBjbGFzcyBfRGVmYXVsdFJlYWx0aW1lIGV4dGVuZHMgYmFzZXJlYWx0aW1lX2RlZmF1bHQge1xuICAvLyBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgcmVxdWlyZXMgYW4gYXJndW1lbnQgdG8gYmUgcGFzc2VkLCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG5vdCBwYXNzIGFuIGFyZ3VtZW50LCB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoaXMgaXMgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIGl0LlxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBNc2dQYWNrID0gX0RlZmF1bHRSZWFsdGltZS5fTXNnUGFjaztcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIERlZmF1bHRSZWFsdGltZS5fTXNnUGFjayB0byBoYXZlIGJlZW4gc2V0XCIpO1xuICAgIH1cbiAgICBzdXBlcihcbiAgICAgIGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCB0cnVlLCBcIlJlYWx0aW1lXCIsIGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGFsbENvbW1vbk1vZHVsYXJQbHVnaW5zKSwge1xuICAgICAgICBDcnlwdG86IChfYTIgPSBfRGVmYXVsdFJlYWx0aW1lLkNyeXB0bykgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCxcbiAgICAgICAgTXNnUGFjayxcbiAgICAgICAgUmVhbHRpbWVQcmVzZW5jZToge1xuICAgICAgICAgIFJlYWx0aW1lUHJlc2VuY2U6IHJlYWx0aW1lcHJlc2VuY2VfZGVmYXVsdCxcbiAgICAgICAgICBwcmVzZW5jZU1lc3NhZ2VGcm9tVmFsdWVzOiBmcm9tVmFsdWVzMixcbiAgICAgICAgICBwcmVzZW5jZU1lc3NhZ2VzRnJvbVZhbHVlc0FycmF5OiBmcm9tVmFsdWVzQXJyYXkyXG4gICAgICAgIH0sXG4gICAgICAgIFdlYlNvY2tldFRyYW5zcG9ydDogd2Vic29ja2V0dHJhbnNwb3J0X2RlZmF1bHQsXG4gICAgICAgIE1lc3NhZ2VJbnRlcmFjdGlvbnM6IEZpbHRlcmVkU3Vic2NyaXB0aW9uc1xuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IENyeXB0bygpIHtcbiAgICBpZiAodGhpcy5fQ3J5cHRvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9DcnlwdG87XG4gIH1cbiAgc3RhdGljIHNldCBDcnlwdG8obmV3VmFsdWUpIHtcbiAgICB0aGlzLl9DcnlwdG8gPSBuZXdWYWx1ZTtcbiAgfVxufTtcbl9EZWZhdWx0UmVhbHRpbWUuVXRpbHMgPSB1dGlsc19leHBvcnRzO1xuX0RlZmF1bHRSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25tYW5hZ2VyX2RlZmF1bHQ7XG5fRGVmYXVsdFJlYWx0aW1lLlByb3RvY29sTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZV9kZWZhdWx0O1xuX0RlZmF1bHRSZWFsdGltZS5fQ3J5cHRvID0gbnVsbDtcbl9EZWZhdWx0UmVhbHRpbWUuTWVzc2FnZSA9IERlZmF1bHRNZXNzYWdlO1xuX0RlZmF1bHRSZWFsdGltZS5QcmVzZW5jZU1lc3NhZ2UgPSBEZWZhdWx0UHJlc2VuY2VNZXNzYWdlO1xuX0RlZmF1bHRSZWFsdGltZS5fTXNnUGFjayA9IG51bGw7XG4vLyBVc2VkIGJ5IHRlc3RzXG5fRGVmYXVsdFJlYWx0aW1lLl9IdHRwID0gSHR0cDtcbnZhciBEZWZhdWx0UmVhbHRpbWUgPSBfRGVmYXVsdFJlYWx0aW1lO1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi91dGlsL2J1ZmZlcnV0aWxzLnRzXG52YXIgaW1wb3J0X2NyeXB0byA9IF9fdG9FU00ocmVxdWlyZShcImNyeXB0b1wiKSk7XG52YXIgQnVmZmVyVXRpbHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmFzZTY0Q2hhclNldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICAgIHRoaXMuaGV4Q2hhclNldCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB9XG4gIGJhc2U2NERlY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyaW5nLCBcImJhc2U2NFwiKTtcbiAgfVxuICBiYXNlNjRFbmNvZGUoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoYnVmZmVyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgfVxuICBhcmVCdWZmZXJzRXF1YWwoYnVmZmVyMSwgYnVmZmVyMikge1xuICAgIGlmICghYnVmZmVyMSB8fCAhYnVmZmVyMilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIxKS5jb21wYXJlKHRoaXMudG9CdWZmZXIoYnVmZmVyMikpID09IDA7XG4gIH1cbiAgYnl0ZUxlbmd0aChidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH1cbiAgaGV4RGVjb2RlKHN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmcsIFwiaGV4XCIpO1xuICB9XG4gIGhleEVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIC8qIEluIG5vZGUsIEJ1ZmZlclV0aWxzIG1ldGhvZHMgdGhhdCByZXR1cm4gYmluYXJ5IG9iamVjdHMgcmV0dXJuIGEgQnVmZmVyXG4gICAqIGZvciBoaXN0b3JpY2FsIHJlYXNvbnM7IHRoZSBicm93c2VyIGVxdWl2YWxlbnRzIHJldHVybiBBcnJheUJ1ZmZlcnMgKi9cbiAgaXNCdWZmZXIoYnVmZmVyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpIHx8IGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpO1xuICB9XG4gIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgY29uc3Qgbm9kZUJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoYnVmZmVyKTtcbiAgICByZXR1cm4gbm9kZUJ1ZmZlci5idWZmZXIuc2xpY2Uobm9kZUJ1ZmZlci5ieXRlT2Zmc2V0LCBub2RlQnVmZmVyLmJ5dGVPZmZzZXQgKyBub2RlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHRvQnVmZmVyKGJ1ZmZlcikge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgYXJyYXlCdWZmZXJWaWV3VG9CdWZmZXIoYXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoYXJyYXlCdWZmZXJWaWV3KTtcbiAgfVxuICB1dGY4RGVjb2RlKGJ1ZmZlcikge1xuICAgIGlmICghdGhpcy5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCBvZiB1dGY4RGVjb2RlIHRvIGJlIGEgYnVmZmVyLCBhcnJheWJ1ZmZlciwgb3Igdmlld1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoYnVmZmVyKS50b1N0cmluZyhcInV0ZjhcIik7XG4gIH1cbiAgdXRmOEVuY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyaW5nLCBcInV0ZjhcIik7XG4gIH1cbiAgaG1hY1NoYTI1NihtZXNzYWdlLCBrZXkpIHtcbiAgICBjb25zdCBtZXNzYWdlQnVmZmVyID0gdGhpcy50b0J1ZmZlcihtZXNzYWdlKTtcbiAgICBjb25zdCBrZXlCdWZmZXIgPSB0aGlzLnRvQnVmZmVyKGtleSk7XG4gICAgY29uc3QgaG1hYzIgPSBpbXBvcnRfY3J5cHRvLmRlZmF1bHQuY3JlYXRlSG1hYyhcIlNIQTI1NlwiLCBrZXlCdWZmZXIpO1xuICAgIGhtYWMyLnVwZGF0ZShtZXNzYWdlQnVmZmVyKTtcbiAgICByZXR1cm4gaG1hYzIuZGlnZXN0KCk7XG4gIH1cbn07XG52YXIgYnVmZmVydXRpbHNfZGVmYXVsdCA9IG5ldyBCdWZmZXJVdGlscygpO1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi91dGlsL2NyeXB0by50c1xudmFyIGltcG9ydF9jcnlwdG8yID0gX190b0VTTShyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbnZhciBpbXBvcnRfdXRpbCA9IF9fdG9FU00ocmVxdWlyZShcInV0aWxcIikpO1xudmFyIGNyZWF0ZUNyeXB0b0NsYXNzID0gZnVuY3Rpb24oYnVmZmVyVXRpbHMpIHtcbiAgdmFyIERFRkFVTFRfQUxHT1JJVEhNID0gXCJhZXNcIjtcbiAgdmFyIERFRkFVTFRfS0VZTEVOR1RIID0gMjU2O1xuICB2YXIgREVGQVVMVF9NT0RFID0gXCJjYmNcIjtcbiAgdmFyIERFRkFVTFRfQkxPQ0tMRU5HVEggPSAxNjtcbiAgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb20oYnl0ZXMpIHtcbiAgICByZXR1cm4gaW1wb3J0X3V0aWwuZGVmYXVsdC5wcm9taXNpZnkoaW1wb3J0X2NyeXB0bzIuZGVmYXVsdC5yYW5kb21CeXRlcykoYnl0ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpIHtcbiAgICByZXR1cm4gcGxhaW50ZXh0TGVuZ3RoICsgREVGQVVMVF9CTE9DS0xFTkdUSCAmIC1ERUZBVUxUX0JMT0NLTEVOR1RIO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMuYWxnb3JpdGhtID09PSBcImFlc1wiICYmIHBhcmFtcy5tb2RlID09PSBcImNiY1wiKSB7XG4gICAgICBpZiAocGFyYW1zLmtleUxlbmd0aCA9PT0gMTI4IHx8IHBhcmFtcy5rZXlMZW5ndGggPT09IDI1Nikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVW5zdXBwb3J0ZWQga2V5IGxlbmd0aCBcIiArIHBhcmFtcy5rZXlMZW5ndGggKyBcIiBmb3IgYWVzLWNiYyBlbmNyeXB0aW9uLiBFbmNyeXB0aW9uIGtleSBtdXN0IGJlIDEyOCBvciAyNTYgYml0cyAoMTYgb3IgMzIgQVNDSUkgY2hhcmFjdGVycylcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXNlQmFzZTY0KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShcIl9cIiwgXCIvXCIpLnJlcGxhY2UoXCItXCIsIFwiK1wiKTtcbiAgfVxuICBmdW5jdGlvbiBmaWxsZWRCdWZmZXIobGVuZ3RoLCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICByZXN1bHQuZmlsbCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgcGtjczVQYWRkaW5nID0gW2ZpbGxlZEJ1ZmZlcigxNiwgMTYpXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMTY7IGkrKylcbiAgICBwa2NzNVBhZGRpbmcucHVzaChmaWxsZWRCdWZmZXIoaSwgaSkpO1xuICBjbGFzcyBDaXBoZXJQYXJhbXMge1xuICAgIGNvbnN0cnVjdG9yKGFsZ29yaXRobSwga2V5TGVuZ3RoLCBtb2RlLCBrZXkpIHtcbiAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgdGhpcy5rZXlMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLml2ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNJbnN0Q2lwaGVyUGFyYW1zKHBhcmFtcykge1xuICAgIHJldHVybiAhIShwYXJhbXMuYWxnb3JpdGhtICYmIHBhcmFtcy5rZXkgJiYgcGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMubW9kZSk7XG4gIH1cbiAgY2xhc3MgQ3J5cHRvMiB7XG4gICAgLyoqXG4gICAgICogT2J0YWluIGEgY29tcGxldGUgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHBhcmFtcywgZmlsbGluZ1xuICAgICAqIGluIGFueSBub3QgcHJvdmlkZWQgd2l0aCBkZWZhdWx0IHZhbHVlcywgY2FsY3VsYXRpbmcgYSBrZXlMZW5ndGggZnJvbVxuICAgICAqIHRoZSBzdXBwbGllZCBrZXksIGFuZCB2YWxpZGF0aW5nIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHBhcmFtcyBhbiBvYmplY3QgY29udGFpbmluZyBhdCBhIG1pbmltdW0gYSBga2V5YCBrZXkgd2l0aCB2YWx1ZSB0aGVcbiAgICAgKiBrZXksIGFzIGVpdGhlciBhIGJpbmFyeSBvciBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKiBNYXkgb3B0aW9uYWxseSBhbHNvIGNvbnRhaW46IGFsZ29yaXRobSAoZGVmYXVsdHMgdG8gQUVTKSxcbiAgICAgKiBtb2RlIChkZWZhdWx0cyB0byAnY2JjJylcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBpZiAoIXBhcmFtcy5rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMua2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGtleSA9IGJ1ZmZlclV0aWxzLmJhc2U2NERlY29kZShub3JtYWxpc2VCYXNlNjQocGFyYW1zLmtleSkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMua2V5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAga2V5ID0gQnVmZmVyLmZyb20ocGFyYW1zLmtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBwYXJhbXMua2V5O1xuICAgICAgfVxuICAgICAgdmFyIGFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gfHwgREVGQVVMVF9BTEdPUklUSE07XG4gICAgICB2YXIga2V5TGVuZ3RoID0ga2V5Lmxlbmd0aCAqIDg7XG4gICAgICB2YXIgbW9kZSA9IHBhcmFtcy5tb2RlIHx8IERFRkFVTFRfTU9ERTtcbiAgICAgIHZhciBjaXBoZXJQYXJhbXMgPSBuZXcgQ2lwaGVyUGFyYW1zKGFsZ29yaXRobSwga2V5TGVuZ3RoLCBtb2RlLCBrZXkpO1xuICAgICAgaWYgKHBhcmFtcy5rZXlMZW5ndGggJiYgcGFyYW1zLmtleUxlbmd0aCAhPT0gY2lwaGVyUGFyYW1zLmtleUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXlMZW5ndGggb2YgXCIgKyBwYXJhbXMua2V5TGVuZ3RoICsgXCIgd2FzIHNwZWNpZmllZCwgYnV0IHRoZSBrZXkgYWN0dWFsbHkgaGFzIGxlbmd0aCBcIiArIGNpcGhlclBhcmFtcy5rZXlMZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKGNpcGhlclBhcmFtcyk7XG4gICAgICByZXR1cm4gY2lwaGVyUGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBlbmNyeXB0aW9uIGtleSBmcm9tIHRoZSBzdXBwbGllZCBrZXlsZW5ndGggKG9yIHRoZVxuICAgICAqIGRlZmF1bHQga2V5TGVuZ3RoIGlmIG5vbmUgc3VwcGxpZWQpIGFzIGEgQnVmZmVyXG4gICAgICogQHBhcmFtIGtleUxlbmd0aCAob3B0aW9uYWwpIHRoZSByZXF1aXJlZCBrZXlMZW5ndGggaW4gYml0c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZVJhbmRvbUtleShrZXlMZW5ndGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVJhbmRvbSgoa2V5TGVuZ3RoIHx8IERFRkFVTFRfS0VZTEVOR1RIKSAvIDgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmFuZG9tIGtleTogXCIgKyBlcnIubWVzc2FnZSwgNTAwLCA1ZTQsIGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsOyBnZXQgYSBDaGFubmVsQ2lwaGVyIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBnaXZlbiBjaXBoZXJQYXJhbXNcbiAgICAgKiBAcGFyYW0gcGFyYW1zIGVpdGhlciBhIENpcGhlclBhcmFtcyBpbnN0YW5jZSBvciBzb21lIHN1YnNldCBvZiBpdHNcbiAgICAgKiBmaWVsZHMgdGhhdCBpbmNsdWRlcyBhIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaXBoZXIocGFyYW1zLCBsb2dnZXIpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICB2YXIgY2lwaGVyUGFyYW1zID0gaXNJbnN0Q2lwaGVyUGFyYW1zKHBhcmFtcykgPyBwYXJhbXMgOiB0aGlzLmdldERlZmF1bHRQYXJhbXMocGFyYW1zKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpcGhlclBhcmFtcyxcbiAgICAgICAgY2lwaGVyOiBuZXcgQ0JDQ2lwaGVyKGNpcGhlclBhcmFtcywgKF9hMiA9IHBhcmFtcy5pdikgIT0gbnVsbCA/IF9hMiA6IG51bGwsIGxvZ2dlcilcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIENyeXB0bzIuQ2lwaGVyUGFyYW1zID0gQ2lwaGVyUGFyYW1zO1xuICBDcnlwdG8yO1xuICBjbGFzcyBDQkNDaXBoZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcywgaXYsIGxvZ2dlcikge1xuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICB0aGlzLmVuY3J5cHRDaXBoZXIgPSBudWxsO1xuICAgICAgdGhpcy5hbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtICsgXCItXCIgKyBTdHJpbmcocGFyYW1zLmtleUxlbmd0aCkgKyBcIi1cIiArIHBhcmFtcy5tb2RlO1xuICAgICAgdGhpcy5rZXkgPSBwYXJhbXMua2V5O1xuICAgICAgdGhpcy5pdiA9IGl2O1xuICAgIH1cbiAgICBhc3luYyBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ0JDQ2lwaGVyLmVuY3J5cHQoKVwiLCBcIlwiKTtcbiAgICAgIGNvbnN0IGl2ID0gYXdhaXQgdGhpcy5nZXRJdigpO1xuICAgICAgaWYgKCF0aGlzLmVuY3J5cHRDaXBoZXIpIHtcbiAgICAgICAgdGhpcy5lbmNyeXB0Q2lwaGVyID0gaW1wb3J0X2NyeXB0bzIuZGVmYXVsdC5jcmVhdGVDaXBoZXJpdih0aGlzLmFsZ29yaXRobSwgdGhpcy5rZXksIGl2KTtcbiAgICAgIH1cbiAgICAgIHZhciBwbGFpbnRleHRCdWZmZXIgPSBidWZmZXJVdGlscy50b0J1ZmZlcihwbGFpbnRleHQpO1xuICAgICAgdmFyIHBsYWludGV4dExlbmd0aCA9IHBsYWludGV4dEJ1ZmZlci5sZW5ndGgsIHBhZGRlZExlbmd0aCA9IGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpO1xuICAgICAgdmFyIGNpcGhlck91dCA9IHRoaXMuZW5jcnlwdENpcGhlci51cGRhdGUoXG4gICAgICAgIEJ1ZmZlci5jb25jYXQoW3BsYWludGV4dEJ1ZmZlciwgcGtjczVQYWRkaW5nW3BhZGRlZExlbmd0aCAtIHBsYWludGV4dExlbmd0aF1dKVxuICAgICAgKTtcbiAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmNvbmNhdChbaXYsIGNpcGhlck91dF0pO1xuICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgdmFyIGRlY3J5cHRDaXBoZXIgPSBpbXBvcnRfY3J5cHRvMi5kZWZhdWx0LmNyZWF0ZURlY2lwaGVyaXYodGhpcy5hbGdvcml0aG0sIHRoaXMua2V5LCBjaXBoZXJ0ZXh0LnNsaWNlKDAsIERFRkFVTFRfQkxPQ0tMRU5HVEgpKSwgcGxhaW50ZXh0ID0gZGVjcnlwdENpcGhlci51cGRhdGUoY2lwaGVydGV4dC5zbGljZShERUZBVUxUX0JMT0NLTEVOR1RIKSksIGZpbmFsID0gZGVjcnlwdENpcGhlci5maW5hbCgpO1xuICAgICAgaWYgKGZpbmFsICYmIGZpbmFsLmxlbmd0aClcbiAgICAgICAgcGxhaW50ZXh0ID0gQnVmZmVyLmNvbmNhdChbcGxhaW50ZXh0LCBmaW5hbF0pO1xuICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SXYoKSB7XG4gICAgICBpZiAodGhpcy5pdikge1xuICAgICAgICB2YXIgaXYgPSB0aGlzLml2O1xuICAgICAgICB0aGlzLml2ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGl2O1xuICAgICAgfVxuICAgICAgdmFyIHJhbmRvbUJsb2NrID0gYXdhaXQgZ2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCk7XG4gICAgICBpZiAoIXRoaXMuZW5jcnlwdENpcGhlcikge1xuICAgICAgICByZXR1cm4gcmFuZG9tQmxvY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0Q2lwaGVyLnVwZGF0ZShyYW5kb21CbG9jayk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBDcnlwdG8yO1xufTtcblxuLy8gc3JjL3BsYXRmb3JtL25vZGVqcy9saWIvdXRpbC9odHRwLnRzXG52YXIgaW1wb3J0X2dvdCA9IF9fdG9FU00ocmVxdWlyZShcImdvdFwiKSk7XG52YXIgaW1wb3J0X2h0dHA1ID0gX190b0VTTShyZXF1aXJlKFwiaHR0cFwiKSk7XG52YXIgaW1wb3J0X2h0dHBzID0gX190b0VTTShyZXF1aXJlKFwiaHR0cHNcIikpO1xudmFyIGdsb2JhbEFnZW50UG9vbCA9IFtdO1xudmFyIF9hO1xudmFyIEh0dHAyID0gKF9hID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmFnZW50ID0gbnVsbDtcbiAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydHNMaW5rSGVhZGVycyA9IHRydWU7XG4gICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgaWYgKChfYTIgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vcHRpb25zLmRpc2FibGVDb25uZWN0aXZpdHlDaGVjaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gKChfYiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCkgfHwgZGVmYXVsdHNfZGVmYXVsdC5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gKF9kID0gKF9jID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zKSAhPSBudWxsID8gX2QgOiBudWxsO1xuICAgICAgY29uc3QgY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0ID0gISgoX2UgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpO1xuICAgICAgY29uc3QgeyBlcnJvciwgc3RhdHVzQ29kZSwgYm9keSB9ID0gYXdhaXQgdGhpcy5kb1VyaShcbiAgICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsXG4gICAgICAgIGNvbm5lY3Rpdml0eUNoZWNrVXJsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBjb25uZWN0aXZpdHlDaGVja1BhcmFtc1xuICAgICAgKTtcbiAgICAgIGlmICghZXJyb3IgJiYgIWNvbm5lY3Rpdml0eVVybElzRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gaXNTdWNjZXNzQ29kZShzdGF0dXNDb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhZXJyb3IgJiYgKGJvZHkgPT0gbnVsbCA/IHZvaWQgMCA6IGJvZHkudG9TdHJpbmcoKS50cmltKCkpID09PSBcInllc1wiO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQgIT0gbnVsbCA/IGNsaWVudCA6IG51bGw7XG4gIH1cbiAgYXN5bmMgZG9VcmkobWV0aG9kLCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcykge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3QgYWdlbnRPcHRpb25zID0gdGhpcy5jbGllbnQgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5yZXN0QWdlbnRPcHRpb25zIHx8IGRlZmF1bHRzX2RlZmF1bHQucmVzdEFnZW50T3B0aW9ucztcbiAgICBjb25zdCBkb09wdGlvbnMgPSB7IGhlYWRlcnM6IGhlYWRlcnMgfHwgdm9pZCAwLCByZXNwb25zZVR5cGU6IFwiYnVmZmVyXCIgfTtcbiAgICBpZiAoIXRoaXMuYWdlbnQpIHtcbiAgICAgIGNvbnN0IHBlcnNpc3RlZEFnZW50ID0gKF9hMiA9IGdsb2JhbEFnZW50UG9vbC5maW5kKCh4KSA9PiBzaGFsbG93RXF1YWxzKGFnZW50T3B0aW9ucywgeC5vcHRpb25zKSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYWdlbnRzO1xuICAgICAgaWYgKHBlcnNpc3RlZEFnZW50KSB7XG4gICAgICAgIHRoaXMuYWdlbnQgPSBwZXJzaXN0ZWRBZ2VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWdlbnQgPSB7XG4gICAgICAgICAgaHR0cDogbmV3IGltcG9ydF9odHRwNS5kZWZhdWx0LkFnZW50KGFnZW50T3B0aW9ucyksXG4gICAgICAgICAgaHR0cHM6IG5ldyBpbXBvcnRfaHR0cHMuZGVmYXVsdC5BZ2VudChhZ2VudE9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICAgIGdsb2JhbEFnZW50UG9vbC5wdXNoKHtcbiAgICAgICAgICBvcHRpb25zOiBhZ2VudE9wdGlvbnMsXG4gICAgICAgICAgYWdlbnRzOiB0aGlzLmFnZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm9keSkge1xuICAgICAgZG9PcHRpb25zLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICBpZiAocGFyYW1zKVxuICAgICAgZG9PcHRpb25zLnNlYXJjaFBhcmFtcyA9IHBhcmFtcztcbiAgICBkb09wdGlvbnMuYWdlbnQgPSB0aGlzLmFnZW50O1xuICAgIGRvT3B0aW9ucy51cmwgPSB1cmk7XG4gICAgZG9PcHRpb25zLnRpbWVvdXQgPSB7XG4gICAgICByZXF1ZXN0OiAodGhpcy5jbGllbnQgJiYgdGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cyB8fCBkZWZhdWx0c19kZWZhdWx0LlRJTUVPVVRTKS5odHRwUmVxdWVzdFRpbWVvdXRcbiAgICB9O1xuICAgIGRvT3B0aW9ucy5yZXRyeSA9IHsgbGltaXQ6IDAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgaW1wb3J0X2dvdC5kZWZhdWx0W21ldGhvZF0oZG9PcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyKG51bGwsIHJlcywgcmVzLmJvZHkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGltcG9ydF9nb3QuZGVmYXVsdC5IVFRQRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXIobnVsbCwgZXJyLnJlc3BvbnNlLCBlcnIucmVzcG9uc2UuYm9keSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlcihlcnIpO1xuICAgIH1cbiAgfVxuICBzaG91bGRGYWxsYmFjayhlcnIpIHtcbiAgICBjb25zdCB7IGNvZGUsIHN0YXR1c0NvZGUgfSA9IGVycjtcbiAgICByZXR1cm4gY29kZSA9PT0gXCJFTkVUVU5SRUFDSFwiIHx8IGNvZGUgPT09IFwiRUhPU1RVTlJFQUNIXCIgfHwgY29kZSA9PT0gXCJFSE9TVERPV05cIiB8fCBjb2RlID09PSBcIkVUSU1FRE9VVFwiIHx8IGNvZGUgPT09IFwiRVNPQ0tFVFRJTUVET1VUXCIgfHwgY29kZSA9PT0gXCJFTk9URk9VTkRcIiB8fCBjb2RlID09PSBcIkVDT05OUkVTRVRcIiB8fCBjb2RlID09PSBcIkVDT05OUkVGVVNFRFwiIHx8IHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0O1xuICB9XG4gIF9oYW5kbGVyKGVyciwgcmVzcG9uc2UsIGJvZHkpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBlcnIgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGUsIGhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzO1xuICAgIGlmIChzdGF0dXNDb2RlID49IDMwMCkge1xuICAgICAgc3dpdGNoIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSB7XG4gICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9qc29uXCI6XG4gICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi94LW1zZ3BhY2tcIjpcbiAgICAgICAgICBpZiAoISgoX2EyID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuX01zZ1BhY2spKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKFwiTXNnUGFja1wiKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBib2R5ID0gdGhpcy5jbGllbnQuX01zZ1BhY2suZGVjb2RlKGJvZHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBib2R5LmVycm9yID8gRXJyb3JJbmZvLmZyb21WYWx1ZXMoYm9keS5lcnJvcikgOiBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBoZWFkZXJzW1wieC1hYmx5LWVycm9ybWVzc2FnZVwiXSB8fCBcIkVycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIiArIHN0YXR1c0NvZGUgKyBcIiBib2R5IHdhczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChib2R5KSxcbiAgICAgICAgTnVtYmVyKGhlYWRlcnNbXCJ4LWFibHktZXJyb3Jjb2RlXCJdKSxcbiAgICAgICAgc3RhdHVzQ29kZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IGVycm9yLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZDogdHJ1ZSwgc3RhdHVzQ29kZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlcnJvcjogbnVsbCwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQ6IGZhbHNlLCBzdGF0dXNDb2RlIH07XG4gIH1cbn0sIF9hLm1ldGhvZHMgPSBbSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuRGVsZXRlLCBIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlBhdGNoXSwgX2EubWV0aG9kc1dpdGhvdXRCb2R5ID0gW0h0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBIdHRwTWV0aG9kc19kZWZhdWx0LkRlbGV0ZV0sIF9hLm1ldGhvZHNXaXRoQm9keSA9IFtIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlBhdGNoXSwgX2EpO1xudmFyIGh0dHBfZGVmYXVsdCA9IEh0dHAyO1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2NvbmZpZy50c1xudmFyIGltcG9ydF9jcnlwdG8zID0gX190b0VTTShyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbnZhciBpbXBvcnRfd3MgPSBfX3RvRVNNKHJlcXVpcmUoXCJ3c1wiKSk7XG52YXIgaW1wb3J0X3V0aWwyID0gX190b0VTTShyZXF1aXJlKFwidXRpbFwiKSk7XG52YXIgQ29uZmlnID0ge1xuICBhZ2VudDogXCJub2RlanMvXCIgKyBwcm9jZXNzLnZlcnNpb25zLm5vZGUsXG4gIGxvZ1RpbWVzdGFtcHM6IHRydWUsXG4gIHVzZXJBZ2VudDogbnVsbCxcbiAgYmluYXJ5VHlwZTogXCJub2RlYnVmZmVyXCIsXG4gIFdlYlNvY2tldDogaW1wb3J0X3dzLmRlZmF1bHQsXG4gIHVzZVByb3RvY29sSGVhcnRiZWF0czogZmFsc2UsXG4gIHN1cHBvcnRzQmluYXJ5OiB0cnVlLFxuICBwcmVmZXJCaW5hcnk6IHRydWUsXG4gIG5leHRUaWNrOiBwcm9jZXNzLm5leHRUaWNrLFxuICBpbnNwZWN0OiBpbXBvcnRfdXRpbDIuZGVmYXVsdC5pbnNwZWN0LFxuICBzdHJpbmdCeXRlU2l6ZTogQnVmZmVyLmJ5dGVMZW5ndGgsXG4gIGluaGVyaXRzOiBpbXBvcnRfdXRpbDIuZGVmYXVsdC5pbmhlcml0cyxcbiAgYWRkRXZlbnRMaXN0ZW5lcjogbnVsbCxcbiAgZ2V0UmFuZG9tQXJyYXlCdWZmZXI6IGFzeW5jIGZ1bmN0aW9uKGJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gaW1wb3J0X3V0aWwyLmRlZmF1bHQucHJvbWlzaWZ5KGltcG9ydF9jcnlwdG8zLmRlZmF1bHQucmFuZG9tQnl0ZXMpKGJ5dGVMZW5ndGgpO1xuICB9XG59O1xudmFyIGNvbmZpZ19kZWZhdWx0ID0gQ29uZmlnO1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9YSFJTdGF0ZXMudHNcbnZhciBYSFJTdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gKChYSFJTdGF0ZXMyKSA9PiB7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9TRU5EXCJdID0gMF0gPSBcIlJFUV9TRU5EXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWXCJdID0gMV0gPSBcIlJFUV9SRUNWXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWX1BPTExcIl0gPSAyXSA9IFwiUkVRX1JFQ1ZfUE9MTFwiO1xuICBYSFJTdGF0ZXMyW1hIUlN0YXRlczJbXCJSRVFfUkVDVl9TVFJFQU1cIl0gPSAzXSA9IFwiUkVRX1JFQ1ZfU1RSRUFNXCI7XG4gIHJldHVybiBYSFJTdGF0ZXMyO1xufSkoWEhSU3RhdGVzIHx8IHt9KTtcbnZhciBYSFJTdGF0ZXNfZGVmYXVsdCA9IFhIUlN0YXRlcztcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L2NvbWV0dHJhbnNwb3J0LnRzXG5mdW5jdGlvbiBzaG91bGRCZUVycm9yQWN0aW9uKGVycikge1xuICBjb25zdCBVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMgPSBbODAwMTUsIDgwMDE3LCA4MDAzMF07XG4gIGlmIChlcnIuY29kZSkge1xuICAgIGlmIChhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihlcnIpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyLmNvZGUpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGVyci5jb2RlID49IDRlNCAmJiBlcnIuY29kZSA8IDVlNDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpIHtcbiAgaWYgKHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSkge1xuICAgIHJldHVybiBbZnJvbVZhbHVlczMoeyBhY3Rpb246IGFjdGlvbnMyLkVSUk9SLCBlcnJvcjogZXJyIH0pXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2Zyb21WYWx1ZXMzKHsgYWN0aW9uOiBhY3Rpb25zMi5ESVNDT05ORUNURUQsIGVycm9yOiBlcnIgfSldO1xuICB9XG59XG52YXIgQ29tZXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIHRyYW5zcG9ydF9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgIHN1cGVyKFxuICAgICAgY29ubmVjdGlvbk1hbmFnZXIsXG4gICAgICBhdXRoLFxuICAgICAgcGFyYW1zLFxuICAgICAgLyogYmluYXJ5IG5vdCBzdXBwb3J0ZWQgZm9yIGNvbWV0IHNvIGZvcmNlIEpTT04gcHJvdG9jb2wgKi9cbiAgICAgIHRydWVcbiAgICApO1xuICAgIC8qIEhpc3RvcmljYWwgY29tbWVudCwgYmFjayBmcm9tIHdoZW4gd2Ugc3VwcG9ydGVkIEpTT05QOlxuICAgICAqXG4gICAgICogPiBGb3IgY29tZXQsIHdlIGNvdWxkIGRvIHRoZSBhdXRoIHVwZGF0ZSBieSBhYm9ydGluZyB0aGUgY3VycmVudCByZWN2IGFuZFxuICAgICAqID4gc3RhcnRpbmcgYSBuZXcgb25lIHdpdGggdGhlIG5ldyB0b2tlbiwgdGhhdCdkIGJlIHN1ZmZpY2llbnQgZm9yIHJlYWx0aW1lLlxuICAgICAqID4gUHJvYmxlbSBpcyBKU09OUCAtIHlvdSBjYW4ndCBjYW5jZWwgdHJ1bHkgYWJvcnQgYSByZWN2IG9uY2Ugc3RhcnRlZC4gU29cbiAgICAgKiA+IHdlIG5lZWQgdG8gc2VuZCBhbiBBVVRIIGZvciBqc29ucC4gSW4gd2hpY2ggY2FzZSBpdCdzIHNpbXBsZXIgdG8ga2VlcCBhbGxcbiAgICAgKiA+IGNvbWV0IHRyYW5zcG9ydHMgdGhlIHNhbWUgYW5kIGRvIGl0IGZvciBhbGwgb2YgdGhlbS4gU28gd2Ugc2VuZCB0aGUgQVVUSFxuICAgICAqID4gaW5zdGVhZCwgYW5kIGRvbid0IG5lZWQgdG8gYWJvcnQgdGhlIHJlY3ZcbiAgICAgKlxuICAgICAqIE5vdyB0aGF0IHdl4oCZdmUgZHJvcHBlZCBKU09OUCBzdXBwb3J0LCB3ZSBtYXkgYmUgYWJsZSB0byByZXZpc2l0IHRoZSBhYm92ZTtcbiAgICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXMvMTIxNC5cbiAgICAgKi9cbiAgICB0aGlzLm9uQXV0aFVwZGF0ZWQgPSAodG9rZW5EZXRhaWxzKSA9PiB7XG4gICAgICB0aGlzLmF1dGhQYXJhbXMgPSB7IGFjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VuIH07XG4gICAgfTtcbiAgICB0aGlzLnN0cmVhbSA9IFwic3RyZWFtXCIgaW4gcGFyYW1zID8gcGFyYW1zLnN0cmVhbSA6IHRydWU7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nQ2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLCBcInN0YXJ0aW5nXCIpO1xuICAgIHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuICAgIGNvbnN0IGhvc3QgPSBkZWZhdWx0c19kZWZhdWx0LmdldEhvc3Qob3B0aW9ucywgcGFyYW1zLmhvc3QpO1xuICAgIGNvbnN0IHBvcnQgPSBkZWZhdWx0c19kZWZhdWx0LmdldFBvcnQob3B0aW9ucyk7XG4gICAgY29uc3QgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/IFwiaHR0cHM6Ly9cIiA6IFwiaHR0cDovL1wiO1xuICAgIHRoaXMuYmFzZVVyaSA9IGNvbWV0U2NoZW1lICsgaG9zdCArIFwiOlwiICsgcG9ydCArIFwiL2NvbWV0L1wiO1xuICAgIGNvbnN0IGNvbm5lY3RVcmkgPSB0aGlzLmJhc2VVcmkgKyBcImNvbm5lY3RcIjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIiwgXCJ1cmk6IFwiICsgY29ubmVjdFVyaSk7XG4gICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKCksIChlcnIsIGF1dGhQYXJhbXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRoUGFyYW1zID0gYXV0aFBhcmFtcztcbiAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSB0aGlzLnBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuICAgICAgaWYgKFwic3RyZWFtXCIgaW4gY29ubmVjdFBhcmFtcylcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBjb25uZWN0UGFyYW1zLnN0cmVhbTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb21ldFRyYW5zcG9ydC5jb25uZWN0KClcIixcbiAgICAgICAgXCJjb25uZWN0UGFyYW1zOlwiICsgdG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKVxuICAgICAgKTtcbiAgICAgIGxldCBwcmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbm5lY3RSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgICAgY29ubmVjdFVyaSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY29ubmVjdFBhcmFtcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVlxuICAgICAgKTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICBwcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZW1pdChcInByZWNvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycjIpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgZXJyMiA9IGVycjIgfHwgbmV3IEVycm9ySW5mbyhcIlJlcXVlc3QgY2FuY2VsbGVkXCIsIDgwMDAzLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICBpZiAoIXByZWNvbm5lY3RlZCAmJiAhZXJyMikge1xuICAgICAgICAgIHByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicHJlY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICBpZiAoZXJyMi5jb2RlKSB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVjdigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29ubmVjdFJlcXVlc3QuZXhlYygpO1xuICAgIH0pO1xuICB9XG4gIHJlcXVlc3RDbG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKVwiKTtcbiAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QodHJ1ZSk7XG4gIH1cbiAgcmVxdWVzdERpc2Nvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKVwiKTtcbiAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoZmFsc2UpO1xuICB9XG4gIF9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoY2xvc2luZykge1xuICAgIGNvbnN0IGNsb3NlT3JEaXNjb25uZWN0VXJpID0gY2xvc2luZyA/IHRoaXMuY2xvc2VVcmkgOiB0aGlzLmRpc2Nvbm5lY3RVcmk7XG4gICAgaWYgKGNsb3NlT3JEaXNjb25uZWN0VXJpKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EKTtcbiAgICAgIHJlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiQ29tZXRUcmFuc3BvcnQucmVxdWVzdFwiICsgKGNsb3NpbmcgPyBcIkNsb3NlKClcIiA6IFwiRGlzY29ubmVjdCgpXCIpLFxuICAgICAgICAgICAgXCJyZXF1ZXN0IHJldHVybmVkIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVxdWVzdC5leGVjKCk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiXCIpO1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiYWJvcnRpbmcgcmVjdiByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcImRpc3Bvc2VkXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uQ29ubmVjdChtZXNzYWdlKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25TdHIgPSAoX2EyID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb25uZWN0aW9uS2V5O1xuICAgIHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5vbkNvbm5lY3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBjb25zdCBiYXNlQ29ubmVjdGlvblVyaSA9IHRoaXMuYmFzZVVyaSArIGNvbm5lY3Rpb25TdHI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29tZXRUcmFuc3BvcnQub25Db25uZWN0KClcIiwgXCJiYXNlVXJpID0gXCIgKyBiYXNlQ29ubmVjdGlvblVyaSk7XG4gICAgdGhpcy5zZW5kVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9zZW5kXCI7XG4gICAgdGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9yZWN2XCI7XG4gICAgdGhpcy5jbG9zZVVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvY2xvc2VcIjtcbiAgICB0aGlzLmRpc2Nvbm5lY3RVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArIFwiL2Rpc2Nvbm5lY3RcIjtcbiAgfVxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICAgIHRoaXMucGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuICAgIHBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICB9XG4gIHNlbmRBbnlQZW5kaW5nKCkge1xuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zO1xuICAgIGlmICghcGVuZGluZ0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICB9XG4gIHNlbmRJdGVtcyhpdGVtcykge1xuICAgIGNvbnN0IHNlbmRSZXF1ZXN0ID0gdGhpcy5zZW5kUmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRoaXMuc2VuZFVyaSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmF1dGhQYXJhbXMsXG4gICAgICB0aGlzLmVuY29kZVJlcXVlc3QoaXRlbXMpLFxuICAgICAgWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1NFTkRcbiAgICApO1xuICAgIHNlbmRSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkNvbWV0VHJhbnNwb3J0LnNlbmRJdGVtcygpXCIsXG4gICAgICAgICAgXCJvbiBjb21wbGV0ZTogZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICApO1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgIHRoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdJdGVtcykge1xuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kQW55UGVuZGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VuZFJlcXVlc3QuZXhlYygpO1xuICB9XG4gIHJlY3YoKSB7XG4gICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlY3ZSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRoaXMucmVjdlVyaSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLmF1dGhQYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfUkVDVl9QT0xMXG4gICAgKTtcbiAgICByZWN2UmVxdWVzdC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgIH0pO1xuICAgIHJlY3ZSZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgKGVycikgPT4ge1xuICAgICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMucmVjdigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmVjdlJlcXVlc3QuZXhlYygpO1xuICB9XG4gIG9uRGF0YShyZXNwb25zZURhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlRGF0YSk7XG4gICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoXG4gICAgICAgICAgICBmcm9tRGVzZXJpYWxpemVkKGl0ZW1zW2ldLCB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlKVxuICAgICAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkNvbWV0VHJhbnNwb3J0Lm9uRGF0YSgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIGV2ZW50OiBcIiArIGUuc3RhY2tcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGVuY29kZVJlcXVlc3QocmVxdWVzdEl0ZW1zKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RJdGVtcyk7XG4gIH1cbiAgZGVjb2RlUmVzcG9uc2UocmVzcG9uc2VEYXRhKSB7XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZURhdGEgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlRGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlRGF0YTtcbiAgfVxufTtcbnZhciBjb21ldHRyYW5zcG9ydF9kZWZhdWx0ID0gQ29tZXRUcmFuc3BvcnQ7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvbGliL3RyYW5zcG9ydC9ub2RlY29tZXR0cmFuc3BvcnQuanNcbnZhciBpbXBvcnRfaHR0cDYgPSBfX3RvRVNNKHJlcXVpcmUoXCJodHRwXCIpKTtcbnZhciBpbXBvcnRfaHR0cHMyID0gX190b0VTTShyZXF1aXJlKFwiaHR0cHNcIikpO1xudmFyIGltcG9ydF91cmwgPSBfX3RvRVNNKHJlcXVpcmUoXCJ1cmxcIikpO1xudmFyIGltcG9ydF91dGlsMyA9IF9fdG9FU00ocmVxdWlyZShcInV0aWxcIikpO1xudmFyIG5vb3AzID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIHNob3J0TmFtZTIgPSBUcmFuc3BvcnROYW1lcy5Db21ldDtcbnZhciBOb2RlQ29tZXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5odHRwQWdlbnQgPSBudWxsO1xuICAgIHRoaXMuaHR0cHNBZ2VudCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSAwO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lMjtcbiAgfVxuICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiTm9kZUNvbWV0VHJhbnNwb3J0OyB1cmk9XCIgKyB0aGlzLmJhc2VVcmkgKyBcIjsgaXNDb25uZWN0ZWQ9XCIgKyB0aGlzLmlzQ29ubmVjdGVkICsgXCI7IGZvcm1hdD1cIiArIHRoaXMuZm9ybWF0ICsgXCI7IHN0cmVhbT1cIiArIHRoaXMuc3RyZWFtO1xuICB9XG4gIGdldEFnZW50KHRscykge1xuICAgIHZhciBwcm9wID0gdGxzID8gXCJodHRwc0FnZW50XCIgOiBcImh0dHBBZ2VudFwiLCBhZ2VudDIgPSB0aGlzW3Byb3BdO1xuICAgIGlmICghYWdlbnQyKVxuICAgICAgYWdlbnQyID0gdGhpc1twcm9wXSA9IG5ldyAodGxzID8gaW1wb3J0X2h0dHBzMi5kZWZhdWx0IDogaW1wb3J0X2h0dHA2LmRlZmF1bHQpLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pO1xuICAgIHJldHVybiBhZ2VudDI7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgc2VsZjIgPSB0aGlzO1xuICAgIHRoaXMub25jZU5vUGVuZGluZyhmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmMi5odHRwQWdlbnQpXG4gICAgICAgIHNlbGYyLmh0dHBBZ2VudC5kZXN0cm95KCk7XG4gICAgICBpZiAoc2VsZjIuaHR0cHNBZ2VudClcbiAgICAgICAgc2VsZjIuaHR0cHNBZ2VudC5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgY29tZXR0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9XG4gIC8qIHZhbGlkIGluIG5vbi1zdHJlYW1pbmcgbW9kZSBvbmx5LCBvciBkYXRhIG9ubHkgY29udGFpbnMgbGFzdCB1cGRhdGUgKi9cbiAgcmVxdWVzdCh1cmksIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlcSA9IHRoaXMuY3JlYXRlUmVxdWVzdCh1cmksIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUpO1xuICAgIHJlcS5vbmNlKFwiY29tcGxldGVcIiwgY2FsbGJhY2spO1xuICAgIHJlcS5leGVjKCk7XG4gICAgcmV0dXJuIHJlcTtcbiAgfVxuICBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMuZm9ybWF0LCB0aGlzLnRpbWVvdXRzLCB0aGlzKTtcbiAgfVxuICBhZGRQZW5kaW5nKCkge1xuICAgICsrdGhpcy5wZW5kaW5nUmVxdWVzdHM7XG4gIH1cbiAgcmVtb3ZlUGVuZGluZygpIHtcbiAgICBpZiAoLS10aGlzLnBlbmRpbmdSZXF1ZXN0cyA8PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoXCJub3BlbmRpbmdcIik7XG4gICAgfVxuICB9XG4gIG9uY2VOb1BlbmRpbmcobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nUmVxdWVzdHMgPT0gMCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vbmNlKFwibm9wZW5kaW5nXCIsIGxpc3RlbmVyKTtcbiAgfVxufTtcbnZhciBSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgZm9ybWF0LCB0aW1lb3V0cywgdHJhbnNwb3J0KSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LmxvZ2dlcik7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT0gXCJzdHJpbmdcIilcbiAgICAgIHVyaSA9IGltcG9ydF91cmwuZGVmYXVsdC5wYXJzZSh1cmkpO1xuICAgIHZhciB0bHMgPSB1cmkucHJvdG9jb2wgPT0gXCJodHRwczpcIjtcbiAgICB0aGlzLmNsaWVudCA9IHRscyA/IGltcG9ydF9odHRwczIuZGVmYXVsdCA6IGltcG9ydF9odHRwNi5kZWZhdWx0O1xuICAgIHRoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcbiAgICB0aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVzID0gbnVsbDtcbiAgICB2YXIgbWV0aG9kID0gXCJHRVRcIiwgY29udGVudFR5cGUgPSBmb3JtYXQgPT0gXCJtc2dwYWNrXCIgPyBcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiIDogXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgaGVhZGVycyA9IGhlYWRlcnMgPyBtaXhpbih7fSwgaGVhZGVycykgOiB7fTtcbiAgICBoZWFkZXJzW1wiYWNjZXB0XCJdID0gY29udGVudFR5cGU7XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIG1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICBib2R5ID0gQnVmZmVyLmZyb20oYm9keSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gYm9keS5sZW5ndGg7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gY29udGVudFR5cGU7XG4gICAgfVxuICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHRoaXMucmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICBob3N0bmFtZTogdXJpLmhvc3RuYW1lLFxuICAgICAgcG9ydDogdXJpLnBvcnQsXG4gICAgICBwYXRoOiB1cmkucGF0aCArIHRvUXVlcnlTdHJpbmcocGFyYW1zKSxcbiAgICAgIG1ldGhvZCxcbiAgICAgIGhlYWRlcnNcbiAgICB9O1xuICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICByZXF1ZXN0T3B0aW9ucy5hZ2VudCA9IHRyYW5zcG9ydC5nZXRBZ2VudCh0bHMpO1xuICB9XG4gIGV4ZWMoKSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0LCBzZWxmMiA9IHRoaXM7XG4gICAgdmFyIHRpbWVyID0gdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmMi5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpLCByZXEgPSB0aGlzLnJlcSA9IHRoaXMuY2xpZW50LnJlcXVlc3QodGhpcy5yZXF1ZXN0T3B0aW9ucyk7XG4gICAgcmVxLm9uKFxuICAgICAgXCJlcnJvclwiLFxuICAgICAgdGhpcy5vblJlcUVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGVyciA9IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiUmVxdWVzdCBlcnJvcjogXCIgKyBlcnIubWVzc2FnZSwgbnVsbCwgNDAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgc2VsZjIudGltZXIgPSBudWxsO1xuICAgICAgICBzZWxmMi5jb21wbGV0ZShlcnIpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmVxLm9uKFwicmVzcG9uc2VcIiwgZnVuY3Rpb24ocmVzKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgc2VsZjIudGltZXIgPSBudWxsO1xuICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcbiAgICAgIGlmIChzdGF0dXNDb2RlID09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0Lk5vQ29udGVudCkge1xuICAgICAgICByZXMucmVzdW1lKCk7XG4gICAgICAgIHNlbGYyLmNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcy5vbihcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBzZWxmMi5vblJlc0Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXCJSZXNwb25zZSBlcnJvcjogXCIgKyBlcnIubWVzc2FnZSwgbnVsbCwgNDAwKTtcbiAgICAgICAgICBzZWxmMi5jb21wbGV0ZShlcnIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgc2VsZjIucmVzID0gcmVzO1xuICAgICAgaWYgKHNlbGYyLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9SRUNWX1NUUkVBTSAmJiBzdGF0dXNDb2RlIDwgNDAwKSB7XG4gICAgICAgIHNlbGYyLnJlYWRTdHJlYW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYyLnJlYWRGdWxseSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnRyYW5zcG9ydClcbiAgICAgIHRoaXMudHJhbnNwb3J0LmFkZFBlbmRpbmcoKTtcbiAgICByZXEuZW5kKHRoaXMuYm9keSk7XG4gIH1cbiAgcmVhZFN0cmVhbSgpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5yZXMsIHNlbGYyID0gdGhpcztcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuc3RyZWFtQ29tcGxldGUgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBvbkNodW5rKGNodW5rKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjaHVuayA9IEpTT04ucGFyc2UoY2h1bmspO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbXNnID0gXCJNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihzZWxmMi5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJOb2RlQ29tZXRUcmFuc3BvcnQuUmVxdWVzdC5yZWFkU3RyZWFtKClcIiwgbXNnKTtcbiAgICAgICAgc2VsZjIuY29tcGxldGUobmV3IFBhcnRpYWxFcnJvckluZm8obXNnLCBudWxsLCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZjIuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH1cbiAgICByZXMub24oXG4gICAgICBcImRhdGFcIixcbiAgICAgIHRoaXMub25kYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgbmV3Q2h1bmtzID0gU3RyaW5nKGRhdGEpLnNwbGl0KFwiXFxuXCIpLCBjaHVua3MgPSBzZWxmMi5jaHVua3M7XG4gICAgICAgIGlmIChuZXdDaHVua3MubGVuZ3RoID4gMSAmJiBjaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKG5ld0NodW5rcy5zaGlmdCgpKTtcbiAgICAgICAgICBzZWxmMi5jaHVua3MgPSBbXTtcbiAgICAgICAgICBvbkNodW5rKGNodW5rcy5qb2luKFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhaWxpbmdOZXdDaHVuayA9IG5ld0NodW5rcy5wb3AoKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nTmV3Q2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZjIuY2h1bmtzLnB1c2godHJhaWxpbmdOZXdDaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2h1bmtzLm1hcChvbkNodW5rKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJlcy5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYyLnN0cmVhbUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYyLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZWFkRnVsbHkoKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMucmVzLCBjaHVua3MgPSBbXSwgc2VsZjIgPSB0aGlzO1xuICAgIHJlcy5vbihcImRhdGFcIiwgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9KTtcbiAgICByZXMub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYm9keSA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKSwgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKFN0cmluZyhib2R5KSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgbXNnID0gXCJNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHNlbGYyLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIk5vZGVDb21ldFRyYW5zcG9ydC5SZXF1ZXN0LnJlYWRGdWxseSgpXCIsIG1zZyk7XG4gICAgICAgICAgc2VsZjIuY29tcGxldGUobmV3IFBhcnRpYWxFcnJvckluZm8obXNnLCBudWxsLCA0MDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCA0MDAgfHwgQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgICAgIHNlbGYyLmNvbXBsZXRlKG51bGwsIGJvZHkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyID0gYm9keS5lcnJvciAmJiBFcnJvckluZm8uZnJvbVZhbHVlcyhib2R5LmVycm9yKTtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcbiAgICAgICAgICAgIFwiRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiICsgc3RhdHVzQ29kZSArIFwiLCBib2R5IHdhczogXCIgKyBpbXBvcnRfdXRpbDMuZGVmYXVsdC5pbnNwZWN0KGJvZHkpLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN0YXR1c0NvZGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYyLmNvbXBsZXRlKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjb21wbGV0ZShlcnIsIGJvZHkpIHtcbiAgICBpZiAoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG4gICAgICBpZiAoYm9keSlcbiAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBib2R5KTtcbiAgICAgIHRoaXMuZW1pdChcImNvbXBsZXRlXCIsIGVyciwgYm9keSk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLm9uZGF0YSAmJiAhdGhpcy5zdHJlYW1Db21wbGV0ZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9uZGF0YSAmJiB0aGlzLnJlcylcbiAgICAgICAgICAgIHRoaXMucmVzLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCB0aGlzLm9uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVQZW5kaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFib3J0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIk5vZGVDb21ldFRyYW5zcG9ydC5SZXF1ZXN0LmFib3J0KClcIiwgXCJcIik7XG4gICAgdmFyIHRpbWVyID0gdGhpcy50aW1lcjtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICAgIGlmIChyZXEpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIk5vZGVDb21ldFRyYW5zcG9ydC5SZXF1ZXN0LmFib3J0KClcIiwgXCJhYm9ydGluZyByZXF1ZXN0XCIpO1xuICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5vblJlcUVycm9yKTtcbiAgICAgIHJlcS5vbihcImVycm9yXCIsIG5vb3AzKTtcbiAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvbXBsZXRlKHsgc3RhdHVzQ29kZTogNDAwLCBjb2RlOiA4MDAwMywgbWVzc2FnZTogXCJDYW5jZWxsZWRcIiB9KTtcbiAgfVxufTtcbnZhciBub2RlY29tZXR0cmFuc3BvcnRfZGVmYXVsdCA9IE5vZGVDb21ldFRyYW5zcG9ydDtcblxuLy8gc3JjL3BsYXRmb3JtL25vZGVqcy9saWIvdHJhbnNwb3J0L2luZGV4LnRzXG52YXIgdHJhbnNwb3J0X2RlZmF1bHQyID0ge1xuICBvcmRlcjogW1RyYW5zcG9ydE5hbWVzLkNvbWV0XSxcbiAgYnVuZGxlZEltcGxlbWVudGF0aW9uczoge1xuICAgIFtUcmFuc3BvcnROYW1lcy5XZWJTb2NrZXRdOiB3ZWJzb2NrZXR0cmFuc3BvcnRfZGVmYXVsdCxcbiAgICBbVHJhbnNwb3J0TmFtZXMuQ29tZXRdOiBub2RlY29tZXR0cmFuc3BvcnRfZGVmYXVsdFxuICB9XG59O1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi91dGlsL2RlZmF1bHRzLnRzXG52YXIgRGVmYXVsdHMyID0ge1xuICBjb25uZWN0aXZpdHlDaGVja1VybDogXCJodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC50eHRcIixcbiAgd3NDb25uZWN0aXZpdHlVcmw6IFwid3NzOi8vd3MtdXAuYWJseS1yZWFsdGltZS5jb21cIixcbiAgLyogTm90ZTogb3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcbiAgICogaW50ZXJzZWN0aW9uIG9mIGJhc2VUcmFuc3BvcnRPcmRlciBhbmQgdGhlIHRyYW5zcG9ydHMgY2xpZW50T3B0aW9uIHRoYXQncyBzdXBwb3J0ZWQuICovXG4gIGRlZmF1bHRUcmFuc3BvcnRzOiBbVHJhbnNwb3J0TmFtZXMuV2ViU29ja2V0XSxcbiAgcmVzdEFnZW50T3B0aW9uczogeyBtYXhTb2NrZXRzOiA0MCwga2VlcEFsaXZlOiB0cnVlIH1cbn07XG52YXIgZGVmYXVsdHNfZGVmYXVsdDIgPSBEZWZhdWx0czI7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvaW5kZXgudHNcbnZhciBtc2dwYWNrID0gcmVxdWlyZV9tc2dwYWNrKCk7XG52YXIgQ3J5cHRvID0gY3JlYXRlQ3J5cHRvQ2xhc3MoYnVmZmVydXRpbHNfZGVmYXVsdCk7XG5QbGF0Zm9ybS5DcnlwdG8gPSBDcnlwdG87XG5QbGF0Zm9ybS5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzX2RlZmF1bHQ7XG5QbGF0Zm9ybS5IdHRwID0gaHR0cF9kZWZhdWx0O1xuUGxhdGZvcm0uQ29uZmlnID0gY29uZmlnX2RlZmF1bHQ7XG5QbGF0Zm9ybS5UcmFuc3BvcnRzID0gdHJhbnNwb3J0X2RlZmF1bHQyO1xuUGxhdGZvcm0uV2ViU3RvcmFnZSA9IG51bGw7XG5mb3IgKGNvbnN0IGNsaWVudENsYXNzIG9mIFtEZWZhdWx0UmVzdCwgRGVmYXVsdFJlYWx0aW1lXSkge1xuICBjbGllbnRDbGFzcy5DcnlwdG8gPSBDcnlwdG87XG4gIGNsaWVudENsYXNzLl9Nc2dQYWNrID0gbXNncGFjaztcbn1cbmxvZ2dlcl9kZWZhdWx0LmluaXRMb2dIYW5kbGVycygpO1xuUGxhdGZvcm0uRGVmYXVsdHMgPSBnZXREZWZhdWx0cyhkZWZhdWx0c19kZWZhdWx0Mik7XG5pZiAoUGxhdGZvcm0uQ29uZmlnLmFnZW50KSB7XG4gIFBsYXRmb3JtLkRlZmF1bHRzLmFnZW50ICs9IFwiIFwiICsgUGxhdGZvcm0uQ29uZmlnLmFnZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVycm9ySW5mbyxcbiAgUmVzdDogRGVmYXVsdFJlc3QsXG4gIFJlYWx0aW1lOiBEZWZhdWx0UmVhbHRpbWUsXG4gIG1zZ3BhY2s6IG51bGwsXG4gIHByb3RvY29sTWVzc2FnZUZyb21EZXNlcmlhbGl6ZWQ6IGZyb21EZXNlcmlhbGl6ZWRJbmNsdWRpbmdEZXBlbmRlbmNpZXNcbn07XG5pZiAodHlwZW9mIG1vZHVsZS5leHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIikge1xuICB2YXIgX19jcCA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gICAgaWYgKChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiKSB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZnJvbSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiBmcm9tW2tleV0sXG4gICAgICAgICAgZW51bWVyYWJsZTogIShkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG4gIH07XG4gIG1vZHVsZS5leHBvcnRzID0gX19jcChtb2R1bGUuZXhwb3J0cywgZXhwb3J0cyk7XG59XG5yZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59KSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFibHktbm9kZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/build/ably-node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/sender.js\");\n\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\n\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsbUZBQWlCOztBQUUzQyxrQ0FBa0MsbUJBQU8sQ0FBQyw2RUFBYztBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBd0I7QUFDbkQscUJBQXFCLG1CQUFPLENBQUMsaUZBQWdCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFjOztBQUV6QztBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2FibHkvbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzPzExOTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbldlYlNvY2tldC5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/buffer-util.js":
/*!**************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/buffer-util.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"?053c\");\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsK0VBQWE7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMseUJBQVk7O0FBRTNDLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2FibHkvbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcz8zZmFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uY2F0LFxuICBtYXNrOiBfbWFzayxcbiAgdG9BcnJheUJ1ZmZlcixcbiAgdG9CdWZmZXIsXG4gIHVubWFzazogX3VubWFza1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLm1hc2sgPSBmdW5jdGlvbiAoc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/constants.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\n\nif (hasBlob) BINARY_TYPES.push('blob');\n\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcz8wNjhmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQklOQVJZX1RZUEVTID0gWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddO1xuY29uc3QgaGFzQmxvYiA9IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcblxuaWYgKGhhc0Jsb2IpIEJJTkFSWV9UWVBFUy5wdXNoKCdibG9iJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBHVUlEOiAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyxcbiAgaGFzQmxvYixcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGU6IFN5bWJvbCgna0lzRm9yT25FdmVudEF0dHJpYnV0ZScpLFxuICBrTGlzdGVuZXI6IFN5bWJvbCgna0xpc3RlbmVyJyksXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIE5PT1A6ICgpID0+IHt9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/event-target.js":
/*!***************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/event-target.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLGtDQUFrQyxFQUFFLG1CQUFPLENBQUMsK0VBQWE7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGlEQUFpRCxrQkFBa0I7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCxrQkFBa0I7QUFDeEUsd0RBQXdELGtCQUFrQjtBQUMxRSwwREFBMEQsa0JBQWtCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsa0JBQWtCO0FBQ3pFLHlEQUF5RCxrQkFBa0I7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RCxrQkFBa0I7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLEdBQUc7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcz9kNjYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcbmNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdrRXJyb3InKTtcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xuY29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xuY29uc3Qga1RhcmdldCA9IFN5bWJvbCgna1RhcmdldCcpO1xuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzW2tUeXBlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3R5cGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb249JyddIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5XG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xuICAgIHRoaXNba1JlYXNvbl0gPSBvcHRpb25zLnJlYXNvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLnJlYXNvbjtcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpc1trUmVhc29uXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB3YXNDbGVhbigpIHtcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ2NvZGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdyZWFzb24nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5lcnJvcj1udWxsXSBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRXJyb3JdID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZXJyb3I7XG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBtZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzW2tNZXNzYWdlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRGF0YV0gPSBvcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsICdkYXRhJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcbiAqIG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9uY2U9ZmFsc2VdIEEgYEJvb2xlYW5gIGluZGljYXRpbmcgdGhhdCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKFxuICAgICAgICAhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV0gJiZcbiAgICAgICAgbGlzdGVuZXJba0xpc3RlbmVyXSA9PT0gaGFuZGxlciAmJlxuICAgICAgICAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB3cmFwcGVyO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgZGF0YTogaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJywge1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXG4gICAgICAgICAgd2FzQ2xlYW46IHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0aGlzLl9jbG9zZUZyYW1lU2VudFxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wZW4nKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cmFwcGVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSA9ICEhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV07XG4gICAgd3JhcHBlcltrTGlzdGVuZXJdID0gaGFuZGxlcjtcblxuICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgIHRoaXMub25jZSh0eXBlLCB3cmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiYgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnQsXG4gIEV2ZW50VGFyZ2V0LFxuICBNZXNzYWdlRXZlbnRcbn07XG5cbi8qKlxuICogQ2FsbCBhbiBldmVudCBsaXN0ZW5lclxuICpcbiAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIHZhbHVlIHRvIHVzZSBhcyBgdGhpc2BgIHdoZW4gY2FsbGluZyB0aGUgbGlzdGVuZXJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbExpc3RlbmVyKGxpc3RlbmVyLCB0aGlzQXJnLCBldmVudCkge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwobGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmcsIGV2ZW50KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/extension.js":
/*!************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/extension.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLGlGQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQW1CO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEJBQTRCO0FBQ3BDO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0RBQStELEVBQUU7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRSxHQUFHLEVBQUU7QUFDMUQsMkJBQTJCO0FBQzNCLGVBQWU7QUFDZjtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcz9lMjM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuLyoqXG4gKiBBZGRzIGFuIG9mZmVyIHRvIHRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBhIHBhcmFtZXRlciB0byB0aGUgbWFwIG9mXG4gKiBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IFRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZXh0ZW5zaW9uIG9yIHBhcmFtZXRlciBuYW1lXG4gKiBAcGFyYW0geyhPYmplY3R8Qm9vbGVhbnxTdHJpbmcpfSBlbGVtIFRoZSBleHRlbnNpb24gcGFyYW1ldGVycyBvciB0aGVcbiAqICAgICBwYXJhbWV0ZXIgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1c2goZGVzdCwgbmFtZSwgZWxlbSkge1xuICBpZiAoZGVzdFtuYW1lXSA9PT0gdW5kZWZpbmVkKSBkZXN0W25hbWVdID0gW2VsZW1dO1xuICBlbHNlIGRlc3RbbmFtZV0ucHVzaChlbGVtKTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBpbnRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwYXJzZWQgb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBvZmZlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICBsZXQgaXNFc2NhcGluZyA9IGZhbHNlO1xuICBsZXQgaW5RdW90ZXMgPSBmYWxzZTtcbiAgbGV0IGV4dGVuc2lvbk5hbWU7XG4gIGxldCBwYXJhbU5hbWU7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgY29kZSA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgaSAhPT0gMCAmJlxuICAgICAgICAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSkgLyogJ1xcdCcgKi9cbiAgICAgICkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgLyogJzsnICovIHx8IGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBjb25zdCBuYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBuYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgcHVzaChwYXJhbXMsIGhlYWRlci5zbGljZShzdGFydCwgZW5kKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzZCAvKiAnPScgKi8gJiYgc3RhcnQgIT09IC0xICYmIGVuZCA9PT0gLTEpIHtcbiAgICAgICAgcGFyYW1OYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL1xuICAgICAgLy8gVGhlIHZhbHVlIG9mIGEgcXVvdGVkLXN0cmluZyBhZnRlciB1bmVzY2FwaW5nIG11c3QgY29uZm9ybSB0byB0aGVcbiAgICAgIC8vIHRva2VuIEFCTkYsIHNvIG9ubHkgdG9rZW4gY2hhcmFjdGVycyBhcmUgdmFsaWQuXG4gICAgICAvLyBSZWY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG4gICAgICAvL1xuICAgICAgaWYgKGlzRXNjYXBpbmcpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKCFtdXN0VW5lc2NhcGUpIG11c3RVbmVzY2FwZSA9IHRydWU7XG4gICAgICAgIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZXMpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAvKiAnXCInICovICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgIGluUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVjIC8qICdcXCcgKi8pIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICYmIGhlYWRlci5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gMHgzZCkge1xuICAgICAgICBpblF1b3RlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSAtMSAmJiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBsZXQgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgICAgIG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGluUXVvdGVzIHx8IGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICBjb25zdCB0b2tlbiA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHB1c2gob2ZmZXJzLCB0b2tlbiwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHB1c2gocGFyYW1zLCB0b2tlbiwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuLnJlcGxhY2UoL1xcXFwvZywgJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4pO1xuICAgIH1cbiAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBvZmZlcnM7XG59XG5cbi8qKlxuICogQnVpbGRzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgZmllbGQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIG1hcCBvZiBleHRlbnNpb25zIGFuZCBwYXJhbWV0ZXJzIHRvIGZvcm1hdFxuICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBmb3JtYXQoZXh0ZW5zaW9ucykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucylcbiAgICAubWFwKChleHRlbnNpb24pID0+IHtcbiAgICAgIGxldCBjb25maWd1cmF0aW9ucyA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWd1cmF0aW9ucykpIGNvbmZpZ3VyYXRpb25zID0gW2NvbmZpZ3VyYXRpb25zXTtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uc1xuICAgICAgICAubWFwKChwYXJhbXMpID0+IHtcbiAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbl1cbiAgICAgICAgICAgIC5jb25jYXQoXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykubWFwKChrKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IHBhcmFtc1trXTtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkgdmFsdWVzID0gW3ZhbHVlc107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgLm1hcCgodikgPT4gKHYgPT09IHRydWUgPyBrIDogYCR7a309JHt2fWApKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfSlcbiAgICAuam9pbignLCAnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGZvcm1hdCwgcGFyc2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/limiter.js":
/*!**********************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/limiter.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanM/YThkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/permessage-deflate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFlO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFXO0FBQ25DLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsK0VBQWE7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RC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QTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcz8xZWRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IExpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXInKTtcbmNvbnN0IHsga1N0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzXSBBZHZlcnRpc2Ugc3VwcG9ydFxuICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gQWR2ZXJ0aXNlL1xuICAgKiAgICAgYWNrbm93bGVkZ2UgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcbiAgICogICAgIGNhbGxzIHRvIHpsaWJcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzXSBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIFJlcXVlc3QvYWNjZXB0XG4gICAqICAgICBkaXNhYmxpbmcgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcbiAgICogICAgIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZCBpZiBjb250ZXh0IHRha2VvdmVyIGlzIGRpc2FibGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBpbmZsYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3JcbiAgICogICAgIGNsaWVudCBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBtYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl90aHJlc2hvbGQgPVxuICAgICAgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IHRoaXMuX29wdGlvbnMudGhyZXNob2xkIDogMTAyNDtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG4gICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG5cbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9XG4gICAgICAgIHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXRcbiAgICAgICAgICA6IDEwO1xuICAgICAgemxpYkxpbWl0ZXIgPSBuZXcgTGltaXRlcihjb25jdXJyZW5jeSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XG4gICAgcmV0dXJuICdwZXJtZXNzYWdlLWRlZmxhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb2ZmZXIoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyL3Jlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICBhY2NlcHQoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucyA9IHRoaXMubm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHRoaXMucGFyYW1zID0gdGhpcy5faXNTZXJ2ZXJcbiAgICAgID8gdGhpcy5hY2NlcHRBc1NlcnZlcihjb25maWd1cmF0aW9ucylcbiAgICAgIDogdGhpcy5hY2NlcHRBc0NsaWVudChjb25maWd1cmF0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcbiAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzU2VydmVyKG9mZmVycykge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XG4gICAgICAgIChwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyAmJlxuICAgICAgICAgIChvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID4gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpKSkgfHxcbiAgICAgICAgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFjY2VwdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPT09IHRydWUgfHxcbiAgICAgIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NlcHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmVzcG9uc2VbMF07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGFyYW1ldGVyIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9mZmVycy9yZXNwb25zZSB3aXRoIG5vcm1hbGl6ZWQgcGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIFwiJHtrZXl9XCIgbXVzdCBoYXZlIG9ubHkgYSBzaW5nbGUgdmFsdWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsaWVudF9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2VydmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VydmVyX21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2RlY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ2NsaWVudCcgOiAnc2VydmVyJztcblxuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9pbmZsYXRlID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcbiAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xuICAgIGlmIChmaW4pIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XG5cbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgICB0aGlzLl9pbmZsYXRlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcblxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4pIHtcbiAgICAgICAgZGF0YSA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEubGVuZ3RoIC0gNCk7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJNZXNzYWdlRGVmbGF0ZTtcblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcbiAgdGhpc1trRXJyb3JdLmNvZGUgPSAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJztcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG4gIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/validation.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRXJDLDBCQUEwQixtQkFBTyxDQUFDLGlHQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsK0VBQWE7QUFDekIsUUFBUSxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLG1GQUFlO0FBQ2pFLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYzs7QUFFakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzPzAwNjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuY29uc3QgREVGRVJfRVZFTlQgPSA2O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzID1cbiAgICAgIG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXG4gICAgICAgIDogdHJ1ZTtcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgdGhpcy5nZXRJbmZvKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGg2NChjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJTkZMQVRJTkc6XG4gICAgICAgIGNhc2UgREVGRVJfRVZFTlQ6XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGlmICghdGhpcy5fZXJyb3JlZCkgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcbiAgICAgICAgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNQVNLIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9NQVNLJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdNQVNLIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfTUFTSydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNihjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSB0aGlzLmNvbnN1bWUoMikucmVhZFVJbnQxNkJFKDApO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gbnVtICogTWF0aC5wb3coMiwgMzIpICsgYnVmLnJlYWRVSW50MzJCRSg0KTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKGNiKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9tYXNrZWQgJiZcbiAgICAgICAgKHRoaXMuX21hc2tbMF0gfCB0aGlzLl9tYXNrWzFdIHwgdGhpcy5fbWFza1syXSB8IHRoaXMuX21hc2tbM10pICE9PSAwXG4gICAgICApIHtcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSB7XG4gICAgICB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gR0VUX0lORk8pIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoY2IpIHtcbiAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQmxvYihmcmFnbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDA3LFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAgICogICAgIGBtZXNzYWdlYFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICAgKTtcblxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jcmVhdGVFcnJvcik7XG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/sender.js":
/*!*********************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/sender.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n            throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError(\"The message must not be greater than 123 bytes\");\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === \"string\") {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while the blob was being read\");\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while data was being compressed\");\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === \"function\") cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === \"function\") callback(err);\n    }\n}\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3RUFBd0UsR0FFeEU7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVDLGNBQWMsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUVuQyxNQUFNRSxvQkFBb0JGLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRUcsWUFBWSxFQUFFQyxVQUFVLEVBQUVDLElBQUksRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNuRCxNQUFNLEVBQUVNLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDOUMsTUFBTSxFQUFFUSxNQUFNQyxTQUFTLEVBQUVDLFFBQVEsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQztBQUU5QyxNQUFNVyxjQUFjQyxPQUFPO0FBQzNCLE1BQU1DLGFBQWFDLE9BQU9DLEtBQUssQ0FBQztBQUNoQyxNQUFNQyxtQkFBbUIsSUFBSTtBQUM3QixJQUFJQztBQUNKLElBQUlDLG9CQUFvQkY7QUFFeEIsTUFBTUcsVUFBVTtBQUNoQixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLGdCQUFnQjtBQUV0Qjs7Q0FFQyxHQUNELE1BQU1DO0lBQ0o7Ozs7Ozs7R0FPQyxHQUNEQyxZQUFZQyxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxDQUFFO1FBQzVDLElBQUksQ0FBQ0MsV0FBVyxHQUFHRixjQUFjLENBQUM7UUFFbEMsSUFBSUMsY0FBYztZQUNoQixJQUFJLENBQUNFLGFBQWEsR0FBR0Y7WUFDckIsSUFBSSxDQUFDRyxXQUFXLEdBQUdmLE9BQU9DLEtBQUssQ0FBQztRQUNsQztRQUVBLElBQUksQ0FBQ2UsT0FBTyxHQUFHTjtRQUVmLElBQUksQ0FBQ08sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBRWpCLElBQUksQ0FBQ0MsY0FBYyxH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QUNBLE9BQU8vQixNQUFNLEdBQUcsRUFBRTtRQUUxQyxJQUFJLE9BQU80RCxhQUFhLFlBQVlBLFNBQVNyQjtJQUMvQztBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNPLFFBQVFZLE1BQU0sRUFBRW5CLEdBQUcsRUFBRTNCLEVBQUU7SUFDOUIrQixjQUFjZSxRQUFRbkIsS0FBSzNCO0lBQzNCOEMsT0FBT3BFLE9BQU8sQ0FBQ2lEO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2FibHkvbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanM/MjVkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXhcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7IEVNUFRZX0JVRkZFUiwga1dlYlNvY2tldCwgTk9PUCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgaXNCbG9iLCBpc1ZhbGlkU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5jb25zdCB7IG1hc2s6IGFwcGx5TWFzaywgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3Qga0J5dGVMZW5ndGggPSBTeW1ib2woJ2tCeXRlTGVuZ3RoJyk7XG5jb25zdCBtYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuY29uc3QgUkFORE9NX1BPT0xfU0laRSA9IDggKiAxMDI0O1xubGV0IHJhbmRvbVBvb2w7XG5sZXQgcmFuZG9tUG9vbFBvaW50ZXIgPSBSQU5ET01fUE9PTF9TSVpFO1xuXG5jb25zdCBERUZBVUxUID0gMDtcbmNvbnN0IERFRkxBVElORyA9IDE7XG5jb25zdCBHRVRfQkxPQl9EQVRBID0gMjtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMsIGdlbmVyYXRlTWFzaykge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuXG4gICAgaWYgKGdlbmVyYXRlTWFzaykge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xuICAgICAgdGhpcy5fbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgdGhpcy5vbmVycm9yID0gTk9PUDtcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhIHBpZWNlIG9mIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBIeUJpIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEByZXR1cm4geyhCdWZmZXJ8U3RyaW5nKVtdfSBUaGUgZnJhbWVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFzaztcbiAgICBsZXQgbWVyZ2UgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgc2tpcE1hc2tpbmcgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLm1hc2spIHtcbiAgICAgIG1hc2sgPSBvcHRpb25zLm1hc2tCdWZmZXIgfHwgbWFza0J1ZmZlcjtcblxuICAgICAgaWYgKG9wdGlvbnMuZ2VuZXJhdGVNYXNrKSB7XG4gICAgICAgIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKG1hc2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJhbmRvbVBvb2xQb2ludGVyID09PSBSQU5ET01fUE9PTF9TSVpFKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG4gICAgICAgICAgaWYgKHJhbmRvbVBvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbGF6aWx5IGluaXRpYWxpemVkIGJlY2F1c2Ugc2VydmVyLXNlbnQgZnJhbWVzIG11c3Qgbm90XG4gICAgICAgICAgICAvLyBiZSBtYXNrZWQgc28gaXQgbWF5IG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcmFuZG9tUG9vbCA9IEJ1ZmZlci5hbGxvYyhSQU5ET01fUE9PTF9TSVpFKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByYW5kb21GaWxsU3luYyhyYW5kb21Qb29sLCAwLCBSQU5ET01fUE9PTF9TSVpFKTtcbiAgICAgICAgICByYW5kb21Qb29sUG9pbnRlciA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBtYXNrWzBdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1sxXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbMl0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzNdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgIH1cblxuICAgICAgc2tpcE1hc2tpbmcgPSAobWFza1swXSB8IG1hc2tbMV0gfCBtYXNrWzJdIHwgbWFza1szXSkgPT09IDA7XG4gICAgICBvZmZzZXQgPSA2O1xuICAgIH1cblxuICAgIGxldCBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKFxuICAgICAgICAoIW9wdGlvbnMubWFzayB8fCBza2lwTWFza2luZykgJiZcbiAgICAgICAgb3B0aW9uc1trQnl0ZUxlbmd0aF0gIT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIGRhdGFMZW5ndGggPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5ICYmICFza2lwTWFza2luZztcbiAgICB9XG5cbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAoZGF0YUxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGFMZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcblxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhTGVuZ3RoLCAyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgdGFyZ2V0WzJdID0gdGFyZ2V0WzNdID0gMDtcbiAgICAgIHRhcmdldC53cml0ZVVJbnRCRShkYXRhTGVuZ3RoLCA0LCA2KTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgdGFyZ2V0WzFdIHw9IDB4ODA7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2tbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcblxuICAgIGlmIChza2lwTWFza2luZykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgdGFyZ2V0LCBvZmZzZXQsIGRhdGFMZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhTGVuZ3RoKTtcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWYgPSBFTVBUWV9CVUZGRVI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWYud3JpdGUoZGF0YSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBidWYubGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOCxcbiAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA5LFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwYSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeVxuICAgKiAgICAgb3IgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKFxuICAgICAgICByc3YxICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLnBhcmFtc1tcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5faXNTZXJ2ZXJcbiAgICAgICAgICAgID8gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICAgICAgOiAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgIF1cbiAgICAgICkge1xuICAgICAgICByc3YxID0gYnl0ZUxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGUsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjFcbiAgICB9O1xuXG4gICAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb250ZW50cyBvZiBhIGJsb2IgYXMgYmluYXJ5IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYiBUaGUgYmxvYlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICB0aGUgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0QmxvYkRhdGEoYmxvYiwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9CTE9CX0RBVEE7XG5cbiAgICBibG9iXG4gICAgICAuYXJyYXlCdWZmZXIoKVxuICAgICAgLnRoZW4oKGFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSB0aGUgYmxvYiB3YXMgYmVpbmcgcmVhZCdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgZXJyb3JzXG4gICAgICAgICAgLy8gdGhhdCBtaWdodCBiZSB0aHJvd24gaW4gdGhlIGNhbGxiYWNrcyBiZWhhdmUgbGlrZSBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgLy8gb3V0c2lkZSB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbENhbGxiYWNrcywgdGhpcywgZXJyLCBjYik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRvQnVmZmVyKGFycmF5QnVmZmVyKTtcblxuICAgICAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgICAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGBvbkVycm9yYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayBmb3IgdGhlIHNhbWUgcmVhc29uIHRoYXRcbiAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGFib3ZlIGlzLlxuICAgICAgICAvL1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG9uRXJyb3IsIHRoaXMsIGVyciwgY2IpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3N0YXRlID0gREVGTEFUSU5HO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBjb21wcmVzc2VkJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNhbGxDYWxsYmFja3ModGhpcywgZXJyLCBjYik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAodGhpcy5fc3RhdGUgPT09IERFRkFVTFQgJiYgdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgICBSZWZsZWN0LmFwcGx5KHBhcmFtc1swXSwgdGhpcywgcGFyYW1zLnNsaWNlKDEpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzZW5kIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFNlbmQgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbnF1ZXVlKHBhcmFtcykge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgZnJhbWUgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFsxXSwgY2IpO1xuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcblxuLyoqXG4gKiBDYWxscyBxdWV1ZWQgY2FsbGJhY2tzIHdpdGggYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gY2FsbCB0aGUgY2FsbGJhY2tzIHdpdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYikge1xuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VuZGVyLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5fcXVldWVbaV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXMgYSBgU2VuZGVyYCBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgcGVuZGluZyBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gb25FcnJvcihzZW5kZXIsIGVyciwgY2IpIHtcbiAgY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpO1xuICBzZW5kZXIub25lcnJvcihlcnIpO1xufVxuIl0sIm5hbWVzIjpbIkR1cGxleCIsInJlcXVpcmUiLCJyYW5kb21GaWxsU3luYyIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiRU1QVFlfQlVGRkVSIiwia1dlYlNvY2tldCIsIk5PT1AiLCJpc0Jsb2IiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsIm1hc2siLCJhcHBseU1hc2siLCJ0b0J1ZmZlciIsImtCeXRlTGVuZ3RoIiwiU3ltYm9sIiwibWFza0J1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwiUkFORE9NX1BPT0xfU0laRSIsInJhbmRvbVBvb2wiLCJyYW5kb21Qb29sUG9pbnRlciIsIkRFRkFVTFQiLCJERUZMQVRJTkciLCJHRVRfQkxPQl9EQVRBIiwiU2VuZGVyIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJleHRlbnNpb25zIiwiZ2VuZXJhdGVNYXNrIiwiX2V4dGVuc2lvbnMiLCJfZ2VuZXJhdGVNYXNrIiwiX21hc2tCdWZmZXIiLCJfc29ja2V0IiwiX2ZpcnN0RnJhZ21lbnQiLCJfY29tcHJlc3MiLCJfYnVmZmVyZWRCeXRlcyIsIl9xdWV1ZSIsIl9zdGF0ZSIsIm9uZXJyb3IiLCJ1bmRlZmluZWQiLCJmcmFtZSIsImRhdGEiLCJvcHRpb25zIiwibWVyZ2UiLCJvZmZzZXQiLCJza2lwTWFza2luZyIsImRhdGFMZW5ndGgiLCJmcm9tIiwibGVuZ3RoIiwicmVhZE9ubHkiLCJwYXlsb2FkTGVuZ3RoIiwidGFyZ2V0IiwiYWxsb2NVbnNhZmUiLCJmaW4iLCJvcGNvZGUiLCJyc3YxIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludEJFIiwiY2xvc2UiLCJjb2RlIiwiY2IiLCJidWYiLCJUeXBlRXJyb3IiLCJieXRlTGVuZ3RoIiwiUmFuZ2VFcnJvciIsIndyaXRlIiwic2V0IiwiZW5xdWV1ZSIsImRpc3BhdGNoIiwic2VuZEZyYW1lIiwicGluZyIsInNpemUiLCJnZXRCbG9iRGF0YSIsInBvbmciLCJzZW5kIiwicGVyTWVzc2FnZURlZmxhdGUiLCJleHRlbnNpb25OYW1lIiwiYmluYXJ5IiwiY29tcHJlc3MiLCJwYXJhbXMiLCJfaXNTZXJ2ZXIiLCJfdGhyZXNob2xkIiwib3B0cyIsImJsb2IiLCJhcnJheUJ1ZmZlciIsInRoZW4iLCJkZXN0cm95ZWQiLCJlcnIiLCJFcnJvciIsInByb2Nlc3MiLCJuZXh0VGljayIsImNhbGxDYWxsYmFja3MiLCJkZXF1ZXVlIiwiY2F0Y2giLCJvbkVycm9yIiwiXyIsInNoaWZ0IiwiUmVmbGVjdCIsImFwcGx5Iiwic2xpY2UiLCJwdXNoIiwibGlzdCIsImNvcmsiLCJ1bmNvcmsiLCJtb2R1bGUiLCJleHBvcnRzIiwic2VuZGVyIiwiaSIsImNhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/stream.js":
/*!*********************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/stream.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9hYmx5L25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzPzQ3YjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHRlcm1pbmF0ZU9uRGVzdHJveSA9IHRydWU7XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHdzLnBhdXNlKCk7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cy5pc1BhdXNlZCkgd3MucmVzdW1lKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/subprotocol.js":
/*!**************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/subprotocol.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsaUZBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBbUI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLCtEQUErRCxFQUFFO0FBQ2pFOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiw2REFBNkQsRUFBRTtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzPzliMDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/validation.js":
/*!*************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/validation.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\n\nconst { hasBlob } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return (\n    hasBlob &&\n    typeof value === 'object' &&\n    typeof value.arrayBuffer === 'function' &&\n    typeof value.type === 'string' &&\n    typeof value.stream === 'function' &&\n    (value[Symbol.toStringTag] === 'Blob' ||\n      value[Symbol.toStringTag] === 'File')\n  );\n}\n\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?8d22\");\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkMsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSwwQkFBMEI7QUFDNUI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDZCQUFnQjs7QUFFaEQsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanM/OTMyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgaXNVdGY4IH0gPSByZXF1aXJlKCdidWZmZXInKTtcblxuY29uc3QgeyBoYXNCbG9iIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdG9rZW5DaGFycyA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyA0OCAtIDYzXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAxLCAwIC8vIDExMiAtIDEyN1xuXTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDEwMDAgJiZcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNSAmJlxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBidWZmZXIgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LlxuICogUG9ydGVkIGZyb20gaHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrLyU3RW1nazI1L3Vjcy91dGY4X2NoZWNrLmMgYnlcbiAqIE1hcmt1cyBLdWhuLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBidWZgIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9pc1ZhbGlkVVRGOChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKChidWZbaV0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gMHh4eHh4eHhcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDEgPT09IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMiA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZTAgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwKSAvLyBTdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZjAgJiYgKGJ1ZltpICsgMV0gJiAweGYwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmNCAmJiBidWZbaSArIDFdID4gMHg4ZikgfHxcbiAgICAgICAgYnVmW2ldID4gMHhmNCAvLyA+IFUrMTBGRkZGXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIGBCbG9iYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYEJsb2JgLCBlbHNlIGBmYWxzZWBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGhhc0Jsb2IgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICh2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQmxvYicgfHxcbiAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGaWxlJylcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQmxvYixcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjgsXG4gIHRva2VuQ2hhcnNcbn07XG5cbmlmIChpc1V0ZjgpIHtcbiAgbW9kdWxlLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAyNCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNVdGY4KGJ1Zik7XG4gIH07XG59IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqLyBlbHNlIGlmICghcHJvY2Vzcy5lbnYuV1NfTk9fVVRGXzhfVkFMSURBVEUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgIHJldHVybiBidWYubGVuZ3RoIDwgMzIgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVmFsaWRVVEY4KGJ1Zik7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/websocket-server.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/websocket-server.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst extension = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDLHlEQUF5RDs7QUFFbEY7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFdkMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQWE7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsaUdBQXNCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLG1GQUFlO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFhO0FBQ3ZDLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTs7QUFFbEQsaUNBQWlDLEdBQUc7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVywyQkFBMkI7QUFDdEMsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLE1BQU0sRUFBRSx3QkFBd0I7QUFDaEQ7QUFDQSx1QkFBdUIsRUFBRSxJQUFJLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanM/Njk4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXgkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHN1YnByb3RvY29sID0gcmVxdWlyZSgnLi9zdWJwcm90b2NvbCcpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0IHNlcnZlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuICAgKiAgICAgY2xhc3MgdG8gdXNlLiBJdCBtdXN0IGJlIHRoZSBgV2ViU29ja2V0YCBjbGFzcyBvciBjbGFzcyB0aGF0IGV4dGVuZHMgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N0YXRlID0gUlVOTklORztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0lORykgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXG4gICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAgICAvL1xuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXEuaGVhZGVycy51cGdyYWRlO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddO1xuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgSFRUUCBtZXRob2QnO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDUsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1WZXJzaW9uIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdG9jb2xzID0gc3VicHJvdG9jb2wucGFyc2Uoc2VjV2ViU29ja2V0UHJvdG9jb2wpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KG51bGwsIHVuZGVmaW5lZCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0aGlzLm9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIC8vXG4gIC8vIFRoZSBzb2NrZXQgaXMgd3JpdGFibGUgdW5sZXNzIHRoZSB1c2VyIGRlc3Ryb3llZCBvciBlbmRlZCBpdCBiZWZvcmUgY2FsbGluZ1xuICAvLyBgc2VydmVyLmhhbmRsZVVwZ3JhZGUoKWAgb3IgaW4gdGhlIGB2ZXJpZnlDbGllbnRgIGZ1bmN0aW9uLCB3aGljaCBpcyBhIHVzZXJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cbiAgLy8gaXMgdGhhdCBzb21lIG9mIHRoZSBkYXRhIHdyaXR0ZW4gYnkgdGhlIHVzZXIgbWlnaHQgYmUgZGlzY2FyZGVkIGR1ZSB0byB0aGVcbiAgLy8gY2FsbCB0byBgc29ja2V0LmVuZCgpYCBiZWxvdywgd2hpY2ggdHJpZ2dlcnMgYW4gYCdlcnJvcidgIGV2ZW50IHRoYXQgaW5cbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXG4gIC8vXG4gIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICBoZWFkZXJzID0ge1xuICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgIC4uLmhlYWRlcnNcbiAgfTtcblxuICBzb2NrZXQub25jZSgnZmluaXNoJywgc29ja2V0LmRlc3Ryb3kpO1xuXG4gIHNvY2tldC5lbmQoXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICdcXHJcXG5cXHJcXG4nICtcbiAgICAgIG1lc3NhZ2VcbiAgKTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCd3c0NsaWVudEVycm9yJ2AgZXZlbnQgb24gYSBgV2ViU29ja2V0U2VydmVyYCBpZiB0aGVyZSBpcyBhdCBsZWFzdFxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0U2VydmVyfSBzZXJ2ZXIgVGhlIFdlYlNvY2tldCBzZXJ2ZXJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KCd3c0NsaWVudEVycm9yJykpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xuXG4gICAgc2VydmVyLmVtaXQoJ3dzQ2xpZW50RXJyb3InLCBlcnIsIHNvY2tldCwgcmVxKTtcbiAgfSBlbHNlIHtcbiAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/node_modules/ws/lib/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/sender.js\");\nconst { isBlob } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/validation.js\");\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = __webpack_require__(/*! ./event-target */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\");\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(\n    websocket._socket.destroy.bind(websocket._socket),\n    closeTimeout\n  );\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msa0VBQWtFOztBQUUzRjs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3BELFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QyxRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLGdCQUFLOztBQUU3QiwwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBc0I7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsNkVBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHlFQUFVO0FBQ2pDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsaUZBQWM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHFGQUFnQjtBQUM1QixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsK0VBQWE7QUFDL0MsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxtRkFBZTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RCxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQixHQUFHLG1CQUFtQjtBQUM1RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FB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QVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9hYmx5L25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzP2IyODQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgRHVwbGV4LCBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHsgaXNCbG9iIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2Vycm9yRW1pdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgdGhlIGN1c3RvbSBcIm5vZGVidWZmZXJcIiB0eXBlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcbiAgICogaW5zdGVhZCBvZiBcImJsb2JcIi5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25vcGVuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZW5kZXIgPSBuZXcgU2VuZGVyKHNvY2tldCwgdGhpcy5fZXh0ZW5zaW9ucywgb3B0aW9ucy5nZW5lcmF0ZU1hc2spO1xuXG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNlbmRlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc29ja2V0W2tXZWJTb2NrZXRdID0gdGhpcztcblxuICAgIHJlY2VpdmVyLm9uKCdjb25jbHVkZScsIHJlY2VpdmVyT25Db25jbHVkZSk7XG4gICAgcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgICByZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRXJyb3IpO1xuICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgcmVjZWl2ZXJPbk1lc3NhZ2UpO1xuICAgIHJlY2VpdmVyLm9uKCdwaW5nJywgcmVjZWl2ZXJPblBpbmcpO1xuICAgIHJlY2VpdmVyLm9uKCdwb25nJywgcmVjZWl2ZXJPblBvbmcpO1xuXG4gICAgc2VuZGVyLm9uZXJyb3IgPSBzZW5kZXJPbkVycm9yO1xuXG4gICAgLy9cbiAgICAvLyBUaGVzZSBtZXRob2RzIG1heSBub3QgYmUgYXZhaWxhYmxlIGlmIGBzb2NrZXRgIGlzIGp1c3QgYSBgRHVwbGV4YC5cbiAgICAvL1xuICAgIGlmIChzb2NrZXQuc2V0VGltZW91dCkgc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgaWYgKHNvY2tldC5zZXROb0RlbGF5KSBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XG4gICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdENsb3NlKCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXG4gICAqICAgICBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCAmJlxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxuICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzZXRDbG9zZVRpbWVyKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ2lzUGF1c2VkJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgYW55XG4gKiAgICAgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBtdWx0aXBsZVxuICogICAgIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmZpbmlzaFJlcXVlc3RdIEEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAqICAgICBjdXN0b21pemUgdGhlIGhlYWRlcnMgb2YgZWFjaCBodHRwIHJlcXVlc3QgYmVmb3JlIGl0IGlzIHNlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcbiAqICAgICByZWRpcmVjdHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gKiAgICAgbWFza2luZyBrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0XSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gKiAgICAgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJlZGlyZWN0cz0xMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0c1xuICogICAgIGFsbG93ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dIFZhbHVlIG9mIHRoZSBgT3JpZ2luYCBvclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXG4gKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcbiAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgJyArXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzXCIsIG9yIFwid3MrdW5peDpcIic7XG4gIH0gZWxzZSBpZiAoaXNJcGNVcmwgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcbiAgfVxuXG4gIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVXJsTWVzc2FnZSk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgcmVxdWVzdCA9IGlzU2VjdXJlID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPVxuICAgIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiB8fCAoaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdCk7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgLi4ub3B0cy5oZWFkZXJzLFxuICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxuICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHByb3RvY29sICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fFxuICAgICAgICBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgICdBbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZWQgc3VicHJvdG9jb2wgd2FzIHNwZWNpZmllZCdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xTZXQuYWRkKHByb3RvY29sKTtcbiAgICB9XG5cbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scy5qb2luKCcsJyk7XG4gIH1cbiAgaWYgKG9wdHMub3JpZ2luKSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLmhlYWRlcnMuT3JpZ2luID0gb3B0cy5vcmlnaW47XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgfHwgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICB9XG5cbiAgaWYgKGlzSXBjVXJsKSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcTtcblxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxJcGMgPSBpc0lwY1VybDtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgPSBpc1NlY3VyZTtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNJcGNVcmxcbiAgICAgICAgPyBvcHRzLnNvY2tldFBhdGhcbiAgICAgICAgOiBwYXJzZWRVcmwuaG9zdDtcblxuICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzO1xuXG4gICAgICAvL1xuICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSB1c2VyIHByb3ZpZGVkIG9wdGlvbnMgc28gdGhhdCBoZWFkZXJzIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAvL1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgaGVhZGVyczoge30gfTtcblxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdlYnNvY2tldC5saXN0ZW5lckNvdW50KCdyZWRpcmVjdCcpID09PSAwKSB7XG4gICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNJcGNVcmxcbiAgICAgICAgPyB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBvcHRzLnNvY2tldFBhdGggPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoXG4gICAgICAgICAgOiBmYWxzZVxuICAgICAgICA6IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBwYXJzZWRVcmwuaG9zdCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XG5cbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCAod2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBkcm9wIHRoZSBmb2xsb3dpbmcgaGVhZGVycy4gVGhlc2VcbiAgICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXG4gICAgICAgIC8vXG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XG5cbiAgICAgICAgaWYgKCFpc1NhbWVIb3N0KSBkZWxldGUgb3B0cy5oZWFkZXJzLmhvc3Q7XG5cbiAgICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxuICAgIC8vIElmIHRoZSBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlzIHNldCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGFzIGl0XG4gICAgLy8gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPVxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cykge1xuICAgICAgLy9cbiAgICAgIC8vIFVubGlrZSB3aGF0IGlzIGRvbmUgZm9yIHRoZSBgJ3VwZ3JhZGUnYCBldmVudCwgbm8gZWFybHkgZXhpdCBpc1xuICAgICAgLy8gdHJpZ2dlcmVkIGhlcmUgaWYgdGhlIHVzZXIgY2FsbHMgYHdlYnNvY2tldC5jbG9zZSgpYCBvclxuICAgICAgLy8gYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgJ3JlZGlyZWN0J2AgZXZlbnQuIFRoaXNcbiAgICAgIC8vIGlzIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsc28gY2FsbCBgcmVxdWVzdC5kZXN0cm95KClgIHdpdGggYW4gZXJyb3JcbiAgICAgIC8vIGJlZm9yZSBjYWxsaW5nIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3IgYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgYW5kIHRoaXNcbiAgICAgIC8vIHdvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyBlbWl0dGVkIG9uIHRoZSBgcmVxdWVzdGAgb2JqZWN0IHdpdGggbm9cbiAgICAgIC8vIGAnZXJyb3InYCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQuXG4gICAgICAvL1xuICAgICAgd2Vic29ja2V0LmVtaXQoJ3JlZGlyZWN0Jywgd2Vic29ja2V0LnVybCwgcmVxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xuICB9XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcVtrQWJvcnRlZF0pIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXG4gICAgLy8gYCd1cGdyYWRlJ2AgZXZlbnQuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCB1cGdyYWRlID0gcmVzLmhlYWRlcnMudXBncmFkZTtcblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RvY29sU2V0LmhhcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJQcm90KSB3ZWJzb2NrZXQuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGV4dGVuc2lvbk5hbWVzWzBdICE9PSBQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0cy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKG9wdHMuZmluaXNoUmVxdWVzdCkge1xuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxLmVuZCgpO1xuICB9XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGFzc2lnbm1lbnQgaXMgcHJhY3RpY2FsbHkgdXNlbGVzcyBhbmQgaXMgZG9uZSBvbmx5IGZvclxuICAvLyBjb25zaXN0ZW5jeS5cbiAgLy9cbiAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlLCB3ZWJzb2NrZXQsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcbiAqIHdoZW4gdGhlIGByZWFkeVN0YXRlYCBhdHRyaWJ1dGUgaXMgYENMT1NJTkdgIG9yIGBDTE9TRURgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGlzQmxvYihkYXRhKSA/IGRhdGEuc2l6ZSA6IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKCF3ZWJzb2NrZXQuaXNQYXVzZWQpIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgYmluYXJ5IG9yIG5vdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSwgaXNCaW5hcnkpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX2F1dG9Qb25nKSB3ZWJzb2NrZXQucG9uZyhkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGBTZW5kZXJgIGVycm9yIGV2ZW50IGhhbmRsZXIuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpO1xuICB9XG5cbiAgLy9cbiAgLy8gYHNvY2tldC5lbmQoKWAgaXMgdXNlZCBpbnN0ZWFkIG9mIGBzb2NrZXQuZGVzdHJveSgpYCB0byBhbGxvdyB0aGUgb3RoZXJcbiAgLy8gcGVlciB0byBmaW5pc2ggc2VuZGluZyBxdWV1ZWQgZGF0YS4gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgYSB0aW1lciBoZXJlXG4gIC8vIGJlY2F1c2UgYENMT1NJTkdgIG1lYW5zIHRoYXQgaXQgaXMgYWxyZWFkeSBzZXQgb3Igbm90IG5lZWRlZC5cbiAgLy9cbiAgdGhpcy5fc29ja2V0LmVuZCgpO1xuXG4gIGlmICghd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQpIHtcbiAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHRpbWVyIHRvIGRlc3Ryb3kgdGhlIHVuZGVybHlpbmcgcmF3IHNvY2tldCBvZiBhIFdlYlNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldENsb3NlVGltZXIod2Vic29ja2V0KSB7XG4gIHdlYnNvY2tldC5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgd2Vic29ja2V0Ll9zb2NrZXQuZGVzdHJveS5iaW5kKHdlYnNvY2tldC5fc29ja2V0KSxcbiAgICBjbG9zZVRpbWVvdXRcbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGxldCBjaHVuaztcblxuICAvL1xuICAvLyBUaGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGhhdmUgYmVlbiByZWNlaXZlZCBvciB0aGUgYCdlbmQnYCBldmVudCBlbWl0dGVkLFxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xuICAvLyBpdC4gSWYgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHNvY2tldCBpcyBpbiBmbG93aW5nIG1vZGUgdGhlbiB0aGVyZSBpcyBub1xuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcbiAgLy8gZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGUgY2h1bmsuXG4gIC8vXG4gIGlmIChcbiAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkICYmXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgKGNodW5rID0gd2Vic29ja2V0Ll9zb2NrZXQucmVhZCgpKSAhPT0gbnVsbFxuICApIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLndyaXRlKGNodW5rKTtcbiAgfVxuXG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICBjbGVhclRpbWVvdXQod2Vic29ja2V0Ll9jbG9zZVRpbWVyKTtcblxuICBpZiAoXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCB8fFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICkge1xuICAgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25GaW5pc2gpO1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2ZpbmlzaCcsIHJlY2VpdmVyT25GaW5pc2gpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XG4gIGlmICghdGhpc1trV2ViU29ja2V0XS5fcmVjZWl2ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVuZCgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xuXG4gIGlmICh3ZWJzb2NrZXQpIHtcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/AblyContext.js":
/*!****************************************************!*\
  !*** ./node_modules/ably/react/mjs/AblyContext.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AblyContext: () => (/* binding */ AblyContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n// We need to make sure we never create more than one Ably React context.\n// This might happen when exporting a context directly from a module -\n// there's a risk of creating multiple instances of the same context\n// if there are misconfigurations in module bundler or package manager on the consumer side of Ably Context.\n// This can lead to problems like having an Ably Channel instance added\n// in one context, and then attempting to retrieve it from another different context.\n// This is why a single Ably context is created and stored in the global state.\nconst contextKey = Symbol.for('__ABLY_CONTEXT__');\nconst globalObjectForContext = typeof globalThis !== 'undefined' ? globalThis : {};\nfunction getContext() {\n    let context = globalObjectForContext[contextKey];\n    if (!context) {\n        context = globalObjectForContext[contextKey] = react__WEBPACK_IMPORTED_MODULE_0__.createContext({});\n    }\n    return context;\n}\nconst AblyContext = getContext();\n//# sourceMappingURL=AblyContext.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvQWJseUNvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdEQUFtQixHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvQWJseUNvbnRleHQuanM/NWUwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgbmV2ZXIgY3JlYXRlIG1vcmUgdGhhbiBvbmUgQWJseSBSZWFjdCBjb250ZXh0LlxuLy8gVGhpcyBtaWdodCBoYXBwZW4gd2hlbiBleHBvcnRpbmcgYSBjb250ZXh0IGRpcmVjdGx5IGZyb20gYSBtb2R1bGUgLVxuLy8gdGhlcmUncyBhIHJpc2sgb2YgY3JlYXRpbmcgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIGNvbnRleHRcbi8vIGlmIHRoZXJlIGFyZSBtaXNjb25maWd1cmF0aW9ucyBpbiBtb2R1bGUgYnVuZGxlciBvciBwYWNrYWdlIG1hbmFnZXIgb24gdGhlIGNvbnN1bWVyIHNpZGUgb2YgQWJseSBDb250ZXh0LlxuLy8gVGhpcyBjYW4gbGVhZCB0byBwcm9ibGVtcyBsaWtlIGhhdmluZyBhbiBBYmx5IENoYW5uZWwgaW5zdGFuY2UgYWRkZWRcbi8vIGluIG9uZSBjb250ZXh0LCBhbmQgdGhlbiBhdHRlbXB0aW5nIHRvIHJldHJpZXZlIGl0IGZyb20gYW5vdGhlciBkaWZmZXJlbnQgY29udGV4dC5cbi8vIFRoaXMgaXMgd2h5IGEgc2luZ2xlIEFibHkgY29udGV4dCBpcyBjcmVhdGVkIGFuZCBzdG9yZWQgaW4gdGhlIGdsb2JhbCBzdGF0ZS5cbmNvbnN0IGNvbnRleHRLZXkgPSBTeW1ib2wuZm9yKCdfX0FCTFlfQ09OVEVYVF9fJyk7XG5jb25zdCBnbG9iYWxPYmplY3RGb3JDb250ZXh0ID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHt9O1xuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICBsZXQgY29udGV4dCA9IGdsb2JhbE9iamVjdEZvckNvbnRleHRbY29udGV4dEtleV07XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBnbG9iYWxPYmplY3RGb3JDb250ZXh0W2NvbnRleHRLZXldID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuZXhwb3J0IGNvbnN0IEFibHlDb250ZXh0ID0gZ2V0Q29udGV4dCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJseUNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/AblyContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/AblyProvider.js":
/*!*****************************************************!*\
  !*** ./node_modules/ably/react/mjs/AblyProvider.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AblyProvider: () => (/* binding */ AblyProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AblyContext.js */ \"(ssr)/./node_modules/ably/react/mjs/AblyContext.js\");\n\n\n\nconst AblyProvider = ({ client, children, ablyId = 'default' }) => {\n    if (!client) {\n        throw new Error('AblyProvider: the `client` prop is required');\n    }\n    const context = react__WEBPACK_IMPORTED_MODULE_1__.useContext(_AblyContext_js__WEBPACK_IMPORTED_MODULE_2__.AblyContext);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        return Object.assign(Object.assign({}, context), { [ablyId]: { client, _channelNameToChannelContext: {} } });\n    }, [context, client, ablyId]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_AblyContext_js__WEBPACK_IMPORTED_MODULE_2__.AblyContext.Provider, Object.assign({ value: value }, { children: children }));\n};\n//# sourceMappingURL=AblyProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvQWJseVByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0Q7QUFDVDtBQUNRO0FBQ3hDLHdCQUF3QixzQ0FBc0M7QUFDckU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUFnQixDQUFDLHdEQUFXO0FBQ2hELGtCQUFrQiw4Q0FBTztBQUN6Qiw2Q0FBNkMsY0FBYyxZQUFZLDRDQUE0QztBQUNuSCxLQUFLO0FBQ0wsV0FBVyxzREFBSSxDQUFDLHdEQUFXLDJCQUEyQixjQUFjLElBQUksb0JBQW9CO0FBQzVGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvQWJseVByb3ZpZGVyLmpzPzA3Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQWJseUNvbnRleHQgfSBmcm9tICcuL0FibHlDb250ZXh0LmpzJztcbmV4cG9ydCBjb25zdCBBYmx5UHJvdmlkZXIgPSAoeyBjbGllbnQsIGNoaWxkcmVuLCBhYmx5SWQgPSAnZGVmYXVsdCcgfSkgPT4ge1xuICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWJseVByb3ZpZGVyOiB0aGUgYGNsaWVudGAgcHJvcCBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChBYmx5Q29udGV4dCk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCksIHsgW2FibHlJZF06IHsgY2xpZW50LCBfY2hhbm5lbE5hbWVUb0NoYW5uZWxDb250ZXh0OiB7fSB9IH0pO1xuICAgIH0sIFtjb250ZXh0LCBjbGllbnQsIGFibHlJZF0pO1xuICAgIHJldHVybiBfanN4KEFibHlDb250ZXh0LlByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgdmFsdWU6IHZhbHVlIH0sIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmx5UHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/AblyProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/AblyReactHooks.js":
/*!*******************************************************!*\
  !*** ./node_modules/ably/react/mjs/AblyReactHooks.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   channelOptionsWithAgent: () => (/* binding */ channelOptionsWithAgent),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = '2.3.1';\nfunction channelOptionsWithAgent(options) {\n    return Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), { agent: `react-hooks/${version}` }) });\n}\n//# sourceMappingURL=AblyReactHooks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvQWJseVJlYWN0SG9va3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNBO0FBQ1AseUNBQXlDLGNBQWMsc0NBQXNDLHVFQUF1RSxzQkFBc0IsUUFBUSxHQUFHLEdBQUc7QUFDeE07QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9BYmx5UmVhY3RIb29rcy5qcz82M2VhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuMy4xJztcbmV4cG9ydCBmdW5jdGlvbiBjaGFubmVsT3B0aW9uc1dpdGhBZ2VudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcGFyYW1zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpLCB7IGFnZW50OiBgcmVhY3QtaG9va3MvJHt2ZXJzaW9ufWAgfSkgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmx5UmVhY3RIb29rcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/AblyReactHooks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/ChannelProvider.js":
/*!********************************************************!*\
  !*** ./node_modules/ably/react/mjs/ChannelProvider.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelProvider: () => (/* binding */ ChannelProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AblyContext.js */ \"(ssr)/./node_modules/ably/react/mjs/AblyContext.js\");\n/* harmony import */ var _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AblyReactHooks.js */ \"(ssr)/./node_modules/ably/react/mjs/AblyReactHooks.js\");\n\n\n\n\nconst ChannelProvider = ({ ablyId = 'default', channelName, options, deriveOptions, children, }) => {\n    const context = react__WEBPACK_IMPORTED_MODULE_1__.useContext(_AblyContext_js__WEBPACK_IMPORTED_MODULE_2__.AblyContext);\n    const { client, _channelNameToChannelContext } = context[ablyId];\n    if (_channelNameToChannelContext[channelName]) {\n        throw new Error('You can not use more than one `ChannelProvider` with the same channel name');\n    }\n    const derived = Boolean(deriveOptions);\n    const channel = derived ? client.channels.getDerived(channelName, deriveOptions) : client.channels.get(channelName);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        return Object.assign(Object.assign({}, context), { [ablyId]: {\n                client,\n                _channelNameToChannelContext: Object.assign(Object.assign({}, _channelNameToChannelContext), { [channelName]: {\n                        channel,\n                        derived,\n                    } }),\n            } });\n    }, [derived, client, channel, channelName, _channelNameToChannelContext, ablyId, context]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(() => {\n        channel.setOptions((0,_AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_3__.channelOptionsWithAgent)(options));\n    }, [channel, options]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_AblyContext_js__WEBPACK_IMPORTED_MODULE_2__.AblyContext.Provider, Object.assign({ value: value }, { children: children }));\n};\n//# sourceMappingURL=ChannelProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvQ2hhbm5lbFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdEO0FBQ1E7QUFDVDtBQUNlO0FBQ3ZELDJCQUEyQixvRUFBb0U7QUFDdEcsb0JBQW9CLDZDQUFnQixDQUFDLHdEQUFXO0FBQ2hELFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOENBQU87QUFDekIsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQSw0RUFBNEUsbUNBQW1DO0FBQy9HO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLEtBQUs7QUFDTCxJQUFJLHNEQUFlO0FBQ25CLDJCQUEyQiwyRUFBdUI7QUFDbEQsS0FBSztBQUNMLFdBQVcsc0RBQUksQ0FBQyx3REFBVywyQkFBMkIsY0FBYyxJQUFJLG9CQUFvQjtBQUM1RjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL0NoYW5uZWxQcm92aWRlci5qcz8yMDRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQWJseUNvbnRleHQgfSBmcm9tICcuL0FibHlDb250ZXh0LmpzJztcbmltcG9ydCB7IGNoYW5uZWxPcHRpb25zV2l0aEFnZW50IH0gZnJvbSAnLi9BYmx5UmVhY3RIb29rcy5qcyc7XG5leHBvcnQgY29uc3QgQ2hhbm5lbFByb3ZpZGVyID0gKHsgYWJseUlkID0gJ2RlZmF1bHQnLCBjaGFubmVsTmFtZSwgb3B0aW9ucywgZGVyaXZlT3B0aW9ucywgY2hpbGRyZW4sIH0pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChBYmx5Q29udGV4dCk7XG4gICAgY29uc3QgeyBjbGllbnQsIF9jaGFubmVsTmFtZVRvQ2hhbm5lbENvbnRleHQgfSA9IGNvbnRleHRbYWJseUlkXTtcbiAgICBpZiAoX2NoYW5uZWxOYW1lVG9DaGFubmVsQ29udGV4dFtjaGFubmVsTmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG5vdCB1c2UgbW9yZSB0aGFuIG9uZSBgQ2hhbm5lbFByb3ZpZGVyYCB3aXRoIHRoZSBzYW1lIGNoYW5uZWwgbmFtZScpO1xuICAgIH1cbiAgICBjb25zdCBkZXJpdmVkID0gQm9vbGVhbihkZXJpdmVPcHRpb25zKTtcbiAgICBjb25zdCBjaGFubmVsID0gZGVyaXZlZCA/IGNsaWVudC5jaGFubmVscy5nZXREZXJpdmVkKGNoYW5uZWxOYW1lLCBkZXJpdmVPcHRpb25zKSA6IGNsaWVudC5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IFthYmx5SWRdOiB7XG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgICAgIF9jaGFubmVsTmFtZVRvQ2hhbm5lbENvbnRleHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX2NoYW5uZWxOYW1lVG9DaGFubmVsQ29udGV4dCksIHsgW2NoYW5uZWxOYW1lXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcml2ZWQsXG4gICAgICAgICAgICAgICAgICAgIH0gfSksXG4gICAgICAgICAgICB9IH0pO1xuICAgIH0sIFtkZXJpdmVkLCBjbGllbnQsIGNoYW5uZWwsIGNoYW5uZWxOYW1lLCBfY2hhbm5lbE5hbWVUb0NoYW5uZWxDb250ZXh0LCBhYmx5SWQsIGNvbnRleHRdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnNXaXRoQWdlbnQob3B0aW9ucykpO1xuICAgIH0sIFtjaGFubmVsLCBvcHRpb25zXSk7XG4gICAgcmV0dXJuIF9qc3goQWJseUNvbnRleHQuUHJvdmlkZXIsIE9iamVjdC5hc3NpZ24oeyB2YWx1ZTogdmFsdWUgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW5uZWxQcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/ChannelProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/useAbly.js":
/*!******************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useAbly.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAbly: () => (/* binding */ useAbly)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AblyContext.js */ \"(ssr)/./node_modules/ably/react/mjs/AblyContext.js\");\n\n\nfunction useAbly(ablyId = 'default') {\n    const client = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_AblyContext_js__WEBPACK_IMPORTED_MODULE_1__.AblyContext)[ablyId].client;\n    if (!client) {\n        throw new Error('Could not find ably client in context. ' + 'Make sure your ably hooks are called inside an <AblyProvider>');\n    }\n    return client;\n}\n//# sourceMappingURL=useAbly.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlQWJseS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEI7QUFDc0I7QUFDekM7QUFDUCxtQkFBbUIsNkNBQWdCLENBQUMsd0RBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL2hvb2tzL3VzZUFibHkuanM/Y2QzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQWJseUNvbnRleHQgfSBmcm9tICcuLi9BYmx5Q29udGV4dC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gdXNlQWJseShhYmx5SWQgPSAnZGVmYXVsdCcpIHtcbiAgICBjb25zdCBjbGllbnQgPSBSZWFjdC51c2VDb250ZXh0KEFibHlDb250ZXh0KVthYmx5SWRdLmNsaWVudDtcbiAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGFibHkgY2xpZW50IGluIGNvbnRleHQuICcgKyAnTWFrZSBzdXJlIHlvdXIgYWJseSBob29rcyBhcmUgY2FsbGVkIGluc2lkZSBhbiA8QWJseVByb3ZpZGVyPicpO1xuICAgIH1cbiAgICByZXR1cm4gY2xpZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQWJseS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/useAbly.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/useChannel.js":
/*!*********************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useChannel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChannel: () => (/* binding */ useChannel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useAbly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useAbly.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useAbly.js\");\n/* harmony import */ var _useStateErrors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useStateErrors.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useStateErrors.js\");\n/* harmony import */ var _useChannelInstance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useChannelInstance.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\");\n\n\n\n\nfunction useChannel(channelNameOrNameAndOptions, eventOrCallback, callback) {\n    const channelHookOptions = typeof channelNameOrNameAndOptions === 'object'\n        ? channelNameOrNameAndOptions\n        : { channelName: channelNameOrNameAndOptions };\n    const ably = (0,_useAbly_js__WEBPACK_IMPORTED_MODULE_1__.useAbly)(channelHookOptions.ablyId);\n    const { channelName, skip } = channelHookOptions;\n    const { channel, derived } = (0,_useChannelInstance_js__WEBPACK_IMPORTED_MODULE_3__.useChannelInstance)(channelHookOptions.ablyId, channelName);\n    const publish = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (!derived)\n            return channel.publish.bind(channel);\n        const regularChannel = ably.channels.get(channelName);\n        // For derived channels we use transient publish (it won't attach to the channel)\n        return regularChannel.publish.bind(regularChannel);\n    }, [ably.channels, derived, channel, channelName]);\n    const channelEvent = typeof eventOrCallback === 'string' ? eventOrCallback : null;\n    const ablyMessageCallback = typeof eventOrCallback === 'string' ? callback : eventOrCallback;\n    const ablyMessageCallbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(ablyMessageCallback);\n    const { connectionError, channelError } = (0,_useStateErrors_js__WEBPACK_IMPORTED_MODULE_2__.useStateErrors)(channelHookOptions);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        ablyMessageCallbackRef.current = ablyMessageCallback;\n    }, [ablyMessageCallback]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const listener = ablyMessageCallbackRef.current\n            ? (message) => {\n                ablyMessageCallbackRef.current && ablyMessageCallbackRef.current(message);\n            }\n            : null;\n        const subscribeArgs = listener\n            ? channelEvent === null\n                ? [listener]\n                : [channelEvent, listener]\n            : null;\n        if (!skip && subscribeArgs) {\n            handleChannelMount(channel, ...subscribeArgs);\n        }\n        return () => {\n            !skip && subscribeArgs && handleChannelUnmount(channel, ...subscribeArgs);\n        };\n    }, [channelEvent, channel, skip]);\n    return { channel, publish, ably, connectionError, channelError };\n}\nasync function handleChannelMount(channel, ...subscribeArgs) {\n    await channel.subscribe(...subscribeArgs);\n}\nasync function handleChannelUnmount(channel, ...subscribeArgs) {\n    await channel.unsubscribe(...subscribeArgs);\n}\n//# sourceMappingURL=useChannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlQ2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRDtBQUNaO0FBQ2M7QUFDUTtBQUN0RDtBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1osaUJBQWlCLG9EQUFPO0FBQ3hCLFlBQVksb0JBQW9CO0FBQ2hDLFlBQVksbUJBQW1CLEVBQUUsMEVBQWtCO0FBQ25ELG9CQUFvQiw4Q0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUMsNkNBQU07QUFDekMsWUFBWSxnQ0FBZ0MsRUFBRSxrRUFBYztBQUM1RCxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL2hvb2tzL3VzZUNoYW5uZWwuanM/NjJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUFibHkgfSBmcm9tICcuL3VzZUFibHkuanMnO1xuaW1wb3J0IHsgdXNlU3RhdGVFcnJvcnMgfSBmcm9tICcuL3VzZVN0YXRlRXJyb3JzLmpzJztcbmltcG9ydCB7IHVzZUNoYW5uZWxJbnN0YW5jZSB9IGZyb20gJy4vdXNlQ2hhbm5lbEluc3RhbmNlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGFubmVsKGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucywgZXZlbnRPckNhbGxiYWNrLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGNoYW5uZWxIb29rT3B0aW9ucyA9IHR5cGVvZiBjaGFubmVsTmFtZU9yTmFtZUFuZE9wdGlvbnMgPT09ICdvYmplY3QnXG4gICAgICAgID8gY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zXG4gICAgICAgIDogeyBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zIH07XG4gICAgY29uc3QgYWJseSA9IHVzZUFibHkoY2hhbm5lbEhvb2tPcHRpb25zLmFibHlJZCk7XG4gICAgY29uc3QgeyBjaGFubmVsTmFtZSwgc2tpcCB9ID0gY2hhbm5lbEhvb2tPcHRpb25zO1xuICAgIGNvbnN0IHsgY2hhbm5lbCwgZGVyaXZlZCB9ID0gdXNlQ2hhbm5lbEluc3RhbmNlKGNoYW5uZWxIb29rT3B0aW9ucy5hYmx5SWQsIGNoYW5uZWxOYW1lKTtcbiAgICBjb25zdCBwdWJsaXNoID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghZGVyaXZlZClcbiAgICAgICAgICAgIHJldHVybiBjaGFubmVsLnB1Ymxpc2guYmluZChjaGFubmVsKTtcbiAgICAgICAgY29uc3QgcmVndWxhckNoYW5uZWwgPSBhYmx5LmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSk7XG4gICAgICAgIC8vIEZvciBkZXJpdmVkIGNoYW5uZWxzIHdlIHVzZSB0cmFuc2llbnQgcHVibGlzaCAoaXQgd29uJ3QgYXR0YWNoIHRvIHRoZSBjaGFubmVsKVxuICAgICAgICByZXR1cm4gcmVndWxhckNoYW5uZWwucHVibGlzaC5iaW5kKHJlZ3VsYXJDaGFubmVsKTtcbiAgICB9LCBbYWJseS5jaGFubmVscywgZGVyaXZlZCwgY2hhbm5lbCwgY2hhbm5lbE5hbWVdKTtcbiAgICBjb25zdCBjaGFubmVsRXZlbnQgPSB0eXBlb2YgZXZlbnRPckNhbGxiYWNrID09PSAnc3RyaW5nJyA/IGV2ZW50T3JDYWxsYmFjayA6IG51bGw7XG4gICAgY29uc3QgYWJseU1lc3NhZ2VDYWxsYmFjayA9IHR5cGVvZiBldmVudE9yQ2FsbGJhY2sgPT09ICdzdHJpbmcnID8gY2FsbGJhY2sgOiBldmVudE9yQ2FsbGJhY2s7XG4gICAgY29uc3QgYWJseU1lc3NhZ2VDYWxsYmFja1JlZiA9IHVzZVJlZihhYmx5TWVzc2FnZUNhbGxiYWNrKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25FcnJvciwgY2hhbm5lbEVycm9yIH0gPSB1c2VTdGF0ZUVycm9ycyhjaGFubmVsSG9va09wdGlvbnMpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGFibHlNZXNzYWdlQ2FsbGJhY2tSZWYuY3VycmVudCA9IGFibHlNZXNzYWdlQ2FsbGJhY2s7XG4gICAgfSwgW2FibHlNZXNzYWdlQ2FsbGJhY2tdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGFibHlNZXNzYWdlQ2FsbGJhY2tSZWYuY3VycmVudFxuICAgICAgICAgICAgPyAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFibHlNZXNzYWdlQ2FsbGJhY2tSZWYuY3VycmVudCAmJiBhYmx5TWVzc2FnZUNhbGxiYWNrUmVmLmN1cnJlbnQobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZUFyZ3MgPSBsaXN0ZW5lclxuICAgICAgICAgICAgPyBjaGFubmVsRXZlbnQgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFtsaXN0ZW5lcl1cbiAgICAgICAgICAgICAgICA6IFtjaGFubmVsRXZlbnQsIGxpc3RlbmVyXVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIXNraXAgJiYgc3Vic2NyaWJlQXJncykge1xuICAgICAgICAgICAgaGFuZGxlQ2hhbm5lbE1vdW50KGNoYW5uZWwsIC4uLnN1YnNjcmliZUFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAhc2tpcCAmJiBzdWJzY3JpYmVBcmdzICYmIGhhbmRsZUNoYW5uZWxVbm1vdW50KGNoYW5uZWwsIC4uLnN1YnNjcmliZUFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0sIFtjaGFubmVsRXZlbnQsIGNoYW5uZWwsIHNraXBdKTtcbiAgICByZXR1cm4geyBjaGFubmVsLCBwdWJsaXNoLCBhYmx5LCBjb25uZWN0aW9uRXJyb3IsIGNoYW5uZWxFcnJvciB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ2hhbm5lbE1vdW50KGNoYW5uZWwsIC4uLnN1YnNjcmliZUFyZ3MpIHtcbiAgICBhd2FpdCBjaGFubmVsLnN1YnNjcmliZSguLi5zdWJzY3JpYmVBcmdzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNoYW5uZWxVbm1vdW50KGNoYW5uZWwsIC4uLnN1YnNjcmliZUFyZ3MpIHtcbiAgICBhd2FpdCBjaGFubmVsLnVuc3Vic2NyaWJlKC4uLnN1YnNjcmliZUFyZ3MpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQ2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/useChannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useChannelInstance.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChannelInstance: () => (/* binding */ useChannelInstance)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AblyContext.js */ \"(ssr)/./node_modules/ably/react/mjs/AblyContext.js\");\n\n\nfunction useChannelInstance(ablyId = 'default', channelName) {\n    const channelContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_AblyContext_js__WEBPACK_IMPORTED_MODULE_1__.AblyContext)[ablyId]._channelNameToChannelContext[channelName];\n    if (!channelContext) {\n        throw new Error(`Could not find a parent ChannelProvider in the component tree for channelName=\"${channelName}\". Make sure your channel based hooks (usePresence, useChannel, useChannelStateListener) are called inside a <ChannelProvider> component`);\n    }\n    return channelContext;\n}\n//# sourceMappingURL=useChannelInstance.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlQ2hhbm5lbEluc3RhbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQUNzQjtBQUN6QztBQUNQLDJCQUEyQiw2Q0FBZ0IsQ0FBQyx3REFBVztBQUN2RDtBQUNBLDBHQUEwRyxZQUFZO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL2hvb2tzL3VzZUNoYW5uZWxJbnN0YW5jZS5qcz9jNmQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBBYmx5Q29udGV4dCB9IGZyb20gJy4uL0FibHlDb250ZXh0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGFubmVsSW5zdGFuY2UoYWJseUlkID0gJ2RlZmF1bHQnLCBjaGFubmVsTmFtZSkge1xuICAgIGNvbnN0IGNoYW5uZWxDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChBYmx5Q29udGV4dClbYWJseUlkXS5fY2hhbm5lbE5hbWVUb0NoYW5uZWxDb250ZXh0W2NoYW5uZWxOYW1lXTtcbiAgICBpZiAoIWNoYW5uZWxDb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBwYXJlbnQgQ2hhbm5lbFByb3ZpZGVyIGluIHRoZSBjb21wb25lbnQgdHJlZSBmb3IgY2hhbm5lbE5hbWU9XCIke2NoYW5uZWxOYW1lfVwiLiBNYWtlIHN1cmUgeW91ciBjaGFubmVsIGJhc2VkIGhvb2tzICh1c2VQcmVzZW5jZSwgdXNlQ2hhbm5lbCwgdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIpIGFyZSBjYWxsZWQgaW5zaWRlIGEgPENoYW5uZWxQcm92aWRlcj4gY29tcG9uZW50YCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsQ29udGV4dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUNoYW5uZWxJbnN0YW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useChannelStateListener.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChannelStateListener: () => (/* binding */ useChannelStateListener)\n/* harmony export */ });\n/* harmony import */ var _useEventListener_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useEventListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useEventListener.js\");\n/* harmony import */ var _useChannelInstance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useChannelInstance.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\");\n\n\nfunction useChannelStateListener(channelNameOrNameAndAblyId, stateOrListener, listener) {\n    const channelHookOptions = typeof channelNameOrNameAndAblyId === 'object'\n        ? channelNameOrNameAndAblyId\n        : { channelName: channelNameOrNameAndAblyId };\n    const { ablyId, channelName } = channelHookOptions;\n    const { channel } = (0,_useChannelInstance_js__WEBPACK_IMPORTED_MODULE_1__.useChannelInstance)(ablyId, channelName);\n    const _listener = typeof listener === 'function' ? listener : stateOrListener;\n    const state = typeof stateOrListener !== 'function' ? stateOrListener : undefined;\n    (0,_useEventListener_js__WEBPACK_IMPORTED_MODULE_0__.useEventListener)(channel, _listener, state);\n}\n//# sourceMappingURL=useChannelStateListener.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlEO0FBQ0k7QUFDdEQ7QUFDUDtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVksc0JBQXNCO0FBQ2xDLFlBQVksVUFBVSxFQUFFLDBFQUFrQjtBQUMxQztBQUNBO0FBQ0EsSUFBSSxzRUFBZ0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VDaGFubmVsU3RhdGVMaXN0ZW5lci5qcz81ZDFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUV2ZW50TGlzdGVuZXIgfSBmcm9tICcuL3VzZUV2ZW50TGlzdGVuZXIuanMnO1xuaW1wb3J0IHsgdXNlQ2hhbm5lbEluc3RhbmNlIH0gZnJvbSAnLi91c2VDaGFubmVsSW5zdGFuY2UuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYW5uZWxTdGF0ZUxpc3RlbmVyKGNoYW5uZWxOYW1lT3JOYW1lQW5kQWJseUlkLCBzdGF0ZU9yTGlzdGVuZXIsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgY2hhbm5lbEhvb2tPcHRpb25zID0gdHlwZW9mIGNoYW5uZWxOYW1lT3JOYW1lQW5kQWJseUlkID09PSAnb2JqZWN0J1xuICAgICAgICA/IGNoYW5uZWxOYW1lT3JOYW1lQW5kQWJseUlkXG4gICAgICAgIDogeyBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWVPck5hbWVBbmRBYmx5SWQgfTtcbiAgICBjb25zdCB7IGFibHlJZCwgY2hhbm5lbE5hbWUgfSA9IGNoYW5uZWxIb29rT3B0aW9ucztcbiAgICBjb25zdCB7IGNoYW5uZWwgfSA9IHVzZUNoYW5uZWxJbnN0YW5jZShhYmx5SWQsIGNoYW5uZWxOYW1lKTtcbiAgICBjb25zdCBfbGlzdGVuZXIgPSB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgPyBsaXN0ZW5lciA6IHN0YXRlT3JMaXN0ZW5lcjtcbiAgICBjb25zdCBzdGF0ZSA9IHR5cGVvZiBzdGF0ZU9yTGlzdGVuZXIgIT09ICdmdW5jdGlvbicgPyBzdGF0ZU9yTGlzdGVuZXIgOiB1bmRlZmluZWQ7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihjaGFubmVsLCBfbGlzdGVuZXIsIHN0YXRlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUNoYW5uZWxTdGF0ZUxpc3RlbmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useConnectionStateListener: () => (/* binding */ useConnectionStateListener)\n/* harmony export */ });\n/* harmony import */ var _useAbly_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useAbly.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useAbly.js\");\n/* harmony import */ var _useEventListener_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useEventListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useEventListener.js\");\n\n\nfunction useConnectionStateListener(stateOrListener, listenerOrAblyId, ablyId = 'default') {\n    const _ablyId = typeof listenerOrAblyId === 'string' ? listenerOrAblyId : ablyId;\n    const ably = (0,_useAbly_js__WEBPACK_IMPORTED_MODULE_0__.useAbly)(_ablyId);\n    const listener = typeof listenerOrAblyId === 'function' ? listenerOrAblyId : stateOrListener;\n    const state = typeof stateOrListener !== 'function' ? stateOrListener : undefined;\n    (0,_useEventListener_js__WEBPACK_IMPORTED_MODULE_1__.useEventListener)(ably.connection, listener, state);\n}\n//# sourceMappingURL=useConnectionStateListener.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVDO0FBQ2tCO0FBQ2xEO0FBQ1A7QUFDQSxpQkFBaUIsb0RBQU87QUFDeEI7QUFDQTtBQUNBLElBQUksc0VBQWdCO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIuanM/YmYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VBYmx5IH0gZnJvbSAnLi91c2VBYmx5LmpzJztcbmltcG9ydCB7IHVzZUV2ZW50TGlzdGVuZXIgfSBmcm9tICcuL3VzZUV2ZW50TGlzdGVuZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyKHN0YXRlT3JMaXN0ZW5lciwgbGlzdGVuZXJPckFibHlJZCwgYWJseUlkID0gJ2RlZmF1bHQnKSB7XG4gICAgY29uc3QgX2FibHlJZCA9IHR5cGVvZiBsaXN0ZW5lck9yQWJseUlkID09PSAnc3RyaW5nJyA/IGxpc3RlbmVyT3JBYmx5SWQgOiBhYmx5SWQ7XG4gICAgY29uc3QgYWJseSA9IHVzZUFibHkoX2FibHlJZCk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSB0eXBlb2YgbGlzdGVuZXJPckFibHlJZCA9PT0gJ2Z1bmN0aW9uJyA/IGxpc3RlbmVyT3JBYmx5SWQgOiBzdGF0ZU9yTGlzdGVuZXI7XG4gICAgY29uc3Qgc3RhdGUgPSB0eXBlb2Ygc3RhdGVPckxpc3RlbmVyICE9PSAnZnVuY3Rpb24nID8gc3RhdGVPckxpc3RlbmVyIDogdW5kZWZpbmVkO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoYWJseS5jb25uZWN0aW9uLCBsaXN0ZW5lciwgc3RhdGUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/useEventListener.js":
/*!***************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useEventListener.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEventListener: () => (/* binding */ useEventListener)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction useEventListener(emitter, listener, event) {\n    const savedListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(listener);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        savedListener.current = listener;\n    }, [listener]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (event) {\n            emitter.on(event, savedListener.current);\n        }\n        else {\n            emitter.on(listener);\n        }\n        return () => {\n            if (event) {\n                emitter.off(event, listener);\n            }\n            else {\n                emitter.off(listener);\n            }\n        };\n    }, [emitter, event, listener]);\n}\n//# sourceMappingURL=useEventListener.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlRXZlbnRMaXN0ZW5lci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUNuQztBQUNQLDBCQUEwQiw2Q0FBTTtBQUNoQyxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VFdmVudExpc3RlbmVyLmpzP2Q5MTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihlbWl0dGVyLCBsaXN0ZW5lciwgZXZlbnQpIHtcbiAgICBjb25zdCBzYXZlZExpc3RlbmVyID0gdXNlUmVmKGxpc3RlbmVyKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzYXZlZExpc3RlbmVyLmN1cnJlbnQgPSBsaXN0ZW5lcjtcbiAgICB9LCBbbGlzdGVuZXJdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub24oZXZlbnQsIHNhdmVkTGlzdGVuZXIuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIub2ZmKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbZW1pdHRlciwgZXZlbnQsIGxpc3RlbmVyXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VFdmVudExpc3RlbmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/useEventListener.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/usePresence.js":
/*!**********************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/usePresence.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePresence: () => (/* binding */ usePresence)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useAbly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useAbly.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useAbly.js\");\n/* harmony import */ var _useChannelInstance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useChannelInstance.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\");\n/* harmony import */ var _useStateErrors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useStateErrors.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useStateErrors.js\");\n/* harmony import */ var _useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useConnectionStateListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js\");\n/* harmony import */ var _useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./useChannelStateListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js\");\n\n\n\n\n\n\nconst INACTIVE_CONNECTION_STATES = ['suspended', 'closing', 'closed', 'failed'];\nconst INACTIVE_CHANNEL_STATES = ['failed', 'suspended', 'detaching'];\nfunction usePresence(channelNameOrNameAndOptions, messageOrPresenceObject) {\n    const params = typeof channelNameOrNameAndOptions === 'object'\n        ? channelNameOrNameAndOptions\n        : { channelName: channelNameOrNameAndOptions };\n    const skip = params.skip;\n    const ably = (0,_useAbly_js__WEBPACK_IMPORTED_MODULE_1__.useAbly)(params.ablyId);\n    const { channel } = (0,_useChannelInstance_js__WEBPACK_IMPORTED_MODULE_2__.useChannelInstance)(params.ablyId, params.channelName);\n    const { connectionError, channelError } = (0,_useStateErrors_js__WEBPACK_IMPORTED_MODULE_3__.useStateErrors)(params);\n    // we can't simply add messageOrPresenceObject to dependency list in our useCallback/useEffect hooks,\n    // since it will most likely cause an infinite loop of updates in cases when user calls this hook\n    // with an object literal instead of a state or memoized object.\n    // to prevent this from happening we store messageOrPresenceObject in a ref, and use that instead.\n    // note that it still prevents us from automatically re-entering presence with new messageOrPresenceObject if it changes.\n    // one of the options to fix this, is to use deep equals to check if the object has actually changed. see https://github.com/ably/ably-js/issues/1688.\n    const messageOrPresenceObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messageOrPresenceObject);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        messageOrPresenceObjectRef.current = messageOrPresenceObject;\n    }, [messageOrPresenceObject]);\n    // we need to listen for the current connection state in order to react to it.\n    // for example, we should enter presence when first connected, re-enter when reconnected,\n    // and be able to prevent entering presence when the connection is in an inactive state.\n    // all of that can be achieved by using the useConnectionStateListener hook.\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(ably.connection.state);\n    (0,_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_4__.useConnectionStateListener)((stateChange) => {\n        setConnectionState(stateChange.current);\n    }, params.ablyId);\n    // similar to connection states, we should only attempt to enter presence when in certain\n    // channel states.\n    const [channelState, setChannelState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(channel.state);\n    (0,_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_5__.useChannelStateListener)(params, (stateChange) => {\n        setChannelState(stateChange.current);\n    });\n    const shouldNotEnterPresence = INACTIVE_CONNECTION_STATES.includes(connectionState) || INACTIVE_CHANNEL_STATES.includes(channelState) || skip;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (shouldNotEnterPresence) {\n            return;\n        }\n        const onMount = async () => {\n            await channel.presence.enter(messageOrPresenceObjectRef.current);\n        };\n        onMount();\n        return () => {\n            // here we use the ably.connection.state property, which upon this cleanup function call\n            // will have the current connection state for that connection, thanks to us accessing the Ably instance here by reference.\n            // if the connection is in one of the inactive states or the channel is not attached, a presence.leave call will produce an exception.\n            // so we only leave presence in other cases.\n            if (channel.state === 'attached' && !INACTIVE_CONNECTION_STATES.includes(ably.connection.state)) {\n                channel.presence.leave();\n            }\n        };\n    }, [shouldNotEnterPresence, channel, ably]);\n    const updateStatus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (messageOrPresenceObject) => {\n        await channel.presence.update(messageOrPresenceObject);\n    }, [channel]);\n    return { updateStatus, connectionError, channelError };\n}\n//# sourceMappingURL=usePresence.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlUHJlc2VuY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRTtBQUMxQjtBQUNzQjtBQUNSO0FBQ3dCO0FBQ047QUFDdkU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGlCQUFpQixvREFBTztBQUN4QixZQUFZLFVBQVUsRUFBRSwwRUFBa0I7QUFDMUMsWUFBWSxnQ0FBZ0MsRUFBRSxrRUFBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkNBQU07QUFDN0MsSUFBSSxnREFBUztBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELCtDQUFRO0FBQzFELElBQUksMEZBQTBCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0Q0FBNEMsK0NBQVE7QUFDcEQsSUFBSSxvRkFBdUI7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLGtEQUFXO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2FibHkvcmVhY3QvbWpzL2hvb2tzL3VzZVByZXNlbmNlLmpzP2ViNmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUFibHkgfSBmcm9tICcuL3VzZUFibHkuanMnO1xuaW1wb3J0IHsgdXNlQ2hhbm5lbEluc3RhbmNlIH0gZnJvbSAnLi91c2VDaGFubmVsSW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgdXNlU3RhdGVFcnJvcnMgfSBmcm9tICcuL3VzZVN0YXRlRXJyb3JzLmpzJztcbmltcG9ydCB7IHVzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyIH0gZnJvbSAnLi91c2VDb25uZWN0aW9uU3RhdGVMaXN0ZW5lci5qcyc7XG5pbXBvcnQgeyB1c2VDaGFubmVsU3RhdGVMaXN0ZW5lciB9IGZyb20gJy4vdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIuanMnO1xuY29uc3QgSU5BQ1RJVkVfQ09OTkVDVElPTl9TVEFURVMgPSBbJ3N1c3BlbmRlZCcsICdjbG9zaW5nJywgJ2Nsb3NlZCcsICdmYWlsZWQnXTtcbmNvbnN0IElOQUNUSVZFX0NIQU5ORUxfU1RBVEVTID0gWydmYWlsZWQnLCAnc3VzcGVuZGVkJywgJ2RldGFjaGluZyddO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVByZXNlbmNlKGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucywgbWVzc2FnZU9yUHJlc2VuY2VPYmplY3QpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0eXBlb2YgY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zID09PSAnb2JqZWN0J1xuICAgICAgICA/IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9uc1xuICAgICAgICA6IHsgY2hhbm5lbE5hbWU6IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucyB9O1xuICAgIGNvbnN0IHNraXAgPSBwYXJhbXMuc2tpcDtcbiAgICBjb25zdCBhYmx5ID0gdXNlQWJseShwYXJhbXMuYWJseUlkKTtcbiAgICBjb25zdCB7IGNoYW5uZWwgfSA9IHVzZUNoYW5uZWxJbnN0YW5jZShwYXJhbXMuYWJseUlkLCBwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkVycm9yLCBjaGFubmVsRXJyb3IgfSA9IHVzZVN0YXRlRXJyb3JzKHBhcmFtcyk7XG4gICAgLy8gd2UgY2FuJ3Qgc2ltcGx5IGFkZCBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCB0byBkZXBlbmRlbmN5IGxpc3QgaW4gb3VyIHVzZUNhbGxiYWNrL3VzZUVmZmVjdCBob29rcyxcbiAgICAvLyBzaW5jZSBpdCB3aWxsIG1vc3QgbGlrZWx5IGNhdXNlIGFuIGluZmluaXRlIGxvb3Agb2YgdXBkYXRlcyBpbiBjYXNlcyB3aGVuIHVzZXIgY2FsbHMgdGhpcyBob29rXG4gICAgLy8gd2l0aCBhbiBvYmplY3QgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgc3RhdGUgb3IgbWVtb2l6ZWQgb2JqZWN0LlxuICAgIC8vIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZyB3ZSBzdG9yZSBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCBpbiBhIHJlZiwgYW5kIHVzZSB0aGF0IGluc3RlYWQuXG4gICAgLy8gbm90ZSB0aGF0IGl0IHN0aWxsIHByZXZlbnRzIHVzIGZyb20gYXV0b21hdGljYWxseSByZS1lbnRlcmluZyBwcmVzZW5jZSB3aXRoIG5ldyBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCBpZiBpdCBjaGFuZ2VzLlxuICAgIC8vIG9uZSBvZiB0aGUgb3B0aW9ucyB0byBmaXggdGhpcywgaXMgdG8gdXNlIGRlZXAgZXF1YWxzIHRvIGNoZWNrIGlmIHRoZSBvYmplY3QgaGFzIGFjdHVhbGx5IGNoYW5nZWQuIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8xNjg4LlxuICAgIGNvbnN0IG1lc3NhZ2VPclByZXNlbmNlT2JqZWN0UmVmID0gdXNlUmVmKG1lc3NhZ2VPclByZXNlbmNlT2JqZWN0KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdFJlZi5jdXJyZW50ID0gbWVzc2FnZU9yUHJlc2VuY2VPYmplY3Q7XG4gICAgfSwgW21lc3NhZ2VPclByZXNlbmNlT2JqZWN0XSk7XG4gICAgLy8gd2UgbmVlZCB0byBsaXN0ZW4gZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgaW4gb3JkZXIgdG8gcmVhY3QgdG8gaXQuXG4gICAgLy8gZm9yIGV4YW1wbGUsIHdlIHNob3VsZCBlbnRlciBwcmVzZW5jZSB3aGVuIGZpcnN0IGNvbm5lY3RlZCwgcmUtZW50ZXIgd2hlbiByZWNvbm5lY3RlZCxcbiAgICAvLyBhbmQgYmUgYWJsZSB0byBwcmV2ZW50IGVudGVyaW5nIHByZXNlbmNlIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgaW4gYW4gaW5hY3RpdmUgc3RhdGUuXG4gICAgLy8gYWxsIG9mIHRoYXQgY2FuIGJlIGFjaGlldmVkIGJ5IHVzaW5nIHRoZSB1c2VDb25uZWN0aW9uU3RhdGVMaXN0ZW5lciBob29rLlxuICAgIGNvbnN0IFtjb25uZWN0aW9uU3RhdGUsIHNldENvbm5lY3Rpb25TdGF0ZV0gPSB1c2VTdGF0ZShhYmx5LmNvbm5lY3Rpb24uc3RhdGUpO1xuICAgIHVzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyKChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoc3RhdGVDaGFuZ2UuY3VycmVudCk7XG4gICAgfSwgcGFyYW1zLmFibHlJZCk7XG4gICAgLy8gc2ltaWxhciB0byBjb25uZWN0aW9uIHN0YXRlcywgd2Ugc2hvdWxkIG9ubHkgYXR0ZW1wdCB0byBlbnRlciBwcmVzZW5jZSB3aGVuIGluIGNlcnRhaW5cbiAgICAvLyBjaGFubmVsIHN0YXRlcy5cbiAgICBjb25zdCBbY2hhbm5lbFN0YXRlLCBzZXRDaGFubmVsU3RhdGVdID0gdXNlU3RhdGUoY2hhbm5lbC5zdGF0ZSk7XG4gICAgdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIocGFyYW1zLCAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgICAgc2V0Q2hhbm5lbFN0YXRlKHN0YXRlQ2hhbmdlLmN1cnJlbnQpO1xuICAgIH0pO1xuICAgIGNvbnN0IHNob3VsZE5vdEVudGVyUHJlc2VuY2UgPSBJTkFDVElWRV9DT05ORUNUSU9OX1NUQVRFUy5pbmNsdWRlcyhjb25uZWN0aW9uU3RhdGUpIHx8IElOQUNUSVZFX0NIQU5ORUxfU1RBVEVTLmluY2x1ZGVzKGNoYW5uZWxTdGF0ZSkgfHwgc2tpcDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkTm90RW50ZXJQcmVzZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uTW91bnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBjaGFubmVsLnByZXNlbmNlLmVudGVyKG1lc3NhZ2VPclByZXNlbmNlT2JqZWN0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBvbk1vdW50KCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBoZXJlIHdlIHVzZSB0aGUgYWJseS5jb25uZWN0aW9uLnN0YXRlIHByb3BlcnR5LCB3aGljaCB1cG9uIHRoaXMgY2xlYW51cCBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAvLyB3aWxsIGhhdmUgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSBmb3IgdGhhdCBjb25uZWN0aW9uLCB0aGFua3MgdG8gdXMgYWNjZXNzaW5nIHRoZSBBYmx5IGluc3RhbmNlIGhlcmUgYnkgcmVmZXJlbmNlLlxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3Rpb24gaXMgaW4gb25lIG9mIHRoZSBpbmFjdGl2ZSBzdGF0ZXMgb3IgdGhlIGNoYW5uZWwgaXMgbm90IGF0dGFjaGVkLCBhIHByZXNlbmNlLmxlYXZlIGNhbGwgd2lsbCBwcm9kdWNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIC8vIHNvIHdlIG9ubHkgbGVhdmUgcHJlc2VuY2UgaW4gb3RoZXIgY2FzZXMuXG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJyAmJiAhSU5BQ1RJVkVfQ09OTkVDVElPTl9TVEFURVMuaW5jbHVkZXMoYWJseS5jb25uZWN0aW9uLnN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwucHJlc2VuY2UubGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbc2hvdWxkTm90RW50ZXJQcmVzZW5jZSwgY2hhbm5lbCwgYWJseV0pO1xuICAgIGNvbnN0IHVwZGF0ZVN0YXR1cyA9IHVzZUNhbGxiYWNrKGFzeW5jIChtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCkgPT4ge1xuICAgICAgICBhd2FpdCBjaGFubmVsLnByZXNlbmNlLnVwZGF0ZShtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCk7XG4gICAgfSwgW2NoYW5uZWxdKTtcbiAgICByZXR1cm4geyB1cGRhdGVTdGF0dXMsIGNvbm5lY3Rpb25FcnJvciwgY2hhbm5lbEVycm9yIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VQcmVzZW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/usePresence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/usePresenceListener.js":
/*!******************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/usePresenceListener.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePresenceListener: () => (/* binding */ usePresenceListener)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useChannelInstance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useChannelInstance.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useChannelInstance.js\");\n/* harmony import */ var _useStateErrors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useStateErrors.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useStateErrors.js\");\n\n\n\nfunction usePresenceListener(channelNameOrNameAndOptions, onPresenceMessageReceived) {\n    const params = typeof channelNameOrNameAndOptions === 'object'\n        ? channelNameOrNameAndOptions\n        : { channelName: channelNameOrNameAndOptions };\n    const skip = params.skip;\n    const { channel } = (0,_useChannelInstance_js__WEBPACK_IMPORTED_MODULE_1__.useChannelInstance)(params.ablyId, params.channelName);\n    const { connectionError, channelError } = (0,_useStateErrors_js__WEBPACK_IMPORTED_MODULE_2__.useStateErrors)(params);\n    const [presenceData, updatePresenceData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const onPresenceMessageReceivedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onPresenceMessageReceived);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        onPresenceMessageReceivedRef.current = onPresenceMessageReceived;\n    }, [onPresenceMessageReceived]);\n    const updatePresence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message) => {\n        var _a;\n        const snapshot = await channel.presence.get();\n        updatePresenceData(snapshot);\n        (_a = onPresenceMessageReceivedRef.current) === null || _a === void 0 ? void 0 : _a.call(onPresenceMessageReceivedRef, message);\n    }, [channel.presence]);\n    const onMount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n        channel.presence.subscribe(['enter', 'leave', 'update'], updatePresence);\n        const snapshot = await channel.presence.get();\n        updatePresenceData(snapshot);\n    }, [channel.presence, updatePresence]);\n    const onUnmount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n        channel.presence.unsubscribe(['enter', 'leave', 'update'], updatePresence);\n    }, [channel.presence, updatePresence]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (skip)\n            return;\n        onMount();\n        return () => {\n            onUnmount();\n        };\n    }, [skip, onMount, onUnmount]);\n    return { presenceData, connectionError, channelError };\n}\n//# sourceMappingURL=usePresenceListener.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlUHJlc2VuY2VMaXN0ZW5lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlFO0FBQ0o7QUFDUjtBQUM5QztBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZLFVBQVUsRUFBRSwwRUFBa0I7QUFDMUMsWUFBWSxnQ0FBZ0MsRUFBRSxrRUFBYztBQUM1RCwrQ0FBK0MsK0NBQVE7QUFDdkQseUNBQXlDLDZDQUFNO0FBQy9DLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsa0RBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGtEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9hYmx5L3JlYWN0L21qcy9ob29rcy91c2VQcmVzZW5jZUxpc3RlbmVyLmpzPzMyNDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNoYW5uZWxJbnN0YW5jZSB9IGZyb20gJy4vdXNlQ2hhbm5lbEluc3RhbmNlLmpzJztcbmltcG9ydCB7IHVzZVN0YXRlRXJyb3JzIH0gZnJvbSAnLi91c2VTdGF0ZUVycm9ycy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc2VuY2VMaXN0ZW5lcihjaGFubmVsTmFtZU9yTmFtZUFuZE9wdGlvbnMsIG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0eXBlb2YgY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zID09PSAnb2JqZWN0J1xuICAgICAgICA/IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9uc1xuICAgICAgICA6IHsgY2hhbm5lbE5hbWU6IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucyB9O1xuICAgIGNvbnN0IHNraXAgPSBwYXJhbXMuc2tpcDtcbiAgICBjb25zdCB7IGNoYW5uZWwgfSA9IHVzZUNoYW5uZWxJbnN0YW5jZShwYXJhbXMuYWJseUlkLCBwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkVycm9yLCBjaGFubmVsRXJyb3IgfSA9IHVzZVN0YXRlRXJyb3JzKHBhcmFtcyk7XG4gICAgY29uc3QgW3ByZXNlbmNlRGF0YSwgdXBkYXRlUHJlc2VuY2VEYXRhXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBvblByZXNlbmNlTWVzc2FnZVJlY2VpdmVkUmVmID0gdXNlUmVmKG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWRSZWYuY3VycmVudCA9IG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWQ7XG4gICAgfSwgW29uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWRdKTtcbiAgICBjb25zdCB1cGRhdGVQcmVzZW5jZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBjaGFubmVsLnByZXNlbmNlLmdldCgpO1xuICAgICAgICB1cGRhdGVQcmVzZW5jZURhdGEoc25hcHNob3QpO1xuICAgICAgICAoX2EgPSBvblByZXNlbmNlTWVzc2FnZVJlY2VpdmVkUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9uUHJlc2VuY2VNZXNzYWdlUmVjZWl2ZWRSZWYsIG1lc3NhZ2UpO1xuICAgIH0sIFtjaGFubmVsLnByZXNlbmNlXSk7XG4gICAgY29uc3Qgb25Nb3VudCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgY2hhbm5lbC5wcmVzZW5jZS5zdWJzY3JpYmUoWydlbnRlcicsICdsZWF2ZScsICd1cGRhdGUnXSwgdXBkYXRlUHJlc2VuY2UpO1xuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGNoYW5uZWwucHJlc2VuY2UuZ2V0KCk7XG4gICAgICAgIHVwZGF0ZVByZXNlbmNlRGF0YShzbmFwc2hvdCk7XG4gICAgfSwgW2NoYW5uZWwucHJlc2VuY2UsIHVwZGF0ZVByZXNlbmNlXSk7XG4gICAgY29uc3Qgb25Vbm1vdW50ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBjaGFubmVsLnByZXNlbmNlLnVuc3Vic2NyaWJlKFsnZW50ZXInLCAnbGVhdmUnLCAndXBkYXRlJ10sIHVwZGF0ZVByZXNlbmNlKTtcbiAgICB9LCBbY2hhbm5lbC5wcmVzZW5jZSwgdXBkYXRlUHJlc2VuY2VdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2tpcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb25Nb3VudCgpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgb25Vbm1vdW50KCk7XG4gICAgICAgIH07XG4gICAgfSwgW3NraXAsIG9uTW91bnQsIG9uVW5tb3VudF0pO1xuICAgIHJldHVybiB7IHByZXNlbmNlRGF0YSwgY29ubmVjdGlvbkVycm9yLCBjaGFubmVsRXJyb3IgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZVByZXNlbmNlTGlzdGVuZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/usePresenceListener.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/hooks/useStateErrors.js":
/*!*************************************************************!*\
  !*** ./node_modules/ably/react/mjs/hooks/useStateErrors.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStateErrors: () => (/* binding */ useStateErrors)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useConnectionStateListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js\");\n/* harmony import */ var _useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useChannelStateListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js\");\n\n\n\nfunction useStateErrors(params) {\n    const [connectionError, setConnectionError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [channelError, setChannelError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_1__.useConnectionStateListener)(['suspended', 'failed', 'disconnected'], (stateChange) => {\n        var _a;\n        if (stateChange.reason) {\n            (_a = params.onConnectionError) === null || _a === void 0 ? void 0 : _a.call(params, stateChange.reason);\n            setConnectionError(stateChange.reason);\n        }\n    }, params.ablyId);\n    (0,_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_1__.useConnectionStateListener)(['connected', 'closed'], () => {\n        setConnectionError(null);\n    }, params.ablyId);\n    (0,_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_2__.useChannelStateListener)(params, ['suspended', 'failed', 'detached'], (stateChange) => {\n        var _a;\n        if (stateChange.reason) {\n            (_a = params.onChannelError) === null || _a === void 0 ? void 0 : _a.call(params, stateChange.reason);\n            setChannelError(stateChange.reason);\n        }\n    });\n    (0,_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_2__.useChannelStateListener)(params, ['attached'], () => {\n        setChannelError(null);\n    });\n    return { connectionError, channelError };\n}\n//# sourceMappingURL=useStateErrors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlU3RhdGVFcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUM0QztBQUNOO0FBQ2hFO0FBQ1Asa0RBQWtELCtDQUFRO0FBQzFELDRDQUE0QywrQ0FBUTtBQUNwRCxJQUFJLDBGQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksMEZBQTBCO0FBQzlCO0FBQ0EsS0FBSztBQUNMLElBQUksb0ZBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxvRkFBdUI7QUFDM0I7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaG9va3MvdXNlU3RhdGVFcnJvcnMuanM/OTFkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyIH0gZnJvbSAnLi91c2VDb25uZWN0aW9uU3RhdGVMaXN0ZW5lci5qcyc7XG5pbXBvcnQgeyB1c2VDaGFubmVsU3RhdGVMaXN0ZW5lciB9IGZyb20gJy4vdXNlQ2hhbm5lbFN0YXRlTGlzdGVuZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlRXJyb3JzKHBhcmFtcykge1xuICAgIGNvbnN0IFtjb25uZWN0aW9uRXJyb3IsIHNldENvbm5lY3Rpb25FcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY2hhbm5lbEVycm9yLCBzZXRDaGFubmVsRXJyb3JdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIoWydzdXNwZW5kZWQnLCAnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCAoc3RhdGVDaGFuZ2UpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc3RhdGVDaGFuZ2UucmVhc29uKSB7XG4gICAgICAgICAgICAoX2EgPSBwYXJhbXMub25Db25uZWN0aW9uRXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHBhcmFtcywgc3RhdGVDaGFuZ2UucmVhc29uKTtcbiAgICAgICAgICAgIHNldENvbm5lY3Rpb25FcnJvcihzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICB9XG4gICAgfSwgcGFyYW1zLmFibHlJZCk7XG4gICAgdXNlQ29ubmVjdGlvblN0YXRlTGlzdGVuZXIoWydjb25uZWN0ZWQnLCAnY2xvc2VkJ10sICgpID0+IHtcbiAgICAgICAgc2V0Q29ubmVjdGlvbkVycm9yKG51bGwpO1xuICAgIH0sIHBhcmFtcy5hYmx5SWQpO1xuICAgIHVzZUNoYW5uZWxTdGF0ZUxpc3RlbmVyKHBhcmFtcywgWydzdXNwZW5kZWQnLCAnZmFpbGVkJywgJ2RldGFjaGVkJ10sIChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZS5yZWFzb24pIHtcbiAgICAgICAgICAgIChfYSA9IHBhcmFtcy5vbkNoYW5uZWxFcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocGFyYW1zLCBzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgc2V0Q2hhbm5lbEVycm9yKHN0YXRlQ2hhbmdlLnJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VDaGFubmVsU3RhdGVMaXN0ZW5lcihwYXJhbXMsIFsnYXR0YWNoZWQnXSwgKCkgPT4ge1xuICAgICAgICBzZXRDaGFubmVsRXJyb3IobnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgY29ubmVjdGlvbkVycm9yLCBjaGFubmVsRXJyb3IgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZVN0YXRlRXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/hooks/useStateErrors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ably/react/mjs/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ably/react/mjs/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AblyContext: () => (/* reexport safe */ _AblyContext_js__WEBPACK_IMPORTED_MODULE_9__.AblyContext),\n/* harmony export */   AblyProvider: () => (/* reexport safe */ _AblyProvider_js__WEBPACK_IMPORTED_MODULE_5__.AblyProvider),\n/* harmony export */   ChannelProvider: () => (/* reexport safe */ _ChannelProvider_js__WEBPACK_IMPORTED_MODULE_8__.ChannelProvider),\n/* harmony export */   channelOptionsWithAgent: () => (/* reexport safe */ _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__.channelOptionsWithAgent),\n/* harmony export */   useAbly: () => (/* reexport safe */ _hooks_useAbly_js__WEBPACK_IMPORTED_MODULE_4__.useAbly),\n/* harmony export */   useChannel: () => (/* reexport safe */ _hooks_useChannel_js__WEBPACK_IMPORTED_MODULE_1__.useChannel),\n/* harmony export */   useChannelStateListener: () => (/* reexport safe */ _hooks_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_6__.useChannelStateListener),\n/* harmony export */   useConnectionStateListener: () => (/* reexport safe */ _hooks_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_7__.useConnectionStateListener),\n/* harmony export */   usePresence: () => (/* reexport safe */ _hooks_usePresence_js__WEBPACK_IMPORTED_MODULE_2__.usePresence),\n/* harmony export */   usePresenceListener: () => (/* reexport safe */ _hooks_usePresenceListener_js__WEBPACK_IMPORTED_MODULE_3__.usePresenceListener),\n/* harmony export */   version: () => (/* reexport safe */ _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AblyReactHooks.js */ \"(ssr)/./node_modules/ably/react/mjs/AblyReactHooks.js\");\n/* harmony import */ var _hooks_useChannel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hooks/useChannel.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useChannel.js\");\n/* harmony import */ var _hooks_usePresence_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks/usePresence.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/usePresence.js\");\n/* harmony import */ var _hooks_usePresenceListener_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hooks/usePresenceListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/usePresenceListener.js\");\n/* harmony import */ var _hooks_useAbly_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks/useAbly.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useAbly.js\");\n/* harmony import */ var _AblyProvider_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AblyProvider.js */ \"(ssr)/./node_modules/ably/react/mjs/AblyProvider.js\");\n/* harmony import */ var _hooks_useChannelStateListener_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hooks/useChannelStateListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useChannelStateListener.js\");\n/* harmony import */ var _hooks_useConnectionStateListener_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hooks/useConnectionStateListener.js */ \"(ssr)/./node_modules/ably/react/mjs/hooks/useConnectionStateListener.js\");\n/* harmony import */ var _ChannelProvider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ChannelProvider.js */ \"(ssr)/./node_modules/ably/react/mjs/ChannelProvider.js\");\n/* harmony import */ var _AblyContext_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AblyContext.js */ \"(ssr)/./node_modules/ably/react/mjs/AblyContext.js\");\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDQztBQUNRO0FBQ1o7QUFDRDtBQUNpQjtBQUNHO0FBQ0M7QUFDdEI7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvYWJseS9yZWFjdC9tanMvaW5kZXguanM/YmRhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL0FibHlSZWFjdEhvb2tzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaG9va3MvdXNlQ2hhbm5lbC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hvb2tzL3VzZVByZXNlbmNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaG9va3MvdXNlUHJlc2VuY2VMaXN0ZW5lci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hvb2tzL3VzZUFibHkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9BYmx5UHJvdmlkZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ob29rcy91c2VDaGFubmVsU3RhdGVMaXN0ZW5lci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hvb2tzL3VzZUNvbm5lY3Rpb25TdGF0ZUxpc3RlbmVyLmpzJztcbmV4cG9ydCB7IENoYW5uZWxQcm92aWRlciB9IGZyb20gJy4vQ2hhbm5lbFByb3ZpZGVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vQWJseUNvbnRleHQuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ably/react/mjs/index.js\n");

/***/ })

};
;