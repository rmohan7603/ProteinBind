import 'dotenv/config';
import { Conversation, Client } from '@xmtp/mls-client';
import { ContentTypeText, TextCodec } from '@xmtp/content-type-text';
import { ContentTypeReply, ReplyCodec } from '@xmtp/content-type-reply';
import { ContentTypeRemoteAttachment, RemoteAttachmentCodec, AttachmentCodec } from '@xmtp/content-type-remote-attachment';
import { ContentTypeReaction, ReactionCodec } from '@xmtp/content-type-reaction';
import { Client as Client$1 } from '@xmtp/xmtp-js';
import * as fs from 'fs';
import { isHex, createWalletClient, http, toBytes } from 'viem';
import { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';
import { mainnet } from 'viem/chains';

/*
  Issue:
  There are many incostencies with casing. Parsing everything with lowerCase
  is not ideal, but it's the best we can do for now.
*/
function mapUsernamesToInboxId(usernames, users) {
    return usernames
        .map((username) => {
        return users.find((user) => user.username === username.replace("@", ""));
    })
        .filter((user) => user !== null);
}
// Define a list of fake users with usernames and addresses
const fakeUsers = [
    {
        username: "alix",
        address: "0x3a044b218BaE80E5b9E16609443A192129A67BeA",
        inboxId: "da3750159ea7541dda1e271076a3663d8c14576ab85bbd3416d45c9f19e35cbc",
        accountAddresses: ["0x3a044b218BaE80E5b9E16609443A192129A67BeA"],
        installationIds: [],
        fake: true,
    },
    {
        username: "eva",
        address: "0xeAc10D864802fCcfe897E3957776634D1AE006B2",
        inboxId: "6196afe3fd16c276113b0e4fc913745c39af337ea869fb49a2835201874de49c",
        accountAddresses: ["0xeAc10D864802fCcfe897E3957776634D1AE006B2"],
        installationIds: [],
        fake: true,
    },
    {
        username: "bo",
        address: "0xbc3246461ab5e1682baE48fa95172CDf0689201a",
        inboxId: "8d833f5419cbbfda027813e1fcd1db86c9ec320fd22fbe182883c47a7f34adc0",
        accountAddresses: ["0xbc3246461ab5e1682baE48fa95172CDf0689201a"],
        installationIds: [],
        fake: true,
    },
];
function populateUsernames(members, clientAddress, senderInboxId) {
    //v2
    if (!members)
        members = fakeUsers;
    // Map existing members to the required format
    const mappedMembers = members.map((member) => ({
        username: member.username?.toLowerCase(),
        accountAddresses: member.accountAddresses.map((address) => address.toLowerCase()),
        address: member?.accountAddresses?.[0].toLowerCase(),
        inboxId: member?.inboxId?.toLowerCase(),
        permissionLevel: member.permissionLevel,
    }));
    for (let member of mappedMembers) {
        if (member?.inboxId?.toLowerCase() === senderInboxId?.toLowerCase()) {
            member.username = "me";
        }
        else if (member?.address?.toLowerCase() === clientAddress?.toLowerCase()) {
            member.username = "bot";
        }
        else if (member.address.toLowerCase() ===
            "0xc16c47ea4a9f6ba81664f7623245b2c7429c71dc") {
            member.username = "fabridesktop";
        }
        else {
            const fakeUser = fakeUsers.find((user) => user.address.toLowerCase() === member.address.toLowerCase());
            if (fakeUser) {
                member.username = fakeUser.username?.toLowerCase();
                member.address = member.address?.toLowerCase();
            }
        }
    }
    const remainingUsers = fakeUsers.filter((fakeUser) => !mappedMembers.some((member) => member.address.toLowerCase() === fakeUser.address.toLowerCase()));
    remainingUsers.forEach((user) => {
        mappedMembers.push({
            username: user.username?.toLowerCase(),
            accountAddresses: [user.address?.toLowerCase()],
            address: user.address?.toLowerCase(),
            inboxId: user.inboxId?.toLowerCase(),
            permissionLevel: 0,
            fake: user.fake,
        });
    });
    return mappedMembers;
}

function parseCommand(content, commands, members) {
    let contentReturn;
    //If is command of other bot. MULTIBOT
    const firstWord = content?.split(" ")[0];
    if ((firstWord.startsWith("/") && !firstWord.includes("@")) ||
        (firstWord.startsWith("/") &&
            firstWord.includes("@") &&
            firstWord.includes("@bot"))) {
        const extractedValues = extractCommandValues(content, commands ?? [], members ?? []);
        contentReturn = {
            content: content,
            ...extractedValues,
        };
    }
    else {
        contentReturn = {
            content: content,
        };
    }
    return contentReturn;
}
function extractCommandValues(content, commands, members) {
    const defaultResult = {
        command: undefined,
        params: {},
    };
    try {
        if (typeof content !== "string")
            return defaultResult;
        // Replace all "“" and "”" with "'" and '"'
        content = content.replaceAll("“", '"').replaceAll("”", '"');
        const parts = content.match(/[^\s"']+|"([^"]*)"|'([^']*)'|`([^`]*)`/g);
        if (!parts)
            return defaultResult;
        let commandName = parts[0].startsWith("/") ? parts[0].slice(1) : parts[0];
        let commandConfig;
        for (const group of commands) {
            commandConfig = group.commands.find((cmd) => cmd.command.startsWith(`/${commandName}`));
            if (commandConfig)
                break;
        }
        if (!commandConfig)
            return defaultResult;
        const values = {
            command: commandName,
            params: {},
        };
        const expectedParams = commandConfig.params || {};
        const usedIndices = new Set();
        Object.keys(expectedParams).forEach((param) => {
            const { values: possibleValues = [], default: defaultValue, type = "string", } = expectedParams[param];
            let valueFound = false;
            if (type === "quoted") {
                const quotedIndex = parts.findIndex((part, idx) => /^["'`].*["'`]$/.test(part) && !usedIndices.has(idx));
                if (quotedIndex !== -1) {
                    values.params[param] = parts[quotedIndex].slice(1, -1);
                    usedIndices.add(quotedIndex);
                    valueFound = true;
                }
            }
            else if (type === "address") {
                const addressIndex = parts.findIndex((part, idx) => /^0x[a-fA-F0-9]{40}$/.test(part) && !usedIndices.has(idx));
                if (addressIndex !== -1) {
                    values.params[param] = parts[addressIndex];
                    usedIndices.add(addressIndex);
                    valueFound = true;
                }
            }
            else if (possibleValues.length > 0) {
                const index = parts.findIndex((part, idx) => possibleValues.includes(part.toLowerCase()) &&
                    !usedIndices.has(idx));
                if (index !== -1) {
                    values.params[param] = parts[index];
                    usedIndices.add(index);
                    valueFound = true;
                }
            }
            else if (param === "prompt") {
                // Extract everything after the command as the prompt
                values.params[param] = parts.slice(1).join(" ");
                valueFound = true;
            }
            else {
                const indices = parts.reduce((acc, part, idx) => {
                    if (!usedIndices.has(idx) &&
                        (type === "number"
                            ? !isNaN(parseFloat(part))
                            : type === "username"
                                ? part.startsWith("@")
                                : true)) {
                        acc.push(idx);
                    }
                    return acc;
                }, []);
                if (indices.length > 0) {
                    if (type === "username") {
                        const usernames = indices.map((idx) => parts[idx].slice(1));
                        const mappedUsers = mapUsernamesToInboxId(usernames, members);
                        values.params[param] = mappedUsers.filter((user) => user !== undefined);
                        indices.forEach((idx) => usedIndices.add(idx));
                    }
                    else {
                        values.params[param] =
                            type === "number"
                                ? parseFloat(parts[indices[0]])
                                : parts[indices[0]];
                        usedIndices.add(indices[0]);
                    }
                    valueFound = true;
                }
            }
            if (!valueFound && defaultValue !== undefined) {
                values.params[param] = defaultValue;
            }
        });
        return values;
    }
    catch (e) {
        console.error(e);
        return defaultResult;
    }
}

class HandlerContext {
    refConv = null;
    message;
    group;
    conversation;
    client;
    v2client;
    commands;
    members;
    commandHandlers;
    agentHandlers;
    getMessageById;
    constructor(conversation, message, { client, v2client }, commands, commandHandlers, agentHandlers) {
        this.client = client;
        this.v2client = v2client;
        if (conversation instanceof Conversation) {
            this.group = conversation;
        }
        else {
            this.conversation = conversation;
        }
        this.commandHandlers = commandHandlers;
        this.agentHandlers = agentHandlers;
        this.commands = commands;
    }
    static async create(conversation, message, { client, v2client }, commands, commandHandlers, agentHandlers) {
        const context = new HandlerContext(conversation, message, { client, v2client }, commands, commandHandlers, agentHandlers);
        //v2
        const senderAddress = "senderAddress" in message
            ? message.senderAddress
            : message.senderInboxId;
        const sentAt = "sentAt" in message ? message.sentAt : message.sent;
        context.members = await populateUsernames("members" in conversation ? conversation.members : [], client.accountAddress, senderAddress);
        context.getMessageById =
            client.conversations?.getMessageById?.bind(client.conversations) ||
                (() => null);
        let content = message.content;
        if (message.contentType.sameAs(ContentTypeText)) {
            content = parseCommand(message?.content, commands ?? [], context.members ?? []);
        }
        else if (message.contentType.sameAs(ContentTypeReply)) {
            content = {
                ...content,
                typeId: message.content.contentType.typeId,
            };
        }
        else if (message.contentType.sameAs(ContentTypeRemoteAttachment)) {
            const attachment = await RemoteAttachmentCodec.load(message.content, client);
            content = {
                ...content,
                attachment: attachment,
            };
        }
        //v2
        const sender = context.members?.find((member) => member.inboxId === senderAddress) ||
            { address: senderAddress, inboxId: senderAddress };
        context.message = {
            id: message.id,
            content: content,
            sender: sender,
            typeId: message.contentType.typeId,
            sent: sentAt,
        };
        return context;
    }
    async reply(message) {
        const reply = {
            content: message,
            contentType: ContentTypeText,
            reference: this.message.id,
        };
        const conversation = this.refConv || this.conversation || this.group;
        if (conversation) {
            if (this.isConversationV2(conversation)) {
                await conversation.send(reply, { contentType: ContentTypeReply });
            }
            else if (conversation instanceof Conversation) {
                await conversation.send(reply, ContentTypeReply);
            }
        }
    }
    async send(message) {
        if (this.refConv)
            await this.refConv.send(message);
        else
            await this.conversation.send(message);
    }
    isConversationV2(conversation) {
        return conversation?.conversationVersion === "v2";
    }
    async react(emoji) {
        const reaction = {
            action: "added",
            schema: "unicode",
            reference: this.message.id,
            content: emoji,
        };
        const conversation = this.refConv || this.conversation || this.group;
        if (conversation) {
            if (this.isConversationV2(conversation)) {
                await conversation.send(reaction, { contentType: ContentTypeReaction });
            }
            else if (conversation instanceof Conversation) {
                await conversation.send(reaction, ContentTypeReaction);
            }
        }
    }
    async sendTo(message, receivers) {
        //Sends a 1 to 1 to multiple users
        for (const receiver of receivers) {
            if (this.v2client.address.toLowerCase() === receiver.toLowerCase())
                continue;
            const targetConversation = await this.v2client.conversations.newConversation(receiver);
            if (this.refConv)
                await this.refConv.send(message);
            else
                await targetConversation.send(message);
        }
    }
    async intent(text, conversation) {
        const { commands, members } = this;
        if (conversation)
            this.refConv = conversation;
        try {
            if (text.startsWith("/")) {
                let content = parseCommand(text, commands ?? [], members ?? []);
                // Mock context for command execution
                const mockContext = {
                    ...this,
                    conversation: conversation ?? this.conversation,
                    message: {
                        ...this.message,
                        content,
                    },
                    intent: this.intent.bind(this),
                    reply: this.reply.bind(this),
                    send: this.send.bind(this),
                    sendTo: this.sendTo.bind(this),
                    react: this.react.bind(this),
                };
                const handler = this.commandHandlers?.[text.split(" ")[0]];
                if (handler)
                    await handler(mockContext);
                this.refConv = null;
            }
            else
                await this.reply(text);
        }
        catch (e) {
            console.log("error", e);
        }
        finally {
            this.refConv = null;
        }
    }
}

async function xmtpClient(clientConfig = {}, privateKey = null) {
    let key = privateKey ?? process.env.KEY;
    if (!key || !isHex(key)) {
        key = generatePrivateKey();
        console.error("KEY not set. Using random one. For using your own wallet , set the KEY environment variable.");
        console.log("Random private key: ", key);
    }
    const account = privateKeyToAccount(key);
    const wallet = createWalletClient({
        account,
        chain: mainnet,
        transport: http(),
    });
    let env = process.env.XMTP_ENV;
    if (!env) {
        env = "production";
    }
    if (!fs.existsSync(`.cache`)) {
        fs.mkdirSync(`.cache`);
    }
    const defaultConfig = {
        env: env,
        dbPath: `.cache/${wallet.account?.address}-${env}`,
        codecs: [
            new TextCodec(),
            new ReactionCodec(),
            new ReplyCodec(),
            new RemoteAttachmentCodec(),
            new AttachmentCodec(),
        ],
    };
    // Merge the default configuration with the provided config. Repeated fields in clientConfig will override the default values
    const finalConfig = { ...defaultConfig, ...clientConfig };
    const client = await Client.create(account.address, finalConfig);
    //v2
    const v2client = await Client$1.create(wallet, finalConfig);
    if (process.env.MSG_LOG) {
        console.log("V3-client", {
            accountAddress: client.accountAddress,
            inboxId: client.inboxId,
            installationId: client.installationId,
        });
        console.log("V2-client", {
            address: v2client.address,
        });
    }
    // register identity
    if (!client.isRegistered && client.signatureText) {
        const signature = await wallet.signMessage({
            message: client.signatureText,
        });
        const signatureBytes = toBytes(signature);
        client.addEcdsaSignature(signatureBytes);
        await client.registerIdentity();
    }
    console.log(`Listening on ${client.accountAddress}`);
    //v2
    return { client, v2client };
}

async function run(handler, config) {
    const { client, v2client } = await xmtpClient(config?.client);
    const { inboxId: address } = client;
    const { address: addressV2 } = v2client;
    // sync and list conversations
    await client.conversations.sync();
    await client.conversations.list();
    const handleMessage = async (client, address, message) => {
        if (message) {
            try {
                const { senderInboxId, contentType, senderAddress } = message;
                const conversation = client.conversations.getConversationById
                    ? await client.conversations.getConversationById(message.conversationId)
                    : message?.conversation;
                if (
                //v2
                !conversation ||
                    //If same address do nothin
                    senderAddress === addressV2 ||
                    //If same address do nothin
                    senderInboxId === address) {
                    return;
                }
                const context = await HandlerContext.create(conversation, message, { client, v2client }, config?.commands ?? [], config?.commandHandlers ?? {}, config?.agentHandlers ?? {});
                await handler(context);
            }
            catch (e) {
                console.log(`error`, e);
            }
        }
    };
    const streamMessages = async (client, address) => {
        while (true) {
            const stream = await client.conversations.streamAllMessages();
            try {
                for await (const message of stream) {
                    if (process?.env?.MSG_LOG) {
                        console.log("incoming:", message.content);
                    }
                    await handleMessage(client, address, message);
                }
            }
            catch (e) {
                console.log(`Restart stream:`, e);
            }
        }
    };
    // Run both clients' streams concurrently
    await Promise.all([
        streamMessages(v2client, addressV2),
        streamMessages(client, address),
    ]);
}

export { HandlerContext, run, xmtpClient };
//# sourceMappingURL=index.js.map
