import { ContentTypeId, ContentCodec, EncodedContent } from '@xmtp/content-type-primitives';
import * as _xmtp_mls_client_bindings_node from '@xmtp/mls-client-bindings-node';
import { NapiMessage, NapiGroup, NapiListMessagesOptions, NapiConversations, NapiCreateGroupOptions, NapiClient } from '@xmtp/mls-client-bindings-node';
export * from '@xmtp/mls-client-bindings-node';
import { mlsTranscriptMessages } from '@xmtp/proto';

type ResolveValue<T> = {
    value: T | undefined;
    done: boolean;
};
type StreamCallback<T> = (err: Error | null, value: T) => void;
declare class AsyncStream<T> {
    #private;
    stopCallback: (() => void) | undefined;
    constructor();
    get isDone(): boolean;
    callback: StreamCallback<T>;
    stop: () => void;
    next: () => Promise<ResolveValue<T>>;
    [Symbol.asyncIterator](): this;
}

type MessageKind = 'application' | 'membership_change';
type MessageDeliveryStatus = 'unpublished' | 'published' | 'failed';
declare class DecodedMessage {
    #private;
    content: any;
    contentType: ContentTypeId;
    conversationId: string;
    deliveryStatus: MessageDeliveryStatus;
    fallback?: string;
    compression?: number;
    id: string;
    kind: MessageKind;
    parameters: Record<string, string>;
    senderInboxId: string;
    sentAt: Date;
    sentAtNs: number;
    constructor(client: Client, message: NapiMessage);
}

declare class Conversation {
    #private;
    constructor(client: Client, group: NapiGroup);
    get id(): string;
    get name(): string;
    updateName(name: string): Promise<void>;
    get imageUrl(): string;
    updateImageUrl(imageUrl: string): Promise<void>;
    get description(): string;
    updateDescription(description: string): Promise<void>;
    get pinnedFrameUrl(): string;
    updatePinnedFrameUrl(pinnedFrameUrl: string): Promise<void>;
    get isActive(): boolean;
    get addedByInboxId(): string;
    get createdAtNs(): number;
    get createdAt(): Date;
    get metadata(): {
        creatorInboxId: string;
        conversationType: string;
    };
    get members(): _xmtp_mls_client_bindings_node.NapiGroupMember[];
    get admins(): string[];
    get superAdmins(): string[];
    get permissions(): {
        policyType: _xmtp_mls_client_bindings_node.NapiGroupPermissionsOptions;
        policySet: _xmtp_mls_client_bindings_node.NapiPermissionPolicySet;
    };
    isAdmin(inboxId: string): boolean;
    isSuperAdmin(inboxId: string): boolean;
    sync(): Promise<void>;
    stream(callback?: StreamCallback<DecodedMessage>): AsyncStream<DecodedMessage>;
    addMembers(accountAddresses: string[]): Promise<void>;
    addMembersByInboxId(inboxIds: string[]): Promise<void>;
    removeMembers(accountAddresses: string[]): Promise<void>;
    removeMembersByInboxId(inboxIds: string[]): Promise<void>;
    addAdmin(inboxId: string): Promise<void>;
    removeAdmin(inboxId: string): Promise<void>;
    addSuperAdmin(inboxId: string): Promise<void>;
    removeSuperAdmin(inboxId: string): Promise<void>;
    publishMessages(): Promise<void>;
    sendOptimistic(content: any, contentType?: ContentTypeId): number[];
    send(content: any, contentType?: ContentTypeId): Promise<string>;
    messages(options?: NapiListMessagesOptions): DecodedMessage[];
}

declare class Conversations {
    #private;
    constructor(client: Client, conversations: NapiConversations);
    getConversationById(id: string): Conversation | null;
    getMessageById(id: string): DecodedMessage | null;
    newConversation(accountAddresses: string[], options?: NapiCreateGroupOptions): Promise<Conversation>;
    list(options?: NapiListMessagesOptions): Promise<Conversation[]>;
    sync(): Promise<void>;
    stream(callback?: StreamCallback<Conversation>): AsyncStream<Conversation>;
    streamAllMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage>>;
}

declare const ApiUrls: {
    readonly local: "http://localhost:5556";
    readonly dev: "https://grpc.dev.xmtp.network:443";
    readonly production: "https://grpc.production.xmtp.network:443";
};
type XmtpEnv = keyof typeof ApiUrls;
/**
 * Network options
 */
type NetworkOptions = {
    /**
     * Specify which XMTP environment to connect to. (default: `dev`)
     */
    env?: XmtpEnv;
    /**
     * apiUrl can be used to override the `env` flag and connect to a
     * specific endpoint
     */
    apiUrl?: string;
};
/**
 * Encryption options
 */
type EncryptionOptions = {
    /**
     * Encryption key to use for the local DB
     */
    encryptionKey?: Uint8Array | null;
};
/**
 * Storage options
 */
type StorageOptions = {
    /**
     * Path to the local DB
     */
    dbPath?: string;
};
type ContentOptions = {
    /**
     * Allow configuring codecs for additional content types
     */
    codecs?: ContentCodec<any>[];
};
type ClientOptions = NetworkOptions & EncryptionOptions & StorageOptions & ContentOptions;
declare class Client {
    #private;
    constructor(client: NapiClient, codecs: ContentCodec<any>[]);
    static create(accountAddress: string, options?: ClientOptions): Promise<Client>;
    get accountAddress(): string;
    get inboxId(): string;
    get installationId(): string;
    get isRegistered(): boolean;
    get signatureText(): string | null;
    canMessage(accountAddresses: string[]): Promise<Record<string, boolean>>;
    addEcdsaSignature(signatureBytes: Uint8Array): void;
    addScwSignature(signatureBytes: Uint8Array, chainId: string, accountAddress: string, chainRpcUrl: string, blockNumber: bigint): void;
    registerIdentity(): Promise<void>;
    get conversations(): Conversations;
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
    encodeContent(content: any, contentType: ContentTypeId): EncodedContent<Record<string, string>>;
    decodeContent(message: NapiMessage, contentType: ContentTypeId): any;
    requestHistorySync(): Promise<void>;
    getInboxIdByAddress(accountAddress: string): Promise<string | null>;
}

declare const ContentTypeGroupUpdated: ContentTypeId;
declare class GroupUpdatedCodec implements ContentCodec<mlsTranscriptMessages.GroupUpdated> {
    get contentType(): ContentTypeId;
    encode(content: mlsTranscriptMessages.GroupUpdated): EncodedContent;
    decode(content: EncodedContent): mlsTranscriptMessages.GroupUpdated;
    fallback(): undefined;
    shouldPush(): boolean;
}

export { ApiUrls, Client, type ClientOptions, ContentTypeGroupUpdated, Conversation, Conversations, DecodedMessage, type EncryptionOptions, GroupUpdatedCodec, type NetworkOptions, type StorageOptions, type StreamCallback, type XmtpEnv };
